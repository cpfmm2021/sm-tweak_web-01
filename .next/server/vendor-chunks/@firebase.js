"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@firebase";
exports.ids = ["vendor-chunks/@firebase"];
exports.modules = {

/***/ "(ssr)/./node_modules/@firebase/analytics/dist/esm/index.esm2017.js":
/*!********************************************************************!*\
  !*** ./node_modules/@firebase/analytics/dist/esm/index.esm2017.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAnalytics: () => (/* binding */ getAnalytics),\n/* harmony export */   getGoogleAnalyticsClientId: () => (/* binding */ getGoogleAnalyticsClientId),\n/* harmony export */   initializeAnalytics: () => (/* binding */ initializeAnalytics),\n/* harmony export */   isSupported: () => (/* binding */ isSupported),\n/* harmony export */   logEvent: () => (/* binding */ logEvent),\n/* harmony export */   setAnalyticsCollectionEnabled: () => (/* binding */ setAnalyticsCollectionEnabled),\n/* harmony export */   setConsent: () => (/* binding */ setConsent),\n/* harmony export */   setCurrentScreen: () => (/* binding */ setCurrentScreen),\n/* harmony export */   setDefaultEventParameters: () => (/* binding */ setDefaultEventParameters),\n/* harmony export */   setUserId: () => (/* binding */ setUserId),\n/* harmony export */   setUserProperties: () => (/* binding */ setUserProperties),\n/* harmony export */   settings: () => (/* binding */ settings)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_installations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/installations */ \"(ssr)/./node_modules/@firebase/installations/dist/esm/index.esm2017.js\");\n\n\n\n\n\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Type constant for Firebase Analytics.\n */\nconst ANALYTICS_TYPE = 'analytics';\n// Key to attach FID to in gtag params.\nconst GA_FID_KEY = 'firebase_id';\nconst ORIGIN_KEY = 'origin';\nconst FETCH_TIMEOUT_MILLIS = 60 * 1000;\nconst DYNAMIC_CONFIG_URL = 'https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig';\nconst GTAG_URL = 'https://www.googletagmanager.com/gtag/js';\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst logger = new _firebase_logger__WEBPACK_IMPORTED_MODULE_1__.Logger('@firebase/analytics');\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst ERRORS = {\n    [\"already-exists\" /* AnalyticsError.ALREADY_EXISTS */]: 'A Firebase Analytics instance with the appId {$id} ' +\n        ' already exists. ' +\n        'Only one Firebase Analytics instance can be created for each appId.',\n    [\"already-initialized\" /* AnalyticsError.ALREADY_INITIALIZED */]: 'initializeAnalytics() cannot be called again with different options than those ' +\n        'it was initially called with. It can be called again with the same options to ' +\n        'return the existing instance, or getAnalytics() can be used ' +\n        'to get a reference to the already-initialized instance.',\n    [\"already-initialized-settings\" /* AnalyticsError.ALREADY_INITIALIZED_SETTINGS */]: 'Firebase Analytics has already been initialized.' +\n        'settings() must be called before initializing any Analytics instance' +\n        'or it will have no effect.',\n    [\"interop-component-reg-failed\" /* AnalyticsError.INTEROP_COMPONENT_REG_FAILED */]: 'Firebase Analytics Interop Component failed to instantiate: {$reason}',\n    [\"invalid-analytics-context\" /* AnalyticsError.INVALID_ANALYTICS_CONTEXT */]: 'Firebase Analytics is not supported in this environment. ' +\n        'Wrap initialization of analytics in analytics.isSupported() ' +\n        'to prevent initialization in unsupported environments. Details: {$errorInfo}',\n    [\"indexeddb-unavailable\" /* AnalyticsError.INDEXEDDB_UNAVAILABLE */]: 'IndexedDB unavailable or restricted in this environment. ' +\n        'Wrap initialization of analytics in analytics.isSupported() ' +\n        'to prevent initialization in unsupported environments. Details: {$errorInfo}',\n    [\"fetch-throttle\" /* AnalyticsError.FETCH_THROTTLE */]: 'The config fetch request timed out while in an exponential backoff state.' +\n        ' Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.',\n    [\"config-fetch-failed\" /* AnalyticsError.CONFIG_FETCH_FAILED */]: 'Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}',\n    [\"no-api-key\" /* AnalyticsError.NO_API_KEY */]: 'The \"apiKey\" field is empty in the local Firebase config. Firebase Analytics requires this field to' +\n        'contain a valid API key.',\n    [\"no-app-id\" /* AnalyticsError.NO_APP_ID */]: 'The \"appId\" field is empty in the local Firebase config. Firebase Analytics requires this field to' +\n        'contain a valid app ID.',\n    [\"no-client-id\" /* AnalyticsError.NO_CLIENT_ID */]: 'The \"client_id\" field is empty.',\n    [\"invalid-gtag-resource\" /* AnalyticsError.INVALID_GTAG_RESOURCE */]: 'Trusted Types detected an invalid gtag resource: {$gtagURL}.'\n};\nconst ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.ErrorFactory('analytics', 'Analytics', ERRORS);\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Verifies and creates a TrustedScriptURL.\n */\nfunction createGtagTrustedTypesScriptURL(url) {\n    if (!url.startsWith(GTAG_URL)) {\n        const err = ERROR_FACTORY.create(\"invalid-gtag-resource\" /* AnalyticsError.INVALID_GTAG_RESOURCE */, {\n            gtagURL: url\n        });\n        logger.warn(err.message);\n        return '';\n    }\n    return url;\n}\n/**\n * Makeshift polyfill for Promise.allSettled(). Resolves when all promises\n * have either resolved or rejected.\n *\n * @param promises Array of promises to wait for.\n */\nfunction promiseAllSettled(promises) {\n    return Promise.all(promises.map(promise => promise.catch(e => e)));\n}\n/**\n * Creates a TrustedTypePolicy object that implements the rules passed as policyOptions.\n *\n * @param policyName A string containing the name of the policy\n * @param policyOptions Object containing implementations of instance methods for TrustedTypesPolicy, see {@link https://developer.mozilla.org/en-US/docs/Web/API/TrustedTypePolicy#instance_methods\n * | the TrustedTypePolicy reference documentation}.\n */\nfunction createTrustedTypesPolicy(policyName, policyOptions) {\n    // Create a TrustedTypes policy that we can use for updating src\n    // properties\n    let trustedTypesPolicy;\n    if (window.trustedTypes) {\n        trustedTypesPolicy = window.trustedTypes.createPolicy(policyName, policyOptions);\n    }\n    return trustedTypesPolicy;\n}\n/**\n * Inserts gtag script tag into the page to asynchronously download gtag.\n * @param dataLayerName Name of datalayer (most often the default, \"_dataLayer\").\n */\nfunction insertScriptTag(dataLayerName, measurementId) {\n    const trustedTypesPolicy = createTrustedTypesPolicy('firebase-js-sdk-policy', {\n        createScriptURL: createGtagTrustedTypesScriptURL\n    });\n    const script = document.createElement('script');\n    // We are not providing an analyticsId in the URL because it would trigger a `page_view`\n    // without fid. We will initialize ga-id using gtag (config) command together with fid.\n    const gtagScriptURL = `${GTAG_URL}?l=${dataLayerName}&id=${measurementId}`;\n    script.src = trustedTypesPolicy\n        ? trustedTypesPolicy === null || trustedTypesPolicy === void 0 ? void 0 : trustedTypesPolicy.createScriptURL(gtagScriptURL)\n        : gtagScriptURL;\n    script.async = true;\n    document.head.appendChild(script);\n}\n/**\n * Get reference to, or create, global datalayer.\n * @param dataLayerName Name of datalayer (most often the default, \"_dataLayer\").\n */\nfunction getOrCreateDataLayer(dataLayerName) {\n    // Check for existing dataLayer and create if needed.\n    let dataLayer = [];\n    if (Array.isArray(window[dataLayerName])) {\n        dataLayer = window[dataLayerName];\n    }\n    else {\n        window[dataLayerName] = dataLayer;\n    }\n    return dataLayer;\n}\n/**\n * Wrapped gtag logic when gtag is called with 'config' command.\n *\n * @param gtagCore Basic gtag function that just appends to dataLayer.\n * @param initializationPromisesMap Map of appIds to their initialization promises.\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\n * @param measurementId GA Measurement ID to set config for.\n * @param gtagParams Gtag config params to set.\n */\nasync function gtagOnConfig(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, measurementId, gtagParams) {\n    // If config is already fetched, we know the appId and can use it to look up what FID promise we\n    /// are waiting for, and wait only on that one.\n    const correspondingAppId = measurementIdToAppId[measurementId];\n    try {\n        if (correspondingAppId) {\n            await initializationPromisesMap[correspondingAppId];\n        }\n        else {\n            // If config is not fetched yet, wait for all configs (we don't know which one we need) and\n            // find the appId (if any) corresponding to this measurementId. If there is one, wait on\n            // that appId's initialization promise. If there is none, promise resolves and gtag\n            // call goes through.\n            const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList);\n            const foundConfig = dynamicConfigResults.find(config => config.measurementId === measurementId);\n            if (foundConfig) {\n                await initializationPromisesMap[foundConfig.appId];\n            }\n        }\n    }\n    catch (e) {\n        logger.error(e);\n    }\n    gtagCore(\"config\" /* GtagCommand.CONFIG */, measurementId, gtagParams);\n}\n/**\n * Wrapped gtag logic when gtag is called with 'event' command.\n *\n * @param gtagCore Basic gtag function that just appends to dataLayer.\n * @param initializationPromisesMap Map of appIds to their initialization promises.\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\n * @param measurementId GA Measurement ID to log event to.\n * @param gtagParams Params to log with this event.\n */\nasync function gtagOnEvent(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementId, gtagParams) {\n    try {\n        let initializationPromisesToWaitFor = [];\n        // If there's a 'send_to' param, check if any ID specified matches\n        // an initializeIds() promise we are waiting for.\n        if (gtagParams && gtagParams['send_to']) {\n            let gaSendToList = gtagParams['send_to'];\n            // Make it an array if is isn't, so it can be dealt with the same way.\n            if (!Array.isArray(gaSendToList)) {\n                gaSendToList = [gaSendToList];\n            }\n            // Checking 'send_to' fields requires having all measurement ID results back from\n            // the dynamic config fetch.\n            const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList);\n            for (const sendToId of gaSendToList) {\n                // Any fetched dynamic measurement ID that matches this 'send_to' ID\n                const foundConfig = dynamicConfigResults.find(config => config.measurementId === sendToId);\n                const initializationPromise = foundConfig && initializationPromisesMap[foundConfig.appId];\n                if (initializationPromise) {\n                    initializationPromisesToWaitFor.push(initializationPromise);\n                }\n                else {\n                    // Found an item in 'send_to' that is not associated\n                    // directly with an FID, possibly a group.  Empty this array,\n                    // exit the loop early, and let it get populated below.\n                    initializationPromisesToWaitFor = [];\n                    break;\n                }\n            }\n        }\n        // This will be unpopulated if there was no 'send_to' field , or\n        // if not all entries in the 'send_to' field could be mapped to\n        // a FID. In these cases, wait on all pending initialization promises.\n        if (initializationPromisesToWaitFor.length === 0) {\n            /* eslint-disable-next-line @typescript-eslint/no-floating-promises */\n            initializationPromisesToWaitFor = Object.values(initializationPromisesMap);\n        }\n        // Run core gtag function with args after all relevant initialization\n        // promises have been resolved.\n        await Promise.all(initializationPromisesToWaitFor);\n        // Workaround for http://b/141370449 - third argument cannot be undefined.\n        gtagCore(\"event\" /* GtagCommand.EVENT */, measurementId, gtagParams || {});\n    }\n    catch (e) {\n        logger.error(e);\n    }\n}\n/**\n * Wraps a standard gtag function with extra code to wait for completion of\n * relevant initialization promises before sending requests.\n *\n * @param gtagCore Basic gtag function that just appends to dataLayer.\n * @param initializationPromisesMap Map of appIds to their initialization promises.\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\n */\nfunction wrapGtag(gtagCore, \n/**\n * Allows wrapped gtag calls to wait on whichever initialization promises are required,\n * depending on the contents of the gtag params' `send_to` field, if any.\n */\ninitializationPromisesMap, \n/**\n * Wrapped gtag calls sometimes require all dynamic config fetches to have returned\n * before determining what initialization promises (which include FIDs) to wait for.\n */\ndynamicConfigPromisesList, \n/**\n * Wrapped gtag config calls can narrow down which initialization promise (with FID)\n * to wait for if the measurementId is already fetched, by getting the corresponding appId,\n * which is the key for the initialization promises map.\n */\nmeasurementIdToAppId) {\n    /**\n     * Wrapper around gtag that ensures FID is sent with gtag calls.\n     * @param command Gtag command type.\n     * @param idOrNameOrParams Measurement ID if command is EVENT/CONFIG, params if command is SET.\n     * @param gtagParams Params if event is EVENT/CONFIG.\n     */\n    async function gtagWrapper(command, ...args) {\n        try {\n            // If event, check that relevant initialization promises have completed.\n            if (command === \"event\" /* GtagCommand.EVENT */) {\n                const [measurementId, gtagParams] = args;\n                // If EVENT, second arg must be measurementId.\n                await gtagOnEvent(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementId, gtagParams);\n            }\n            else if (command === \"config\" /* GtagCommand.CONFIG */) {\n                const [measurementId, gtagParams] = args;\n                // If CONFIG, second arg must be measurementId.\n                await gtagOnConfig(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, measurementId, gtagParams);\n            }\n            else if (command === \"consent\" /* GtagCommand.CONSENT */) {\n                const [consentAction, gtagParams] = args;\n                // consentAction can be one of 'default' or 'update'.\n                gtagCore(\"consent\" /* GtagCommand.CONSENT */, consentAction, gtagParams);\n            }\n            else if (command === \"get\" /* GtagCommand.GET */) {\n                const [measurementId, fieldName, callback] = args;\n                gtagCore(\"get\" /* GtagCommand.GET */, measurementId, fieldName, callback);\n            }\n            else if (command === \"set\" /* GtagCommand.SET */) {\n                const [customParams] = args;\n                // If SET, second arg must be params.\n                gtagCore(\"set\" /* GtagCommand.SET */, customParams);\n            }\n            else {\n                gtagCore(command, ...args);\n            }\n        }\n        catch (e) {\n            logger.error(e);\n        }\n    }\n    return gtagWrapper;\n}\n/**\n * Creates global gtag function or wraps existing one if found.\n * This wrapped function attaches Firebase instance ID (FID) to gtag 'config' and\n * 'event' calls that belong to the GAID associated with this Firebase instance.\n *\n * @param initializationPromisesMap Map of appIds to their initialization promises.\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\n * @param dataLayerName Name of global GA datalayer array.\n * @param gtagFunctionName Name of global gtag function (\"gtag\" if not user-specified).\n */\nfunction wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagFunctionName) {\n    // Create a basic core gtag function\n    let gtagCore = function (..._args) {\n        // Must push IArguments object, not an array.\n        window[dataLayerName].push(arguments);\n    };\n    // Replace it with existing one if found\n    if (window[gtagFunctionName] &&\n        typeof window[gtagFunctionName] === 'function') {\n        // @ts-ignore\n        gtagCore = window[gtagFunctionName];\n    }\n    window[gtagFunctionName] = wrapGtag(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId);\n    return {\n        gtagCore,\n        wrappedGtag: window[gtagFunctionName]\n    };\n}\n/**\n * Returns the script tag in the DOM matching both the gtag url pattern\n * and the provided data layer name.\n */\nfunction findGtagScriptOnPage(dataLayerName) {\n    const scriptTags = window.document.getElementsByTagName('script');\n    for (const tag of Object.values(scriptTags)) {\n        if (tag.src &&\n            tag.src.includes(GTAG_URL) &&\n            tag.src.includes(dataLayerName)) {\n            return tag;\n        }\n    }\n    return null;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Backoff factor for 503 errors, which we want to be conservative about\n * to avoid overloading servers. Each retry interval will be\n * BASE_INTERVAL_MILLIS * LONG_RETRY_FACTOR ^ retryCount, so the second one\n * will be ~30 seconds (with fuzzing).\n */\nconst LONG_RETRY_FACTOR = 30;\n/**\n * Base wait interval to multiplied by backoffFactor^backoffCount.\n */\nconst BASE_INTERVAL_MILLIS = 1000;\n/**\n * Stubbable retry data storage class.\n */\nclass RetryData {\n    constructor(throttleMetadata = {}, intervalMillis = BASE_INTERVAL_MILLIS) {\n        this.throttleMetadata = throttleMetadata;\n        this.intervalMillis = intervalMillis;\n    }\n    getThrottleMetadata(appId) {\n        return this.throttleMetadata[appId];\n    }\n    setThrottleMetadata(appId, metadata) {\n        this.throttleMetadata[appId] = metadata;\n    }\n    deleteThrottleMetadata(appId) {\n        delete this.throttleMetadata[appId];\n    }\n}\nconst defaultRetryData = new RetryData();\n/**\n * Set GET request headers.\n * @param apiKey App API key.\n */\nfunction getHeaders(apiKey) {\n    return new Headers({\n        Accept: 'application/json',\n        'x-goog-api-key': apiKey\n    });\n}\n/**\n * Fetches dynamic config from backend.\n * @param app Firebase app to fetch config for.\n */\nasync function fetchDynamicConfig(appFields) {\n    var _a;\n    const { appId, apiKey } = appFields;\n    const request = {\n        method: 'GET',\n        headers: getHeaders(apiKey)\n    };\n    const appUrl = DYNAMIC_CONFIG_URL.replace('{app-id}', appId);\n    const response = await fetch(appUrl, request);\n    if (response.status !== 200 && response.status !== 304) {\n        let errorMessage = '';\n        try {\n            // Try to get any error message text from server response.\n            const jsonResponse = (await response.json());\n            if ((_a = jsonResponse.error) === null || _a === void 0 ? void 0 : _a.message) {\n                errorMessage = jsonResponse.error.message;\n            }\n        }\n        catch (_ignored) { }\n        throw ERROR_FACTORY.create(\"config-fetch-failed\" /* AnalyticsError.CONFIG_FETCH_FAILED */, {\n            httpStatus: response.status,\n            responseMessage: errorMessage\n        });\n    }\n    return response.json();\n}\n/**\n * Fetches dynamic config from backend, retrying if failed.\n * @param app Firebase app to fetch config for.\n */\nasync function fetchDynamicConfigWithRetry(app, \n// retryData and timeoutMillis are parameterized to allow passing a different value for testing.\nretryData = defaultRetryData, timeoutMillis) {\n    const { appId, apiKey, measurementId } = app.options;\n    if (!appId) {\n        throw ERROR_FACTORY.create(\"no-app-id\" /* AnalyticsError.NO_APP_ID */);\n    }\n    if (!apiKey) {\n        if (measurementId) {\n            return {\n                measurementId,\n                appId\n            };\n        }\n        throw ERROR_FACTORY.create(\"no-api-key\" /* AnalyticsError.NO_API_KEY */);\n    }\n    const throttleMetadata = retryData.getThrottleMetadata(appId) || {\n        backoffCount: 0,\n        throttleEndTimeMillis: Date.now()\n    };\n    const signal = new AnalyticsAbortSignal();\n    setTimeout(async () => {\n        // Note a very low delay, eg < 10ms, can elapse before listeners are initialized.\n        signal.abort();\n    }, timeoutMillis !== undefined ? timeoutMillis : FETCH_TIMEOUT_MILLIS);\n    return attemptFetchDynamicConfigWithRetry({ appId, apiKey, measurementId }, throttleMetadata, signal, retryData);\n}\n/**\n * Runs one retry attempt.\n * @param appFields Necessary app config fields.\n * @param throttleMetadata Ongoing metadata to determine throttling times.\n * @param signal Abort signal.\n */\nasync function attemptFetchDynamicConfigWithRetry(appFields, { throttleEndTimeMillis, backoffCount }, signal, retryData = defaultRetryData // for testing\n) {\n    var _a;\n    const { appId, measurementId } = appFields;\n    // Starts with a (potentially zero) timeout to support resumption from stored state.\n    // Ensures the throttle end time is honored if the last attempt timed out.\n    // Note the SDK will never make a request if the fetch timeout expires at this point.\n    try {\n        await setAbortableTimeout(signal, throttleEndTimeMillis);\n    }\n    catch (e) {\n        if (measurementId) {\n            logger.warn(`Timed out fetching this Firebase app's measurement ID from the server.` +\n                ` Falling back to the measurement ID ${measurementId}` +\n                ` provided in the \"measurementId\" field in the local Firebase config. [${e === null || e === void 0 ? void 0 : e.message}]`);\n            return { appId, measurementId };\n        }\n        throw e;\n    }\n    try {\n        const response = await fetchDynamicConfig(appFields);\n        // Note the SDK only clears throttle state if response is success or non-retriable.\n        retryData.deleteThrottleMetadata(appId);\n        return response;\n    }\n    catch (e) {\n        const error = e;\n        if (!isRetriableError(error)) {\n            retryData.deleteThrottleMetadata(appId);\n            if (measurementId) {\n                logger.warn(`Failed to fetch this Firebase app's measurement ID from the server.` +\n                    ` Falling back to the measurement ID ${measurementId}` +\n                    ` provided in the \"measurementId\" field in the local Firebase config. [${error === null || error === void 0 ? void 0 : error.message}]`);\n                return { appId, measurementId };\n            }\n            else {\n                throw e;\n            }\n        }\n        const backoffMillis = Number((_a = error === null || error === void 0 ? void 0 : error.customData) === null || _a === void 0 ? void 0 : _a.httpStatus) === 503\n            ? (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.calculateBackoffMillis)(backoffCount, retryData.intervalMillis, LONG_RETRY_FACTOR)\n            : (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.calculateBackoffMillis)(backoffCount, retryData.intervalMillis);\n        // Increments backoff state.\n        const throttleMetadata = {\n            throttleEndTimeMillis: Date.now() + backoffMillis,\n            backoffCount: backoffCount + 1\n        };\n        // Persists state.\n        retryData.setThrottleMetadata(appId, throttleMetadata);\n        logger.debug(`Calling attemptFetch again in ${backoffMillis} millis`);\n        return attemptFetchDynamicConfigWithRetry(appFields, throttleMetadata, signal, retryData);\n    }\n}\n/**\n * Supports waiting on a backoff by:\n *\n * <ul>\n *   <li>Promisifying setTimeout, so we can set a timeout in our Promise chain</li>\n *   <li>Listening on a signal bus for abort events, just like the Fetch API</li>\n *   <li>Failing in the same way the Fetch API fails, so timing out a live request and a throttled\n *       request appear the same.</li>\n * </ul>\n *\n * <p>Visible for testing.\n */\nfunction setAbortableTimeout(signal, throttleEndTimeMillis) {\n    return new Promise((resolve, reject) => {\n        // Derives backoff from given end time, normalizing negative numbers to zero.\n        const backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);\n        const timeout = setTimeout(resolve, backoffMillis);\n        // Adds listener, rather than sets onabort, because signal is a shared object.\n        signal.addEventListener(() => {\n            clearTimeout(timeout);\n            // If the request completes before this timeout, the rejection has no effect.\n            reject(ERROR_FACTORY.create(\"fetch-throttle\" /* AnalyticsError.FETCH_THROTTLE */, {\n                throttleEndTimeMillis\n            }));\n        });\n    });\n}\n/**\n * Returns true if the {@link Error} indicates a fetch request may succeed later.\n */\nfunction isRetriableError(e) {\n    if (!(e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) || !e.customData) {\n        return false;\n    }\n    // Uses string index defined by ErrorData, which FirebaseError implements.\n    const httpStatus = Number(e.customData['httpStatus']);\n    return (httpStatus === 429 ||\n        httpStatus === 500 ||\n        httpStatus === 503 ||\n        httpStatus === 504);\n}\n/**\n * Shims a minimal AbortSignal (copied from Remote Config).\n *\n * <p>AbortController's AbortSignal conveniently decouples fetch timeout logic from other aspects\n * of networking, such as retries. Firebase doesn't use AbortController enough to justify a\n * polyfill recommendation, like we do with the Fetch API, but this minimal shim can easily be\n * swapped out if/when we do.\n */\nclass AnalyticsAbortSignal {\n    constructor() {\n        this.listeners = [];\n    }\n    addEventListener(listener) {\n        this.listeners.push(listener);\n    }\n    abort() {\n        this.listeners.forEach(listener => listener());\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Event parameters to set on 'gtag' during initialization.\n */\nlet defaultEventParametersForInit;\n/**\n * Logs an analytics event through the Firebase SDK.\n *\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\n * @param eventName Google Analytics event name, choose from standard list or use a custom string.\n * @param eventParams Analytics event parameters.\n */\nasync function logEvent$1(gtagFunction, initializationPromise, eventName, eventParams, options) {\n    if (options && options.global) {\n        gtagFunction(\"event\" /* GtagCommand.EVENT */, eventName, eventParams);\n        return;\n    }\n    else {\n        const measurementId = await initializationPromise;\n        const params = Object.assign(Object.assign({}, eventParams), { 'send_to': measurementId });\n        gtagFunction(\"event\" /* GtagCommand.EVENT */, eventName, params);\n    }\n}\n/**\n * Set screen_name parameter for this Google Analytics ID.\n *\n * @deprecated Use {@link logEvent} with `eventName` as 'screen_view' and add relevant `eventParams`.\n * See {@link https://firebase.google.com/docs/analytics/screenviews | Track Screenviews}.\n *\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\n * @param screenName Screen name string to set.\n */\nasync function setCurrentScreen$1(gtagFunction, initializationPromise, screenName, options) {\n    if (options && options.global) {\n        gtagFunction(\"set\" /* GtagCommand.SET */, { 'screen_name': screenName });\n        return Promise.resolve();\n    }\n    else {\n        const measurementId = await initializationPromise;\n        gtagFunction(\"config\" /* GtagCommand.CONFIG */, measurementId, {\n            update: true,\n            'screen_name': screenName\n        });\n    }\n}\n/**\n * Set user_id parameter for this Google Analytics ID.\n *\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\n * @param id User ID string to set\n */\nasync function setUserId$1(gtagFunction, initializationPromise, id, options) {\n    if (options && options.global) {\n        gtagFunction(\"set\" /* GtagCommand.SET */, { 'user_id': id });\n        return Promise.resolve();\n    }\n    else {\n        const measurementId = await initializationPromise;\n        gtagFunction(\"config\" /* GtagCommand.CONFIG */, measurementId, {\n            update: true,\n            'user_id': id\n        });\n    }\n}\n/**\n * Set all other user properties other than user_id and screen_name.\n *\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\n * @param properties Map of user properties to set\n */\nasync function setUserProperties$1(gtagFunction, initializationPromise, properties, options) {\n    if (options && options.global) {\n        const flatProperties = {};\n        for (const key of Object.keys(properties)) {\n            // use dot notation for merge behavior in gtag.js\n            flatProperties[`user_properties.${key}`] = properties[key];\n        }\n        gtagFunction(\"set\" /* GtagCommand.SET */, flatProperties);\n        return Promise.resolve();\n    }\n    else {\n        const measurementId = await initializationPromise;\n        gtagFunction(\"config\" /* GtagCommand.CONFIG */, measurementId, {\n            update: true,\n            'user_properties': properties\n        });\n    }\n}\n/**\n * Retrieves a unique Google Analytics identifier for the web client.\n * See {@link https://developers.google.com/analytics/devguides/collection/ga4/reference/config#client_id | client_id}.\n *\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\n */\nasync function internalGetGoogleAnalyticsClientId(gtagFunction, initializationPromise) {\n    const measurementId = await initializationPromise;\n    return new Promise((resolve, reject) => {\n        gtagFunction(\"get\" /* GtagCommand.GET */, measurementId, 'client_id', (clientId) => {\n            if (!clientId) {\n                reject(ERROR_FACTORY.create(\"no-client-id\" /* AnalyticsError.NO_CLIENT_ID */));\n            }\n            resolve(clientId);\n        });\n    });\n}\n/**\n * Set whether collection is enabled for this ID.\n *\n * @param enabled If true, collection is enabled for this ID.\n */\nasync function setAnalyticsCollectionEnabled$1(initializationPromise, enabled) {\n    const measurementId = await initializationPromise;\n    window[`ga-disable-${measurementId}`] = !enabled;\n}\n/**\n * Consent parameters to default to during 'gtag' initialization.\n */\nlet defaultConsentSettingsForInit;\n/**\n * Sets the variable {@link defaultConsentSettingsForInit} for use in the initialization of\n * analytics.\n *\n * @param consentSettings Maps the applicable end user consent state for gtag.js.\n */\nfunction _setConsentDefaultForInit(consentSettings) {\n    defaultConsentSettingsForInit = consentSettings;\n}\n/**\n * Sets the variable `defaultEventParametersForInit` for use in the initialization of\n * analytics.\n *\n * @param customParams Any custom params the user may pass to gtag.js.\n */\nfunction _setDefaultEventParametersForInit(customParams) {\n    defaultEventParametersForInit = customParams;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function validateIndexedDB() {\n    if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isIndexedDBAvailable)()) {\n        logger.warn(ERROR_FACTORY.create(\"indexeddb-unavailable\" /* AnalyticsError.INDEXEDDB_UNAVAILABLE */, {\n            errorInfo: 'IndexedDB is not available in this environment.'\n        }).message);\n        return false;\n    }\n    else {\n        try {\n            await (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateIndexedDBOpenable)();\n        }\n        catch (e) {\n            logger.warn(ERROR_FACTORY.create(\"indexeddb-unavailable\" /* AnalyticsError.INDEXEDDB_UNAVAILABLE */, {\n                errorInfo: e === null || e === void 0 ? void 0 : e.toString()\n            }).message);\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Initialize the analytics instance in gtag.js by calling config command with fid.\n *\n * NOTE: We combine analytics initialization and setting fid together because we want fid to be\n * part of the `page_view` event that's sent during the initialization\n * @param app Firebase app\n * @param gtagCore The gtag function that's not wrapped.\n * @param dynamicConfigPromisesList Array of all dynamic config promises.\n * @param measurementIdToAppId Maps measurementID to appID.\n * @param installations _FirebaseInstallationsInternal instance.\n *\n * @returns Measurement ID.\n */\nasync function _initializeAnalytics(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCore, dataLayerName, options) {\n    var _a;\n    const dynamicConfigPromise = fetchDynamicConfigWithRetry(app);\n    // Once fetched, map measurementIds to appId, for ease of lookup in wrapped gtag function.\n    dynamicConfigPromise\n        .then(config => {\n        measurementIdToAppId[config.measurementId] = config.appId;\n        if (app.options.measurementId &&\n            config.measurementId !== app.options.measurementId) {\n            logger.warn(`The measurement ID in the local Firebase config (${app.options.measurementId})` +\n                ` does not match the measurement ID fetched from the server (${config.measurementId}).` +\n                ` To ensure analytics events are always sent to the correct Analytics property,` +\n                ` update the` +\n                ` measurement ID field in the local config or remove it from the local config.`);\n        }\n    })\n        .catch(e => logger.error(e));\n    // Add to list to track state of all dynamic config promises.\n    dynamicConfigPromisesList.push(dynamicConfigPromise);\n    const fidPromise = validateIndexedDB().then(envIsValid => {\n        if (envIsValid) {\n            return installations.getId();\n        }\n        else {\n            return undefined;\n        }\n    });\n    const [dynamicConfig, fid] = await Promise.all([\n        dynamicConfigPromise,\n        fidPromise\n    ]);\n    // Detect if user has already put the gtag <script> tag on this page with the passed in\n    // data layer name.\n    if (!findGtagScriptOnPage(dataLayerName)) {\n        insertScriptTag(dataLayerName, dynamicConfig.measurementId);\n    }\n    // Detects if there are consent settings that need to be configured.\n    if (defaultConsentSettingsForInit) {\n        gtagCore(\"consent\" /* GtagCommand.CONSENT */, 'default', defaultConsentSettingsForInit);\n        _setConsentDefaultForInit(undefined);\n    }\n    // This command initializes gtag.js and only needs to be called once for the entire web app,\n    // but since it is idempotent, we can call it multiple times.\n    // We keep it together with other initialization logic for better code structure.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    gtagCore('js', new Date());\n    // User config added first. We don't want users to accidentally overwrite\n    // base Firebase config properties.\n    const configProperties = (_a = options === null || options === void 0 ? void 0 : options.config) !== null && _a !== void 0 ? _a : {};\n    // guard against developers accidentally setting properties with prefix `firebase_`\n    configProperties[ORIGIN_KEY] = 'firebase';\n    configProperties.update = true;\n    if (fid != null) {\n        configProperties[GA_FID_KEY] = fid;\n    }\n    // It should be the first config command called on this GA-ID\n    // Initialize this GA-ID and set FID on it using the gtag config API.\n    // Note: This will trigger a page_view event unless 'send_page_view' is set to false in\n    // `configProperties`.\n    gtagCore(\"config\" /* GtagCommand.CONFIG */, dynamicConfig.measurementId, configProperties);\n    // Detects if there is data that will be set on every event logged from the SDK.\n    if (defaultEventParametersForInit) {\n        gtagCore(\"set\" /* GtagCommand.SET */, defaultEventParametersForInit);\n        _setDefaultEventParametersForInit(undefined);\n    }\n    return dynamicConfig.measurementId;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Analytics Service class.\n */\nclass AnalyticsService {\n    constructor(app) {\n        this.app = app;\n    }\n    _delete() {\n        delete initializationPromisesMap[this.app.options.appId];\n        return Promise.resolve();\n    }\n}\n/**\n * Maps appId to full initialization promise. Wrapped gtag calls must wait on\n * all or some of these, depending on the call's `send_to` param and the status\n * of the dynamic config fetches (see below).\n */\nlet initializationPromisesMap = {};\n/**\n * List of dynamic config fetch promises. In certain cases, wrapped gtag calls\n * wait on all these to be complete in order to determine if it can selectively\n * wait for only certain initialization (FID) promises or if it must wait for all.\n */\nlet dynamicConfigPromisesList = [];\n/**\n * Maps fetched measurementIds to appId. Populated when the app's dynamic config\n * fetch completes. If already populated, gtag config calls can use this to\n * selectively wait for only this app's initialization promise (FID) instead of all\n * initialization promises.\n */\nconst measurementIdToAppId = {};\n/**\n * Name for window global data layer array used by GA: defaults to 'dataLayer'.\n */\nlet dataLayerName = 'dataLayer';\n/**\n * Name for window global gtag function used by GA: defaults to 'gtag'.\n */\nlet gtagName = 'gtag';\n/**\n * Reproduction of standard gtag function or reference to existing\n * gtag function on window object.\n */\nlet gtagCoreFunction;\n/**\n * Wrapper around gtag function that ensures FID is sent with all\n * relevant event and config calls.\n */\nlet wrappedGtagFunction;\n/**\n * Flag to ensure page initialization steps (creation or wrapping of\n * dataLayer and gtag script) are only run once per page load.\n */\nlet globalInitDone = false;\n/**\n * Configures Firebase Analytics to use custom `gtag` or `dataLayer` names.\n * Intended to be used if `gtag.js` script has been installed on\n * this page independently of Firebase Analytics, and is using non-default\n * names for either the `gtag` function or for `dataLayer`.\n * Must be called before calling `getAnalytics()` or it won't\n * have any effect.\n *\n * @public\n *\n * @param options - Custom gtag and dataLayer names.\n */\nfunction settings(options) {\n    if (globalInitDone) {\n        throw ERROR_FACTORY.create(\"already-initialized\" /* AnalyticsError.ALREADY_INITIALIZED */);\n    }\n    if (options.dataLayerName) {\n        dataLayerName = options.dataLayerName;\n    }\n    if (options.gtagName) {\n        gtagName = options.gtagName;\n    }\n}\n/**\n * Returns true if no environment mismatch is found.\n * If environment mismatches are found, throws an INVALID_ANALYTICS_CONTEXT\n * error that also lists details for each mismatch found.\n */\nfunction warnOnBrowserContextMismatch() {\n    const mismatchedEnvMessages = [];\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isBrowserExtension)()) {\n        mismatchedEnvMessages.push('This is a browser extension environment.');\n    }\n    if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.areCookiesEnabled)()) {\n        mismatchedEnvMessages.push('Cookies are not available.');\n    }\n    if (mismatchedEnvMessages.length > 0) {\n        const details = mismatchedEnvMessages\n            .map((message, index) => `(${index + 1}) ${message}`)\n            .join(' ');\n        const err = ERROR_FACTORY.create(\"invalid-analytics-context\" /* AnalyticsError.INVALID_ANALYTICS_CONTEXT */, {\n            errorInfo: details\n        });\n        logger.warn(err.message);\n    }\n}\n/**\n * Analytics instance factory.\n * @internal\n */\nfunction factory(app, installations, options) {\n    warnOnBrowserContextMismatch();\n    const appId = app.options.appId;\n    if (!appId) {\n        throw ERROR_FACTORY.create(\"no-app-id\" /* AnalyticsError.NO_APP_ID */);\n    }\n    if (!app.options.apiKey) {\n        if (app.options.measurementId) {\n            logger.warn(`The \"apiKey\" field is empty in the local Firebase config. This is needed to fetch the latest` +\n                ` measurement ID for this Firebase app. Falling back to the measurement ID ${app.options.measurementId}` +\n                ` provided in the \"measurementId\" field in the local Firebase config.`);\n        }\n        else {\n            throw ERROR_FACTORY.create(\"no-api-key\" /* AnalyticsError.NO_API_KEY */);\n        }\n    }\n    if (initializationPromisesMap[appId] != null) {\n        throw ERROR_FACTORY.create(\"already-exists\" /* AnalyticsError.ALREADY_EXISTS */, {\n            id: appId\n        });\n    }\n    if (!globalInitDone) {\n        // Steps here should only be done once per page: creation or wrapping\n        // of dataLayer and global gtag function.\n        getOrCreateDataLayer(dataLayerName);\n        const { wrappedGtag, gtagCore } = wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagName);\n        wrappedGtagFunction = wrappedGtag;\n        gtagCoreFunction = gtagCore;\n        globalInitDone = true;\n    }\n    // Async but non-blocking.\n    // This map reflects the completion state of all promises for each appId.\n    initializationPromisesMap[appId] = _initializeAnalytics(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCoreFunction, dataLayerName, options);\n    const analyticsInstance = new AnalyticsService(app);\n    return analyticsInstance;\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Returns an {@link Analytics} instance for the given app.\n *\n * @public\n *\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\n */\nfunction getAnalytics(app = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)()) {\n    app = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(app);\n    // Dependencies\n    const analyticsProvider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, ANALYTICS_TYPE);\n    if (analyticsProvider.isInitialized()) {\n        return analyticsProvider.getImmediate();\n    }\n    return initializeAnalytics(app);\n}\n/**\n * Returns an {@link Analytics} instance for the given app.\n *\n * @public\n *\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\n */\nfunction initializeAnalytics(app, options = {}) {\n    // Dependencies\n    const analyticsProvider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, ANALYTICS_TYPE);\n    if (analyticsProvider.isInitialized()) {\n        const existingInstance = analyticsProvider.getImmediate();\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(options, analyticsProvider.getOptions())) {\n            return existingInstance;\n        }\n        else {\n            throw ERROR_FACTORY.create(\"already-initialized\" /* AnalyticsError.ALREADY_INITIALIZED */);\n        }\n    }\n    const analyticsInstance = analyticsProvider.initialize({ options });\n    return analyticsInstance;\n}\n/**\n * This is a public static method provided to users that wraps four different checks:\n *\n * 1. Check if it's not a browser extension environment.\n * 2. Check if cookies are enabled in current browser.\n * 3. Check if IndexedDB is supported by the browser environment.\n * 4. Check if the current browser context is valid for using `IndexedDB.open()`.\n *\n * @public\n *\n */\nasync function isSupported() {\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isBrowserExtension)()) {\n        return false;\n    }\n    if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.areCookiesEnabled)()) {\n        return false;\n    }\n    if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isIndexedDBAvailable)()) {\n        return false;\n    }\n    try {\n        const isDBOpenable = await (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateIndexedDBOpenable)();\n        return isDBOpenable;\n    }\n    catch (error) {\n        return false;\n    }\n}\n/**\n * Use gtag `config` command to set `screen_name`.\n *\n * @public\n *\n * @deprecated Use {@link logEvent} with `eventName` as 'screen_view' and add relevant `eventParams`.\n * See {@link https://firebase.google.com/docs/analytics/screenviews | Track Screenviews}.\n *\n * @param analyticsInstance - The {@link Analytics} instance.\n * @param screenName - Screen name to set.\n */\nfunction setCurrentScreen(analyticsInstance, screenName, options) {\n    analyticsInstance = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(analyticsInstance);\n    setCurrentScreen$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], screenName, options).catch(e => logger.error(e));\n}\n/**\n * Retrieves a unique Google Analytics identifier for the web client.\n * See {@link https://developers.google.com/analytics/devguides/collection/ga4/reference/config#client_id | client_id}.\n *\n * @public\n *\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\n */\nasync function getGoogleAnalyticsClientId(analyticsInstance) {\n    analyticsInstance = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(analyticsInstance);\n    return internalGetGoogleAnalyticsClientId(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId]);\n}\n/**\n * Use gtag `config` command to set `user_id`.\n *\n * @public\n *\n * @param analyticsInstance - The {@link Analytics} instance.\n * @param id - User ID to set.\n */\nfunction setUserId(analyticsInstance, id, options) {\n    analyticsInstance = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(analyticsInstance);\n    setUserId$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], id, options).catch(e => logger.error(e));\n}\n/**\n * Use gtag `config` command to set all params specified.\n *\n * @public\n */\nfunction setUserProperties(analyticsInstance, properties, options) {\n    analyticsInstance = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(analyticsInstance);\n    setUserProperties$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], properties, options).catch(e => logger.error(e));\n}\n/**\n * Sets whether Google Analytics collection is enabled for this app on this device.\n * Sets global `window['ga-disable-analyticsId'] = true;`\n *\n * @public\n *\n * @param analyticsInstance - The {@link Analytics} instance.\n * @param enabled - If true, enables collection, if false, disables it.\n */\nfunction setAnalyticsCollectionEnabled(analyticsInstance, enabled) {\n    analyticsInstance = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(analyticsInstance);\n    setAnalyticsCollectionEnabled$1(initializationPromisesMap[analyticsInstance.app.options.appId], enabled).catch(e => logger.error(e));\n}\n/**\n * Adds data that will be set on every event logged from the SDK, including automatic ones.\n * With gtag's \"set\" command, the values passed persist on the current page and are passed with\n * all subsequent events.\n * @public\n * @param customParams - Any custom params the user may pass to gtag.js.\n */\nfunction setDefaultEventParameters(customParams) {\n    // Check if reference to existing gtag function on window object exists\n    if (wrappedGtagFunction) {\n        wrappedGtagFunction(\"set\" /* GtagCommand.SET */, customParams);\n    }\n    else {\n        _setDefaultEventParametersForInit(customParams);\n    }\n}\n/**\n * Sends a Google Analytics event with given `eventParams`. This method\n * automatically associates this logged event with this Firebase web\n * app instance on this device.\n * List of official event parameters can be found in the gtag.js\n * reference documentation:\n * {@link https://developers.google.com/gtagjs/reference/ga4-events\n * | the GA4 reference documentation}.\n *\n * @public\n */\nfunction logEvent(analyticsInstance, eventName, eventParams, options) {\n    analyticsInstance = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(analyticsInstance);\n    logEvent$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], eventName, eventParams, options).catch(e => logger.error(e));\n}\n/**\n * Sets the applicable end user consent state for this web app across all gtag references once\n * Firebase Analytics is initialized.\n *\n * Use the {@link ConsentSettings} to specify individual consent type values. By default consent\n * types are set to \"granted\".\n * @public\n * @param consentSettings - Maps the applicable end user consent state for gtag.js.\n */\nfunction setConsent(consentSettings) {\n    // Check if reference to existing gtag function on window object exists\n    if (wrappedGtagFunction) {\n        wrappedGtagFunction(\"consent\" /* GtagCommand.CONSENT */, 'update', consentSettings);\n    }\n    else {\n        _setConsentDefaultForInit(consentSettings);\n    }\n}\n\nconst name = \"@firebase/analytics\";\nconst version = \"0.10.10\";\n\n/**\n * The Firebase Analytics Web SDK.\n * This SDK does not work in a Node.js environment.\n *\n * @packageDocumentation\n */\nfunction registerAnalytics() {\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_3__.Component(ANALYTICS_TYPE, (container, { options: analyticsOptions }) => {\n        // getImmediate for FirebaseApp will always succeed\n        const app = container.getProvider('app').getImmediate();\n        const installations = container\n            .getProvider('installations-internal')\n            .getImmediate();\n        return factory(app, installations, analyticsOptions);\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_3__.Component('analytics-internal', internalFactory, \"PRIVATE\" /* ComponentType.PRIVATE */));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version);\n    // BUILD_TARGET will be replaced by values like esm2017, cjs2017, etc during the compilation\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, 'esm2017');\n    function internalFactory(container) {\n        try {\n            const analytics = container.getProvider(ANALYTICS_TYPE).getImmediate();\n            return {\n                logEvent: (eventName, eventParams, options) => logEvent(analytics, eventName, eventParams, options)\n            };\n        }\n        catch (e) {\n            throw ERROR_FACTORY.create(\"interop-component-reg-failed\" /* AnalyticsError.INTEROP_COMPONENT_REG_FAILED */, {\n                reason: e\n            });\n        }\n    }\n}\nregisterAnalytics();\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FuYWx5dGljcy9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBGO0FBQ2hEO0FBQ2tLO0FBQzVKO0FBQ2Y7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixPQUFPO0FBQzVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFNOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLEtBQUs7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0pBQXNKLFFBQVE7QUFDOUo7QUFDQTtBQUNBLDBFQUEwRSxXQUFXO0FBQ3JGO0FBQ0E7QUFDQSwwRUFBMEUsV0FBVztBQUNyRjtBQUNBLDhFQUE4RSx1QkFBdUI7QUFDckcsc0dBQXNHLFlBQVksR0FBRyxpQkFBaUI7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZIQUE2SCxTQUFTO0FBQ3RJO0FBQ0EsMEJBQTBCLHdEQUFZOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRztBQUMzRyxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUyxLQUFLLGNBQWMsTUFBTSxjQUFjO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQkFBK0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnREFBZ0QsOEJBQThCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHFDQUFxQztBQUNwRztBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGNBQWM7QUFDckUseUZBQXlGLGdEQUFnRDtBQUN6SSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGNBQWM7QUFDekUsNkZBQTZGLDREQUE0RDtBQUN6Six5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzRUFBc0I7QUFDcEMsY0FBYyxzRUFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZUFBZTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQSx1QkFBdUIseURBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsa0JBQWtCLDBCQUEwQjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDLFFBQVEsaUZBQWlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwyQkFBMkI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZUFBZTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxJQUFJO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOEdBQThHO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsY0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUNBQXFDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9FQUFvQjtBQUM3QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlFQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsMEJBQTBCO0FBQ3RHLCtFQUErRSxxQkFBcUI7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtFQUFrQjtBQUMxQjtBQUNBO0FBQ0EsU0FBUyxpRUFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsVUFBVSxJQUFJLFFBQVE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLDBCQUEwQjtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQ0FBaUM7QUFDdEQ7QUFDQSw0QkFBNEIscURBQU07QUFDbEMsVUFBVSxrRUFBa0I7QUFDNUI7QUFDQSw4QkFBOEIsMkRBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlDQUFpQztBQUN0RDtBQUNBLDhDQUE4QztBQUM5QztBQUNBLDhCQUE4QiwyREFBWTtBQUMxQztBQUNBO0FBQ0EsWUFBWSx5REFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsU0FBUztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrRUFBa0I7QUFDMUI7QUFDQTtBQUNBLFNBQVMsaUVBQWlCO0FBQzFCO0FBQ0E7QUFDQSxTQUFTLG9FQUFvQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMseUVBQXlCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDLFFBQVEsaUZBQWlGO0FBQ3pGO0FBQ0EsbUNBQW1DLGlCQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0VBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4R0FBOEc7QUFDdEg7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlDQUFpQztBQUN0RDtBQUNBO0FBQ0Esd0JBQXdCLGtFQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtFQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtFQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrRUFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrRUFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUVBQWtCLEtBQUssMERBQVMsK0JBQStCLDJCQUEyQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxpRUFBa0IsS0FBSywwREFBUztBQUNwQyxJQUFJLDhEQUFlO0FBQ25CO0FBQ0EsSUFBSSw4REFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFZ087QUFDaE8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hbmFseXRpY3MvZGlzdC9lc20vaW5kZXguZXNtMjAxNy5qcz9mOTJkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9nZXRQcm92aWRlciwgZ2V0QXBwLCBfcmVnaXN0ZXJDb21wb25lbnQsIHJlZ2lzdGVyVmVyc2lvbiB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQGZpcmViYXNlL2xvZ2dlcic7XG5pbXBvcnQgeyBFcnJvckZhY3RvcnksIGNhbGN1bGF0ZUJhY2tvZmZNaWxsaXMsIEZpcmViYXNlRXJyb3IsIGlzSW5kZXhlZERCQXZhaWxhYmxlLCB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlLCBpc0Jyb3dzZXJFeHRlbnNpb24sIGFyZUNvb2tpZXNFbmFibGVkLCBnZXRNb2R1bGFySW5zdGFuY2UsIGRlZXBFcXVhbCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0ICdAZmlyZWJhc2UvaW5zdGFsbGF0aW9ucyc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFR5cGUgY29uc3RhbnQgZm9yIEZpcmViYXNlIEFuYWx5dGljcy5cbiAqL1xuY29uc3QgQU5BTFlUSUNTX1RZUEUgPSAnYW5hbHl0aWNzJztcbi8vIEtleSB0byBhdHRhY2ggRklEIHRvIGluIGd0YWcgcGFyYW1zLlxuY29uc3QgR0FfRklEX0tFWSA9ICdmaXJlYmFzZV9pZCc7XG5jb25zdCBPUklHSU5fS0VZID0gJ29yaWdpbic7XG5jb25zdCBGRVRDSF9USU1FT1VUX01JTExJUyA9IDYwICogMTAwMDtcbmNvbnN0IERZTkFNSUNfQ09ORklHX1VSTCA9ICdodHRwczovL2ZpcmViYXNlLmdvb2dsZWFwaXMuY29tL3YxYWxwaGEvcHJvamVjdHMvLS9hcHBzL3thcHAtaWR9L3dlYkNvbmZpZyc7XG5jb25zdCBHVEFHX1VSTCA9ICdodHRwczovL3d3dy5nb29nbGV0YWdtYW5hZ2VyLmNvbS9ndGFnL2pzJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoJ0BmaXJlYmFzZS9hbmFseXRpY3MnKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IEVSUk9SUyA9IHtcbiAgICBbXCJhbHJlYWR5LWV4aXN0c1wiIC8qIEFuYWx5dGljc0Vycm9yLkFMUkVBRFlfRVhJU1RTICovXTogJ0EgRmlyZWJhc2UgQW5hbHl0aWNzIGluc3RhbmNlIHdpdGggdGhlIGFwcElkIHskaWR9ICcgK1xuICAgICAgICAnIGFscmVhZHkgZXhpc3RzLiAnICtcbiAgICAgICAgJ09ubHkgb25lIEZpcmViYXNlIEFuYWx5dGljcyBpbnN0YW5jZSBjYW4gYmUgY3JlYXRlZCBmb3IgZWFjaCBhcHBJZC4nLFxuICAgIFtcImFscmVhZHktaW5pdGlhbGl6ZWRcIiAvKiBBbmFseXRpY3NFcnJvci5BTFJFQURZX0lOSVRJQUxJWkVEICovXTogJ2luaXRpYWxpemVBbmFseXRpY3MoKSBjYW5ub3QgYmUgY2FsbGVkIGFnYWluIHdpdGggZGlmZmVyZW50IG9wdGlvbnMgdGhhbiB0aG9zZSAnICtcbiAgICAgICAgJ2l0IHdhcyBpbml0aWFsbHkgY2FsbGVkIHdpdGguIEl0IGNhbiBiZSBjYWxsZWQgYWdhaW4gd2l0aCB0aGUgc2FtZSBvcHRpb25zIHRvICcgK1xuICAgICAgICAncmV0dXJuIHRoZSBleGlzdGluZyBpbnN0YW5jZSwgb3IgZ2V0QW5hbHl0aWNzKCkgY2FuIGJlIHVzZWQgJyArXG4gICAgICAgICd0byBnZXQgYSByZWZlcmVuY2UgdG8gdGhlIGFscmVhZHktaW5pdGlhbGl6ZWQgaW5zdGFuY2UuJyxcbiAgICBbXCJhbHJlYWR5LWluaXRpYWxpemVkLXNldHRpbmdzXCIgLyogQW5hbHl0aWNzRXJyb3IuQUxSRUFEWV9JTklUSUFMSVpFRF9TRVRUSU5HUyAqL106ICdGaXJlYmFzZSBBbmFseXRpY3MgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZC4nICtcbiAgICAgICAgJ3NldHRpbmdzKCkgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGluaXRpYWxpemluZyBhbnkgQW5hbHl0aWNzIGluc3RhbmNlJyArXG4gICAgICAgICdvciBpdCB3aWxsIGhhdmUgbm8gZWZmZWN0LicsXG4gICAgW1wiaW50ZXJvcC1jb21wb25lbnQtcmVnLWZhaWxlZFwiIC8qIEFuYWx5dGljc0Vycm9yLklOVEVST1BfQ09NUE9ORU5UX1JFR19GQUlMRUQgKi9dOiAnRmlyZWJhc2UgQW5hbHl0aWNzIEludGVyb3AgQ29tcG9uZW50IGZhaWxlZCB0byBpbnN0YW50aWF0ZTogeyRyZWFzb259JyxcbiAgICBbXCJpbnZhbGlkLWFuYWx5dGljcy1jb250ZXh0XCIgLyogQW5hbHl0aWNzRXJyb3IuSU5WQUxJRF9BTkFMWVRJQ1NfQ09OVEVYVCAqL106ICdGaXJlYmFzZSBBbmFseXRpY3MgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50LiAnICtcbiAgICAgICAgJ1dyYXAgaW5pdGlhbGl6YXRpb24gb2YgYW5hbHl0aWNzIGluIGFuYWx5dGljcy5pc1N1cHBvcnRlZCgpICcgK1xuICAgICAgICAndG8gcHJldmVudCBpbml0aWFsaXphdGlvbiBpbiB1bnN1cHBvcnRlZCBlbnZpcm9ubWVudHMuIERldGFpbHM6IHskZXJyb3JJbmZvfScsXG4gICAgW1wiaW5kZXhlZGRiLXVuYXZhaWxhYmxlXCIgLyogQW5hbHl0aWNzRXJyb3IuSU5ERVhFRERCX1VOQVZBSUxBQkxFICovXTogJ0luZGV4ZWREQiB1bmF2YWlsYWJsZSBvciByZXN0cmljdGVkIGluIHRoaXMgZW52aXJvbm1lbnQuICcgK1xuICAgICAgICAnV3JhcCBpbml0aWFsaXphdGlvbiBvZiBhbmFseXRpY3MgaW4gYW5hbHl0aWNzLmlzU3VwcG9ydGVkKCkgJyArXG4gICAgICAgICd0byBwcmV2ZW50IGluaXRpYWxpemF0aW9uIGluIHVuc3VwcG9ydGVkIGVudmlyb25tZW50cy4gRGV0YWlsczogeyRlcnJvckluZm99JyxcbiAgICBbXCJmZXRjaC10aHJvdHRsZVwiIC8qIEFuYWx5dGljc0Vycm9yLkZFVENIX1RIUk9UVExFICovXTogJ1RoZSBjb25maWcgZmV0Y2ggcmVxdWVzdCB0aW1lZCBvdXQgd2hpbGUgaW4gYW4gZXhwb25lbnRpYWwgYmFja29mZiBzdGF0ZS4nICtcbiAgICAgICAgJyBVbml4IHRpbWVzdGFtcCBpbiBtaWxsaXNlY29uZHMgd2hlbiBmZXRjaCByZXF1ZXN0IHRocm90dGxpbmcgZW5kczogeyR0aHJvdHRsZUVuZFRpbWVNaWxsaXN9LicsXG4gICAgW1wiY29uZmlnLWZldGNoLWZhaWxlZFwiIC8qIEFuYWx5dGljc0Vycm9yLkNPTkZJR19GRVRDSF9GQUlMRUQgKi9dOiAnRHluYW1pYyBjb25maWcgZmV0Y2ggZmFpbGVkOiBbeyRodHRwU3RhdHVzfV0geyRyZXNwb25zZU1lc3NhZ2V9JyxcbiAgICBbXCJuby1hcGkta2V5XCIgLyogQW5hbHl0aWNzRXJyb3IuTk9fQVBJX0tFWSAqL106ICdUaGUgXCJhcGlLZXlcIiBmaWVsZCBpcyBlbXB0eSBpbiB0aGUgbG9jYWwgRmlyZWJhc2UgY29uZmlnLiBGaXJlYmFzZSBBbmFseXRpY3MgcmVxdWlyZXMgdGhpcyBmaWVsZCB0bycgK1xuICAgICAgICAnY29udGFpbiBhIHZhbGlkIEFQSSBrZXkuJyxcbiAgICBbXCJuby1hcHAtaWRcIiAvKiBBbmFseXRpY3NFcnJvci5OT19BUFBfSUQgKi9dOiAnVGhlIFwiYXBwSWRcIiBmaWVsZCBpcyBlbXB0eSBpbiB0aGUgbG9jYWwgRmlyZWJhc2UgY29uZmlnLiBGaXJlYmFzZSBBbmFseXRpY3MgcmVxdWlyZXMgdGhpcyBmaWVsZCB0bycgK1xuICAgICAgICAnY29udGFpbiBhIHZhbGlkIGFwcCBJRC4nLFxuICAgIFtcIm5vLWNsaWVudC1pZFwiIC8qIEFuYWx5dGljc0Vycm9yLk5PX0NMSUVOVF9JRCAqL106ICdUaGUgXCJjbGllbnRfaWRcIiBmaWVsZCBpcyBlbXB0eS4nLFxuICAgIFtcImludmFsaWQtZ3RhZy1yZXNvdXJjZVwiIC8qIEFuYWx5dGljc0Vycm9yLklOVkFMSURfR1RBR19SRVNPVVJDRSAqL106ICdUcnVzdGVkIFR5cGVzIGRldGVjdGVkIGFuIGludmFsaWQgZ3RhZyByZXNvdXJjZTogeyRndGFnVVJMfS4nXG59O1xuY29uc3QgRVJST1JfRkFDVE9SWSA9IG5ldyBFcnJvckZhY3RvcnkoJ2FuYWx5dGljcycsICdBbmFseXRpY3MnLCBFUlJPUlMpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBWZXJpZmllcyBhbmQgY3JlYXRlcyBhIFRydXN0ZWRTY3JpcHRVUkwuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUd0YWdUcnVzdGVkVHlwZXNTY3JpcHRVUkwodXJsKSB7XG4gICAgaWYgKCF1cmwuc3RhcnRzV2l0aChHVEFHX1VSTCkpIHtcbiAgICAgICAgY29uc3QgZXJyID0gRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpbnZhbGlkLWd0YWctcmVzb3VyY2VcIiAvKiBBbmFseXRpY3NFcnJvci5JTlZBTElEX0dUQUdfUkVTT1VSQ0UgKi8sIHtcbiAgICAgICAgICAgIGd0YWdVUkw6IHVybFxuICAgICAgICB9KTtcbiAgICAgICAgbG9nZ2VyLndhcm4oZXJyLm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG59XG4vKipcbiAqIE1ha2VzaGlmdCBwb2x5ZmlsbCBmb3IgUHJvbWlzZS5hbGxTZXR0bGVkKCkuIFJlc29sdmVzIHdoZW4gYWxsIHByb21pc2VzXG4gKiBoYXZlIGVpdGhlciByZXNvbHZlZCBvciByZWplY3RlZC5cbiAqXG4gKiBAcGFyYW0gcHJvbWlzZXMgQXJyYXkgb2YgcHJvbWlzZXMgdG8gd2FpdCBmb3IuXG4gKi9cbmZ1bmN0aW9uIHByb21pc2VBbGxTZXR0bGVkKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzLm1hcChwcm9taXNlID0+IHByb21pc2UuY2F0Y2goZSA9PiBlKSkpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgVHJ1c3RlZFR5cGVQb2xpY3kgb2JqZWN0IHRoYXQgaW1wbGVtZW50cyB0aGUgcnVsZXMgcGFzc2VkIGFzIHBvbGljeU9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHBvbGljeU5hbWUgQSBzdHJpbmcgY29udGFpbmluZyB0aGUgbmFtZSBvZiB0aGUgcG9saWN5XG4gKiBAcGFyYW0gcG9saWN5T3B0aW9ucyBPYmplY3QgY29udGFpbmluZyBpbXBsZW1lbnRhdGlvbnMgb2YgaW5zdGFuY2UgbWV0aG9kcyBmb3IgVHJ1c3RlZFR5cGVzUG9saWN5LCBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UcnVzdGVkVHlwZVBvbGljeSNpbnN0YW5jZV9tZXRob2RzXG4gKiB8IHRoZSBUcnVzdGVkVHlwZVBvbGljeSByZWZlcmVuY2UgZG9jdW1lbnRhdGlvbn0uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeShwb2xpY3lOYW1lLCBwb2xpY3lPcHRpb25zKSB7XG4gICAgLy8gQ3JlYXRlIGEgVHJ1c3RlZFR5cGVzIHBvbGljeSB0aGF0IHdlIGNhbiB1c2UgZm9yIHVwZGF0aW5nIHNyY1xuICAgIC8vIHByb3BlcnRpZXNcbiAgICBsZXQgdHJ1c3RlZFR5cGVzUG9saWN5O1xuICAgIGlmICh3aW5kb3cudHJ1c3RlZFR5cGVzKSB7XG4gICAgICAgIHRydXN0ZWRUeXBlc1BvbGljeSA9IHdpbmRvdy50cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5KHBvbGljeU5hbWUsIHBvbGljeU9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1c3RlZFR5cGVzUG9saWN5O1xufVxuLyoqXG4gKiBJbnNlcnRzIGd0YWcgc2NyaXB0IHRhZyBpbnRvIHRoZSBwYWdlIHRvIGFzeW5jaHJvbm91c2x5IGRvd25sb2FkIGd0YWcuXG4gKiBAcGFyYW0gZGF0YUxheWVyTmFtZSBOYW1lIG9mIGRhdGFsYXllciAobW9zdCBvZnRlbiB0aGUgZGVmYXVsdCwgXCJfZGF0YUxheWVyXCIpLlxuICovXG5mdW5jdGlvbiBpbnNlcnRTY3JpcHRUYWcoZGF0YUxheWVyTmFtZSwgbWVhc3VyZW1lbnRJZCkge1xuICAgIGNvbnN0IHRydXN0ZWRUeXBlc1BvbGljeSA9IGNyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeSgnZmlyZWJhc2UtanMtc2RrLXBvbGljeScsIHtcbiAgICAgICAgY3JlYXRlU2NyaXB0VVJMOiBjcmVhdGVHdGFnVHJ1c3RlZFR5cGVzU2NyaXB0VVJMXG4gICAgfSk7XG4gICAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgLy8gV2UgYXJlIG5vdCBwcm92aWRpbmcgYW4gYW5hbHl0aWNzSWQgaW4gdGhlIFVSTCBiZWNhdXNlIGl0IHdvdWxkIHRyaWdnZXIgYSBgcGFnZV92aWV3YFxuICAgIC8vIHdpdGhvdXQgZmlkLiBXZSB3aWxsIGluaXRpYWxpemUgZ2EtaWQgdXNpbmcgZ3RhZyAoY29uZmlnKSBjb21tYW5kIHRvZ2V0aGVyIHdpdGggZmlkLlxuICAgIGNvbnN0IGd0YWdTY3JpcHRVUkwgPSBgJHtHVEFHX1VSTH0/bD0ke2RhdGFMYXllck5hbWV9JmlkPSR7bWVhc3VyZW1lbnRJZH1gO1xuICAgIHNjcmlwdC5zcmMgPSB0cnVzdGVkVHlwZXNQb2xpY3lcbiAgICAgICAgPyB0cnVzdGVkVHlwZXNQb2xpY3kgPT09IG51bGwgfHwgdHJ1c3RlZFR5cGVzUG9saWN5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlU2NyaXB0VVJMKGd0YWdTY3JpcHRVUkwpXG4gICAgICAgIDogZ3RhZ1NjcmlwdFVSTDtcbiAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbn1cbi8qKlxuICogR2V0IHJlZmVyZW5jZSB0bywgb3IgY3JlYXRlLCBnbG9iYWwgZGF0YWxheWVyLlxuICogQHBhcmFtIGRhdGFMYXllck5hbWUgTmFtZSBvZiBkYXRhbGF5ZXIgKG1vc3Qgb2Z0ZW4gdGhlIGRlZmF1bHQsIFwiX2RhdGFMYXllclwiKS5cbiAqL1xuZnVuY3Rpb24gZ2V0T3JDcmVhdGVEYXRhTGF5ZXIoZGF0YUxheWVyTmFtZSkge1xuICAgIC8vIENoZWNrIGZvciBleGlzdGluZyBkYXRhTGF5ZXIgYW5kIGNyZWF0ZSBpZiBuZWVkZWQuXG4gICAgbGV0IGRhdGFMYXllciA9IFtdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHdpbmRvd1tkYXRhTGF5ZXJOYW1lXSkpIHtcbiAgICAgICAgZGF0YUxheWVyID0gd2luZG93W2RhdGFMYXllck5hbWVdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd2luZG93W2RhdGFMYXllck5hbWVdID0gZGF0YUxheWVyO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YUxheWVyO1xufVxuLyoqXG4gKiBXcmFwcGVkIGd0YWcgbG9naWMgd2hlbiBndGFnIGlzIGNhbGxlZCB3aXRoICdjb25maWcnIGNvbW1hbmQuXG4gKlxuICogQHBhcmFtIGd0YWdDb3JlIEJhc2ljIGd0YWcgZnVuY3Rpb24gdGhhdCBqdXN0IGFwcGVuZHMgdG8gZGF0YUxheWVyLlxuICogQHBhcmFtIGluaXRpYWxpemF0aW9uUHJvbWlzZXNNYXAgTWFwIG9mIGFwcElkcyB0byB0aGVpciBpbml0aWFsaXphdGlvbiBwcm9taXNlcy5cbiAqIEBwYXJhbSBkeW5hbWljQ29uZmlnUHJvbWlzZXNMaXN0IEFycmF5IG9mIGR5bmFtaWMgY29uZmlnIGZldGNoIHByb21pc2VzLlxuICogQHBhcmFtIG1lYXN1cmVtZW50SWRUb0FwcElkIE1hcCBvZiBHQSBtZWFzdXJlbWVudElEcyB0byBjb3JyZXNwb25kaW5nIEZpcmViYXNlIGFwcElkLlxuICogQHBhcmFtIG1lYXN1cmVtZW50SWQgR0EgTWVhc3VyZW1lbnQgSUQgdG8gc2V0IGNvbmZpZyBmb3IuXG4gKiBAcGFyYW0gZ3RhZ1BhcmFtcyBHdGFnIGNvbmZpZyBwYXJhbXMgdG8gc2V0LlxuICovXG5hc3luYyBmdW5jdGlvbiBndGFnT25Db25maWcoZ3RhZ0NvcmUsIGluaXRpYWxpemF0aW9uUHJvbWlzZXNNYXAsIGR5bmFtaWNDb25maWdQcm9taXNlc0xpc3QsIG1lYXN1cmVtZW50SWRUb0FwcElkLCBtZWFzdXJlbWVudElkLCBndGFnUGFyYW1zKSB7XG4gICAgLy8gSWYgY29uZmlnIGlzIGFscmVhZHkgZmV0Y2hlZCwgd2Uga25vdyB0aGUgYXBwSWQgYW5kIGNhbiB1c2UgaXQgdG8gbG9vayB1cCB3aGF0IEZJRCBwcm9taXNlIHdlXG4gICAgLy8vIGFyZSB3YWl0aW5nIGZvciwgYW5kIHdhaXQgb25seSBvbiB0aGF0IG9uZS5cbiAgICBjb25zdCBjb3JyZXNwb25kaW5nQXBwSWQgPSBtZWFzdXJlbWVudElkVG9BcHBJZFttZWFzdXJlbWVudElkXTtcbiAgICB0cnkge1xuICAgICAgICBpZiAoY29ycmVzcG9uZGluZ0FwcElkKSB7XG4gICAgICAgICAgICBhd2FpdCBpbml0aWFsaXphdGlvblByb21pc2VzTWFwW2NvcnJlc3BvbmRpbmdBcHBJZF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBjb25maWcgaXMgbm90IGZldGNoZWQgeWV0LCB3YWl0IGZvciBhbGwgY29uZmlncyAod2UgZG9uJ3Qga25vdyB3aGljaCBvbmUgd2UgbmVlZCkgYW5kXG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBhcHBJZCAoaWYgYW55KSBjb3JyZXNwb25kaW5nIHRvIHRoaXMgbWVhc3VyZW1lbnRJZC4gSWYgdGhlcmUgaXMgb25lLCB3YWl0IG9uXG4gICAgICAgICAgICAvLyB0aGF0IGFwcElkJ3MgaW5pdGlhbGl6YXRpb24gcHJvbWlzZS4gSWYgdGhlcmUgaXMgbm9uZSwgcHJvbWlzZSByZXNvbHZlcyBhbmQgZ3RhZ1xuICAgICAgICAgICAgLy8gY2FsbCBnb2VzIHRocm91Z2guXG4gICAgICAgICAgICBjb25zdCBkeW5hbWljQ29uZmlnUmVzdWx0cyA9IGF3YWl0IHByb21pc2VBbGxTZXR0bGVkKGR5bmFtaWNDb25maWdQcm9taXNlc0xpc3QpO1xuICAgICAgICAgICAgY29uc3QgZm91bmRDb25maWcgPSBkeW5hbWljQ29uZmlnUmVzdWx0cy5maW5kKGNvbmZpZyA9PiBjb25maWcubWVhc3VyZW1lbnRJZCA9PT0gbWVhc3VyZW1lbnRJZCk7XG4gICAgICAgICAgICBpZiAoZm91bmRDb25maWcpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBpbml0aWFsaXphdGlvblByb21pc2VzTWFwW2ZvdW5kQ29uZmlnLmFwcElkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoZSk7XG4gICAgfVxuICAgIGd0YWdDb3JlKFwiY29uZmlnXCIgLyogR3RhZ0NvbW1hbmQuQ09ORklHICovLCBtZWFzdXJlbWVudElkLCBndGFnUGFyYW1zKTtcbn1cbi8qKlxuICogV3JhcHBlZCBndGFnIGxvZ2ljIHdoZW4gZ3RhZyBpcyBjYWxsZWQgd2l0aCAnZXZlbnQnIGNvbW1hbmQuXG4gKlxuICogQHBhcmFtIGd0YWdDb3JlIEJhc2ljIGd0YWcgZnVuY3Rpb24gdGhhdCBqdXN0IGFwcGVuZHMgdG8gZGF0YUxheWVyLlxuICogQHBhcmFtIGluaXRpYWxpemF0aW9uUHJvbWlzZXNNYXAgTWFwIG9mIGFwcElkcyB0byB0aGVpciBpbml0aWFsaXphdGlvbiBwcm9taXNlcy5cbiAqIEBwYXJhbSBkeW5hbWljQ29uZmlnUHJvbWlzZXNMaXN0IEFycmF5IG9mIGR5bmFtaWMgY29uZmlnIGZldGNoIHByb21pc2VzLlxuICogQHBhcmFtIG1lYXN1cmVtZW50SWQgR0EgTWVhc3VyZW1lbnQgSUQgdG8gbG9nIGV2ZW50IHRvLlxuICogQHBhcmFtIGd0YWdQYXJhbXMgUGFyYW1zIHRvIGxvZyB3aXRoIHRoaXMgZXZlbnQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGd0YWdPbkV2ZW50KGd0YWdDb3JlLCBpbml0aWFsaXphdGlvblByb21pc2VzTWFwLCBkeW5hbWljQ29uZmlnUHJvbWlzZXNMaXN0LCBtZWFzdXJlbWVudElkLCBndGFnUGFyYW1zKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IGluaXRpYWxpemF0aW9uUHJvbWlzZXNUb1dhaXRGb3IgPSBbXTtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBhICdzZW5kX3RvJyBwYXJhbSwgY2hlY2sgaWYgYW55IElEIHNwZWNpZmllZCBtYXRjaGVzXG4gICAgICAgIC8vIGFuIGluaXRpYWxpemVJZHMoKSBwcm9taXNlIHdlIGFyZSB3YWl0aW5nIGZvci5cbiAgICAgICAgaWYgKGd0YWdQYXJhbXMgJiYgZ3RhZ1BhcmFtc1snc2VuZF90byddKSB7XG4gICAgICAgICAgICBsZXQgZ2FTZW5kVG9MaXN0ID0gZ3RhZ1BhcmFtc1snc2VuZF90byddO1xuICAgICAgICAgICAgLy8gTWFrZSBpdCBhbiBhcnJheSBpZiBpcyBpc24ndCwgc28gaXQgY2FuIGJlIGRlYWx0IHdpdGggdGhlIHNhbWUgd2F5LlxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGdhU2VuZFRvTGlzdCkpIHtcbiAgICAgICAgICAgICAgICBnYVNlbmRUb0xpc3QgPSBbZ2FTZW5kVG9MaXN0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNraW5nICdzZW5kX3RvJyBmaWVsZHMgcmVxdWlyZXMgaGF2aW5nIGFsbCBtZWFzdXJlbWVudCBJRCByZXN1bHRzIGJhY2sgZnJvbVxuICAgICAgICAgICAgLy8gdGhlIGR5bmFtaWMgY29uZmlnIGZldGNoLlxuICAgICAgICAgICAgY29uc3QgZHluYW1pY0NvbmZpZ1Jlc3VsdHMgPSBhd2FpdCBwcm9taXNlQWxsU2V0dGxlZChkeW5hbWljQ29uZmlnUHJvbWlzZXNMaXN0KTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2VuZFRvSWQgb2YgZ2FTZW5kVG9MaXN0KSB7XG4gICAgICAgICAgICAgICAgLy8gQW55IGZldGNoZWQgZHluYW1pYyBtZWFzdXJlbWVudCBJRCB0aGF0IG1hdGNoZXMgdGhpcyAnc2VuZF90bycgSURcbiAgICAgICAgICAgICAgICBjb25zdCBmb3VuZENvbmZpZyA9IGR5bmFtaWNDb25maWdSZXN1bHRzLmZpbmQoY29uZmlnID0+IGNvbmZpZy5tZWFzdXJlbWVudElkID09PSBzZW5kVG9JZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbGl6YXRpb25Qcm9taXNlID0gZm91bmRDb25maWcgJiYgaW5pdGlhbGl6YXRpb25Qcm9taXNlc01hcFtmb3VuZENvbmZpZy5hcHBJZF07XG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxpemF0aW9uUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblByb21pc2VzVG9XYWl0Rm9yLnB1c2goaW5pdGlhbGl6YXRpb25Qcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvdW5kIGFuIGl0ZW0gaW4gJ3NlbmRfdG8nIHRoYXQgaXMgbm90IGFzc29jaWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlyZWN0bHkgd2l0aCBhbiBGSUQsIHBvc3NpYmx5IGEgZ3JvdXAuICBFbXB0eSB0aGlzIGFycmF5LFxuICAgICAgICAgICAgICAgICAgICAvLyBleGl0IHRoZSBsb29wIGVhcmx5LCBhbmQgbGV0IGl0IGdldCBwb3B1bGF0ZWQgYmVsb3cuXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uUHJvbWlzZXNUb1dhaXRGb3IgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSB1bnBvcHVsYXRlZCBpZiB0aGVyZSB3YXMgbm8gJ3NlbmRfdG8nIGZpZWxkICwgb3JcbiAgICAgICAgLy8gaWYgbm90IGFsbCBlbnRyaWVzIGluIHRoZSAnc2VuZF90bycgZmllbGQgY291bGQgYmUgbWFwcGVkIHRvXG4gICAgICAgIC8vIGEgRklELiBJbiB0aGVzZSBjYXNlcywgd2FpdCBvbiBhbGwgcGVuZGluZyBpbml0aWFsaXphdGlvbiBwcm9taXNlcy5cbiAgICAgICAgaWYgKGluaXRpYWxpemF0aW9uUHJvbWlzZXNUb1dhaXRGb3IubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzICovXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblByb21pc2VzVG9XYWl0Rm9yID0gT2JqZWN0LnZhbHVlcyhpbml0aWFsaXphdGlvblByb21pc2VzTWFwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSdW4gY29yZSBndGFnIGZ1bmN0aW9uIHdpdGggYXJncyBhZnRlciBhbGwgcmVsZXZhbnQgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgLy8gcHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkLlxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChpbml0aWFsaXphdGlvblByb21pc2VzVG9XYWl0Rm9yKTtcbiAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cDovL2IvMTQxMzcwNDQ5IC0gdGhpcmQgYXJndW1lbnQgY2Fubm90IGJlIHVuZGVmaW5lZC5cbiAgICAgICAgZ3RhZ0NvcmUoXCJldmVudFwiIC8qIEd0YWdDb21tYW5kLkVWRU5UICovLCBtZWFzdXJlbWVudElkLCBndGFnUGFyYW1zIHx8IHt9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGUpO1xuICAgIH1cbn1cbi8qKlxuICogV3JhcHMgYSBzdGFuZGFyZCBndGFnIGZ1bmN0aW9uIHdpdGggZXh0cmEgY29kZSB0byB3YWl0IGZvciBjb21wbGV0aW9uIG9mXG4gKiByZWxldmFudCBpbml0aWFsaXphdGlvbiBwcm9taXNlcyBiZWZvcmUgc2VuZGluZyByZXF1ZXN0cy5cbiAqXG4gKiBAcGFyYW0gZ3RhZ0NvcmUgQmFzaWMgZ3RhZyBmdW5jdGlvbiB0aGF0IGp1c3QgYXBwZW5kcyB0byBkYXRhTGF5ZXIuXG4gKiBAcGFyYW0gaW5pdGlhbGl6YXRpb25Qcm9taXNlc01hcCBNYXAgb2YgYXBwSWRzIHRvIHRoZWlyIGluaXRpYWxpemF0aW9uIHByb21pc2VzLlxuICogQHBhcmFtIGR5bmFtaWNDb25maWdQcm9taXNlc0xpc3QgQXJyYXkgb2YgZHluYW1pYyBjb25maWcgZmV0Y2ggcHJvbWlzZXMuXG4gKiBAcGFyYW0gbWVhc3VyZW1lbnRJZFRvQXBwSWQgTWFwIG9mIEdBIG1lYXN1cmVtZW50SURzIHRvIGNvcnJlc3BvbmRpbmcgRmlyZWJhc2UgYXBwSWQuXG4gKi9cbmZ1bmN0aW9uIHdyYXBHdGFnKGd0YWdDb3JlLCBcbi8qKlxuICogQWxsb3dzIHdyYXBwZWQgZ3RhZyBjYWxscyB0byB3YWl0IG9uIHdoaWNoZXZlciBpbml0aWFsaXphdGlvbiBwcm9taXNlcyBhcmUgcmVxdWlyZWQsXG4gKiBkZXBlbmRpbmcgb24gdGhlIGNvbnRlbnRzIG9mIHRoZSBndGFnIHBhcmFtcycgYHNlbmRfdG9gIGZpZWxkLCBpZiBhbnkuXG4gKi9cbmluaXRpYWxpemF0aW9uUHJvbWlzZXNNYXAsIFxuLyoqXG4gKiBXcmFwcGVkIGd0YWcgY2FsbHMgc29tZXRpbWVzIHJlcXVpcmUgYWxsIGR5bmFtaWMgY29uZmlnIGZldGNoZXMgdG8gaGF2ZSByZXR1cm5lZFxuICogYmVmb3JlIGRldGVybWluaW5nIHdoYXQgaW5pdGlhbGl6YXRpb24gcHJvbWlzZXMgKHdoaWNoIGluY2x1ZGUgRklEcykgdG8gd2FpdCBmb3IuXG4gKi9cbmR5bmFtaWNDb25maWdQcm9taXNlc0xpc3QsIFxuLyoqXG4gKiBXcmFwcGVkIGd0YWcgY29uZmlnIGNhbGxzIGNhbiBuYXJyb3cgZG93biB3aGljaCBpbml0aWFsaXphdGlvbiBwcm9taXNlICh3aXRoIEZJRClcbiAqIHRvIHdhaXQgZm9yIGlmIHRoZSBtZWFzdXJlbWVudElkIGlzIGFscmVhZHkgZmV0Y2hlZCwgYnkgZ2V0dGluZyB0aGUgY29ycmVzcG9uZGluZyBhcHBJZCxcbiAqIHdoaWNoIGlzIHRoZSBrZXkgZm9yIHRoZSBpbml0aWFsaXphdGlvbiBwcm9taXNlcyBtYXAuXG4gKi9cbm1lYXN1cmVtZW50SWRUb0FwcElkKSB7XG4gICAgLyoqXG4gICAgICogV3JhcHBlciBhcm91bmQgZ3RhZyB0aGF0IGVuc3VyZXMgRklEIGlzIHNlbnQgd2l0aCBndGFnIGNhbGxzLlxuICAgICAqIEBwYXJhbSBjb21tYW5kIEd0YWcgY29tbWFuZCB0eXBlLlxuICAgICAqIEBwYXJhbSBpZE9yTmFtZU9yUGFyYW1zIE1lYXN1cmVtZW50IElEIGlmIGNvbW1hbmQgaXMgRVZFTlQvQ09ORklHLCBwYXJhbXMgaWYgY29tbWFuZCBpcyBTRVQuXG4gICAgICogQHBhcmFtIGd0YWdQYXJhbXMgUGFyYW1zIGlmIGV2ZW50IGlzIEVWRU5UL0NPTkZJRy5cbiAgICAgKi9cbiAgICBhc3luYyBmdW5jdGlvbiBndGFnV3JhcHBlcihjb21tYW5kLCAuLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBJZiBldmVudCwgY2hlY2sgdGhhdCByZWxldmFudCBpbml0aWFsaXphdGlvbiBwcm9taXNlcyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgICAgICAgIGlmIChjb21tYW5kID09PSBcImV2ZW50XCIgLyogR3RhZ0NvbW1hbmQuRVZFTlQgKi8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbbWVhc3VyZW1lbnRJZCwgZ3RhZ1BhcmFtc10gPSBhcmdzO1xuICAgICAgICAgICAgICAgIC8vIElmIEVWRU5ULCBzZWNvbmQgYXJnIG11c3QgYmUgbWVhc3VyZW1lbnRJZC5cbiAgICAgICAgICAgICAgICBhd2FpdCBndGFnT25FdmVudChndGFnQ29yZSwgaW5pdGlhbGl6YXRpb25Qcm9taXNlc01hcCwgZHluYW1pY0NvbmZpZ1Byb21pc2VzTGlzdCwgbWVhc3VyZW1lbnRJZCwgZ3RhZ1BhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb21tYW5kID09PSBcImNvbmZpZ1wiIC8qIEd0YWdDb21tYW5kLkNPTkZJRyAqLykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFttZWFzdXJlbWVudElkLCBndGFnUGFyYW1zXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgLy8gSWYgQ09ORklHLCBzZWNvbmQgYXJnIG11c3QgYmUgbWVhc3VyZW1lbnRJZC5cbiAgICAgICAgICAgICAgICBhd2FpdCBndGFnT25Db25maWcoZ3RhZ0NvcmUsIGluaXRpYWxpemF0aW9uUHJvbWlzZXNNYXAsIGR5bmFtaWNDb25maWdQcm9taXNlc0xpc3QsIG1lYXN1cmVtZW50SWRUb0FwcElkLCBtZWFzdXJlbWVudElkLCBndGFnUGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiY29uc2VudFwiIC8qIEd0YWdDb21tYW5kLkNPTlNFTlQgKi8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbY29uc2VudEFjdGlvbiwgZ3RhZ1BhcmFtc10gPSBhcmdzO1xuICAgICAgICAgICAgICAgIC8vIGNvbnNlbnRBY3Rpb24gY2FuIGJlIG9uZSBvZiAnZGVmYXVsdCcgb3IgJ3VwZGF0ZScuXG4gICAgICAgICAgICAgICAgZ3RhZ0NvcmUoXCJjb25zZW50XCIgLyogR3RhZ0NvbW1hbmQuQ09OU0VOVCAqLywgY29uc2VudEFjdGlvbiwgZ3RhZ1BhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb21tYW5kID09PSBcImdldFwiIC8qIEd0YWdDb21tYW5kLkdFVCAqLykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFttZWFzdXJlbWVudElkLCBmaWVsZE5hbWUsIGNhbGxiYWNrXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgZ3RhZ0NvcmUoXCJnZXRcIiAvKiBHdGFnQ29tbWFuZC5HRVQgKi8sIG1lYXN1cmVtZW50SWQsIGZpZWxkTmFtZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJzZXRcIiAvKiBHdGFnQ29tbWFuZC5TRVQgKi8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbY3VzdG9tUGFyYW1zXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgLy8gSWYgU0VULCBzZWNvbmQgYXJnIG11c3QgYmUgcGFyYW1zLlxuICAgICAgICAgICAgICAgIGd0YWdDb3JlKFwic2V0XCIgLyogR3RhZ0NvbW1hbmQuU0VUICovLCBjdXN0b21QYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3RhZ0NvcmUoY29tbWFuZCwgLi4uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ3RhZ1dyYXBwZXI7XG59XG4vKipcbiAqIENyZWF0ZXMgZ2xvYmFsIGd0YWcgZnVuY3Rpb24gb3Igd3JhcHMgZXhpc3Rpbmcgb25lIGlmIGZvdW5kLlxuICogVGhpcyB3cmFwcGVkIGZ1bmN0aW9uIGF0dGFjaGVzIEZpcmViYXNlIGluc3RhbmNlIElEIChGSUQpIHRvIGd0YWcgJ2NvbmZpZycgYW5kXG4gKiAnZXZlbnQnIGNhbGxzIHRoYXQgYmVsb25nIHRvIHRoZSBHQUlEIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEZpcmViYXNlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBpbml0aWFsaXphdGlvblByb21pc2VzTWFwIE1hcCBvZiBhcHBJZHMgdG8gdGhlaXIgaW5pdGlhbGl6YXRpb24gcHJvbWlzZXMuXG4gKiBAcGFyYW0gZHluYW1pY0NvbmZpZ1Byb21pc2VzTGlzdCBBcnJheSBvZiBkeW5hbWljIGNvbmZpZyBmZXRjaCBwcm9taXNlcy5cbiAqIEBwYXJhbSBtZWFzdXJlbWVudElkVG9BcHBJZCBNYXAgb2YgR0EgbWVhc3VyZW1lbnRJRHMgdG8gY29ycmVzcG9uZGluZyBGaXJlYmFzZSBhcHBJZC5cbiAqIEBwYXJhbSBkYXRhTGF5ZXJOYW1lIE5hbWUgb2YgZ2xvYmFsIEdBIGRhdGFsYXllciBhcnJheS5cbiAqIEBwYXJhbSBndGFnRnVuY3Rpb25OYW1lIE5hbWUgb2YgZ2xvYmFsIGd0YWcgZnVuY3Rpb24gKFwiZ3RhZ1wiIGlmIG5vdCB1c2VyLXNwZWNpZmllZCkuXG4gKi9cbmZ1bmN0aW9uIHdyYXBPckNyZWF0ZUd0YWcoaW5pdGlhbGl6YXRpb25Qcm9taXNlc01hcCwgZHluYW1pY0NvbmZpZ1Byb21pc2VzTGlzdCwgbWVhc3VyZW1lbnRJZFRvQXBwSWQsIGRhdGFMYXllck5hbWUsIGd0YWdGdW5jdGlvbk5hbWUpIHtcbiAgICAvLyBDcmVhdGUgYSBiYXNpYyBjb3JlIGd0YWcgZnVuY3Rpb25cbiAgICBsZXQgZ3RhZ0NvcmUgPSBmdW5jdGlvbiAoLi4uX2FyZ3MpIHtcbiAgICAgICAgLy8gTXVzdCBwdXNoIElBcmd1bWVudHMgb2JqZWN0LCBub3QgYW4gYXJyYXkuXG4gICAgICAgIHdpbmRvd1tkYXRhTGF5ZXJOYW1lXS5wdXNoKGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvLyBSZXBsYWNlIGl0IHdpdGggZXhpc3Rpbmcgb25lIGlmIGZvdW5kXG4gICAgaWYgKHdpbmRvd1tndGFnRnVuY3Rpb25OYW1lXSAmJlxuICAgICAgICB0eXBlb2Ygd2luZG93W2d0YWdGdW5jdGlvbk5hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZ3RhZ0NvcmUgPSB3aW5kb3dbZ3RhZ0Z1bmN0aW9uTmFtZV07XG4gICAgfVxuICAgIHdpbmRvd1tndGFnRnVuY3Rpb25OYW1lXSA9IHdyYXBHdGFnKGd0YWdDb3JlLCBpbml0aWFsaXphdGlvblByb21pc2VzTWFwLCBkeW5hbWljQ29uZmlnUHJvbWlzZXNMaXN0LCBtZWFzdXJlbWVudElkVG9BcHBJZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ3RhZ0NvcmUsXG4gICAgICAgIHdyYXBwZWRHdGFnOiB3aW5kb3dbZ3RhZ0Z1bmN0aW9uTmFtZV1cbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY3JpcHQgdGFnIGluIHRoZSBET00gbWF0Y2hpbmcgYm90aCB0aGUgZ3RhZyB1cmwgcGF0dGVyblxuICogYW5kIHRoZSBwcm92aWRlZCBkYXRhIGxheWVyIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIGZpbmRHdGFnU2NyaXB0T25QYWdlKGRhdGFMYXllck5hbWUpIHtcbiAgICBjb25zdCBzY3JpcHRUYWdzID0gd2luZG93LmRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgICBmb3IgKGNvbnN0IHRhZyBvZiBPYmplY3QudmFsdWVzKHNjcmlwdFRhZ3MpKSB7XG4gICAgICAgIGlmICh0YWcuc3JjICYmXG4gICAgICAgICAgICB0YWcuc3JjLmluY2x1ZGVzKEdUQUdfVVJMKSAmJlxuICAgICAgICAgICAgdGFnLnNyYy5pbmNsdWRlcyhkYXRhTGF5ZXJOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhZztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQmFja29mZiBmYWN0b3IgZm9yIDUwMyBlcnJvcnMsIHdoaWNoIHdlIHdhbnQgdG8gYmUgY29uc2VydmF0aXZlIGFib3V0XG4gKiB0byBhdm9pZCBvdmVybG9hZGluZyBzZXJ2ZXJzLiBFYWNoIHJldHJ5IGludGVydmFsIHdpbGwgYmVcbiAqIEJBU0VfSU5URVJWQUxfTUlMTElTICogTE9OR19SRVRSWV9GQUNUT1IgXiByZXRyeUNvdW50LCBzbyB0aGUgc2Vjb25kIG9uZVxuICogd2lsbCBiZSB+MzAgc2Vjb25kcyAod2l0aCBmdXp6aW5nKS5cbiAqL1xuY29uc3QgTE9OR19SRVRSWV9GQUNUT1IgPSAzMDtcbi8qKlxuICogQmFzZSB3YWl0IGludGVydmFsIHRvIG11bHRpcGxpZWQgYnkgYmFja29mZkZhY3Rvcl5iYWNrb2ZmQ291bnQuXG4gKi9cbmNvbnN0IEJBU0VfSU5URVJWQUxfTUlMTElTID0gMTAwMDtcbi8qKlxuICogU3R1YmJhYmxlIHJldHJ5IGRhdGEgc3RvcmFnZSBjbGFzcy5cbiAqL1xuY2xhc3MgUmV0cnlEYXRhIHtcbiAgICBjb25zdHJ1Y3Rvcih0aHJvdHRsZU1ldGFkYXRhID0ge30sIGludGVydmFsTWlsbGlzID0gQkFTRV9JTlRFUlZBTF9NSUxMSVMpIHtcbiAgICAgICAgdGhpcy50aHJvdHRsZU1ldGFkYXRhID0gdGhyb3R0bGVNZXRhZGF0YTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbE1pbGxpcyA9IGludGVydmFsTWlsbGlzO1xuICAgIH1cbiAgICBnZXRUaHJvdHRsZU1ldGFkYXRhKGFwcElkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRocm90dGxlTWV0YWRhdGFbYXBwSWRdO1xuICAgIH1cbiAgICBzZXRUaHJvdHRsZU1ldGFkYXRhKGFwcElkLCBtZXRhZGF0YSkge1xuICAgICAgICB0aGlzLnRocm90dGxlTWV0YWRhdGFbYXBwSWRdID0gbWV0YWRhdGE7XG4gICAgfVxuICAgIGRlbGV0ZVRocm90dGxlTWV0YWRhdGEoYXBwSWQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudGhyb3R0bGVNZXRhZGF0YVthcHBJZF07XG4gICAgfVxufVxuY29uc3QgZGVmYXVsdFJldHJ5RGF0YSA9IG5ldyBSZXRyeURhdGEoKTtcbi8qKlxuICogU2V0IEdFVCByZXF1ZXN0IGhlYWRlcnMuXG4gKiBAcGFyYW0gYXBpS2V5IEFwcCBBUEkga2V5LlxuICovXG5mdW5jdGlvbiBnZXRIZWFkZXJzKGFwaUtleSkge1xuICAgIHJldHVybiBuZXcgSGVhZGVycyh7XG4gICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAneC1nb29nLWFwaS1rZXknOiBhcGlLZXlcbiAgICB9KTtcbn1cbi8qKlxuICogRmV0Y2hlcyBkeW5hbWljIGNvbmZpZyBmcm9tIGJhY2tlbmQuXG4gKiBAcGFyYW0gYXBwIEZpcmViYXNlIGFwcCB0byBmZXRjaCBjb25maWcgZm9yLlxuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaER5bmFtaWNDb25maWcoYXBwRmllbGRzKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgYXBwSWQsIGFwaUtleSB9ID0gYXBwRmllbGRzO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IGdldEhlYWRlcnMoYXBpS2V5KVxuICAgIH07XG4gICAgY29uc3QgYXBwVXJsID0gRFlOQU1JQ19DT05GSUdfVVJMLnJlcGxhY2UoJ3thcHAtaWR9JywgYXBwSWQpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYXBwVXJsLCByZXF1ZXN0KTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzICE9PSAzMDQpIHtcbiAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9ICcnO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIGdldCBhbnkgZXJyb3IgbWVzc2FnZSB0ZXh0IGZyb20gc2VydmVyIHJlc3BvbnNlLlxuICAgICAgICAgICAgY29uc3QganNvblJlc3BvbnNlID0gKGF3YWl0IHJlc3BvbnNlLmpzb24oKSk7XG4gICAgICAgICAgICBpZiAoKF9hID0ganNvblJlc3BvbnNlLmVycm9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGpzb25SZXNwb25zZS5lcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfaWdub3JlZCkgeyB9XG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiY29uZmlnLWZldGNoLWZhaWxlZFwiIC8qIEFuYWx5dGljc0Vycm9yLkNPTkZJR19GRVRDSF9GQUlMRUQgKi8sIHtcbiAgICAgICAgICAgIGh0dHBTdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZTogZXJyb3JNZXNzYWdlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xufVxuLyoqXG4gKiBGZXRjaGVzIGR5bmFtaWMgY29uZmlnIGZyb20gYmFja2VuZCwgcmV0cnlpbmcgaWYgZmFpbGVkLlxuICogQHBhcmFtIGFwcCBGaXJlYmFzZSBhcHAgdG8gZmV0Y2ggY29uZmlnIGZvci5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hEeW5hbWljQ29uZmlnV2l0aFJldHJ5KGFwcCwgXG4vLyByZXRyeURhdGEgYW5kIHRpbWVvdXRNaWxsaXMgYXJlIHBhcmFtZXRlcml6ZWQgdG8gYWxsb3cgcGFzc2luZyBhIGRpZmZlcmVudCB2YWx1ZSBmb3IgdGVzdGluZy5cbnJldHJ5RGF0YSA9IGRlZmF1bHRSZXRyeURhdGEsIHRpbWVvdXRNaWxsaXMpIHtcbiAgICBjb25zdCB7IGFwcElkLCBhcGlLZXksIG1lYXN1cmVtZW50SWQgfSA9IGFwcC5vcHRpb25zO1xuICAgIGlmICghYXBwSWQpIHtcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJuby1hcHAtaWRcIiAvKiBBbmFseXRpY3NFcnJvci5OT19BUFBfSUQgKi8pO1xuICAgIH1cbiAgICBpZiAoIWFwaUtleSkge1xuICAgICAgICBpZiAobWVhc3VyZW1lbnRJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtZWFzdXJlbWVudElkLFxuICAgICAgICAgICAgICAgIGFwcElkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwibm8tYXBpLWtleVwiIC8qIEFuYWx5dGljc0Vycm9yLk5PX0FQSV9LRVkgKi8pO1xuICAgIH1cbiAgICBjb25zdCB0aHJvdHRsZU1ldGFkYXRhID0gcmV0cnlEYXRhLmdldFRocm90dGxlTWV0YWRhdGEoYXBwSWQpIHx8IHtcbiAgICAgICAgYmFja29mZkNvdW50OiAwLFxuICAgICAgICB0aHJvdHRsZUVuZFRpbWVNaWxsaXM6IERhdGUubm93KClcbiAgICB9O1xuICAgIGNvbnN0IHNpZ25hbCA9IG5ldyBBbmFseXRpY3NBYm9ydFNpZ25hbCgpO1xuICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBOb3RlIGEgdmVyeSBsb3cgZGVsYXksIGVnIDwgMTBtcywgY2FuIGVsYXBzZSBiZWZvcmUgbGlzdGVuZXJzIGFyZSBpbml0aWFsaXplZC5cbiAgICAgICAgc2lnbmFsLmFib3J0KCk7XG4gICAgfSwgdGltZW91dE1pbGxpcyAhPT0gdW5kZWZpbmVkID8gdGltZW91dE1pbGxpcyA6IEZFVENIX1RJTUVPVVRfTUlMTElTKTtcbiAgICByZXR1cm4gYXR0ZW1wdEZldGNoRHluYW1pY0NvbmZpZ1dpdGhSZXRyeSh7IGFwcElkLCBhcGlLZXksIG1lYXN1cmVtZW50SWQgfSwgdGhyb3R0bGVNZXRhZGF0YSwgc2lnbmFsLCByZXRyeURhdGEpO1xufVxuLyoqXG4gKiBSdW5zIG9uZSByZXRyeSBhdHRlbXB0LlxuICogQHBhcmFtIGFwcEZpZWxkcyBOZWNlc3NhcnkgYXBwIGNvbmZpZyBmaWVsZHMuXG4gKiBAcGFyYW0gdGhyb3R0bGVNZXRhZGF0YSBPbmdvaW5nIG1ldGFkYXRhIHRvIGRldGVybWluZSB0aHJvdHRsaW5nIHRpbWVzLlxuICogQHBhcmFtIHNpZ25hbCBBYm9ydCBzaWduYWwuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGF0dGVtcHRGZXRjaER5bmFtaWNDb25maWdXaXRoUmV0cnkoYXBwRmllbGRzLCB7IHRocm90dGxlRW5kVGltZU1pbGxpcywgYmFja29mZkNvdW50IH0sIHNpZ25hbCwgcmV0cnlEYXRhID0gZGVmYXVsdFJldHJ5RGF0YSAvLyBmb3IgdGVzdGluZ1xuKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgYXBwSWQsIG1lYXN1cmVtZW50SWQgfSA9IGFwcEZpZWxkcztcbiAgICAvLyBTdGFydHMgd2l0aCBhIChwb3RlbnRpYWxseSB6ZXJvKSB0aW1lb3V0IHRvIHN1cHBvcnQgcmVzdW1wdGlvbiBmcm9tIHN0b3JlZCBzdGF0ZS5cbiAgICAvLyBFbnN1cmVzIHRoZSB0aHJvdHRsZSBlbmQgdGltZSBpcyBob25vcmVkIGlmIHRoZSBsYXN0IGF0dGVtcHQgdGltZWQgb3V0LlxuICAgIC8vIE5vdGUgdGhlIFNESyB3aWxsIG5ldmVyIG1ha2UgYSByZXF1ZXN0IGlmIHRoZSBmZXRjaCB0aW1lb3V0IGV4cGlyZXMgYXQgdGhpcyBwb2ludC5cbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBzZXRBYm9ydGFibGVUaW1lb3V0KHNpZ25hbCwgdGhyb3R0bGVFbmRUaW1lTWlsbGlzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKG1lYXN1cmVtZW50SWQpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBUaW1lZCBvdXQgZmV0Y2hpbmcgdGhpcyBGaXJlYmFzZSBhcHAncyBtZWFzdXJlbWVudCBJRCBmcm9tIHRoZSBzZXJ2ZXIuYCArXG4gICAgICAgICAgICAgICAgYCBGYWxsaW5nIGJhY2sgdG8gdGhlIG1lYXN1cmVtZW50IElEICR7bWVhc3VyZW1lbnRJZH1gICtcbiAgICAgICAgICAgICAgICBgIHByb3ZpZGVkIGluIHRoZSBcIm1lYXN1cmVtZW50SWRcIiBmaWVsZCBpbiB0aGUgbG9jYWwgRmlyZWJhc2UgY29uZmlnLiBbJHtlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZX1dYCk7XG4gICAgICAgICAgICByZXR1cm4geyBhcHBJZCwgbWVhc3VyZW1lbnRJZCB9O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hEeW5hbWljQ29uZmlnKGFwcEZpZWxkcyk7XG4gICAgICAgIC8vIE5vdGUgdGhlIFNESyBvbmx5IGNsZWFycyB0aHJvdHRsZSBzdGF0ZSBpZiByZXNwb25zZSBpcyBzdWNjZXNzIG9yIG5vbi1yZXRyaWFibGUuXG4gICAgICAgIHJldHJ5RGF0YS5kZWxldGVUaHJvdHRsZU1ldGFkYXRhKGFwcElkKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBlcnJvciA9IGU7XG4gICAgICAgIGlmICghaXNSZXRyaWFibGVFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgIHJldHJ5RGF0YS5kZWxldGVUaHJvdHRsZU1ldGFkYXRhKGFwcElkKTtcbiAgICAgICAgICAgIGlmIChtZWFzdXJlbWVudElkKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYEZhaWxlZCB0byBmZXRjaCB0aGlzIEZpcmViYXNlIGFwcCdzIG1lYXN1cmVtZW50IElEIGZyb20gdGhlIHNlcnZlci5gICtcbiAgICAgICAgICAgICAgICAgICAgYCBGYWxsaW5nIGJhY2sgdG8gdGhlIG1lYXN1cmVtZW50IElEICR7bWVhc3VyZW1lbnRJZH1gICtcbiAgICAgICAgICAgICAgICAgICAgYCBwcm92aWRlZCBpbiB0aGUgXCJtZWFzdXJlbWVudElkXCIgZmllbGQgaW4gdGhlIGxvY2FsIEZpcmViYXNlIGNvbmZpZy4gWyR7ZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2V9XWApO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGFwcElkLCBtZWFzdXJlbWVudElkIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhY2tvZmZNaWxsaXMgPSBOdW1iZXIoKF9hID0gZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLmN1c3RvbURhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwU3RhdHVzKSA9PT0gNTAzXG4gICAgICAgICAgICA/IGNhbGN1bGF0ZUJhY2tvZmZNaWxsaXMoYmFja29mZkNvdW50LCByZXRyeURhdGEuaW50ZXJ2YWxNaWxsaXMsIExPTkdfUkVUUllfRkFDVE9SKVxuICAgICAgICAgICAgOiBjYWxjdWxhdGVCYWNrb2ZmTWlsbGlzKGJhY2tvZmZDb3VudCwgcmV0cnlEYXRhLmludGVydmFsTWlsbGlzKTtcbiAgICAgICAgLy8gSW5jcmVtZW50cyBiYWNrb2ZmIHN0YXRlLlxuICAgICAgICBjb25zdCB0aHJvdHRsZU1ldGFkYXRhID0ge1xuICAgICAgICAgICAgdGhyb3R0bGVFbmRUaW1lTWlsbGlzOiBEYXRlLm5vdygpICsgYmFja29mZk1pbGxpcyxcbiAgICAgICAgICAgIGJhY2tvZmZDb3VudDogYmFja29mZkNvdW50ICsgMVxuICAgICAgICB9O1xuICAgICAgICAvLyBQZXJzaXN0cyBzdGF0ZS5cbiAgICAgICAgcmV0cnlEYXRhLnNldFRocm90dGxlTWV0YWRhdGEoYXBwSWQsIHRocm90dGxlTWV0YWRhdGEpO1xuICAgICAgICBsb2dnZXIuZGVidWcoYENhbGxpbmcgYXR0ZW1wdEZldGNoIGFnYWluIGluICR7YmFja29mZk1pbGxpc30gbWlsbGlzYCk7XG4gICAgICAgIHJldHVybiBhdHRlbXB0RmV0Y2hEeW5hbWljQ29uZmlnV2l0aFJldHJ5KGFwcEZpZWxkcywgdGhyb3R0bGVNZXRhZGF0YSwgc2lnbmFsLCByZXRyeURhdGEpO1xuICAgIH1cbn1cbi8qKlxuICogU3VwcG9ydHMgd2FpdGluZyBvbiBhIGJhY2tvZmYgYnk6XG4gKlxuICogPHVsPlxuICogICA8bGk+UHJvbWlzaWZ5aW5nIHNldFRpbWVvdXQsIHNvIHdlIGNhbiBzZXQgYSB0aW1lb3V0IGluIG91ciBQcm9taXNlIGNoYWluPC9saT5cbiAqICAgPGxpPkxpc3RlbmluZyBvbiBhIHNpZ25hbCBidXMgZm9yIGFib3J0IGV2ZW50cywganVzdCBsaWtlIHRoZSBGZXRjaCBBUEk8L2xpPlxuICogICA8bGk+RmFpbGluZyBpbiB0aGUgc2FtZSB3YXkgdGhlIEZldGNoIEFQSSBmYWlscywgc28gdGltaW5nIG91dCBhIGxpdmUgcmVxdWVzdCBhbmQgYSB0aHJvdHRsZWRcbiAqICAgICAgIHJlcXVlc3QgYXBwZWFyIHRoZSBzYW1lLjwvbGk+XG4gKiA8L3VsPlxuICpcbiAqIDxwPlZpc2libGUgZm9yIHRlc3RpbmcuXG4gKi9cbmZ1bmN0aW9uIHNldEFib3J0YWJsZVRpbWVvdXQoc2lnbmFsLCB0aHJvdHRsZUVuZFRpbWVNaWxsaXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAvLyBEZXJpdmVzIGJhY2tvZmYgZnJvbSBnaXZlbiBlbmQgdGltZSwgbm9ybWFsaXppbmcgbmVnYXRpdmUgbnVtYmVycyB0byB6ZXJvLlxuICAgICAgICBjb25zdCBiYWNrb2ZmTWlsbGlzID0gTWF0aC5tYXgodGhyb3R0bGVFbmRUaW1lTWlsbGlzIC0gRGF0ZS5ub3coKSwgMCk7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KHJlc29sdmUsIGJhY2tvZmZNaWxsaXMpO1xuICAgICAgICAvLyBBZGRzIGxpc3RlbmVyLCByYXRoZXIgdGhhbiBzZXRzIG9uYWJvcnQsIGJlY2F1c2Ugc2lnbmFsIGlzIGEgc2hhcmVkIG9iamVjdC5cbiAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3QgY29tcGxldGVzIGJlZm9yZSB0aGlzIHRpbWVvdXQsIHRoZSByZWplY3Rpb24gaGFzIG5vIGVmZmVjdC5cbiAgICAgICAgICAgIHJlamVjdChFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImZldGNoLXRocm90dGxlXCIgLyogQW5hbHl0aWNzRXJyb3IuRkVUQ0hfVEhST1RUTEUgKi8sIHtcbiAgICAgICAgICAgICAgICB0aHJvdHRsZUVuZFRpbWVNaWxsaXNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUge0BsaW5rIEVycm9yfSBpbmRpY2F0ZXMgYSBmZXRjaCByZXF1ZXN0IG1heSBzdWNjZWVkIGxhdGVyLlxuICovXG5mdW5jdGlvbiBpc1JldHJpYWJsZUVycm9yKGUpIHtcbiAgICBpZiAoIShlIGluc3RhbmNlb2YgRmlyZWJhc2VFcnJvcikgfHwgIWUuY3VzdG9tRGF0YSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFVzZXMgc3RyaW5nIGluZGV4IGRlZmluZWQgYnkgRXJyb3JEYXRhLCB3aGljaCBGaXJlYmFzZUVycm9yIGltcGxlbWVudHMuXG4gICAgY29uc3QgaHR0cFN0YXR1cyA9IE51bWJlcihlLmN1c3RvbURhdGFbJ2h0dHBTdGF0dXMnXSk7XG4gICAgcmV0dXJuIChodHRwU3RhdHVzID09PSA0MjkgfHxcbiAgICAgICAgaHR0cFN0YXR1cyA9PT0gNTAwIHx8XG4gICAgICAgIGh0dHBTdGF0dXMgPT09IDUwMyB8fFxuICAgICAgICBodHRwU3RhdHVzID09PSA1MDQpO1xufVxuLyoqXG4gKiBTaGltcyBhIG1pbmltYWwgQWJvcnRTaWduYWwgKGNvcGllZCBmcm9tIFJlbW90ZSBDb25maWcpLlxuICpcbiAqIDxwPkFib3J0Q29udHJvbGxlcidzIEFib3J0U2lnbmFsIGNvbnZlbmllbnRseSBkZWNvdXBsZXMgZmV0Y2ggdGltZW91dCBsb2dpYyBmcm9tIG90aGVyIGFzcGVjdHNcbiAqIG9mIG5ldHdvcmtpbmcsIHN1Y2ggYXMgcmV0cmllcy4gRmlyZWJhc2UgZG9lc24ndCB1c2UgQWJvcnRDb250cm9sbGVyIGVub3VnaCB0byBqdXN0aWZ5IGFcbiAqIHBvbHlmaWxsIHJlY29tbWVuZGF0aW9uLCBsaWtlIHdlIGRvIHdpdGggdGhlIEZldGNoIEFQSSwgYnV0IHRoaXMgbWluaW1hbCBzaGltIGNhbiBlYXNpbHkgYmVcbiAqIHN3YXBwZWQgb3V0IGlmL3doZW4gd2UgZG8uXG4gKi9cbmNsYXNzIEFuYWx5dGljc0Fib3J0U2lnbmFsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICB9XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgYWJvcnQoKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBFdmVudCBwYXJhbWV0ZXJzIHRvIHNldCBvbiAnZ3RhZycgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICovXG5sZXQgZGVmYXVsdEV2ZW50UGFyYW1ldGVyc0ZvckluaXQ7XG4vKipcbiAqIExvZ3MgYW4gYW5hbHl0aWNzIGV2ZW50IHRocm91Z2ggdGhlIEZpcmViYXNlIFNESy5cbiAqXG4gKiBAcGFyYW0gZ3RhZ0Z1bmN0aW9uIFdyYXBwZWQgZ3RhZyBmdW5jdGlvbiB0aGF0IHdhaXRzIGZvciBmaWQgdG8gYmUgc2V0IGJlZm9yZSBzZW5kaW5nIGFuIGV2ZW50XG4gKiBAcGFyYW0gZXZlbnROYW1lIEdvb2dsZSBBbmFseXRpY3MgZXZlbnQgbmFtZSwgY2hvb3NlIGZyb20gc3RhbmRhcmQgbGlzdCBvciB1c2UgYSBjdXN0b20gc3RyaW5nLlxuICogQHBhcmFtIGV2ZW50UGFyYW1zIEFuYWx5dGljcyBldmVudCBwYXJhbWV0ZXJzLlxuICovXG5hc3luYyBmdW5jdGlvbiBsb2dFdmVudCQxKGd0YWdGdW5jdGlvbiwgaW5pdGlhbGl6YXRpb25Qcm9taXNlLCBldmVudE5hbWUsIGV2ZW50UGFyYW1zLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5nbG9iYWwpIHtcbiAgICAgICAgZ3RhZ0Z1bmN0aW9uKFwiZXZlbnRcIiAvKiBHdGFnQ29tbWFuZC5FVkVOVCAqLywgZXZlbnROYW1lLCBldmVudFBhcmFtcyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVtZW50SWQgPSBhd2FpdCBpbml0aWFsaXphdGlvblByb21pc2U7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRQYXJhbXMpLCB7ICdzZW5kX3RvJzogbWVhc3VyZW1lbnRJZCB9KTtcbiAgICAgICAgZ3RhZ0Z1bmN0aW9uKFwiZXZlbnRcIiAvKiBHdGFnQ29tbWFuZC5FVkVOVCAqLywgZXZlbnROYW1lLCBwYXJhbXMpO1xuICAgIH1cbn1cbi8qKlxuICogU2V0IHNjcmVlbl9uYW1lIHBhcmFtZXRlciBmb3IgdGhpcyBHb29nbGUgQW5hbHl0aWNzIElELlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgbG9nRXZlbnR9IHdpdGggYGV2ZW50TmFtZWAgYXMgJ3NjcmVlbl92aWV3JyBhbmQgYWRkIHJlbGV2YW50IGBldmVudFBhcmFtc2AuXG4gKiBTZWUge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2FuYWx5dGljcy9zY3JlZW52aWV3cyB8IFRyYWNrIFNjcmVlbnZpZXdzfS5cbiAqXG4gKiBAcGFyYW0gZ3RhZ0Z1bmN0aW9uIFdyYXBwZWQgZ3RhZyBmdW5jdGlvbiB0aGF0IHdhaXRzIGZvciBmaWQgdG8gYmUgc2V0IGJlZm9yZSBzZW5kaW5nIGFuIGV2ZW50XG4gKiBAcGFyYW0gc2NyZWVuTmFtZSBTY3JlZW4gbmFtZSBzdHJpbmcgdG8gc2V0LlxuICovXG5hc3luYyBmdW5jdGlvbiBzZXRDdXJyZW50U2NyZWVuJDEoZ3RhZ0Z1bmN0aW9uLCBpbml0aWFsaXphdGlvblByb21pc2UsIHNjcmVlbk5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmdsb2JhbCkge1xuICAgICAgICBndGFnRnVuY3Rpb24oXCJzZXRcIiAvKiBHdGFnQ29tbWFuZC5TRVQgKi8sIHsgJ3NjcmVlbl9uYW1lJzogc2NyZWVuTmFtZSB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWVhc3VyZW1lbnRJZCA9IGF3YWl0IGluaXRpYWxpemF0aW9uUHJvbWlzZTtcbiAgICAgICAgZ3RhZ0Z1bmN0aW9uKFwiY29uZmlnXCIgLyogR3RhZ0NvbW1hbmQuQ09ORklHICovLCBtZWFzdXJlbWVudElkLCB7XG4gICAgICAgICAgICB1cGRhdGU6IHRydWUsXG4gICAgICAgICAgICAnc2NyZWVuX25hbWUnOiBzY3JlZW5OYW1lXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogU2V0IHVzZXJfaWQgcGFyYW1ldGVyIGZvciB0aGlzIEdvb2dsZSBBbmFseXRpY3MgSUQuXG4gKlxuICogQHBhcmFtIGd0YWdGdW5jdGlvbiBXcmFwcGVkIGd0YWcgZnVuY3Rpb24gdGhhdCB3YWl0cyBmb3IgZmlkIHRvIGJlIHNldCBiZWZvcmUgc2VuZGluZyBhbiBldmVudFxuICogQHBhcmFtIGlkIFVzZXIgSUQgc3RyaW5nIHRvIHNldFxuICovXG5hc3luYyBmdW5jdGlvbiBzZXRVc2VySWQkMShndGFnRnVuY3Rpb24sIGluaXRpYWxpemF0aW9uUHJvbWlzZSwgaWQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmdsb2JhbCkge1xuICAgICAgICBndGFnRnVuY3Rpb24oXCJzZXRcIiAvKiBHdGFnQ29tbWFuZC5TRVQgKi8sIHsgJ3VzZXJfaWQnOiBpZCB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWVhc3VyZW1lbnRJZCA9IGF3YWl0IGluaXRpYWxpemF0aW9uUHJvbWlzZTtcbiAgICAgICAgZ3RhZ0Z1bmN0aW9uKFwiY29uZmlnXCIgLyogR3RhZ0NvbW1hbmQuQ09ORklHICovLCBtZWFzdXJlbWVudElkLCB7XG4gICAgICAgICAgICB1cGRhdGU6IHRydWUsXG4gICAgICAgICAgICAndXNlcl9pZCc6IGlkXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogU2V0IGFsbCBvdGhlciB1c2VyIHByb3BlcnRpZXMgb3RoZXIgdGhhbiB1c2VyX2lkIGFuZCBzY3JlZW5fbmFtZS5cbiAqXG4gKiBAcGFyYW0gZ3RhZ0Z1bmN0aW9uIFdyYXBwZWQgZ3RhZyBmdW5jdGlvbiB0aGF0IHdhaXRzIGZvciBmaWQgdG8gYmUgc2V0IGJlZm9yZSBzZW5kaW5nIGFuIGV2ZW50XG4gKiBAcGFyYW0gcHJvcGVydGllcyBNYXAgb2YgdXNlciBwcm9wZXJ0aWVzIHRvIHNldFxuICovXG5hc3luYyBmdW5jdGlvbiBzZXRVc2VyUHJvcGVydGllcyQxKGd0YWdGdW5jdGlvbiwgaW5pdGlhbGl6YXRpb25Qcm9taXNlLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5nbG9iYWwpIHtcbiAgICAgICAgY29uc3QgZmxhdFByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocHJvcGVydGllcykpIHtcbiAgICAgICAgICAgIC8vIHVzZSBkb3Qgbm90YXRpb24gZm9yIG1lcmdlIGJlaGF2aW9yIGluIGd0YWcuanNcbiAgICAgICAgICAgIGZsYXRQcm9wZXJ0aWVzW2B1c2VyX3Byb3BlcnRpZXMuJHtrZXl9YF0gPSBwcm9wZXJ0aWVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZ3RhZ0Z1bmN0aW9uKFwic2V0XCIgLyogR3RhZ0NvbW1hbmQuU0VUICovLCBmbGF0UHJvcGVydGllcyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVtZW50SWQgPSBhd2FpdCBpbml0aWFsaXphdGlvblByb21pc2U7XG4gICAgICAgIGd0YWdGdW5jdGlvbihcImNvbmZpZ1wiIC8qIEd0YWdDb21tYW5kLkNPTkZJRyAqLywgbWVhc3VyZW1lbnRJZCwge1xuICAgICAgICAgICAgdXBkYXRlOiB0cnVlLFxuICAgICAgICAgICAgJ3VzZXJfcHJvcGVydGllcyc6IHByb3BlcnRpZXNcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXRyaWV2ZXMgYSB1bmlxdWUgR29vZ2xlIEFuYWx5dGljcyBpZGVudGlmaWVyIGZvciB0aGUgd2ViIGNsaWVudC5cbiAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vYW5hbHl0aWNzL2Rldmd1aWRlcy9jb2xsZWN0aW9uL2dhNC9yZWZlcmVuY2UvY29uZmlnI2NsaWVudF9pZCB8IGNsaWVudF9pZH0uXG4gKlxuICogQHBhcmFtIGd0YWdGdW5jdGlvbiBXcmFwcGVkIGd0YWcgZnVuY3Rpb24gdGhhdCB3YWl0cyBmb3IgZmlkIHRvIGJlIHNldCBiZWZvcmUgc2VuZGluZyBhbiBldmVudFxuICovXG5hc3luYyBmdW5jdGlvbiBpbnRlcm5hbEdldEdvb2dsZUFuYWx5dGljc0NsaWVudElkKGd0YWdGdW5jdGlvbiwgaW5pdGlhbGl6YXRpb25Qcm9taXNlKSB7XG4gICAgY29uc3QgbWVhc3VyZW1lbnRJZCA9IGF3YWl0IGluaXRpYWxpemF0aW9uUHJvbWlzZTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBndGFnRnVuY3Rpb24oXCJnZXRcIiAvKiBHdGFnQ29tbWFuZC5HRVQgKi8sIG1lYXN1cmVtZW50SWQsICdjbGllbnRfaWQnLCAoY2xpZW50SWQpID0+IHtcbiAgICAgICAgICAgIGlmICghY2xpZW50SWQpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJuby1jbGllbnQtaWRcIiAvKiBBbmFseXRpY3NFcnJvci5OT19DTElFTlRfSUQgKi8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoY2xpZW50SWQpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8qKlxuICogU2V0IHdoZXRoZXIgY29sbGVjdGlvbiBpcyBlbmFibGVkIGZvciB0aGlzIElELlxuICpcbiAqIEBwYXJhbSBlbmFibGVkIElmIHRydWUsIGNvbGxlY3Rpb24gaXMgZW5hYmxlZCBmb3IgdGhpcyBJRC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2V0QW5hbHl0aWNzQ29sbGVjdGlvbkVuYWJsZWQkMShpbml0aWFsaXphdGlvblByb21pc2UsIGVuYWJsZWQpIHtcbiAgICBjb25zdCBtZWFzdXJlbWVudElkID0gYXdhaXQgaW5pdGlhbGl6YXRpb25Qcm9taXNlO1xuICAgIHdpbmRvd1tgZ2EtZGlzYWJsZS0ke21lYXN1cmVtZW50SWR9YF0gPSAhZW5hYmxlZDtcbn1cbi8qKlxuICogQ29uc2VudCBwYXJhbWV0ZXJzIHRvIGRlZmF1bHQgdG8gZHVyaW5nICdndGFnJyBpbml0aWFsaXphdGlvbi5cbiAqL1xubGV0IGRlZmF1bHRDb25zZW50U2V0dGluZ3NGb3JJbml0O1xuLyoqXG4gKiBTZXRzIHRoZSB2YXJpYWJsZSB7QGxpbmsgZGVmYXVsdENvbnNlbnRTZXR0aW5nc0ZvckluaXR9IGZvciB1c2UgaW4gdGhlIGluaXRpYWxpemF0aW9uIG9mXG4gKiBhbmFseXRpY3MuXG4gKlxuICogQHBhcmFtIGNvbnNlbnRTZXR0aW5ncyBNYXBzIHRoZSBhcHBsaWNhYmxlIGVuZCB1c2VyIGNvbnNlbnQgc3RhdGUgZm9yIGd0YWcuanMuXG4gKi9cbmZ1bmN0aW9uIF9zZXRDb25zZW50RGVmYXVsdEZvckluaXQoY29uc2VudFNldHRpbmdzKSB7XG4gICAgZGVmYXVsdENvbnNlbnRTZXR0aW5nc0ZvckluaXQgPSBjb25zZW50U2V0dGluZ3M7XG59XG4vKipcbiAqIFNldHMgdGhlIHZhcmlhYmxlIGBkZWZhdWx0RXZlbnRQYXJhbWV0ZXJzRm9ySW5pdGAgZm9yIHVzZSBpbiB0aGUgaW5pdGlhbGl6YXRpb24gb2ZcbiAqIGFuYWx5dGljcy5cbiAqXG4gKiBAcGFyYW0gY3VzdG9tUGFyYW1zIEFueSBjdXN0b20gcGFyYW1zIHRoZSB1c2VyIG1heSBwYXNzIHRvIGd0YWcuanMuXG4gKi9cbmZ1bmN0aW9uIF9zZXREZWZhdWx0RXZlbnRQYXJhbWV0ZXJzRm9ySW5pdChjdXN0b21QYXJhbXMpIHtcbiAgICBkZWZhdWx0RXZlbnRQYXJhbWV0ZXJzRm9ySW5pdCA9IGN1c3RvbVBhcmFtcztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlSW5kZXhlZERCKCkge1xuICAgIGlmICghaXNJbmRleGVkREJBdmFpbGFibGUoKSkge1xuICAgICAgICBsb2dnZXIud2FybihFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImluZGV4ZWRkYi11bmF2YWlsYWJsZVwiIC8qIEFuYWx5dGljc0Vycm9yLklOREVYRUREQl9VTkFWQUlMQUJMRSAqLywge1xuICAgICAgICAgICAgZXJyb3JJbmZvOiAnSW5kZXhlZERCIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudC4nXG4gICAgICAgIH0pLm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImluZGV4ZWRkYi11bmF2YWlsYWJsZVwiIC8qIEFuYWx5dGljc0Vycm9yLklOREVYRUREQl9VTkFWQUlMQUJMRSAqLywge1xuICAgICAgICAgICAgICAgIGVycm9ySW5mbzogZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnRvU3RyaW5nKClcbiAgICAgICAgICAgIH0pLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBhbmFseXRpY3MgaW5zdGFuY2UgaW4gZ3RhZy5qcyBieSBjYWxsaW5nIGNvbmZpZyBjb21tYW5kIHdpdGggZmlkLlxuICpcbiAqIE5PVEU6IFdlIGNvbWJpbmUgYW5hbHl0aWNzIGluaXRpYWxpemF0aW9uIGFuZCBzZXR0aW5nIGZpZCB0b2dldGhlciBiZWNhdXNlIHdlIHdhbnQgZmlkIHRvIGJlXG4gKiBwYXJ0IG9mIHRoZSBgcGFnZV92aWV3YCBldmVudCB0aGF0J3Mgc2VudCBkdXJpbmcgdGhlIGluaXRpYWxpemF0aW9uXG4gKiBAcGFyYW0gYXBwIEZpcmViYXNlIGFwcFxuICogQHBhcmFtIGd0YWdDb3JlIFRoZSBndGFnIGZ1bmN0aW9uIHRoYXQncyBub3Qgd3JhcHBlZC5cbiAqIEBwYXJhbSBkeW5hbWljQ29uZmlnUHJvbWlzZXNMaXN0IEFycmF5IG9mIGFsbCBkeW5hbWljIGNvbmZpZyBwcm9taXNlcy5cbiAqIEBwYXJhbSBtZWFzdXJlbWVudElkVG9BcHBJZCBNYXBzIG1lYXN1cmVtZW50SUQgdG8gYXBwSUQuXG4gKiBAcGFyYW0gaW5zdGFsbGF0aW9ucyBfRmlyZWJhc2VJbnN0YWxsYXRpb25zSW50ZXJuYWwgaW5zdGFuY2UuXG4gKlxuICogQHJldHVybnMgTWVhc3VyZW1lbnQgSUQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9pbml0aWFsaXplQW5hbHl0aWNzKGFwcCwgZHluYW1pY0NvbmZpZ1Byb21pc2VzTGlzdCwgbWVhc3VyZW1lbnRJZFRvQXBwSWQsIGluc3RhbGxhdGlvbnMsIGd0YWdDb3JlLCBkYXRhTGF5ZXJOYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGR5bmFtaWNDb25maWdQcm9taXNlID0gZmV0Y2hEeW5hbWljQ29uZmlnV2l0aFJldHJ5KGFwcCk7XG4gICAgLy8gT25jZSBmZXRjaGVkLCBtYXAgbWVhc3VyZW1lbnRJZHMgdG8gYXBwSWQsIGZvciBlYXNlIG9mIGxvb2t1cCBpbiB3cmFwcGVkIGd0YWcgZnVuY3Rpb24uXG4gICAgZHluYW1pY0NvbmZpZ1Byb21pc2VcbiAgICAgICAgLnRoZW4oY29uZmlnID0+IHtcbiAgICAgICAgbWVhc3VyZW1lbnRJZFRvQXBwSWRbY29uZmlnLm1lYXN1cmVtZW50SWRdID0gY29uZmlnLmFwcElkO1xuICAgICAgICBpZiAoYXBwLm9wdGlvbnMubWVhc3VyZW1lbnRJZCAmJlxuICAgICAgICAgICAgY29uZmlnLm1lYXN1cmVtZW50SWQgIT09IGFwcC5vcHRpb25zLm1lYXN1cmVtZW50SWQpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBUaGUgbWVhc3VyZW1lbnQgSUQgaW4gdGhlIGxvY2FsIEZpcmViYXNlIGNvbmZpZyAoJHthcHAub3B0aW9ucy5tZWFzdXJlbWVudElkfSlgICtcbiAgICAgICAgICAgICAgICBgIGRvZXMgbm90IG1hdGNoIHRoZSBtZWFzdXJlbWVudCBJRCBmZXRjaGVkIGZyb20gdGhlIHNlcnZlciAoJHtjb25maWcubWVhc3VyZW1lbnRJZH0pLmAgK1xuICAgICAgICAgICAgICAgIGAgVG8gZW5zdXJlIGFuYWx5dGljcyBldmVudHMgYXJlIGFsd2F5cyBzZW50IHRvIHRoZSBjb3JyZWN0IEFuYWx5dGljcyBwcm9wZXJ0eSxgICtcbiAgICAgICAgICAgICAgICBgIHVwZGF0ZSB0aGVgICtcbiAgICAgICAgICAgICAgICBgIG1lYXN1cmVtZW50IElEIGZpZWxkIGluIHRoZSBsb2NhbCBjb25maWcgb3IgcmVtb3ZlIGl0IGZyb20gdGhlIGxvY2FsIGNvbmZpZy5gKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgICAgIC5jYXRjaChlID0+IGxvZ2dlci5lcnJvcihlKSk7XG4gICAgLy8gQWRkIHRvIGxpc3QgdG8gdHJhY2sgc3RhdGUgb2YgYWxsIGR5bmFtaWMgY29uZmlnIHByb21pc2VzLlxuICAgIGR5bmFtaWNDb25maWdQcm9taXNlc0xpc3QucHVzaChkeW5hbWljQ29uZmlnUHJvbWlzZSk7XG4gICAgY29uc3QgZmlkUHJvbWlzZSA9IHZhbGlkYXRlSW5kZXhlZERCKCkudGhlbihlbnZJc1ZhbGlkID0+IHtcbiAgICAgICAgaWYgKGVudklzVmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YWxsYXRpb25zLmdldElkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgW2R5bmFtaWNDb25maWcsIGZpZF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIGR5bmFtaWNDb25maWdQcm9taXNlLFxuICAgICAgICBmaWRQcm9taXNlXG4gICAgXSk7XG4gICAgLy8gRGV0ZWN0IGlmIHVzZXIgaGFzIGFscmVhZHkgcHV0IHRoZSBndGFnIDxzY3JpcHQ+IHRhZyBvbiB0aGlzIHBhZ2Ugd2l0aCB0aGUgcGFzc2VkIGluXG4gICAgLy8gZGF0YSBsYXllciBuYW1lLlxuICAgIGlmICghZmluZEd0YWdTY3JpcHRPblBhZ2UoZGF0YUxheWVyTmFtZSkpIHtcbiAgICAgICAgaW5zZXJ0U2NyaXB0VGFnKGRhdGFMYXllck5hbWUsIGR5bmFtaWNDb25maWcubWVhc3VyZW1lbnRJZCk7XG4gICAgfVxuICAgIC8vIERldGVjdHMgaWYgdGhlcmUgYXJlIGNvbnNlbnQgc2V0dGluZ3MgdGhhdCBuZWVkIHRvIGJlIGNvbmZpZ3VyZWQuXG4gICAgaWYgKGRlZmF1bHRDb25zZW50U2V0dGluZ3NGb3JJbml0KSB7XG4gICAgICAgIGd0YWdDb3JlKFwiY29uc2VudFwiIC8qIEd0YWdDb21tYW5kLkNPTlNFTlQgKi8sICdkZWZhdWx0JywgZGVmYXVsdENvbnNlbnRTZXR0aW5nc0ZvckluaXQpO1xuICAgICAgICBfc2V0Q29uc2VudERlZmF1bHRGb3JJbml0KHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8vIFRoaXMgY29tbWFuZCBpbml0aWFsaXplcyBndGFnLmpzIGFuZCBvbmx5IG5lZWRzIHRvIGJlIGNhbGxlZCBvbmNlIGZvciB0aGUgZW50aXJlIHdlYiBhcHAsXG4gICAgLy8gYnV0IHNpbmNlIGl0IGlzIGlkZW1wb3RlbnQsIHdlIGNhbiBjYWxsIGl0IG11bHRpcGxlIHRpbWVzLlxuICAgIC8vIFdlIGtlZXAgaXQgdG9nZXRoZXIgd2l0aCBvdGhlciBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgYmV0dGVyIGNvZGUgc3RydWN0dXJlLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZ3RhZ0NvcmUoJ2pzJywgbmV3IERhdGUoKSk7XG4gICAgLy8gVXNlciBjb25maWcgYWRkZWQgZmlyc3QuIFdlIGRvbid0IHdhbnQgdXNlcnMgdG8gYWNjaWRlbnRhbGx5IG92ZXJ3cml0ZVxuICAgIC8vIGJhc2UgRmlyZWJhc2UgY29uZmlnIHByb3BlcnRpZXMuXG4gICAgY29uc3QgY29uZmlnUHJvcGVydGllcyA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jb25maWcpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgIC8vIGd1YXJkIGFnYWluc3QgZGV2ZWxvcGVycyBhY2NpZGVudGFsbHkgc2V0dGluZyBwcm9wZXJ0aWVzIHdpdGggcHJlZml4IGBmaXJlYmFzZV9gXG4gICAgY29uZmlnUHJvcGVydGllc1tPUklHSU5fS0VZXSA9ICdmaXJlYmFzZSc7XG4gICAgY29uZmlnUHJvcGVydGllcy51cGRhdGUgPSB0cnVlO1xuICAgIGlmIChmaWQgIT0gbnVsbCkge1xuICAgICAgICBjb25maWdQcm9wZXJ0aWVzW0dBX0ZJRF9LRVldID0gZmlkO1xuICAgIH1cbiAgICAvLyBJdCBzaG91bGQgYmUgdGhlIGZpcnN0IGNvbmZpZyBjb21tYW5kIGNhbGxlZCBvbiB0aGlzIEdBLUlEXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGlzIEdBLUlEIGFuZCBzZXQgRklEIG9uIGl0IHVzaW5nIHRoZSBndGFnIGNvbmZpZyBBUEkuXG4gICAgLy8gTm90ZTogVGhpcyB3aWxsIHRyaWdnZXIgYSBwYWdlX3ZpZXcgZXZlbnQgdW5sZXNzICdzZW5kX3BhZ2VfdmlldycgaXMgc2V0IHRvIGZhbHNlIGluXG4gICAgLy8gYGNvbmZpZ1Byb3BlcnRpZXNgLlxuICAgIGd0YWdDb3JlKFwiY29uZmlnXCIgLyogR3RhZ0NvbW1hbmQuQ09ORklHICovLCBkeW5hbWljQ29uZmlnLm1lYXN1cmVtZW50SWQsIGNvbmZpZ1Byb3BlcnRpZXMpO1xuICAgIC8vIERldGVjdHMgaWYgdGhlcmUgaXMgZGF0YSB0aGF0IHdpbGwgYmUgc2V0IG9uIGV2ZXJ5IGV2ZW50IGxvZ2dlZCBmcm9tIHRoZSBTREsuXG4gICAgaWYgKGRlZmF1bHRFdmVudFBhcmFtZXRlcnNGb3JJbml0KSB7XG4gICAgICAgIGd0YWdDb3JlKFwic2V0XCIgLyogR3RhZ0NvbW1hbmQuU0VUICovLCBkZWZhdWx0RXZlbnRQYXJhbWV0ZXJzRm9ySW5pdCk7XG4gICAgICAgIF9zZXREZWZhdWx0RXZlbnRQYXJhbWV0ZXJzRm9ySW5pdCh1bmRlZmluZWQpO1xuICAgIH1cbiAgICByZXR1cm4gZHluYW1pY0NvbmZpZy5tZWFzdXJlbWVudElkO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBbmFseXRpY3MgU2VydmljZSBjbGFzcy5cbiAqL1xuY2xhc3MgQW5hbHl0aWNzU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoYXBwKSB7XG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xuICAgIH1cbiAgICBfZGVsZXRlKCkge1xuICAgICAgICBkZWxldGUgaW5pdGlhbGl6YXRpb25Qcm9taXNlc01hcFt0aGlzLmFwcC5vcHRpb25zLmFwcElkXTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbn1cbi8qKlxuICogTWFwcyBhcHBJZCB0byBmdWxsIGluaXRpYWxpemF0aW9uIHByb21pc2UuIFdyYXBwZWQgZ3RhZyBjYWxscyBtdXN0IHdhaXQgb25cbiAqIGFsbCBvciBzb21lIG9mIHRoZXNlLCBkZXBlbmRpbmcgb24gdGhlIGNhbGwncyBgc2VuZF90b2AgcGFyYW0gYW5kIHRoZSBzdGF0dXNcbiAqIG9mIHRoZSBkeW5hbWljIGNvbmZpZyBmZXRjaGVzIChzZWUgYmVsb3cpLlxuICovXG5sZXQgaW5pdGlhbGl6YXRpb25Qcm9taXNlc01hcCA9IHt9O1xuLyoqXG4gKiBMaXN0IG9mIGR5bmFtaWMgY29uZmlnIGZldGNoIHByb21pc2VzLiBJbiBjZXJ0YWluIGNhc2VzLCB3cmFwcGVkIGd0YWcgY2FsbHNcbiAqIHdhaXQgb24gYWxsIHRoZXNlIHRvIGJlIGNvbXBsZXRlIGluIG9yZGVyIHRvIGRldGVybWluZSBpZiBpdCBjYW4gc2VsZWN0aXZlbHlcbiAqIHdhaXQgZm9yIG9ubHkgY2VydGFpbiBpbml0aWFsaXphdGlvbiAoRklEKSBwcm9taXNlcyBvciBpZiBpdCBtdXN0IHdhaXQgZm9yIGFsbC5cbiAqL1xubGV0IGR5bmFtaWNDb25maWdQcm9taXNlc0xpc3QgPSBbXTtcbi8qKlxuICogTWFwcyBmZXRjaGVkIG1lYXN1cmVtZW50SWRzIHRvIGFwcElkLiBQb3B1bGF0ZWQgd2hlbiB0aGUgYXBwJ3MgZHluYW1pYyBjb25maWdcbiAqIGZldGNoIGNvbXBsZXRlcy4gSWYgYWxyZWFkeSBwb3B1bGF0ZWQsIGd0YWcgY29uZmlnIGNhbGxzIGNhbiB1c2UgdGhpcyB0b1xuICogc2VsZWN0aXZlbHkgd2FpdCBmb3Igb25seSB0aGlzIGFwcCdzIGluaXRpYWxpemF0aW9uIHByb21pc2UgKEZJRCkgaW5zdGVhZCBvZiBhbGxcbiAqIGluaXRpYWxpemF0aW9uIHByb21pc2VzLlxuICovXG5jb25zdCBtZWFzdXJlbWVudElkVG9BcHBJZCA9IHt9O1xuLyoqXG4gKiBOYW1lIGZvciB3aW5kb3cgZ2xvYmFsIGRhdGEgbGF5ZXIgYXJyYXkgdXNlZCBieSBHQTogZGVmYXVsdHMgdG8gJ2RhdGFMYXllcicuXG4gKi9cbmxldCBkYXRhTGF5ZXJOYW1lID0gJ2RhdGFMYXllcic7XG4vKipcbiAqIE5hbWUgZm9yIHdpbmRvdyBnbG9iYWwgZ3RhZyBmdW5jdGlvbiB1c2VkIGJ5IEdBOiBkZWZhdWx0cyB0byAnZ3RhZycuXG4gKi9cbmxldCBndGFnTmFtZSA9ICdndGFnJztcbi8qKlxuICogUmVwcm9kdWN0aW9uIG9mIHN0YW5kYXJkIGd0YWcgZnVuY3Rpb24gb3IgcmVmZXJlbmNlIHRvIGV4aXN0aW5nXG4gKiBndGFnIGZ1bmN0aW9uIG9uIHdpbmRvdyBvYmplY3QuXG4gKi9cbmxldCBndGFnQ29yZUZ1bmN0aW9uO1xuLyoqXG4gKiBXcmFwcGVyIGFyb3VuZCBndGFnIGZ1bmN0aW9uIHRoYXQgZW5zdXJlcyBGSUQgaXMgc2VudCB3aXRoIGFsbFxuICogcmVsZXZhbnQgZXZlbnQgYW5kIGNvbmZpZyBjYWxscy5cbiAqL1xubGV0IHdyYXBwZWRHdGFnRnVuY3Rpb247XG4vKipcbiAqIEZsYWcgdG8gZW5zdXJlIHBhZ2UgaW5pdGlhbGl6YXRpb24gc3RlcHMgKGNyZWF0aW9uIG9yIHdyYXBwaW5nIG9mXG4gKiBkYXRhTGF5ZXIgYW5kIGd0YWcgc2NyaXB0KSBhcmUgb25seSBydW4gb25jZSBwZXIgcGFnZSBsb2FkLlxuICovXG5sZXQgZ2xvYmFsSW5pdERvbmUgPSBmYWxzZTtcbi8qKlxuICogQ29uZmlndXJlcyBGaXJlYmFzZSBBbmFseXRpY3MgdG8gdXNlIGN1c3RvbSBgZ3RhZ2Agb3IgYGRhdGFMYXllcmAgbmFtZXMuXG4gKiBJbnRlbmRlZCB0byBiZSB1c2VkIGlmIGBndGFnLmpzYCBzY3JpcHQgaGFzIGJlZW4gaW5zdGFsbGVkIG9uXG4gKiB0aGlzIHBhZ2UgaW5kZXBlbmRlbnRseSBvZiBGaXJlYmFzZSBBbmFseXRpY3MsIGFuZCBpcyB1c2luZyBub24tZGVmYXVsdFxuICogbmFtZXMgZm9yIGVpdGhlciB0aGUgYGd0YWdgIGZ1bmN0aW9uIG9yIGZvciBgZGF0YUxheWVyYC5cbiAqIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBnZXRBbmFseXRpY3MoKWAgb3IgaXQgd29uJ3RcbiAqIGhhdmUgYW55IGVmZmVjdC5cbiAqXG4gKiBAcHVibGljXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBDdXN0b20gZ3RhZyBhbmQgZGF0YUxheWVyIG5hbWVzLlxuICovXG5mdW5jdGlvbiBzZXR0aW5ncyhvcHRpb25zKSB7XG4gICAgaWYgKGdsb2JhbEluaXREb25lKSB7XG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiYWxyZWFkeS1pbml0aWFsaXplZFwiIC8qIEFuYWx5dGljc0Vycm9yLkFMUkVBRFlfSU5JVElBTElaRUQgKi8pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kYXRhTGF5ZXJOYW1lKSB7XG4gICAgICAgIGRhdGFMYXllck5hbWUgPSBvcHRpb25zLmRhdGFMYXllck5hbWU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmd0YWdOYW1lKSB7XG4gICAgICAgIGd0YWdOYW1lID0gb3B0aW9ucy5ndGFnTmFtZTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBubyBlbnZpcm9ubWVudCBtaXNtYXRjaCBpcyBmb3VuZC5cbiAqIElmIGVudmlyb25tZW50IG1pc21hdGNoZXMgYXJlIGZvdW5kLCB0aHJvd3MgYW4gSU5WQUxJRF9BTkFMWVRJQ1NfQ09OVEVYVFxuICogZXJyb3IgdGhhdCBhbHNvIGxpc3RzIGRldGFpbHMgZm9yIGVhY2ggbWlzbWF0Y2ggZm91bmQuXG4gKi9cbmZ1bmN0aW9uIHdhcm5PbkJyb3dzZXJDb250ZXh0TWlzbWF0Y2goKSB7XG4gICAgY29uc3QgbWlzbWF0Y2hlZEVudk1lc3NhZ2VzID0gW107XG4gICAgaWYgKGlzQnJvd3NlckV4dGVuc2lvbigpKSB7XG4gICAgICAgIG1pc21hdGNoZWRFbnZNZXNzYWdlcy5wdXNoKCdUaGlzIGlzIGEgYnJvd3NlciBleHRlbnNpb24gZW52aXJvbm1lbnQuJyk7XG4gICAgfVxuICAgIGlmICghYXJlQ29va2llc0VuYWJsZWQoKSkge1xuICAgICAgICBtaXNtYXRjaGVkRW52TWVzc2FnZXMucHVzaCgnQ29va2llcyBhcmUgbm90IGF2YWlsYWJsZS4nKTtcbiAgICB9XG4gICAgaWYgKG1pc21hdGNoZWRFbnZNZXNzYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSBtaXNtYXRjaGVkRW52TWVzc2FnZXNcbiAgICAgICAgICAgIC5tYXAoKG1lc3NhZ2UsIGluZGV4KSA9PiBgKCR7aW5kZXggKyAxfSkgJHttZXNzYWdlfWApXG4gICAgICAgICAgICAuam9pbignICcpO1xuICAgICAgICBjb25zdCBlcnIgPSBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImludmFsaWQtYW5hbHl0aWNzLWNvbnRleHRcIiAvKiBBbmFseXRpY3NFcnJvci5JTlZBTElEX0FOQUxZVElDU19DT05URVhUICovLCB7XG4gICAgICAgICAgICBlcnJvckluZm86IGRldGFpbHNcbiAgICAgICAgfSk7XG4gICAgICAgIGxvZ2dlci53YXJuKGVyci5tZXNzYWdlKTtcbiAgICB9XG59XG4vKipcbiAqIEFuYWx5dGljcyBpbnN0YW5jZSBmYWN0b3J5LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGZhY3RvcnkoYXBwLCBpbnN0YWxsYXRpb25zLCBvcHRpb25zKSB7XG4gICAgd2Fybk9uQnJvd3NlckNvbnRleHRNaXNtYXRjaCgpO1xuICAgIGNvbnN0IGFwcElkID0gYXBwLm9wdGlvbnMuYXBwSWQ7XG4gICAgaWYgKCFhcHBJZCkge1xuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcIm5vLWFwcC1pZFwiIC8qIEFuYWx5dGljc0Vycm9yLk5PX0FQUF9JRCAqLyk7XG4gICAgfVxuICAgIGlmICghYXBwLm9wdGlvbnMuYXBpS2V5KSB7XG4gICAgICAgIGlmIChhcHAub3B0aW9ucy5tZWFzdXJlbWVudElkKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgVGhlIFwiYXBpS2V5XCIgZmllbGQgaXMgZW1wdHkgaW4gdGhlIGxvY2FsIEZpcmViYXNlIGNvbmZpZy4gVGhpcyBpcyBuZWVkZWQgdG8gZmV0Y2ggdGhlIGxhdGVzdGAgK1xuICAgICAgICAgICAgICAgIGAgbWVhc3VyZW1lbnQgSUQgZm9yIHRoaXMgRmlyZWJhc2UgYXBwLiBGYWxsaW5nIGJhY2sgdG8gdGhlIG1lYXN1cmVtZW50IElEICR7YXBwLm9wdGlvbnMubWVhc3VyZW1lbnRJZH1gICtcbiAgICAgICAgICAgICAgICBgIHByb3ZpZGVkIGluIHRoZSBcIm1lYXN1cmVtZW50SWRcIiBmaWVsZCBpbiB0aGUgbG9jYWwgRmlyZWJhc2UgY29uZmlnLmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJuby1hcGkta2V5XCIgLyogQW5hbHl0aWNzRXJyb3IuTk9fQVBJX0tFWSAqLyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluaXRpYWxpemF0aW9uUHJvbWlzZXNNYXBbYXBwSWRdICE9IG51bGwpIHtcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJhbHJlYWR5LWV4aXN0c1wiIC8qIEFuYWx5dGljc0Vycm9yLkFMUkVBRFlfRVhJU1RTICovLCB7XG4gICAgICAgICAgICBpZDogYXBwSWRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghZ2xvYmFsSW5pdERvbmUpIHtcbiAgICAgICAgLy8gU3RlcHMgaGVyZSBzaG91bGQgb25seSBiZSBkb25lIG9uY2UgcGVyIHBhZ2U6IGNyZWF0aW9uIG9yIHdyYXBwaW5nXG4gICAgICAgIC8vIG9mIGRhdGFMYXllciBhbmQgZ2xvYmFsIGd0YWcgZnVuY3Rpb24uXG4gICAgICAgIGdldE9yQ3JlYXRlRGF0YUxheWVyKGRhdGFMYXllck5hbWUpO1xuICAgICAgICBjb25zdCB7IHdyYXBwZWRHdGFnLCBndGFnQ29yZSB9ID0gd3JhcE9yQ3JlYXRlR3RhZyhpbml0aWFsaXphdGlvblByb21pc2VzTWFwLCBkeW5hbWljQ29uZmlnUHJvbWlzZXNMaXN0LCBtZWFzdXJlbWVudElkVG9BcHBJZCwgZGF0YUxheWVyTmFtZSwgZ3RhZ05hbWUpO1xuICAgICAgICB3cmFwcGVkR3RhZ0Z1bmN0aW9uID0gd3JhcHBlZEd0YWc7XG4gICAgICAgIGd0YWdDb3JlRnVuY3Rpb24gPSBndGFnQ29yZTtcbiAgICAgICAgZ2xvYmFsSW5pdERvbmUgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBBc3luYyBidXQgbm9uLWJsb2NraW5nLlxuICAgIC8vIFRoaXMgbWFwIHJlZmxlY3RzIHRoZSBjb21wbGV0aW9uIHN0YXRlIG9mIGFsbCBwcm9taXNlcyBmb3IgZWFjaCBhcHBJZC5cbiAgICBpbml0aWFsaXphdGlvblByb21pc2VzTWFwW2FwcElkXSA9IF9pbml0aWFsaXplQW5hbHl0aWNzKGFwcCwgZHluYW1pY0NvbmZpZ1Byb21pc2VzTGlzdCwgbWVhc3VyZW1lbnRJZFRvQXBwSWQsIGluc3RhbGxhdGlvbnMsIGd0YWdDb3JlRnVuY3Rpb24sIGRhdGFMYXllck5hbWUsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGFuYWx5dGljc0luc3RhbmNlID0gbmV3IEFuYWx5dGljc1NlcnZpY2UoYXBwKTtcbiAgICByZXR1cm4gYW5hbHl0aWNzSW5zdGFuY2U7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKlxuICogUmV0dXJucyBhbiB7QGxpbmsgQW5hbHl0aWNzfSBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIGFwcC5cbiAqXG4gKiBAcHVibGljXG4gKlxuICogQHBhcmFtIGFwcCAtIFRoZSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gdG8gdXNlLlxuICovXG5mdW5jdGlvbiBnZXRBbmFseXRpY3MoYXBwID0gZ2V0QXBwKCkpIHtcbiAgICBhcHAgPSBnZXRNb2R1bGFySW5zdGFuY2UoYXBwKTtcbiAgICAvLyBEZXBlbmRlbmNpZXNcbiAgICBjb25zdCBhbmFseXRpY3NQcm92aWRlciA9IF9nZXRQcm92aWRlcihhcHAsIEFOQUxZVElDU19UWVBFKTtcbiAgICBpZiAoYW5hbHl0aWNzUHJvdmlkZXIuaXNJbml0aWFsaXplZCgpKSB7XG4gICAgICAgIHJldHVybiBhbmFseXRpY3NQcm92aWRlci5nZXRJbW1lZGlhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGluaXRpYWxpemVBbmFseXRpY3MoYXBwKTtcbn1cbi8qKlxuICogUmV0dXJucyBhbiB7QGxpbmsgQW5hbHl0aWNzfSBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIGFwcC5cbiAqXG4gKiBAcHVibGljXG4gKlxuICogQHBhcmFtIGFwcCAtIFRoZSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gdG8gdXNlLlxuICovXG5mdW5jdGlvbiBpbml0aWFsaXplQW5hbHl0aWNzKGFwcCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gRGVwZW5kZW5jaWVzXG4gICAgY29uc3QgYW5hbHl0aWNzUHJvdmlkZXIgPSBfZ2V0UHJvdmlkZXIoYXBwLCBBTkFMWVRJQ1NfVFlQRSk7XG4gICAgaWYgKGFuYWx5dGljc1Byb3ZpZGVyLmlzSW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICBjb25zdCBleGlzdGluZ0luc3RhbmNlID0gYW5hbHl0aWNzUHJvdmlkZXIuZ2V0SW1tZWRpYXRlKCk7XG4gICAgICAgIGlmIChkZWVwRXF1YWwob3B0aW9ucywgYW5hbHl0aWNzUHJvdmlkZXIuZ2V0T3B0aW9ucygpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nSW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImFscmVhZHktaW5pdGlhbGl6ZWRcIiAvKiBBbmFseXRpY3NFcnJvci5BTFJFQURZX0lOSVRJQUxJWkVEICovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhbmFseXRpY3NJbnN0YW5jZSA9IGFuYWx5dGljc1Byb3ZpZGVyLmluaXRpYWxpemUoeyBvcHRpb25zIH0pO1xuICAgIHJldHVybiBhbmFseXRpY3NJbnN0YW5jZTtcbn1cbi8qKlxuICogVGhpcyBpcyBhIHB1YmxpYyBzdGF0aWMgbWV0aG9kIHByb3ZpZGVkIHRvIHVzZXJzIHRoYXQgd3JhcHMgZm91ciBkaWZmZXJlbnQgY2hlY2tzOlxuICpcbiAqIDEuIENoZWNrIGlmIGl0J3Mgbm90IGEgYnJvd3NlciBleHRlbnNpb24gZW52aXJvbm1lbnQuXG4gKiAyLiBDaGVjayBpZiBjb29raWVzIGFyZSBlbmFibGVkIGluIGN1cnJlbnQgYnJvd3Nlci5cbiAqIDMuIENoZWNrIGlmIEluZGV4ZWREQiBpcyBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gKiA0LiBDaGVjayBpZiB0aGUgY3VycmVudCBicm93c2VyIGNvbnRleHQgaXMgdmFsaWQgZm9yIHVzaW5nIGBJbmRleGVkREIub3BlbigpYC5cbiAqXG4gKiBAcHVibGljXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBpc1N1cHBvcnRlZCgpIHtcbiAgICBpZiAoaXNCcm93c2VyRXh0ZW5zaW9uKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWFyZUNvb2tpZXNFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzSW5kZXhlZERCQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBpc0RCT3BlbmFibGUgPSBhd2FpdCB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlKCk7XG4gICAgICAgIHJldHVybiBpc0RCT3BlbmFibGU7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBVc2UgZ3RhZyBgY29uZmlnYCBjb21tYW5kIHRvIHNldCBgc2NyZWVuX25hbWVgLlxuICpcbiAqIEBwdWJsaWNcbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIGxvZ0V2ZW50fSB3aXRoIGBldmVudE5hbWVgIGFzICdzY3JlZW5fdmlldycgYW5kIGFkZCByZWxldmFudCBgZXZlbnRQYXJhbXNgLlxuICogU2VlIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9hbmFseXRpY3Mvc2NyZWVudmlld3MgfCBUcmFjayBTY3JlZW52aWV3c30uXG4gKlxuICogQHBhcmFtIGFuYWx5dGljc0luc3RhbmNlIC0gVGhlIHtAbGluayBBbmFseXRpY3N9IGluc3RhbmNlLlxuICogQHBhcmFtIHNjcmVlbk5hbWUgLSBTY3JlZW4gbmFtZSB0byBzZXQuXG4gKi9cbmZ1bmN0aW9uIHNldEN1cnJlbnRTY3JlZW4oYW5hbHl0aWNzSW5zdGFuY2UsIHNjcmVlbk5hbWUsIG9wdGlvbnMpIHtcbiAgICBhbmFseXRpY3NJbnN0YW5jZSA9IGdldE1vZHVsYXJJbnN0YW5jZShhbmFseXRpY3NJbnN0YW5jZSk7XG4gICAgc2V0Q3VycmVudFNjcmVlbiQxKHdyYXBwZWRHdGFnRnVuY3Rpb24sIGluaXRpYWxpemF0aW9uUHJvbWlzZXNNYXBbYW5hbHl0aWNzSW5zdGFuY2UuYXBwLm9wdGlvbnMuYXBwSWRdLCBzY3JlZW5OYW1lLCBvcHRpb25zKS5jYXRjaChlID0+IGxvZ2dlci5lcnJvcihlKSk7XG59XG4vKipcbiAqIFJldHJpZXZlcyBhIHVuaXF1ZSBHb29nbGUgQW5hbHl0aWNzIGlkZW50aWZpZXIgZm9yIHRoZSB3ZWIgY2xpZW50LlxuICogU2VlIHtAbGluayBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9hbmFseXRpY3MvZGV2Z3VpZGVzL2NvbGxlY3Rpb24vZ2E0L3JlZmVyZW5jZS9jb25maWcjY2xpZW50X2lkIHwgY2xpZW50X2lkfS5cbiAqXG4gKiBAcHVibGljXG4gKlxuICogQHBhcmFtIGFwcCAtIFRoZSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gdG8gdXNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRHb29nbGVBbmFseXRpY3NDbGllbnRJZChhbmFseXRpY3NJbnN0YW5jZSkge1xuICAgIGFuYWx5dGljc0luc3RhbmNlID0gZ2V0TW9kdWxhckluc3RhbmNlKGFuYWx5dGljc0luc3RhbmNlKTtcbiAgICByZXR1cm4gaW50ZXJuYWxHZXRHb29nbGVBbmFseXRpY3NDbGllbnRJZCh3cmFwcGVkR3RhZ0Z1bmN0aW9uLCBpbml0aWFsaXphdGlvblByb21pc2VzTWFwW2FuYWx5dGljc0luc3RhbmNlLmFwcC5vcHRpb25zLmFwcElkXSk7XG59XG4vKipcbiAqIFVzZSBndGFnIGBjb25maWdgIGNvbW1hbmQgdG8gc2V0IGB1c2VyX2lkYC5cbiAqXG4gKiBAcHVibGljXG4gKlxuICogQHBhcmFtIGFuYWx5dGljc0luc3RhbmNlIC0gVGhlIHtAbGluayBBbmFseXRpY3N9IGluc3RhbmNlLlxuICogQHBhcmFtIGlkIC0gVXNlciBJRCB0byBzZXQuXG4gKi9cbmZ1bmN0aW9uIHNldFVzZXJJZChhbmFseXRpY3NJbnN0YW5jZSwgaWQsIG9wdGlvbnMpIHtcbiAgICBhbmFseXRpY3NJbnN0YW5jZSA9IGdldE1vZHVsYXJJbnN0YW5jZShhbmFseXRpY3NJbnN0YW5jZSk7XG4gICAgc2V0VXNlcklkJDEod3JhcHBlZEd0YWdGdW5jdGlvbiwgaW5pdGlhbGl6YXRpb25Qcm9taXNlc01hcFthbmFseXRpY3NJbnN0YW5jZS5hcHAub3B0aW9ucy5hcHBJZF0sIGlkLCBvcHRpb25zKS5jYXRjaChlID0+IGxvZ2dlci5lcnJvcihlKSk7XG59XG4vKipcbiAqIFVzZSBndGFnIGBjb25maWdgIGNvbW1hbmQgdG8gc2V0IGFsbCBwYXJhbXMgc3BlY2lmaWVkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc2V0VXNlclByb3BlcnRpZXMoYW5hbHl0aWNzSW5zdGFuY2UsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgICBhbmFseXRpY3NJbnN0YW5jZSA9IGdldE1vZHVsYXJJbnN0YW5jZShhbmFseXRpY3NJbnN0YW5jZSk7XG4gICAgc2V0VXNlclByb3BlcnRpZXMkMSh3cmFwcGVkR3RhZ0Z1bmN0aW9uLCBpbml0aWFsaXphdGlvblByb21pc2VzTWFwW2FuYWx5dGljc0luc3RhbmNlLmFwcC5vcHRpb25zLmFwcElkXSwgcHJvcGVydGllcywgb3B0aW9ucykuY2F0Y2goZSA9PiBsb2dnZXIuZXJyb3IoZSkpO1xufVxuLyoqXG4gKiBTZXRzIHdoZXRoZXIgR29vZ2xlIEFuYWx5dGljcyBjb2xsZWN0aW9uIGlzIGVuYWJsZWQgZm9yIHRoaXMgYXBwIG9uIHRoaXMgZGV2aWNlLlxuICogU2V0cyBnbG9iYWwgYHdpbmRvd1snZ2EtZGlzYWJsZS1hbmFseXRpY3NJZCddID0gdHJ1ZTtgXG4gKlxuICogQHB1YmxpY1xuICpcbiAqIEBwYXJhbSBhbmFseXRpY3NJbnN0YW5jZSAtIFRoZSB7QGxpbmsgQW5hbHl0aWNzfSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBlbmFibGVkIC0gSWYgdHJ1ZSwgZW5hYmxlcyBjb2xsZWN0aW9uLCBpZiBmYWxzZSwgZGlzYWJsZXMgaXQuXG4gKi9cbmZ1bmN0aW9uIHNldEFuYWx5dGljc0NvbGxlY3Rpb25FbmFibGVkKGFuYWx5dGljc0luc3RhbmNlLCBlbmFibGVkKSB7XG4gICAgYW5hbHl0aWNzSW5zdGFuY2UgPSBnZXRNb2R1bGFySW5zdGFuY2UoYW5hbHl0aWNzSW5zdGFuY2UpO1xuICAgIHNldEFuYWx5dGljc0NvbGxlY3Rpb25FbmFibGVkJDEoaW5pdGlhbGl6YXRpb25Qcm9taXNlc01hcFthbmFseXRpY3NJbnN0YW5jZS5hcHAub3B0aW9ucy5hcHBJZF0sIGVuYWJsZWQpLmNhdGNoKGUgPT4gbG9nZ2VyLmVycm9yKGUpKTtcbn1cbi8qKlxuICogQWRkcyBkYXRhIHRoYXQgd2lsbCBiZSBzZXQgb24gZXZlcnkgZXZlbnQgbG9nZ2VkIGZyb20gdGhlIFNESywgaW5jbHVkaW5nIGF1dG9tYXRpYyBvbmVzLlxuICogV2l0aCBndGFnJ3MgXCJzZXRcIiBjb21tYW5kLCB0aGUgdmFsdWVzIHBhc3NlZCBwZXJzaXN0IG9uIHRoZSBjdXJyZW50IHBhZ2UgYW5kIGFyZSBwYXNzZWQgd2l0aFxuICogYWxsIHN1YnNlcXVlbnQgZXZlbnRzLlxuICogQHB1YmxpY1xuICogQHBhcmFtIGN1c3RvbVBhcmFtcyAtIEFueSBjdXN0b20gcGFyYW1zIHRoZSB1c2VyIG1heSBwYXNzIHRvIGd0YWcuanMuXG4gKi9cbmZ1bmN0aW9uIHNldERlZmF1bHRFdmVudFBhcmFtZXRlcnMoY3VzdG9tUGFyYW1zKSB7XG4gICAgLy8gQ2hlY2sgaWYgcmVmZXJlbmNlIHRvIGV4aXN0aW5nIGd0YWcgZnVuY3Rpb24gb24gd2luZG93IG9iamVjdCBleGlzdHNcbiAgICBpZiAod3JhcHBlZEd0YWdGdW5jdGlvbikge1xuICAgICAgICB3cmFwcGVkR3RhZ0Z1bmN0aW9uKFwic2V0XCIgLyogR3RhZ0NvbW1hbmQuU0VUICovLCBjdXN0b21QYXJhbXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgX3NldERlZmF1bHRFdmVudFBhcmFtZXRlcnNGb3JJbml0KGN1c3RvbVBhcmFtcyk7XG4gICAgfVxufVxuLyoqXG4gKiBTZW5kcyBhIEdvb2dsZSBBbmFseXRpY3MgZXZlbnQgd2l0aCBnaXZlbiBgZXZlbnRQYXJhbXNgLiBUaGlzIG1ldGhvZFxuICogYXV0b21hdGljYWxseSBhc3NvY2lhdGVzIHRoaXMgbG9nZ2VkIGV2ZW50IHdpdGggdGhpcyBGaXJlYmFzZSB3ZWJcbiAqIGFwcCBpbnN0YW5jZSBvbiB0aGlzIGRldmljZS5cbiAqIExpc3Qgb2Ygb2ZmaWNpYWwgZXZlbnQgcGFyYW1ldGVycyBjYW4gYmUgZm91bmQgaW4gdGhlIGd0YWcuanNcbiAqIHJlZmVyZW5jZSBkb2N1bWVudGF0aW9uOlxuICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2d0YWdqcy9yZWZlcmVuY2UvZ2E0LWV2ZW50c1xuICogfCB0aGUgR0E0IHJlZmVyZW5jZSBkb2N1bWVudGF0aW9ufS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGxvZ0V2ZW50KGFuYWx5dGljc0luc3RhbmNlLCBldmVudE5hbWUsIGV2ZW50UGFyYW1zLCBvcHRpb25zKSB7XG4gICAgYW5hbHl0aWNzSW5zdGFuY2UgPSBnZXRNb2R1bGFySW5zdGFuY2UoYW5hbHl0aWNzSW5zdGFuY2UpO1xuICAgIGxvZ0V2ZW50JDEod3JhcHBlZEd0YWdGdW5jdGlvbiwgaW5pdGlhbGl6YXRpb25Qcm9taXNlc01hcFthbmFseXRpY3NJbnN0YW5jZS5hcHAub3B0aW9ucy5hcHBJZF0sIGV2ZW50TmFtZSwgZXZlbnRQYXJhbXMsIG9wdGlvbnMpLmNhdGNoKGUgPT4gbG9nZ2VyLmVycm9yKGUpKTtcbn1cbi8qKlxuICogU2V0cyB0aGUgYXBwbGljYWJsZSBlbmQgdXNlciBjb25zZW50IHN0YXRlIGZvciB0aGlzIHdlYiBhcHAgYWNyb3NzIGFsbCBndGFnIHJlZmVyZW5jZXMgb25jZVxuICogRmlyZWJhc2UgQW5hbHl0aWNzIGlzIGluaXRpYWxpemVkLlxuICpcbiAqIFVzZSB0aGUge0BsaW5rIENvbnNlbnRTZXR0aW5nc30gdG8gc3BlY2lmeSBpbmRpdmlkdWFsIGNvbnNlbnQgdHlwZSB2YWx1ZXMuIEJ5IGRlZmF1bHQgY29uc2VudFxuICogdHlwZXMgYXJlIHNldCB0byBcImdyYW50ZWRcIi5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBjb25zZW50U2V0dGluZ3MgLSBNYXBzIHRoZSBhcHBsaWNhYmxlIGVuZCB1c2VyIGNvbnNlbnQgc3RhdGUgZm9yIGd0YWcuanMuXG4gKi9cbmZ1bmN0aW9uIHNldENvbnNlbnQoY29uc2VudFNldHRpbmdzKSB7XG4gICAgLy8gQ2hlY2sgaWYgcmVmZXJlbmNlIHRvIGV4aXN0aW5nIGd0YWcgZnVuY3Rpb24gb24gd2luZG93IG9iamVjdCBleGlzdHNcbiAgICBpZiAod3JhcHBlZEd0YWdGdW5jdGlvbikge1xuICAgICAgICB3cmFwcGVkR3RhZ0Z1bmN0aW9uKFwiY29uc2VudFwiIC8qIEd0YWdDb21tYW5kLkNPTlNFTlQgKi8sICd1cGRhdGUnLCBjb25zZW50U2V0dGluZ3MpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgX3NldENvbnNlbnREZWZhdWx0Rm9ySW5pdChjb25zZW50U2V0dGluZ3MpO1xuICAgIH1cbn1cblxuY29uc3QgbmFtZSA9IFwiQGZpcmViYXNlL2FuYWx5dGljc1wiO1xuY29uc3QgdmVyc2lvbiA9IFwiMC4xMC4xMFwiO1xuXG4vKipcbiAqIFRoZSBGaXJlYmFzZSBBbmFseXRpY3MgV2ViIFNESy5cbiAqIFRoaXMgU0RLIGRvZXMgbm90IHdvcmsgaW4gYSBOb2RlLmpzIGVudmlyb25tZW50LlxuICpcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5mdW5jdGlvbiByZWdpc3RlckFuYWx5dGljcygpIHtcbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudChBTkFMWVRJQ1NfVFlQRSwgKGNvbnRhaW5lciwgeyBvcHRpb25zOiBhbmFseXRpY3NPcHRpb25zIH0pID0+IHtcbiAgICAgICAgLy8gZ2V0SW1tZWRpYXRlIGZvciBGaXJlYmFzZUFwcCB3aWxsIGFsd2F5cyBzdWNjZWVkXG4gICAgICAgIGNvbnN0IGFwcCA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XG4gICAgICAgIGNvbnN0IGluc3RhbGxhdGlvbnMgPSBjb250YWluZXJcbiAgICAgICAgICAgIC5nZXRQcm92aWRlcignaW5zdGFsbGF0aW9ucy1pbnRlcm5hbCcpXG4gICAgICAgICAgICAuZ2V0SW1tZWRpYXRlKCk7XG4gICAgICAgIHJldHVybiBmYWN0b3J5KGFwcCwgaW5zdGFsbGF0aW9ucywgYW5hbHl0aWNzT3B0aW9ucyk7XG4gICAgfSwgXCJQVUJMSUNcIiAvKiBDb21wb25lbnRUeXBlLlBVQkxJQyAqLykpO1xuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KCdhbmFseXRpY3MtaW50ZXJuYWwnLCBpbnRlcm5hbEZhY3RvcnksIFwiUFJJVkFURVwiIC8qIENvbXBvbmVudFR5cGUuUFJJVkFURSAqLykpO1xuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uKTtcbiAgICAvLyBCVUlMRF9UQVJHRVQgd2lsbCBiZSByZXBsYWNlZCBieSB2YWx1ZXMgbGlrZSBlc20yMDE3LCBjanMyMDE3LCBldGMgZHVyaW5nIHRoZSBjb21waWxhdGlvblxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uLCAnZXNtMjAxNycpO1xuICAgIGZ1bmN0aW9uIGludGVybmFsRmFjdG9yeShjb250YWluZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFuYWx5dGljcyA9IGNvbnRhaW5lci5nZXRQcm92aWRlcihBTkFMWVRJQ1NfVFlQRSkuZ2V0SW1tZWRpYXRlKCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxvZ0V2ZW50OiAoZXZlbnROYW1lLCBldmVudFBhcmFtcywgb3B0aW9ucykgPT4gbG9nRXZlbnQoYW5hbHl0aWNzLCBldmVudE5hbWUsIGV2ZW50UGFyYW1zLCBvcHRpb25zKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpbnRlcm9wLWNvbXBvbmVudC1yZWctZmFpbGVkXCIgLyogQW5hbHl0aWNzRXJyb3IuSU5URVJPUF9DT01QT05FTlRfUkVHX0ZBSUxFRCAqLywge1xuICAgICAgICAgICAgICAgIHJlYXNvbjogZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5yZWdpc3RlckFuYWx5dGljcygpO1xuXG5leHBvcnQgeyBnZXRBbmFseXRpY3MsIGdldEdvb2dsZUFuYWx5dGljc0NsaWVudElkLCBpbml0aWFsaXplQW5hbHl0aWNzLCBpc1N1cHBvcnRlZCwgbG9nRXZlbnQsIHNldEFuYWx5dGljc0NvbGxlY3Rpb25FbmFibGVkLCBzZXRDb25zZW50LCBzZXRDdXJyZW50U2NyZWVuLCBzZXREZWZhdWx0RXZlbnRQYXJhbWV0ZXJzLCBzZXRVc2VySWQsIHNldFVzZXJQcm9wZXJ0aWVzLCBzZXR0aW5ncyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/analytics/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js":
/*!**************************************************************!*\
  !*** ./node_modules/@firebase/app/dist/esm/index.esm2017.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FirebaseError: () => (/* reexport safe */ _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError),\n/* harmony export */   SDK_VERSION: () => (/* binding */ SDK_VERSION),\n/* harmony export */   _DEFAULT_ENTRY_NAME: () => (/* binding */ DEFAULT_ENTRY_NAME),\n/* harmony export */   _addComponent: () => (/* binding */ _addComponent),\n/* harmony export */   _addOrOverwriteComponent: () => (/* binding */ _addOrOverwriteComponent),\n/* harmony export */   _apps: () => (/* binding */ _apps),\n/* harmony export */   _clearComponents: () => (/* binding */ _clearComponents),\n/* harmony export */   _components: () => (/* binding */ _components),\n/* harmony export */   _getProvider: () => (/* binding */ _getProvider),\n/* harmony export */   _isFirebaseApp: () => (/* binding */ _isFirebaseApp),\n/* harmony export */   _isFirebaseServerApp: () => (/* binding */ _isFirebaseServerApp),\n/* harmony export */   _registerComponent: () => (/* binding */ _registerComponent),\n/* harmony export */   _removeServiceInstance: () => (/* binding */ _removeServiceInstance),\n/* harmony export */   _serverApps: () => (/* binding */ _serverApps),\n/* harmony export */   deleteApp: () => (/* binding */ deleteApp),\n/* harmony export */   getApp: () => (/* binding */ getApp),\n/* harmony export */   getApps: () => (/* binding */ getApps),\n/* harmony export */   initializeApp: () => (/* binding */ initializeApp),\n/* harmony export */   initializeServerApp: () => (/* binding */ initializeServerApp),\n/* harmony export */   onLog: () => (/* binding */ onLog),\n/* harmony export */   registerVersion: () => (/* binding */ registerVersion),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! idb */ \"(ssr)/./node_modules/idb/build/index.js\");\n\n\n\n\n\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass PlatformLoggerServiceImpl {\n    constructor(container) {\n        this.container = container;\n    }\n    // In initial implementation, this will be called by installations on\n    // auth token refresh, and installations will send this string.\n    getPlatformInfoString() {\n        const providers = this.container.getProviders();\n        // Loop through providers and get library/version pairs from any that are\n        // version components.\n        return providers\n            .map(provider => {\n            if (isVersionServiceProvider(provider)) {\n                const service = provider.getImmediate();\n                return `${service.library}/${service.version}`;\n            }\n            else {\n                return null;\n            }\n        })\n            .filter(logString => logString)\n            .join(' ');\n    }\n}\n/**\n *\n * @param provider check if this provider provides a VersionService\n *\n * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider\n * provides VersionService. The provider is not necessarily a 'app-version'\n * provider.\n */\nfunction isVersionServiceProvider(provider) {\n    const component = provider.getComponent();\n    return (component === null || component === void 0 ? void 0 : component.type) === \"VERSION\" /* ComponentType.VERSION */;\n}\n\nconst name$q = \"@firebase/app\";\nconst version$1 = \"0.10.16\";\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst logger = new _firebase_logger__WEBPACK_IMPORTED_MODULE_1__.Logger('@firebase/app');\n\nconst name$p = \"@firebase/app-compat\";\n\nconst name$o = \"@firebase/analytics-compat\";\n\nconst name$n = \"@firebase/analytics\";\n\nconst name$m = \"@firebase/app-check-compat\";\n\nconst name$l = \"@firebase/app-check\";\n\nconst name$k = \"@firebase/auth\";\n\nconst name$j = \"@firebase/auth-compat\";\n\nconst name$i = \"@firebase/database\";\n\nconst name$h = \"@firebase/data-connect\";\n\nconst name$g = \"@firebase/database-compat\";\n\nconst name$f = \"@firebase/functions\";\n\nconst name$e = \"@firebase/functions-compat\";\n\nconst name$d = \"@firebase/installations\";\n\nconst name$c = \"@firebase/installations-compat\";\n\nconst name$b = \"@firebase/messaging\";\n\nconst name$a = \"@firebase/messaging-compat\";\n\nconst name$9 = \"@firebase/performance\";\n\nconst name$8 = \"@firebase/performance-compat\";\n\nconst name$7 = \"@firebase/remote-config\";\n\nconst name$6 = \"@firebase/remote-config-compat\";\n\nconst name$5 = \"@firebase/storage\";\n\nconst name$4 = \"@firebase/storage-compat\";\n\nconst name$3 = \"@firebase/firestore\";\n\nconst name$2 = \"@firebase/vertexai\";\n\nconst name$1 = \"@firebase/firestore-compat\";\n\nconst name = \"firebase\";\nconst version = \"11.0.2\";\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The default app name\n *\n * @internal\n */\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\nconst PLATFORM_LOG_STRING = {\n    [name$q]: 'fire-core',\n    [name$p]: 'fire-core-compat',\n    [name$n]: 'fire-analytics',\n    [name$o]: 'fire-analytics-compat',\n    [name$l]: 'fire-app-check',\n    [name$m]: 'fire-app-check-compat',\n    [name$k]: 'fire-auth',\n    [name$j]: 'fire-auth-compat',\n    [name$i]: 'fire-rtdb',\n    [name$h]: 'fire-data-connect',\n    [name$g]: 'fire-rtdb-compat',\n    [name$f]: 'fire-fn',\n    [name$e]: 'fire-fn-compat',\n    [name$d]: 'fire-iid',\n    [name$c]: 'fire-iid-compat',\n    [name$b]: 'fire-fcm',\n    [name$a]: 'fire-fcm-compat',\n    [name$9]: 'fire-perf',\n    [name$8]: 'fire-perf-compat',\n    [name$7]: 'fire-rc',\n    [name$6]: 'fire-rc-compat',\n    [name$5]: 'fire-gcs',\n    [name$4]: 'fire-gcs-compat',\n    [name$3]: 'fire-fst',\n    [name$1]: 'fire-fst-compat',\n    [name$2]: 'fire-vertex',\n    'fire-js': 'fire-js', // Platform identifier for JS SDK.\n    [name]: 'fire-js-all'\n};\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @internal\n */\nconst _apps = new Map();\n/**\n * @internal\n */\nconst _serverApps = new Map();\n/**\n * Registered components.\n *\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst _components = new Map();\n/**\n * @param component - the component being added to this app's container\n *\n * @internal\n */\nfunction _addComponent(app, component) {\n    try {\n        app.container.addComponent(component);\n    }\n    catch (e) {\n        logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);\n    }\n}\n/**\n *\n * @internal\n */\nfunction _addOrOverwriteComponent(app, component) {\n    app.container.addOrOverwriteComponent(component);\n}\n/**\n *\n * @param component - the component to register\n * @returns whether or not the component is registered successfully\n *\n * @internal\n */\nfunction _registerComponent(component) {\n    const componentName = component.name;\n    if (_components.has(componentName)) {\n        logger.debug(`There were multiple attempts to register component ${componentName}.`);\n        return false;\n    }\n    _components.set(componentName, component);\n    // add the component to existing app instances\n    for (const app of _apps.values()) {\n        _addComponent(app, component);\n    }\n    for (const serverApp of _serverApps.values()) {\n        _addComponent(serverApp, component);\n    }\n    return true;\n}\n/**\n *\n * @param app - FirebaseApp instance\n * @param name - service name\n *\n * @returns the provider for the service with the matching name\n *\n * @internal\n */\nfunction _getProvider(app, name) {\n    const heartbeatController = app.container\n        .getProvider('heartbeat')\n        .getImmediate({ optional: true });\n    if (heartbeatController) {\n        void heartbeatController.triggerHeartbeat();\n    }\n    return app.container.getProvider(name);\n}\n/**\n *\n * @param app - FirebaseApp instance\n * @param name - service name\n * @param instanceIdentifier - service instance identifier in case the service supports multiple instances\n *\n * @internal\n */\nfunction _removeServiceInstance(app, name, instanceIdentifier = DEFAULT_ENTRY_NAME) {\n    _getProvider(app, name).clearInstance(instanceIdentifier);\n}\n/**\n *\n * @param obj - an object of type FirebaseApp or FirebaseOptions.\n *\n * @returns true if the provide object is of type FirebaseApp.\n *\n * @internal\n */\nfunction _isFirebaseApp(obj) {\n    return obj.options !== undefined;\n}\n/**\n *\n * @param obj - an object of type FirebaseApp.\n *\n * @returns true if the provided object is of type FirebaseServerAppImpl.\n *\n * @internal\n */\nfunction _isFirebaseServerApp(obj) {\n    return obj.settings !== undefined;\n}\n/**\n * Test only\n *\n * @internal\n */\nfunction _clearComponents() {\n    _components.clear();\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst ERRORS = {\n    [\"no-app\" /* AppError.NO_APP */]: \"No Firebase App '{$appName}' has been created - \" +\n        'call initializeApp() first',\n    [\"bad-app-name\" /* AppError.BAD_APP_NAME */]: \"Illegal App name: '{$appName}'\",\n    [\"duplicate-app\" /* AppError.DUPLICATE_APP */]: \"Firebase App named '{$appName}' already exists with different options or config\",\n    [\"app-deleted\" /* AppError.APP_DELETED */]: \"Firebase App named '{$appName}' already deleted\",\n    [\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */]: 'Firebase Server App has been deleted',\n    [\"no-options\" /* AppError.NO_OPTIONS */]: 'Need to provide options, when not being deployed to hosting via source.',\n    [\"invalid-app-argument\" /* AppError.INVALID_APP_ARGUMENT */]: 'firebase.{$appName}() takes either no argument or a ' +\n        'Firebase App instance.',\n    [\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */]: 'First argument to `onLog` must be null or a function.',\n    [\"idb-open\" /* AppError.IDB_OPEN */]: 'Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.',\n    [\"idb-get\" /* AppError.IDB_GET */]: 'Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.',\n    [\"idb-set\" /* AppError.IDB_WRITE */]: 'Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.',\n    [\"idb-delete\" /* AppError.IDB_DELETE */]: 'Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.',\n    [\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */]: 'FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.',\n    [\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */]: 'FirebaseServerApp is not for use in browser environments.'\n};\nconst ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.ErrorFactory('app', 'Firebase', ERRORS);\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass FirebaseAppImpl {\n    constructor(options, config, container) {\n        this._isDeleted = false;\n        this._options = Object.assign({}, options);\n        this._config = Object.assign({}, config);\n        this._name = config.name;\n        this._automaticDataCollectionEnabled =\n            config.automaticDataCollectionEnabled;\n        this._container = container;\n        this.container.addComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('app', () => this, \"PUBLIC\" /* ComponentType.PUBLIC */));\n    }\n    get automaticDataCollectionEnabled() {\n        this.checkDestroyed();\n        return this._automaticDataCollectionEnabled;\n    }\n    set automaticDataCollectionEnabled(val) {\n        this.checkDestroyed();\n        this._automaticDataCollectionEnabled = val;\n    }\n    get name() {\n        this.checkDestroyed();\n        return this._name;\n    }\n    get options() {\n        this.checkDestroyed();\n        return this._options;\n    }\n    get config() {\n        this.checkDestroyed();\n        return this._config;\n    }\n    get container() {\n        return this._container;\n    }\n    get isDeleted() {\n        return this._isDeleted;\n    }\n    set isDeleted(val) {\n        this._isDeleted = val;\n    }\n    /**\n     * This function will throw an Error if the App has already been deleted -\n     * use before performing API actions on the App.\n     */\n    checkDestroyed() {\n        if (this.isDeleted) {\n            throw ERROR_FACTORY.create(\"app-deleted\" /* AppError.APP_DELETED */, { appName: this._name });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass FirebaseServerAppImpl extends FirebaseAppImpl {\n    constructor(options, serverConfig, name, container) {\n        // Build configuration parameters for the FirebaseAppImpl base class.\n        const automaticDataCollectionEnabled = serverConfig.automaticDataCollectionEnabled !== undefined\n            ? serverConfig.automaticDataCollectionEnabled\n            : false;\n        // Create the FirebaseAppSettings object for the FirebaseAppImp constructor.\n        const config = {\n            name,\n            automaticDataCollectionEnabled\n        };\n        if (options.apiKey !== undefined) {\n            // Construct the parent FirebaseAppImp object.\n            super(options, config, container);\n        }\n        else {\n            const appImpl = options;\n            super(appImpl.options, config, container);\n        }\n        // Now construct the data for the FirebaseServerAppImpl.\n        this._serverConfig = Object.assign({ automaticDataCollectionEnabled }, serverConfig);\n        this._finalizationRegistry = null;\n        if (typeof FinalizationRegistry !== 'undefined') {\n            this._finalizationRegistry = new FinalizationRegistry(() => {\n                this.automaticCleanup();\n            });\n        }\n        this._refCount = 0;\n        this.incRefCount(this._serverConfig.releaseOnDeref);\n        // Do not retain a hard reference to the dref object, otherwise the FinalizationRegistry\n        // will never trigger.\n        this._serverConfig.releaseOnDeref = undefined;\n        serverConfig.releaseOnDeref = undefined;\n        registerVersion(name$q, version$1, 'serverapp');\n    }\n    toJSON() {\n        return undefined;\n    }\n    get refCount() {\n        return this._refCount;\n    }\n    // Increment the reference count of this server app. If an object is provided, register it\n    // with the finalization registry.\n    incRefCount(obj) {\n        if (this.isDeleted) {\n            return;\n        }\n        this._refCount++;\n        if (obj !== undefined && this._finalizationRegistry !== null) {\n            this._finalizationRegistry.register(obj, this);\n        }\n    }\n    // Decrement the reference count.\n    decRefCount() {\n        if (this.isDeleted) {\n            return 0;\n        }\n        return --this._refCount;\n    }\n    // Invoked by the FinalizationRegistry callback to note that this app should go through its\n    // reference counts and delete itself if no reference count remain. The coordinating logic that\n    // handles this is in deleteApp(...).\n    automaticCleanup() {\n        void deleteApp(this);\n    }\n    get settings() {\n        this.checkDestroyed();\n        return this._serverConfig;\n    }\n    /**\n     * This function will throw an Error if the App has already been deleted -\n     * use before performing API actions on the App.\n     */\n    checkDestroyed() {\n        if (this.isDeleted) {\n            throw ERROR_FACTORY.create(\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The current SDK version.\n *\n * @public\n */\nconst SDK_VERSION = version;\nfunction initializeApp(_options, rawConfig = {}) {\n    let options = _options;\n    if (typeof rawConfig !== 'object') {\n        const name = rawConfig;\n        rawConfig = { name };\n    }\n    const config = Object.assign({ name: DEFAULT_ENTRY_NAME, automaticDataCollectionEnabled: false }, rawConfig);\n    const name = config.name;\n    if (typeof name !== 'string' || !name) {\n        throw ERROR_FACTORY.create(\"bad-app-name\" /* AppError.BAD_APP_NAME */, {\n            appName: String(name)\n        });\n    }\n    options || (options = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)());\n    if (!options) {\n        throw ERROR_FACTORY.create(\"no-options\" /* AppError.NO_OPTIONS */);\n    }\n    const existingApp = _apps.get(name);\n    if (existingApp) {\n        // return the existing app if options and config deep equal the ones in the existing app.\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(options, existingApp.options) &&\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(config, existingApp.config)) {\n            return existingApp;\n        }\n        else {\n            throw ERROR_FACTORY.create(\"duplicate-app\" /* AppError.DUPLICATE_APP */, { appName: name });\n        }\n    }\n    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(name);\n    for (const component of _components.values()) {\n        container.addComponent(component);\n    }\n    const newApp = new FirebaseAppImpl(options, config, container);\n    _apps.set(name, newApp);\n    return newApp;\n}\nfunction initializeServerApp(_options, _serverAppConfig) {\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isBrowser)() && !(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isWebWorker)()) {\n        // FirebaseServerApp isn't designed to be run in browsers.\n        throw ERROR_FACTORY.create(\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */);\n    }\n    if (_serverAppConfig.automaticDataCollectionEnabled === undefined) {\n        _serverAppConfig.automaticDataCollectionEnabled = false;\n    }\n    let appOptions;\n    if (_isFirebaseApp(_options)) {\n        appOptions = _options.options;\n    }\n    else {\n        appOptions = _options;\n    }\n    // Build an app name based on a hash of the configuration options.\n    const nameObj = Object.assign(Object.assign({}, _serverAppConfig), appOptions);\n    // However, Do not mangle the name based on releaseOnDeref, since it will vary between the\n    // construction of FirebaseServerApp instances. For example, if the object is the request headers.\n    if (nameObj.releaseOnDeref !== undefined) {\n        delete nameObj.releaseOnDeref;\n    }\n    const hashCode = (s) => {\n        return [...s].reduce((hash, c) => (Math.imul(31, hash) + c.charCodeAt(0)) | 0, 0);\n    };\n    if (_serverAppConfig.releaseOnDeref !== undefined) {\n        if (typeof FinalizationRegistry === 'undefined') {\n            throw ERROR_FACTORY.create(\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */, {});\n        }\n    }\n    const nameString = '' + hashCode(JSON.stringify(nameObj));\n    const existingApp = _serverApps.get(nameString);\n    if (existingApp) {\n        existingApp.incRefCount(_serverAppConfig.releaseOnDeref);\n        return existingApp;\n    }\n    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(nameString);\n    for (const component of _components.values()) {\n        container.addComponent(component);\n    }\n    const newApp = new FirebaseServerAppImpl(appOptions, _serverAppConfig, nameString, container);\n    _serverApps.set(nameString, newApp);\n    return newApp;\n}\n/**\n * Retrieves a {@link @firebase/app#FirebaseApp} instance.\n *\n * When called with no arguments, the default app is returned. When an app name\n * is provided, the app corresponding to that name is returned.\n *\n * An exception is thrown if the app being retrieved has not yet been\n * initialized.\n *\n * @example\n * ```javascript\n * // Return the default app\n * const app = getApp();\n * ```\n *\n * @example\n * ```javascript\n * // Return a named app\n * const otherApp = getApp(\"otherApp\");\n * ```\n *\n * @param name - Optional name of the app to return. If no name is\n *   provided, the default is `\"[DEFAULT]\"`.\n *\n * @returns The app corresponding to the provided app name.\n *   If no app name is provided, the default app is returned.\n *\n * @public\n */\nfunction getApp(name = DEFAULT_ENTRY_NAME) {\n    const app = _apps.get(name);\n    if (!app && name === DEFAULT_ENTRY_NAME && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)()) {\n        return initializeApp();\n    }\n    if (!app) {\n        throw ERROR_FACTORY.create(\"no-app\" /* AppError.NO_APP */, { appName: name });\n    }\n    return app;\n}\n/**\n * A (read-only) array of all initialized apps.\n * @public\n */\nfunction getApps() {\n    return Array.from(_apps.values());\n}\n/**\n * Renders this app unusable and frees the resources of all associated\n * services.\n *\n * @example\n * ```javascript\n * deleteApp(app)\n *   .then(function() {\n *     console.log(\"App deleted successfully\");\n *   })\n *   .catch(function(error) {\n *     console.log(\"Error deleting app:\", error);\n *   });\n * ```\n *\n * @public\n */\nasync function deleteApp(app) {\n    let cleanupProviders = false;\n    const name = app.name;\n    if (_apps.has(name)) {\n        cleanupProviders = true;\n        _apps.delete(name);\n    }\n    else if (_serverApps.has(name)) {\n        const firebaseServerApp = app;\n        if (firebaseServerApp.decRefCount() <= 0) {\n            _serverApps.delete(name);\n            cleanupProviders = true;\n        }\n    }\n    if (cleanupProviders) {\n        await Promise.all(app.container\n            .getProviders()\n            .map(provider => provider.delete()));\n        app.isDeleted = true;\n    }\n}\n/**\n * Registers a library's name and version for platform logging purposes.\n * @param library - Name of 1p or 3p library (e.g. firestore, angularfire)\n * @param version - Current version of that library.\n * @param variant - Bundle variant, e.g., node, rn, etc.\n *\n * @public\n */\nfunction registerVersion(libraryKeyOrName, version, variant) {\n    var _a;\n    // TODO: We can use this check to whitelist strings when/if we set up\n    // a good whitelist system.\n    let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;\n    if (variant) {\n        library += `-${variant}`;\n    }\n    const libraryMismatch = library.match(/\\s|\\//);\n    const versionMismatch = version.match(/\\s|\\//);\n    if (libraryMismatch || versionMismatch) {\n        const warning = [\n            `Unable to register library \"${library}\" with version \"${version}\":`\n        ];\n        if (libraryMismatch) {\n            warning.push(`library name \"${library}\" contains illegal characters (whitespace or \"/\")`);\n        }\n        if (libraryMismatch && versionMismatch) {\n            warning.push('and');\n        }\n        if (versionMismatch) {\n            warning.push(`version name \"${version}\" contains illegal characters (whitespace or \"/\")`);\n        }\n        logger.warn(warning.join(' '));\n        return;\n    }\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(`${library}-version`, () => ({ library, version }), \"VERSION\" /* ComponentType.VERSION */));\n}\n/**\n * Sets log handler for all Firebase SDKs.\n * @param logCallback - An optional custom log handler that executes user code whenever\n * the Firebase SDK makes a logging call.\n *\n * @public\n */\nfunction onLog(logCallback, options) {\n    if (logCallback !== null && typeof logCallback !== 'function') {\n        throw ERROR_FACTORY.create(\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */);\n    }\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setUserLogHandler)(logCallback, options);\n}\n/**\n * Sets log level for all Firebase SDKs.\n *\n * All of the log types above the current log level are captured (i.e. if\n * you set the log level to `info`, errors are logged, but `debug` and\n * `verbose` logs are not).\n *\n * @public\n */\nfunction setLogLevel(logLevel) {\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setLogLevel)(logLevel);\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DB_NAME = 'firebase-heartbeat-database';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'firebase-heartbeat-store';\nlet dbPromise = null;\nfunction getDbPromise() {\n    if (!dbPromise) {\n        dbPromise = (0,idb__WEBPACK_IMPORTED_MODULE_3__.openDB)(DB_NAME, DB_VERSION, {\n            upgrade: (db, oldVersion) => {\n                // We don't use 'break' in this switch statement, the fall-through\n                // behavior is what we want, because if there are multiple versions between\n                // the old version and the current version, we want ALL the migrations\n                // that correspond to those versions to run, not only the last one.\n                // eslint-disable-next-line default-case\n                switch (oldVersion) {\n                    case 0:\n                        try {\n                            db.createObjectStore(STORE_NAME);\n                        }\n                        catch (e) {\n                            // Safari/iOS browsers throw occasional exceptions on\n                            // db.createObjectStore() that may be a bug. Avoid blocking\n                            // the rest of the app functionality.\n                            console.warn(e);\n                        }\n                }\n            }\n        }).catch(e => {\n            throw ERROR_FACTORY.create(\"idb-open\" /* AppError.IDB_OPEN */, {\n                originalErrorMessage: e.message\n            });\n        });\n    }\n    return dbPromise;\n}\nasync function readHeartbeatsFromIndexedDB(app) {\n    try {\n        const db = await getDbPromise();\n        const tx = db.transaction(STORE_NAME);\n        const result = await tx.objectStore(STORE_NAME).get(computeKey(app));\n        // We already have the value but tx.done can throw,\n        // so we need to await it here to catch errors\n        await tx.done;\n        return result;\n    }\n    catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\n            logger.warn(e.message);\n        }\n        else {\n            const idbGetError = ERROR_FACTORY.create(\"idb-get\" /* AppError.IDB_GET */, {\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n            logger.warn(idbGetError.message);\n        }\n    }\n}\nasync function writeHeartbeatsToIndexedDB(app, heartbeatObject) {\n    try {\n        const db = await getDbPromise();\n        const tx = db.transaction(STORE_NAME, 'readwrite');\n        const objectStore = tx.objectStore(STORE_NAME);\n        await objectStore.put(heartbeatObject, computeKey(app));\n        await tx.done;\n    }\n    catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\n            logger.warn(e.message);\n        }\n        else {\n            const idbGetError = ERROR_FACTORY.create(\"idb-set\" /* AppError.IDB_WRITE */, {\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n            logger.warn(idbGetError.message);\n        }\n    }\n}\nfunction computeKey(app) {\n    return `${app.name}!${app.options.appId}`;\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst MAX_HEADER_BYTES = 1024;\n// 30 days\nconst STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1000;\nclass HeartbeatServiceImpl {\n    constructor(container) {\n        this.container = container;\n        /**\n         * In-memory cache for heartbeats, used by getHeartbeatsHeader() to generate\n         * the header string.\n         * Stores one record per date. This will be consolidated into the standard\n         * format of one record per user agent string before being sent as a header.\n         * Populated from indexedDB when the controller is instantiated and should\n         * be kept in sync with indexedDB.\n         * Leave public for easier testing.\n         */\n        this._heartbeatsCache = null;\n        const app = this.container.getProvider('app').getImmediate();\n        this._storage = new HeartbeatStorageImpl(app);\n        this._heartbeatsCachePromise = this._storage.read().then(result => {\n            this._heartbeatsCache = result;\n            return result;\n        });\n    }\n    /**\n     * Called to report a heartbeat. The function will generate\n     * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it\n     * to IndexedDB.\n     * Note that we only store one heartbeat per day. So if a heartbeat for today is\n     * already logged, subsequent calls to this function in the same day will be ignored.\n     */\n    async triggerHeartbeat() {\n        var _a, _b;\n        try {\n            const platformLogger = this.container\n                .getProvider('platform-logger')\n                .getImmediate();\n            // This is the \"Firebase user agent\" string from the platform logger\n            // service, not the browser user agent.\n            const agent = platformLogger.getPlatformInfoString();\n            const date = getUTCDateString();\n            if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null) {\n                this._heartbeatsCache = await this._heartbeatsCachePromise;\n                // If we failed to construct a heartbeats cache, then return immediately.\n                if (((_b = this._heartbeatsCache) === null || _b === void 0 ? void 0 : _b.heartbeats) == null) {\n                    return;\n                }\n            }\n            // Do not store a heartbeat if one is already stored for this day\n            // or if a header has already been sent today.\n            if (this._heartbeatsCache.lastSentHeartbeatDate === date ||\n                this._heartbeatsCache.heartbeats.some(singleDateHeartbeat => singleDateHeartbeat.date === date)) {\n                return;\n            }\n            else {\n                // There is no entry for this date. Create one.\n                this._heartbeatsCache.heartbeats.push({ date, agent });\n            }\n            // Remove entries older than 30 days.\n            this._heartbeatsCache.heartbeats =\n                this._heartbeatsCache.heartbeats.filter(singleDateHeartbeat => {\n                    const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();\n                    const now = Date.now();\n                    return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;\n                });\n            return this._storage.overwrite(this._heartbeatsCache);\n        }\n        catch (e) {\n            logger.warn(e);\n        }\n    }\n    /**\n     * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.\n     * It also clears all heartbeats from memory as well as in IndexedDB.\n     *\n     * NOTE: Consuming product SDKs should not send the header if this method\n     * returns an empty string.\n     */\n    async getHeartbeatsHeader() {\n        var _a;\n        try {\n            if (this._heartbeatsCache === null) {\n                await this._heartbeatsCachePromise;\n            }\n            // If it's still null or the array is empty, there is no data to send.\n            if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null ||\n                this._heartbeatsCache.heartbeats.length === 0) {\n                return '';\n            }\n            const date = getUTCDateString();\n            // Extract as many heartbeats from the cache as will fit under the size limit.\n            const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);\n            const headerString = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(JSON.stringify({ version: 2, heartbeats: heartbeatsToSend }));\n            // Store last sent date to prevent another being logged/sent for the same day.\n            this._heartbeatsCache.lastSentHeartbeatDate = date;\n            if (unsentEntries.length > 0) {\n                // Store any unsent entries if they exist.\n                this._heartbeatsCache.heartbeats = unsentEntries;\n                // This seems more likely than emptying the array (below) to lead to some odd state\n                // since the cache isn't empty and this will be called again on the next request,\n                // and is probably safest if we await it.\n                await this._storage.overwrite(this._heartbeatsCache);\n            }\n            else {\n                this._heartbeatsCache.heartbeats = [];\n                // Do not wait for this, to reduce latency.\n                void this._storage.overwrite(this._heartbeatsCache);\n            }\n            return headerString;\n        }\n        catch (e) {\n            logger.warn(e);\n            return '';\n        }\n    }\n}\nfunction getUTCDateString() {\n    const today = new Date();\n    // Returns date format 'YYYY-MM-DD'\n    return today.toISOString().substring(0, 10);\n}\nfunction extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {\n    // Heartbeats grouped by user agent in the standard format to be sent in\n    // the header.\n    const heartbeatsToSend = [];\n    // Single date format heartbeats that are not sent.\n    let unsentEntries = heartbeatsCache.slice();\n    for (const singleDateHeartbeat of heartbeatsCache) {\n        // Look for an existing entry with the same user agent.\n        const heartbeatEntry = heartbeatsToSend.find(hb => hb.agent === singleDateHeartbeat.agent);\n        if (!heartbeatEntry) {\n            // If no entry for this user agent exists, create one.\n            heartbeatsToSend.push({\n                agent: singleDateHeartbeat.agent,\n                dates: [singleDateHeartbeat.date]\n            });\n            if (countBytes(heartbeatsToSend) > maxSize) {\n                // If the header would exceed max size, remove the added heartbeat\n                // entry and stop adding to the header.\n                heartbeatsToSend.pop();\n                break;\n            }\n        }\n        else {\n            heartbeatEntry.dates.push(singleDateHeartbeat.date);\n            // If the header would exceed max size, remove the added date\n            // and stop adding to the header.\n            if (countBytes(heartbeatsToSend) > maxSize) {\n                heartbeatEntry.dates.pop();\n                break;\n            }\n        }\n        // Pop unsent entry from queue. (Skipped if adding the entry exceeded\n        // quota and the loop breaks early.)\n        unsentEntries = unsentEntries.slice(1);\n    }\n    return {\n        heartbeatsToSend,\n        unsentEntries\n    };\n}\nclass HeartbeatStorageImpl {\n    constructor(app) {\n        this.app = app;\n        this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();\n    }\n    async runIndexedDBEnvironmentCheck() {\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isIndexedDBAvailable)()) {\n            return false;\n        }\n        else {\n            return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateIndexedDBOpenable)()\n                .then(() => true)\n                .catch(() => false);\n        }\n    }\n    /**\n     * Read all heartbeats.\n     */\n    async read() {\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return { heartbeats: [] };\n        }\n        else {\n            const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);\n            if (idbHeartbeatObject === null || idbHeartbeatObject === void 0 ? void 0 : idbHeartbeatObject.heartbeats) {\n                return idbHeartbeatObject;\n            }\n            else {\n                return { heartbeats: [] };\n            }\n        }\n    }\n    // overwrite the storage with the provided heartbeats\n    async overwrite(heartbeatsObject) {\n        var _a;\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return;\n        }\n        else {\n            const existingHeartbeatsObject = await this.read();\n            return writeHeartbeatsToIndexedDB(this.app, {\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n                heartbeats: heartbeatsObject.heartbeats\n            });\n        }\n    }\n    // add heartbeats\n    async add(heartbeatsObject) {\n        var _a;\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return;\n        }\n        else {\n            const existingHeartbeatsObject = await this.read();\n            return writeHeartbeatsToIndexedDB(this.app, {\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n                heartbeats: [\n                    ...existingHeartbeatsObject.heartbeats,\n                    ...heartbeatsObject.heartbeats\n                ]\n            });\n        }\n    }\n}\n/**\n * Calculate bytes of a HeartbeatsByUserAgent array after being wrapped\n * in a platform logging header JSON object, stringified, and converted\n * to base 64.\n */\nfunction countBytes(heartbeatsCache) {\n    // base64 has a restricted set of characters, all of which should be 1 byte.\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(\n    // heartbeatsCache wrapper properties\n    JSON.stringify({ version: 2, heartbeats: heartbeatsCache })).length;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction registerCoreComponents(variant) {\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('platform-logger', container => new PlatformLoggerServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */));\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('heartbeat', container => new HeartbeatServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */));\n    // Register `app` package.\n    registerVersion(name$q, version$1, variant);\n    // BUILD_TARGET will be replaced by values like esm2017, cjs2017, etc during the compilation\n    registerVersion(name$q, version$1, 'esm2017');\n    // Register platform SDK identifier (no version).\n    registerVersion('fire-js', '');\n}\n\n/**\n * Firebase App\n *\n * @remarks This package coordinates the communication between the different Firebase components\n * @packageDocumentation\n */\nregisterCoreComponents('');\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9FO0FBQ3VCO0FBQzBHO0FBQ3RKO0FBQ2xCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCLEdBQUcsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0RBQU07O0FBRXpCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnQkFBZ0Isc0NBQXNDLFNBQVM7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsY0FBYztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsU0FBUztBQUNsRTtBQUNBLHVFQUF1RSxTQUFTO0FBQ2hGLDBFQUEwRSxTQUFTO0FBQ25GLHNFQUFzRSxTQUFTO0FBQy9FO0FBQ0E7QUFDQSw2RUFBNkUsU0FBUztBQUN0RjtBQUNBO0FBQ0EsaUdBQWlHLHNCQUFzQjtBQUN2SCxvR0FBb0csc0JBQXNCO0FBQzFILG9HQUFvRyxzQkFBc0I7QUFDMUgsMkdBQTJHLHNCQUFzQjtBQUNqSTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0RBQVk7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywwREFBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYscUJBQXFCO0FBQ3hHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0NBQWdDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsbUNBQW1DLGlFQUFpRTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDBCQUEwQixtRUFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBUztBQUNyQixZQUFZLHlEQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixlQUFlO0FBQ3RHO0FBQ0E7QUFDQSwwQkFBMEIsbUVBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUFTLE9BQU8sMkRBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1JQUFtSTtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1FQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlDQUFpQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG1FQUFtQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsZUFBZTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUSxrQkFBa0IsUUFBUTtBQUM3RTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBEQUFTLElBQUksUUFBUSxvQkFBb0Isa0JBQWtCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUVBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZEQUFhO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJDQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseURBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5REFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVMsR0FBRyxrQkFBa0I7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGFBQWE7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQ0FBa0M7QUFDdEQsaUNBQWlDLDZFQUE2QixrQkFBa0IsMENBQTBDO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0VBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5RUFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZFQUE2QjtBQUN4QztBQUNBLHFCQUFxQix5Q0FBeUM7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwREFBUztBQUNwQywyQkFBMkIsMERBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1XO0FBQ25XIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXBwL2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanM/YWY4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIENvbXBvbmVudENvbnRhaW5lciB9IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IHsgTG9nZ2VyLCBzZXRVc2VyTG9nSGFuZGxlciwgc2V0TG9nTGV2ZWwgYXMgc2V0TG9nTGV2ZWwkMSB9IGZyb20gJ0BmaXJlYmFzZS9sb2dnZXInO1xuaW1wb3J0IHsgRXJyb3JGYWN0b3J5LCBnZXREZWZhdWx0QXBwQ29uZmlnLCBkZWVwRXF1YWwsIGlzQnJvd3NlciwgaXNXZWJXb3JrZXIsIEZpcmViYXNlRXJyb3IsIGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nLCBpc0luZGV4ZWREQkF2YWlsYWJsZSwgdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmV4cG9ydCB7IEZpcmViYXNlRXJyb3IgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBvcGVuREIgfSBmcm9tICdpZGInO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgUGxhdGZvcm1Mb2dnZXJTZXJ2aWNlSW1wbCB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIH1cbiAgICAvLyBJbiBpbml0aWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdpbGwgYmUgY2FsbGVkIGJ5IGluc3RhbGxhdGlvbnMgb25cbiAgICAvLyBhdXRoIHRva2VuIHJlZnJlc2gsIGFuZCBpbnN0YWxsYXRpb25zIHdpbGwgc2VuZCB0aGlzIHN0cmluZy5cbiAgICBnZXRQbGF0Zm9ybUluZm9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVycyA9IHRoaXMuY29udGFpbmVyLmdldFByb3ZpZGVycygpO1xuICAgICAgICAvLyBMb29wIHRocm91Z2ggcHJvdmlkZXJzIGFuZCBnZXQgbGlicmFyeS92ZXJzaW9uIHBhaXJzIGZyb20gYW55IHRoYXQgYXJlXG4gICAgICAgIC8vIHZlcnNpb24gY29tcG9uZW50cy5cbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyc1xuICAgICAgICAgICAgLm1hcChwcm92aWRlciA9PiB7XG4gICAgICAgICAgICBpZiAoaXNWZXJzaW9uU2VydmljZVByb3ZpZGVyKHByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZpY2UgPSBwcm92aWRlci5nZXRJbW1lZGlhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7c2VydmljZS5saWJyYXJ5fS8ke3NlcnZpY2UudmVyc2lvbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGxvZ1N0cmluZyA9PiBsb2dTdHJpbmcpXG4gICAgICAgICAgICAuam9pbignICcpO1xuICAgIH1cbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBwcm92aWRlciBjaGVjayBpZiB0aGlzIHByb3ZpZGVyIHByb3ZpZGVzIGEgVmVyc2lvblNlcnZpY2VcbiAqXG4gKiBOT1RFOiBVc2luZyBQcm92aWRlcjwnYXBwLXZlcnNpb24nPiBpcyBhIGhhY2sgdG8gaW5kaWNhdGUgdGhhdCB0aGUgcHJvdmlkZXJcbiAqIHByb3ZpZGVzIFZlcnNpb25TZXJ2aWNlLiBUaGUgcHJvdmlkZXIgaXMgbm90IG5lY2Vzc2FyaWx5IGEgJ2FwcC12ZXJzaW9uJ1xuICogcHJvdmlkZXIuXG4gKi9cbmZ1bmN0aW9uIGlzVmVyc2lvblNlcnZpY2VQcm92aWRlcihwcm92aWRlcikge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IHByb3ZpZGVyLmdldENvbXBvbmVudCgpO1xuICAgIHJldHVybiAoY29tcG9uZW50ID09PSBudWxsIHx8IGNvbXBvbmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcG9uZW50LnR5cGUpID09PSBcIlZFUlNJT05cIiAvKiBDb21wb25lbnRUeXBlLlZFUlNJT04gKi87XG59XG5cbmNvbnN0IG5hbWUkcSA9IFwiQGZpcmViYXNlL2FwcFwiO1xuY29uc3QgdmVyc2lvbiQxID0gXCIwLjEwLjE2XCI7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCdAZmlyZWJhc2UvYXBwJyk7XG5cbmNvbnN0IG5hbWUkcCA9IFwiQGZpcmViYXNlL2FwcC1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRvID0gXCJAZmlyZWJhc2UvYW5hbHl0aWNzLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJG4gPSBcIkBmaXJlYmFzZS9hbmFseXRpY3NcIjtcblxuY29uc3QgbmFtZSRtID0gXCJAZmlyZWJhc2UvYXBwLWNoZWNrLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGwgPSBcIkBmaXJlYmFzZS9hcHAtY2hlY2tcIjtcblxuY29uc3QgbmFtZSRrID0gXCJAZmlyZWJhc2UvYXV0aFwiO1xuXG5jb25zdCBuYW1lJGogPSBcIkBmaXJlYmFzZS9hdXRoLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGkgPSBcIkBmaXJlYmFzZS9kYXRhYmFzZVwiO1xuXG5jb25zdCBuYW1lJGggPSBcIkBmaXJlYmFzZS9kYXRhLWNvbm5lY3RcIjtcblxuY29uc3QgbmFtZSRnID0gXCJAZmlyZWJhc2UvZGF0YWJhc2UtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkZiA9IFwiQGZpcmViYXNlL2Z1bmN0aW9uc1wiO1xuXG5jb25zdCBuYW1lJGUgPSBcIkBmaXJlYmFzZS9mdW5jdGlvbnMtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkZCA9IFwiQGZpcmViYXNlL2luc3RhbGxhdGlvbnNcIjtcblxuY29uc3QgbmFtZSRjID0gXCJAZmlyZWJhc2UvaW5zdGFsbGF0aW9ucy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRiID0gXCJAZmlyZWJhc2UvbWVzc2FnaW5nXCI7XG5cbmNvbnN0IG5hbWUkYSA9IFwiQGZpcmViYXNlL21lc3NhZ2luZy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSQ5ID0gXCJAZmlyZWJhc2UvcGVyZm9ybWFuY2VcIjtcblxuY29uc3QgbmFtZSQ4ID0gXCJAZmlyZWJhc2UvcGVyZm9ybWFuY2UtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkNyA9IFwiQGZpcmViYXNlL3JlbW90ZS1jb25maWdcIjtcblxuY29uc3QgbmFtZSQ2ID0gXCJAZmlyZWJhc2UvcmVtb3RlLWNvbmZpZy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSQ1ID0gXCJAZmlyZWJhc2Uvc3RvcmFnZVwiO1xuXG5jb25zdCBuYW1lJDQgPSBcIkBmaXJlYmFzZS9zdG9yYWdlLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJDMgPSBcIkBmaXJlYmFzZS9maXJlc3RvcmVcIjtcblxuY29uc3QgbmFtZSQyID0gXCJAZmlyZWJhc2UvdmVydGV4YWlcIjtcblxuY29uc3QgbmFtZSQxID0gXCJAZmlyZWJhc2UvZmlyZXN0b3JlLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lID0gXCJmaXJlYmFzZVwiO1xuY29uc3QgdmVyc2lvbiA9IFwiMTEuMC4yXCI7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRoZSBkZWZhdWx0IGFwcCBuYW1lXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IERFRkFVTFRfRU5UUllfTkFNRSA9ICdbREVGQVVMVF0nO1xuY29uc3QgUExBVEZPUk1fTE9HX1NUUklORyA9IHtcbiAgICBbbmFtZSRxXTogJ2ZpcmUtY29yZScsXG4gICAgW25hbWUkcF06ICdmaXJlLWNvcmUtY29tcGF0JyxcbiAgICBbbmFtZSRuXTogJ2ZpcmUtYW5hbHl0aWNzJyxcbiAgICBbbmFtZSRvXTogJ2ZpcmUtYW5hbHl0aWNzLWNvbXBhdCcsXG4gICAgW25hbWUkbF06ICdmaXJlLWFwcC1jaGVjaycsXG4gICAgW25hbWUkbV06ICdmaXJlLWFwcC1jaGVjay1jb21wYXQnLFxuICAgIFtuYW1lJGtdOiAnZmlyZS1hdXRoJyxcbiAgICBbbmFtZSRqXTogJ2ZpcmUtYXV0aC1jb21wYXQnLFxuICAgIFtuYW1lJGldOiAnZmlyZS1ydGRiJyxcbiAgICBbbmFtZSRoXTogJ2ZpcmUtZGF0YS1jb25uZWN0JyxcbiAgICBbbmFtZSRnXTogJ2ZpcmUtcnRkYi1jb21wYXQnLFxuICAgIFtuYW1lJGZdOiAnZmlyZS1mbicsXG4gICAgW25hbWUkZV06ICdmaXJlLWZuLWNvbXBhdCcsXG4gICAgW25hbWUkZF06ICdmaXJlLWlpZCcsXG4gICAgW25hbWUkY106ICdmaXJlLWlpZC1jb21wYXQnLFxuICAgIFtuYW1lJGJdOiAnZmlyZS1mY20nLFxuICAgIFtuYW1lJGFdOiAnZmlyZS1mY20tY29tcGF0JyxcbiAgICBbbmFtZSQ5XTogJ2ZpcmUtcGVyZicsXG4gICAgW25hbWUkOF06ICdmaXJlLXBlcmYtY29tcGF0JyxcbiAgICBbbmFtZSQ3XTogJ2ZpcmUtcmMnLFxuICAgIFtuYW1lJDZdOiAnZmlyZS1yYy1jb21wYXQnLFxuICAgIFtuYW1lJDVdOiAnZmlyZS1nY3MnLFxuICAgIFtuYW1lJDRdOiAnZmlyZS1nY3MtY29tcGF0JyxcbiAgICBbbmFtZSQzXTogJ2ZpcmUtZnN0JyxcbiAgICBbbmFtZSQxXTogJ2ZpcmUtZnN0LWNvbXBhdCcsXG4gICAgW25hbWUkMl06ICdmaXJlLXZlcnRleCcsXG4gICAgJ2ZpcmUtanMnOiAnZmlyZS1qcycsIC8vIFBsYXRmb3JtIGlkZW50aWZpZXIgZm9yIEpTIFNESy5cbiAgICBbbmFtZV06ICdmaXJlLWpzLWFsbCdcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBfYXBwcyA9IG5ldyBNYXAoKTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IF9zZXJ2ZXJBcHBzID0gbmV3IE1hcCgpO1xuLyoqXG4gKiBSZWdpc3RlcmVkIGNvbXBvbmVudHMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBfY29tcG9uZW50cyA9IG5ldyBNYXAoKTtcbi8qKlxuICogQHBhcmFtIGNvbXBvbmVudCAtIHRoZSBjb21wb25lbnQgYmVpbmcgYWRkZWQgdG8gdGhpcyBhcHAncyBjb250YWluZXJcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gX2FkZENvbXBvbmVudChhcHAsIGNvbXBvbmVudCkge1xuICAgIHRyeSB7XG4gICAgICAgIGFwcC5jb250YWluZXIuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgQ29tcG9uZW50ICR7Y29tcG9uZW50Lm5hbWV9IGZhaWxlZCB0byByZWdpc3RlciB3aXRoIEZpcmViYXNlQXBwICR7YXBwLm5hbWV9YCwgZSk7XG4gICAgfVxufVxuLyoqXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIF9hZGRPck92ZXJ3cml0ZUNvbXBvbmVudChhcHAsIGNvbXBvbmVudCkge1xuICAgIGFwcC5jb250YWluZXIuYWRkT3JPdmVyd3JpdGVDb21wb25lbnQoY29tcG9uZW50KTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBjb21wb25lbnQgLSB0aGUgY29tcG9uZW50IHRvIHJlZ2lzdGVyXG4gKiBAcmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgY29tcG9uZW50IGlzIHJlZ2lzdGVyZWQgc3VjY2Vzc2Z1bGx5XG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIF9yZWdpc3RlckNvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICBjb25zdCBjb21wb25lbnROYW1lID0gY29tcG9uZW50Lm5hbWU7XG4gICAgaWYgKF9jb21wb25lbnRzLmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoYFRoZXJlIHdlcmUgbXVsdGlwbGUgYXR0ZW1wdHMgdG8gcmVnaXN0ZXIgY29tcG9uZW50ICR7Y29tcG9uZW50TmFtZX0uYCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX2NvbXBvbmVudHMuc2V0KGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudCk7XG4gICAgLy8gYWRkIHRoZSBjb21wb25lbnQgdG8gZXhpc3RpbmcgYXBwIGluc3RhbmNlc1xuICAgIGZvciAoY29uc3QgYXBwIG9mIF9hcHBzLnZhbHVlcygpKSB7XG4gICAgICAgIF9hZGRDb21wb25lbnQoYXBwLCBjb21wb25lbnQpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHNlcnZlckFwcCBvZiBfc2VydmVyQXBwcy52YWx1ZXMoKSkge1xuICAgICAgICBfYWRkQ29tcG9uZW50KHNlcnZlckFwcCwgY29tcG9uZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gYXBwIC0gRmlyZWJhc2VBcHAgaW5zdGFuY2VcbiAqIEBwYXJhbSBuYW1lIC0gc2VydmljZSBuYW1lXG4gKlxuICogQHJldHVybnMgdGhlIHByb3ZpZGVyIGZvciB0aGUgc2VydmljZSB3aXRoIHRoZSBtYXRjaGluZyBuYW1lXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIF9nZXRQcm92aWRlcihhcHAsIG5hbWUpIHtcbiAgICBjb25zdCBoZWFydGJlYXRDb250cm9sbGVyID0gYXBwLmNvbnRhaW5lclxuICAgICAgICAuZ2V0UHJvdmlkZXIoJ2hlYXJ0YmVhdCcpXG4gICAgICAgIC5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KTtcbiAgICBpZiAoaGVhcnRiZWF0Q29udHJvbGxlcikge1xuICAgICAgICB2b2lkIGhlYXJ0YmVhdENvbnRyb2xsZXIudHJpZ2dlckhlYXJ0YmVhdCgpO1xuICAgIH1cbiAgICByZXR1cm4gYXBwLmNvbnRhaW5lci5nZXRQcm92aWRlcihuYW1lKTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBhcHAgLSBGaXJlYmFzZUFwcCBpbnN0YW5jZVxuICogQHBhcmFtIG5hbWUgLSBzZXJ2aWNlIG5hbWVcbiAqIEBwYXJhbSBpbnN0YW5jZUlkZW50aWZpZXIgLSBzZXJ2aWNlIGluc3RhbmNlIGlkZW50aWZpZXIgaW4gY2FzZSB0aGUgc2VydmljZSBzdXBwb3J0cyBtdWx0aXBsZSBpbnN0YW5jZXNcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gX3JlbW92ZVNlcnZpY2VJbnN0YW5jZShhcHAsIG5hbWUsIGluc3RhbmNlSWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xuICAgIF9nZXRQcm92aWRlcihhcHAsIG5hbWUpLmNsZWFySW5zdGFuY2UoaW5zdGFuY2VJZGVudGlmaWVyKTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBvYmogLSBhbiBvYmplY3Qgb2YgdHlwZSBGaXJlYmFzZUFwcCBvciBGaXJlYmFzZU9wdGlvbnMuXG4gKlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZSBvYmplY3QgaXMgb2YgdHlwZSBGaXJlYmFzZUFwcC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gX2lzRmlyZWJhc2VBcHAob2JqKSB7XG4gICAgcmV0dXJuIG9iai5vcHRpb25zICE9PSB1bmRlZmluZWQ7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gb2JqIC0gYW4gb2JqZWN0IG9mIHR5cGUgRmlyZWJhc2VBcHAuXG4gKlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgb2JqZWN0IGlzIG9mIHR5cGUgRmlyZWJhc2VTZXJ2ZXJBcHBJbXBsLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBfaXNGaXJlYmFzZVNlcnZlckFwcChvYmopIHtcbiAgICByZXR1cm4gb2JqLnNldHRpbmdzICE9PSB1bmRlZmluZWQ7XG59XG4vKipcbiAqIFRlc3Qgb25seVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBfY2xlYXJDb21wb25lbnRzKCkge1xuICAgIF9jb21wb25lbnRzLmNsZWFyKCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBFUlJPUlMgPSB7XG4gICAgW1wibm8tYXBwXCIgLyogQXBwRXJyb3IuTk9fQVBQICovXTogXCJObyBGaXJlYmFzZSBBcHAgJ3skYXBwTmFtZX0nIGhhcyBiZWVuIGNyZWF0ZWQgLSBcIiArXG4gICAgICAgICdjYWxsIGluaXRpYWxpemVBcHAoKSBmaXJzdCcsXG4gICAgW1wiYmFkLWFwcC1uYW1lXCIgLyogQXBwRXJyb3IuQkFEX0FQUF9OQU1FICovXTogXCJJbGxlZ2FsIEFwcCBuYW1lOiAneyRhcHBOYW1lfSdcIixcbiAgICBbXCJkdXBsaWNhdGUtYXBwXCIgLyogQXBwRXJyb3IuRFVQTElDQVRFX0FQUCAqL106IFwiRmlyZWJhc2UgQXBwIG5hbWVkICd7JGFwcE5hbWV9JyBhbHJlYWR5IGV4aXN0cyB3aXRoIGRpZmZlcmVudCBvcHRpb25zIG9yIGNvbmZpZ1wiLFxuICAgIFtcImFwcC1kZWxldGVkXCIgLyogQXBwRXJyb3IuQVBQX0RFTEVURUQgKi9dOiBcIkZpcmViYXNlIEFwcCBuYW1lZCAneyRhcHBOYW1lfScgYWxyZWFkeSBkZWxldGVkXCIsXG4gICAgW1wic2VydmVyLWFwcC1kZWxldGVkXCIgLyogQXBwRXJyb3IuU0VSVkVSX0FQUF9ERUxFVEVEICovXTogJ0ZpcmViYXNlIFNlcnZlciBBcHAgaGFzIGJlZW4gZGVsZXRlZCcsXG4gICAgW1wibm8tb3B0aW9uc1wiIC8qIEFwcEVycm9yLk5PX09QVElPTlMgKi9dOiAnTmVlZCB0byBwcm92aWRlIG9wdGlvbnMsIHdoZW4gbm90IGJlaW5nIGRlcGxveWVkIHRvIGhvc3RpbmcgdmlhIHNvdXJjZS4nLFxuICAgIFtcImludmFsaWQtYXBwLWFyZ3VtZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9BUFBfQVJHVU1FTlQgKi9dOiAnZmlyZWJhc2UueyRhcHBOYW1lfSgpIHRha2VzIGVpdGhlciBubyBhcmd1bWVudCBvciBhICcgK1xuICAgICAgICAnRmlyZWJhc2UgQXBwIGluc3RhbmNlLicsXG4gICAgW1wiaW52YWxpZC1sb2ctYXJndW1lbnRcIiAvKiBBcHBFcnJvci5JTlZBTElEX0xPR19BUkdVTUVOVCAqL106ICdGaXJzdCBhcmd1bWVudCB0byBgb25Mb2dgIG11c3QgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLicsXG4gICAgW1wiaWRiLW9wZW5cIiAvKiBBcHBFcnJvci5JREJfT1BFTiAqL106ICdFcnJvciB0aHJvd24gd2hlbiBvcGVuaW5nIEluZGV4ZWREQi4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXG4gICAgW1wiaWRiLWdldFwiIC8qIEFwcEVycm9yLklEQl9HRVQgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gcmVhZGluZyBmcm9tIEluZGV4ZWREQi4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXG4gICAgW1wiaWRiLXNldFwiIC8qIEFwcEVycm9yLklEQl9XUklURSAqL106ICdFcnJvciB0aHJvd24gd2hlbiB3cml0aW5nIHRvIEluZGV4ZWREQi4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXG4gICAgW1wiaWRiLWRlbGV0ZVwiIC8qIEFwcEVycm9yLklEQl9ERUxFVEUgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gZGVsZXRpbmcgZnJvbSBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxuICAgIFtcImZpbmFsaXphdGlvbi1yZWdpc3RyeS1ub3Qtc3VwcG9ydGVkXCIgLyogQXBwRXJyb3IuRklOQUxJWkFUSU9OX1JFR0lTVFJZX05PVF9TVVBQT1JURUQgKi9dOiAnRmlyZWJhc2VTZXJ2ZXJBcHAgZGVsZXRlT25EZXJlZiBmaWVsZCBkZWZpbmVkIGJ1dCB0aGUgSlMgcnVudGltZSBkb2VzIG5vdCBzdXBwb3J0IEZpbmFsaXphdGlvblJlZ2lzdHJ5LicsXG4gICAgW1wiaW52YWxpZC1zZXJ2ZXItYXBwLWVudmlyb25tZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9TRVJWRVJfQVBQX0VOVklST05NRU5UICovXTogJ0ZpcmViYXNlU2VydmVyQXBwIGlzIG5vdCBmb3IgdXNlIGluIGJyb3dzZXIgZW52aXJvbm1lbnRzLidcbn07XG5jb25zdCBFUlJPUl9GQUNUT1JZID0gbmV3IEVycm9yRmFjdG9yeSgnYXBwJywgJ0ZpcmViYXNlJywgRVJST1JTKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIEZpcmViYXNlQXBwSW1wbCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgY29uZmlnLCBjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5faXNEZWxldGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IGNvbmZpZy5uYW1lO1xuICAgICAgICB0aGlzLl9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPVxuICAgICAgICAgICAgY29uZmlnLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZDtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDb21wb25lbnQobmV3IENvbXBvbmVudCgnYXBwJywgKCkgPT4gdGhpcywgXCJQVUJMSUNcIiAvKiBDb21wb25lbnRUeXBlLlBVQkxJQyAqLykpO1xuICAgIH1cbiAgICBnZXQgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkKCkge1xuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ7XG4gICAgfVxuICAgIHNldCBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQodmFsKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcbiAgICAgICAgdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID0gdmFsO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gICAgfVxuICAgIGdldCBjb25maWcoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZztcbiAgICB9XG4gICAgZ2V0IGNvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgICB9XG4gICAgZ2V0IGlzRGVsZXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRGVsZXRlZDtcbiAgICB9XG4gICAgc2V0IGlzRGVsZXRlZCh2YWwpIHtcbiAgICAgICAgdGhpcy5faXNEZWxldGVkID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gRXJyb3IgaWYgdGhlIEFwcCBoYXMgYWxyZWFkeSBiZWVuIGRlbGV0ZWQgLVxuICAgICAqIHVzZSBiZWZvcmUgcGVyZm9ybWluZyBBUEkgYWN0aW9ucyBvbiB0aGUgQXBwLlxuICAgICAqL1xuICAgIGNoZWNrRGVzdHJveWVkKCkge1xuICAgICAgICBpZiAodGhpcy5pc0RlbGV0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiYXBwLWRlbGV0ZWRcIiAvKiBBcHBFcnJvci5BUFBfREVMRVRFRCAqLywgeyBhcHBOYW1lOiB0aGlzLl9uYW1lIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgRmlyZWJhc2VTZXJ2ZXJBcHBJbXBsIGV4dGVuZHMgRmlyZWJhc2VBcHBJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBzZXJ2ZXJDb25maWcsIG5hbWUsIGNvbnRhaW5lcikge1xuICAgICAgICAvLyBCdWlsZCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgZm9yIHRoZSBGaXJlYmFzZUFwcEltcGwgYmFzZSBjbGFzcy5cbiAgICAgICAgY29uc3QgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID0gc2VydmVyQ29uZmlnLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHNlcnZlckNvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWRcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgRmlyZWJhc2VBcHBTZXR0aW5ncyBvYmplY3QgZm9yIHRoZSBGaXJlYmFzZUFwcEltcCBjb25zdHJ1Y3Rvci5cbiAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy5hcGlLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBwYXJlbnQgRmlyZWJhc2VBcHBJbXAgb2JqZWN0LlxuICAgICAgICAgICAgc3VwZXIob3B0aW9ucywgY29uZmlnLCBjb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYXBwSW1wbCA9IG9wdGlvbnM7XG4gICAgICAgICAgICBzdXBlcihhcHBJbXBsLm9wdGlvbnMsIGNvbmZpZywgY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3cgY29uc3RydWN0IHRoZSBkYXRhIGZvciB0aGUgRmlyZWJhc2VTZXJ2ZXJBcHBJbXBsLlxuICAgICAgICB0aGlzLl9zZXJ2ZXJDb25maWcgPSBPYmplY3QuYXNzaWduKHsgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkIH0sIHNlcnZlckNvbmZpZyk7XG4gICAgICAgIHRoaXMuX2ZpbmFsaXphdGlvblJlZ2lzdHJ5ID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmFsaXphdGlvblJlZ2lzdHJ5ID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9tYXRpY0NsZWFudXAoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlZkNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5pbmNSZWZDb3VudCh0aGlzLl9zZXJ2ZXJDb25maWcucmVsZWFzZU9uRGVyZWYpO1xuICAgICAgICAvLyBEbyBub3QgcmV0YWluIGEgaGFyZCByZWZlcmVuY2UgdG8gdGhlIGRyZWYgb2JqZWN0LCBvdGhlcndpc2UgdGhlIEZpbmFsaXphdGlvblJlZ2lzdHJ5XG4gICAgICAgIC8vIHdpbGwgbmV2ZXIgdHJpZ2dlci5cbiAgICAgICAgdGhpcy5fc2VydmVyQ29uZmlnLnJlbGVhc2VPbkRlcmVmID0gdW5kZWZpbmVkO1xuICAgICAgICBzZXJ2ZXJDb25maWcucmVsZWFzZU9uRGVyZWYgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lJHEsIHZlcnNpb24kMSwgJ3NlcnZlcmFwcCcpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCByZWZDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZkNvdW50O1xuICAgIH1cbiAgICAvLyBJbmNyZW1lbnQgdGhlIHJlZmVyZW5jZSBjb3VudCBvZiB0aGlzIHNlcnZlciBhcHAuIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCwgcmVnaXN0ZXIgaXRcbiAgICAvLyB3aXRoIHRoZSBmaW5hbGl6YXRpb24gcmVnaXN0cnkuXG4gICAgaW5jUmVmQ291bnQob2JqKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGVsZXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlZkNvdW50Kys7XG4gICAgICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9maW5hbGl6YXRpb25SZWdpc3RyeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fZmluYWxpemF0aW9uUmVnaXN0cnkucmVnaXN0ZXIob2JqLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBEZWNyZW1lbnQgdGhlIHJlZmVyZW5jZSBjb3VudC5cbiAgICBkZWNSZWZDb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEZWxldGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLS10aGlzLl9yZWZDb3VudDtcbiAgICB9XG4gICAgLy8gSW52b2tlZCBieSB0aGUgRmluYWxpemF0aW9uUmVnaXN0cnkgY2FsbGJhY2sgdG8gbm90ZSB0aGF0IHRoaXMgYXBwIHNob3VsZCBnbyB0aHJvdWdoIGl0c1xuICAgIC8vIHJlZmVyZW5jZSBjb3VudHMgYW5kIGRlbGV0ZSBpdHNlbGYgaWYgbm8gcmVmZXJlbmNlIGNvdW50IHJlbWFpbi4gVGhlIGNvb3JkaW5hdGluZyBsb2dpYyB0aGF0XG4gICAgLy8gaGFuZGxlcyB0aGlzIGlzIGluIGRlbGV0ZUFwcCguLi4pLlxuICAgIGF1dG9tYXRpY0NsZWFudXAoKSB7XG4gICAgICAgIHZvaWQgZGVsZXRlQXBwKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgc2V0dGluZ3MoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcnZlckNvbmZpZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHRocm93IGFuIEVycm9yIGlmIHRoZSBBcHAgaGFzIGFscmVhZHkgYmVlbiBkZWxldGVkIC1cbiAgICAgKiB1c2UgYmVmb3JlIHBlcmZvcm1pbmcgQVBJIGFjdGlvbnMgb24gdGhlIEFwcC5cbiAgICAgKi9cbiAgICBjaGVja0Rlc3Ryb3llZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEZWxldGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcInNlcnZlci1hcHAtZGVsZXRlZFwiIC8qIEFwcEVycm9yLlNFUlZFUl9BUFBfREVMRVRFRCAqLyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRoZSBjdXJyZW50IFNESyB2ZXJzaW9uLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgU0RLX1ZFUlNJT04gPSB2ZXJzaW9uO1xuZnVuY3Rpb24gaW5pdGlhbGl6ZUFwcChfb3B0aW9ucywgcmF3Q29uZmlnID0ge30pIHtcbiAgICBsZXQgb3B0aW9ucyA9IF9vcHRpb25zO1xuICAgIGlmICh0eXBlb2YgcmF3Q29uZmlnICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCBuYW1lID0gcmF3Q29uZmlnO1xuICAgICAgICByYXdDb25maWcgPSB7IG5hbWUgfTtcbiAgICB9XG4gICAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbih7IG5hbWU6IERFRkFVTFRfRU5UUllfTkFNRSwgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkOiBmYWxzZSB9LCByYXdDb25maWcpO1xuICAgIGNvbnN0IG5hbWUgPSBjb25maWcubmFtZTtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8ICFuYW1lKSB7XG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiYmFkLWFwcC1uYW1lXCIgLyogQXBwRXJyb3IuQkFEX0FQUF9OQU1FICovLCB7XG4gICAgICAgICAgICBhcHBOYW1lOiBTdHJpbmcobmFtZSlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSBnZXREZWZhdWx0QXBwQ29uZmlnKCkpO1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcIm5vLW9wdGlvbnNcIiAvKiBBcHBFcnJvci5OT19PUFRJT05TICovKTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdBcHAgPSBfYXBwcy5nZXQobmFtZSk7XG4gICAgaWYgKGV4aXN0aW5nQXBwKSB7XG4gICAgICAgIC8vIHJldHVybiB0aGUgZXhpc3RpbmcgYXBwIGlmIG9wdGlvbnMgYW5kIGNvbmZpZyBkZWVwIGVxdWFsIHRoZSBvbmVzIGluIHRoZSBleGlzdGluZyBhcHAuXG4gICAgICAgIGlmIChkZWVwRXF1YWwob3B0aW9ucywgZXhpc3RpbmdBcHAub3B0aW9ucykgJiZcbiAgICAgICAgICAgIGRlZXBFcXVhbChjb25maWcsIGV4aXN0aW5nQXBwLmNvbmZpZykpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0FwcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiZHVwbGljYXRlLWFwcFwiIC8qIEFwcEVycm9yLkRVUExJQ0FURV9BUFAgKi8sIHsgYXBwTmFtZTogbmFtZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjb250YWluZXIgPSBuZXcgQ29tcG9uZW50Q29udGFpbmVyKG5hbWUpO1xuICAgIGZvciAoY29uc3QgY29tcG9uZW50IG9mIF9jb21wb25lbnRzLnZhbHVlcygpKSB7XG4gICAgICAgIGNvbnRhaW5lci5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcbiAgICB9XG4gICAgY29uc3QgbmV3QXBwID0gbmV3IEZpcmViYXNlQXBwSW1wbChvcHRpb25zLCBjb25maWcsIGNvbnRhaW5lcik7XG4gICAgX2FwcHMuc2V0KG5hbWUsIG5ld0FwcCk7XG4gICAgcmV0dXJuIG5ld0FwcDtcbn1cbmZ1bmN0aW9uIGluaXRpYWxpemVTZXJ2ZXJBcHAoX29wdGlvbnMsIF9zZXJ2ZXJBcHBDb25maWcpIHtcbiAgICBpZiAoaXNCcm93c2VyKCkgJiYgIWlzV2ViV29ya2VyKCkpIHtcbiAgICAgICAgLy8gRmlyZWJhc2VTZXJ2ZXJBcHAgaXNuJ3QgZGVzaWduZWQgdG8gYmUgcnVuIGluIGJyb3dzZXJzLlxuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImludmFsaWQtc2VydmVyLWFwcC1lbnZpcm9ubWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfU0VSVkVSX0FQUF9FTlZJUk9OTUVOVCAqLyk7XG4gICAgfVxuICAgIGlmIChfc2VydmVyQXBwQ29uZmlnLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIF9zZXJ2ZXJBcHBDb25maWcuYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGxldCBhcHBPcHRpb25zO1xuICAgIGlmIChfaXNGaXJlYmFzZUFwcChfb3B0aW9ucykpIHtcbiAgICAgICAgYXBwT3B0aW9ucyA9IF9vcHRpb25zLm9wdGlvbnM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhcHBPcHRpb25zID0gX29wdGlvbnM7XG4gICAgfVxuICAgIC8vIEJ1aWxkIGFuIGFwcCBuYW1lIGJhc2VkIG9uIGEgaGFzaCBvZiB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgIGNvbnN0IG5hbWVPYmogPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF9zZXJ2ZXJBcHBDb25maWcpLCBhcHBPcHRpb25zKTtcbiAgICAvLyBIb3dldmVyLCBEbyBub3QgbWFuZ2xlIHRoZSBuYW1lIGJhc2VkIG9uIHJlbGVhc2VPbkRlcmVmLCBzaW5jZSBpdCB3aWxsIHZhcnkgYmV0d2VlbiB0aGVcbiAgICAvLyBjb25zdHJ1Y3Rpb24gb2YgRmlyZWJhc2VTZXJ2ZXJBcHAgaW5zdGFuY2VzLiBGb3IgZXhhbXBsZSwgaWYgdGhlIG9iamVjdCBpcyB0aGUgcmVxdWVzdCBoZWFkZXJzLlxuICAgIGlmIChuYW1lT2JqLnJlbGVhc2VPbkRlcmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsZXRlIG5hbWVPYmoucmVsZWFzZU9uRGVyZWY7XG4gICAgfVxuICAgIGNvbnN0IGhhc2hDb2RlID0gKHMpID0+IHtcbiAgICAgICAgcmV0dXJuIFsuLi5zXS5yZWR1Y2UoKGhhc2gsIGMpID0+IChNYXRoLmltdWwoMzEsIGhhc2gpICsgYy5jaGFyQ29kZUF0KDApKSB8IDAsIDApO1xuICAgIH07XG4gICAgaWYgKF9zZXJ2ZXJBcHBDb25maWcucmVsZWFzZU9uRGVyZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJmaW5hbGl6YXRpb24tcmVnaXN0cnktbm90LXN1cHBvcnRlZFwiIC8qIEFwcEVycm9yLkZJTkFMSVpBVElPTl9SRUdJU1RSWV9OT1RfU1VQUE9SVEVEICovLCB7fSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmFtZVN0cmluZyA9ICcnICsgaGFzaENvZGUoSlNPTi5zdHJpbmdpZnkobmFtZU9iaikpO1xuICAgIGNvbnN0IGV4aXN0aW5nQXBwID0gX3NlcnZlckFwcHMuZ2V0KG5hbWVTdHJpbmcpO1xuICAgIGlmIChleGlzdGluZ0FwcCkge1xuICAgICAgICBleGlzdGluZ0FwcC5pbmNSZWZDb3VudChfc2VydmVyQXBwQ29uZmlnLnJlbGVhc2VPbkRlcmVmKTtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nQXBwO1xuICAgIH1cbiAgICBjb25zdCBjb250YWluZXIgPSBuZXcgQ29tcG9uZW50Q29udGFpbmVyKG5hbWVTdHJpbmcpO1xuICAgIGZvciAoY29uc3QgY29tcG9uZW50IG9mIF9jb21wb25lbnRzLnZhbHVlcygpKSB7XG4gICAgICAgIGNvbnRhaW5lci5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcbiAgICB9XG4gICAgY29uc3QgbmV3QXBwID0gbmV3IEZpcmViYXNlU2VydmVyQXBwSW1wbChhcHBPcHRpb25zLCBfc2VydmVyQXBwQ29uZmlnLCBuYW1lU3RyaW5nLCBjb250YWluZXIpO1xuICAgIF9zZXJ2ZXJBcHBzLnNldChuYW1lU3RyaW5nLCBuZXdBcHApO1xuICAgIHJldHVybiBuZXdBcHA7XG59XG4vKipcbiAqIFJldHJpZXZlcyBhIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfSBpbnN0YW5jZS5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cywgdGhlIGRlZmF1bHQgYXBwIGlzIHJldHVybmVkLiBXaGVuIGFuIGFwcCBuYW1lXG4gKiBpcyBwcm92aWRlZCwgdGhlIGFwcCBjb3JyZXNwb25kaW5nIHRvIHRoYXQgbmFtZSBpcyByZXR1cm5lZC5cbiAqXG4gKiBBbiBleGNlcHRpb24gaXMgdGhyb3duIGlmIHRoZSBhcHAgYmVpbmcgcmV0cmlldmVkIGhhcyBub3QgeWV0IGJlZW5cbiAqIGluaXRpYWxpemVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBSZXR1cm4gdGhlIGRlZmF1bHQgYXBwXG4gKiBjb25zdCBhcHAgPSBnZXRBcHAoKTtcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBSZXR1cm4gYSBuYW1lZCBhcHBcbiAqIGNvbnN0IG90aGVyQXBwID0gZ2V0QXBwKFwib3RoZXJBcHBcIik7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbmFtZSAtIE9wdGlvbmFsIG5hbWUgb2YgdGhlIGFwcCB0byByZXR1cm4uIElmIG5vIG5hbWUgaXNcbiAqICAgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGlzIGBcIltERUZBVUxUXVwiYC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgYXBwIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3ZpZGVkIGFwcCBuYW1lLlxuICogICBJZiBubyBhcHAgbmFtZSBpcyBwcm92aWRlZCwgdGhlIGRlZmF1bHQgYXBwIGlzIHJldHVybmVkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZ2V0QXBwKG5hbWUgPSBERUZBVUxUX0VOVFJZX05BTUUpIHtcbiAgICBjb25zdCBhcHAgPSBfYXBwcy5nZXQobmFtZSk7XG4gICAgaWYgKCFhcHAgJiYgbmFtZSA9PT0gREVGQVVMVF9FTlRSWV9OQU1FICYmIGdldERlZmF1bHRBcHBDb25maWcoKSkge1xuICAgICAgICByZXR1cm4gaW5pdGlhbGl6ZUFwcCgpO1xuICAgIH1cbiAgICBpZiAoIWFwcCkge1xuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcIm5vLWFwcFwiIC8qIEFwcEVycm9yLk5PX0FQUCAqLywgeyBhcHBOYW1lOiBuYW1lIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXBwO1xufVxuLyoqXG4gKiBBIChyZWFkLW9ubHkpIGFycmF5IG9mIGFsbCBpbml0aWFsaXplZCBhcHBzLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBnZXRBcHBzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKF9hcHBzLnZhbHVlcygpKTtcbn1cbi8qKlxuICogUmVuZGVycyB0aGlzIGFwcCB1bnVzYWJsZSBhbmQgZnJlZXMgdGhlIHJlc291cmNlcyBvZiBhbGwgYXNzb2NpYXRlZFxuICogc2VydmljZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGRlbGV0ZUFwcChhcHApXG4gKiAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICogICAgIGNvbnNvbGUubG9nKFwiQXBwIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICogICB9KVxuICogICAuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAqICAgICBjb25zb2xlLmxvZyhcIkVycm9yIGRlbGV0aW5nIGFwcDpcIiwgZXJyb3IpO1xuICogICB9KTtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVsZXRlQXBwKGFwcCkge1xuICAgIGxldCBjbGVhbnVwUHJvdmlkZXJzID0gZmFsc2U7XG4gICAgY29uc3QgbmFtZSA9IGFwcC5uYW1lO1xuICAgIGlmIChfYXBwcy5oYXMobmFtZSkpIHtcbiAgICAgICAgY2xlYW51cFByb3ZpZGVycyA9IHRydWU7XG4gICAgICAgIF9hcHBzLmRlbGV0ZShuYW1lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoX3NlcnZlckFwcHMuaGFzKG5hbWUpKSB7XG4gICAgICAgIGNvbnN0IGZpcmViYXNlU2VydmVyQXBwID0gYXBwO1xuICAgICAgICBpZiAoZmlyZWJhc2VTZXJ2ZXJBcHAuZGVjUmVmQ291bnQoKSA8PSAwKSB7XG4gICAgICAgICAgICBfc2VydmVyQXBwcy5kZWxldGUobmFtZSk7XG4gICAgICAgICAgICBjbGVhbnVwUHJvdmlkZXJzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2xlYW51cFByb3ZpZGVycykge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChhcHAuY29udGFpbmVyXG4gICAgICAgICAgICAuZ2V0UHJvdmlkZXJzKClcbiAgICAgICAgICAgIC5tYXAocHJvdmlkZXIgPT4gcHJvdmlkZXIuZGVsZXRlKCkpKTtcbiAgICAgICAgYXBwLmlzRGVsZXRlZCA9IHRydWU7XG4gICAgfVxufVxuLyoqXG4gKiBSZWdpc3RlcnMgYSBsaWJyYXJ5J3MgbmFtZSBhbmQgdmVyc2lvbiBmb3IgcGxhdGZvcm0gbG9nZ2luZyBwdXJwb3Nlcy5cbiAqIEBwYXJhbSBsaWJyYXJ5IC0gTmFtZSBvZiAxcCBvciAzcCBsaWJyYXJ5IChlLmcuIGZpcmVzdG9yZSwgYW5ndWxhcmZpcmUpXG4gKiBAcGFyYW0gdmVyc2lvbiAtIEN1cnJlbnQgdmVyc2lvbiBvZiB0aGF0IGxpYnJhcnkuXG4gKiBAcGFyYW0gdmFyaWFudCAtIEJ1bmRsZSB2YXJpYW50LCBlLmcuLCBub2RlLCBybiwgZXRjLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJWZXJzaW9uKGxpYnJhcnlLZXlPck5hbWUsIHZlcnNpb24sIHZhcmlhbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gVE9ETzogV2UgY2FuIHVzZSB0aGlzIGNoZWNrIHRvIHdoaXRlbGlzdCBzdHJpbmdzIHdoZW4vaWYgd2Ugc2V0IHVwXG4gICAgLy8gYSBnb29kIHdoaXRlbGlzdCBzeXN0ZW0uXG4gICAgbGV0IGxpYnJhcnkgPSAoX2EgPSBQTEFURk9STV9MT0dfU1RSSU5HW2xpYnJhcnlLZXlPck5hbWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBsaWJyYXJ5S2V5T3JOYW1lO1xuICAgIGlmICh2YXJpYW50KSB7XG4gICAgICAgIGxpYnJhcnkgKz0gYC0ke3ZhcmlhbnR9YDtcbiAgICB9XG4gICAgY29uc3QgbGlicmFyeU1pc21hdGNoID0gbGlicmFyeS5tYXRjaCgvXFxzfFxcLy8pO1xuICAgIGNvbnN0IHZlcnNpb25NaXNtYXRjaCA9IHZlcnNpb24ubWF0Y2goL1xcc3xcXC8vKTtcbiAgICBpZiAobGlicmFyeU1pc21hdGNoIHx8IHZlcnNpb25NaXNtYXRjaCkge1xuICAgICAgICBjb25zdCB3YXJuaW5nID0gW1xuICAgICAgICAgICAgYFVuYWJsZSB0byByZWdpc3RlciBsaWJyYXJ5IFwiJHtsaWJyYXJ5fVwiIHdpdGggdmVyc2lvbiBcIiR7dmVyc2lvbn1cIjpgXG4gICAgICAgIF07XG4gICAgICAgIGlmIChsaWJyYXJ5TWlzbWF0Y2gpIHtcbiAgICAgICAgICAgIHdhcm5pbmcucHVzaChgbGlicmFyeSBuYW1lIFwiJHtsaWJyYXJ5fVwiIGNvbnRhaW5zIGlsbGVnYWwgY2hhcmFjdGVycyAod2hpdGVzcGFjZSBvciBcIi9cIilgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlicmFyeU1pc21hdGNoICYmIHZlcnNpb25NaXNtYXRjaCkge1xuICAgICAgICAgICAgd2FybmluZy5wdXNoKCdhbmQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmVyc2lvbk1pc21hdGNoKSB7XG4gICAgICAgICAgICB3YXJuaW5nLnB1c2goYHZlcnNpb24gbmFtZSBcIiR7dmVyc2lvbn1cIiBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcnMgKHdoaXRlc3BhY2Ugb3IgXCIvXCIpYCk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLndhcm4od2FybmluZy5qb2luKCcgJykpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KGAke2xpYnJhcnl9LXZlcnNpb25gLCAoKSA9PiAoeyBsaWJyYXJ5LCB2ZXJzaW9uIH0pLCBcIlZFUlNJT05cIiAvKiBDb21wb25lbnRUeXBlLlZFUlNJT04gKi8pKTtcbn1cbi8qKlxuICogU2V0cyBsb2cgaGFuZGxlciBmb3IgYWxsIEZpcmViYXNlIFNES3MuXG4gKiBAcGFyYW0gbG9nQ2FsbGJhY2sgLSBBbiBvcHRpb25hbCBjdXN0b20gbG9nIGhhbmRsZXIgdGhhdCBleGVjdXRlcyB1c2VyIGNvZGUgd2hlbmV2ZXJcbiAqIHRoZSBGaXJlYmFzZSBTREsgbWFrZXMgYSBsb2dnaW5nIGNhbGwuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBvbkxvZyhsb2dDYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGlmIChsb2dDYWxsYmFjayAhPT0gbnVsbCAmJiB0eXBlb2YgbG9nQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpbnZhbGlkLWxvZy1hcmd1bWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfTE9HX0FSR1VNRU5UICovKTtcbiAgICB9XG4gICAgc2V0VXNlckxvZ0hhbmRsZXIobG9nQ2FsbGJhY2ssIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBTZXRzIGxvZyBsZXZlbCBmb3IgYWxsIEZpcmViYXNlIFNES3MuXG4gKlxuICogQWxsIG9mIHRoZSBsb2cgdHlwZXMgYWJvdmUgdGhlIGN1cnJlbnQgbG9nIGxldmVsIGFyZSBjYXB0dXJlZCAoaS5lLiBpZlxuICogeW91IHNldCB0aGUgbG9nIGxldmVsIHRvIGBpbmZvYCwgZXJyb3JzIGFyZSBsb2dnZWQsIGJ1dCBgZGVidWdgIGFuZFxuICogYHZlcmJvc2VgIGxvZ3MgYXJlIG5vdCkuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBzZXRMb2dMZXZlbChsb2dMZXZlbCkge1xuICAgIHNldExvZ0xldmVsJDEobG9nTGV2ZWwpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgREJfTkFNRSA9ICdmaXJlYmFzZS1oZWFydGJlYXQtZGF0YWJhc2UnO1xuY29uc3QgREJfVkVSU0lPTiA9IDE7XG5jb25zdCBTVE9SRV9OQU1FID0gJ2ZpcmViYXNlLWhlYXJ0YmVhdC1zdG9yZSc7XG5sZXQgZGJQcm9taXNlID0gbnVsbDtcbmZ1bmN0aW9uIGdldERiUHJvbWlzZSgpIHtcbiAgICBpZiAoIWRiUHJvbWlzZSkge1xuICAgICAgICBkYlByb21pc2UgPSBvcGVuREIoREJfTkFNRSwgREJfVkVSU0lPTiwge1xuICAgICAgICAgICAgdXBncmFkZTogKGRiLCBvbGRWZXJzaW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdXNlICdicmVhaycgaW4gdGhpcyBzd2l0Y2ggc3RhdGVtZW50LCB0aGUgZmFsbC10aHJvdWdoXG4gICAgICAgICAgICAgICAgLy8gYmVoYXZpb3IgaXMgd2hhdCB3ZSB3YW50LCBiZWNhdXNlIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSB2ZXJzaW9ucyBiZXR3ZWVuXG4gICAgICAgICAgICAgICAgLy8gdGhlIG9sZCB2ZXJzaW9uIGFuZCB0aGUgY3VycmVudCB2ZXJzaW9uLCB3ZSB3YW50IEFMTCB0aGUgbWlncmF0aW9uc1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgY29ycmVzcG9uZCB0byB0aG9zZSB2ZXJzaW9ucyB0byBydW4sIG5vdCBvbmx5IHRoZSBsYXN0IG9uZS5cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVmYXVsdC1jYXNlXG4gICAgICAgICAgICAgICAgc3dpdGNoIChvbGRWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoU1RPUkVfTkFNRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaS9pT1MgYnJvd3NlcnMgdGhyb3cgb2NjYXNpb25hbCBleGNlcHRpb25zIG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGIuY3JlYXRlT2JqZWN0U3RvcmUoKSB0aGF0IG1heSBiZSBhIGJ1Zy4gQXZvaWQgYmxvY2tpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcmVzdCBvZiB0aGUgYXBwIGZ1bmN0aW9uYWxpdHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImlkYi1vcGVuXCIgLyogQXBwRXJyb3IuSURCX09QRU4gKi8sIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yTWVzc2FnZTogZS5tZXNzYWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkYlByb21pc2U7XG59XG5hc3luYyBmdW5jdGlvbiByZWFkSGVhcnRiZWF0c0Zyb21JbmRleGVkREIoYXBwKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGIgPSBhd2FpdCBnZXREYlByb21pc2UoKTtcbiAgICAgICAgY29uc3QgdHggPSBkYi50cmFuc2FjdGlvbihTVE9SRV9OQU1FKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdHgub2JqZWN0U3RvcmUoU1RPUkVfTkFNRSkuZ2V0KGNvbXB1dGVLZXkoYXBwKSk7XG4gICAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSB0aGUgdmFsdWUgYnV0IHR4LmRvbmUgY2FuIHRocm93LFxuICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIGF3YWl0IGl0IGhlcmUgdG8gY2F0Y2ggZXJyb3JzXG4gICAgICAgIGF3YWl0IHR4LmRvbmU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRmlyZWJhc2VFcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oZS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGlkYkdldEVycm9yID0gRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpZGItZ2V0XCIgLyogQXBwRXJyb3IuSURCX0dFVCAqLywge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3JNZXNzYWdlOiBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsb2dnZXIud2FybihpZGJHZXRFcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCKGFwcCwgaGVhcnRiZWF0T2JqZWN0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGIgPSBhd2FpdCBnZXREYlByb21pc2UoKTtcbiAgICAgICAgY29uc3QgdHggPSBkYi50cmFuc2FjdGlvbihTVE9SRV9OQU1FLCAncmVhZHdyaXRlJyk7XG4gICAgICAgIGNvbnN0IG9iamVjdFN0b3JlID0gdHgub2JqZWN0U3RvcmUoU1RPUkVfTkFNRSk7XG4gICAgICAgIGF3YWl0IG9iamVjdFN0b3JlLnB1dChoZWFydGJlYXRPYmplY3QsIGNvbXB1dGVLZXkoYXBwKSk7XG4gICAgICAgIGF3YWl0IHR4LmRvbmU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRmlyZWJhc2VFcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oZS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGlkYkdldEVycm9yID0gRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpZGItc2V0XCIgLyogQXBwRXJyb3IuSURCX1dSSVRFICovLCB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFcnJvck1lc3NhZ2U6IGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5tZXNzYWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGlkYkdldEVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZUtleShhcHApIHtcbiAgICByZXR1cm4gYCR7YXBwLm5hbWV9ISR7YXBwLm9wdGlvbnMuYXBwSWR9YDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IE1BWF9IRUFERVJfQllURVMgPSAxMDI0O1xuLy8gMzAgZGF5c1xuY29uc3QgU1RPUkVEX0hFQVJUQkVBVF9SRVRFTlRJT05fTUFYX01JTExJUyA9IDMwICogMjQgKiA2MCAqIDYwICogMTAwMDtcbmNsYXNzIEhlYXJ0YmVhdFNlcnZpY2VJbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbi1tZW1vcnkgY2FjaGUgZm9yIGhlYXJ0YmVhdHMsIHVzZWQgYnkgZ2V0SGVhcnRiZWF0c0hlYWRlcigpIHRvIGdlbmVyYXRlXG4gICAgICAgICAqIHRoZSBoZWFkZXIgc3RyaW5nLlxuICAgICAgICAgKiBTdG9yZXMgb25lIHJlY29yZCBwZXIgZGF0ZS4gVGhpcyB3aWxsIGJlIGNvbnNvbGlkYXRlZCBpbnRvIHRoZSBzdGFuZGFyZFxuICAgICAgICAgKiBmb3JtYXQgb2Ygb25lIHJlY29yZCBwZXIgdXNlciBhZ2VudCBzdHJpbmcgYmVmb3JlIGJlaW5nIHNlbnQgYXMgYSBoZWFkZXIuXG4gICAgICAgICAqIFBvcHVsYXRlZCBmcm9tIGluZGV4ZWREQiB3aGVuIHRoZSBjb250cm9sbGVyIGlzIGluc3RhbnRpYXRlZCBhbmQgc2hvdWxkXG4gICAgICAgICAqIGJlIGtlcHQgaW4gc3luYyB3aXRoIGluZGV4ZWREQi5cbiAgICAgICAgICogTGVhdmUgcHVibGljIGZvciBlYXNpZXIgdGVzdGluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9IG51bGw7XG4gICAgICAgIGNvbnN0IGFwcCA9IHRoaXMuY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcbiAgICAgICAgdGhpcy5fc3RvcmFnZSA9IG5ldyBIZWFydGJlYXRTdG9yYWdlSW1wbChhcHApO1xuICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGVQcm9taXNlID0gdGhpcy5fc3RvcmFnZS5yZWFkKCkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB0byByZXBvcnQgYSBoZWFydGJlYXQuIFRoZSBmdW5jdGlvbiB3aWxsIGdlbmVyYXRlXG4gICAgICogYSBIZWFydGJlYXRzQnlVc2VyQWdlbnQgb2JqZWN0LCB1cGRhdGUgaGVhcnRiZWF0c0NhY2hlLCBhbmQgcGVyc2lzdCBpdFxuICAgICAqIHRvIEluZGV4ZWREQi5cbiAgICAgKiBOb3RlIHRoYXQgd2Ugb25seSBzdG9yZSBvbmUgaGVhcnRiZWF0IHBlciBkYXkuIFNvIGlmIGEgaGVhcnRiZWF0IGZvciB0b2RheSBpc1xuICAgICAqIGFscmVhZHkgbG9nZ2VkLCBzdWJzZXF1ZW50IGNhbGxzIHRvIHRoaXMgZnVuY3Rpb24gaW4gdGhlIHNhbWUgZGF5IHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKi9cbiAgICBhc3luYyB0cmlnZ2VySGVhcnRiZWF0KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGxhdGZvcm1Mb2dnZXIgPSB0aGlzLmNvbnRhaW5lclxuICAgICAgICAgICAgICAgIC5nZXRQcm92aWRlcigncGxhdGZvcm0tbG9nZ2VyJylcbiAgICAgICAgICAgICAgICAuZ2V0SW1tZWRpYXRlKCk7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBcIkZpcmViYXNlIHVzZXIgYWdlbnRcIiBzdHJpbmcgZnJvbSB0aGUgcGxhdGZvcm0gbG9nZ2VyXG4gICAgICAgICAgICAvLyBzZXJ2aWNlLCBub3QgdGhlIGJyb3dzZXIgdXNlciBhZ2VudC5cbiAgICAgICAgICAgIGNvbnN0IGFnZW50ID0gcGxhdGZvcm1Mb2dnZXIuZ2V0UGxhdGZvcm1JbmZvU3RyaW5nKCk7XG4gICAgICAgICAgICBjb25zdCBkYXRlID0gZ2V0VVRDRGF0ZVN0cmluZygpO1xuICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLl9oZWFydGJlYXRzQ2FjaGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWFydGJlYXRzKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gYXdhaXQgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBmYWlsZWQgdG8gY29uc3RydWN0IGEgaGVhcnRiZWF0cyBjYWNoZSwgdGhlbiByZXR1cm4gaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgICAgaWYgKCgoX2IgPSB0aGlzLl9oZWFydGJlYXRzQ2FjaGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oZWFydGJlYXRzKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEbyBub3Qgc3RvcmUgYSBoZWFydGJlYXQgaWYgb25lIGlzIGFscmVhZHkgc3RvcmVkIGZvciB0aGlzIGRheVxuICAgICAgICAgICAgLy8gb3IgaWYgYSBoZWFkZXIgaGFzIGFscmVhZHkgYmVlbiBzZW50IHRvZGF5LlxuICAgICAgICAgICAgaWYgKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5sYXN0U2VudEhlYXJ0YmVhdERhdGUgPT09IGRhdGUgfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5zb21lKHNpbmdsZURhdGVIZWFydGJlYXQgPT4gc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlID09PSBkYXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIGVudHJ5IGZvciB0aGlzIGRhdGUuIENyZWF0ZSBvbmUuXG4gICAgICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMucHVzaCh7IGRhdGUsIGFnZW50IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIGVudHJpZXMgb2xkZXIgdGhhbiAzMCBkYXlzLlxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMgPVxuICAgICAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzLmZpbHRlcihzaW5nbGVEYXRlSGVhcnRiZWF0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGJUaW1lc3RhbXAgPSBuZXcgRGF0ZShzaW5nbGVEYXRlSGVhcnRiZWF0LmRhdGUpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vdyAtIGhiVGltZXN0YW1wIDw9IFNUT1JFRF9IRUFSVEJFQVRfUkVURU5USU9OX01BWF9NSUxMSVM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcmFnZS5vdmVyd3JpdGUodGhpcy5faGVhcnRiZWF0c0NhY2hlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB3aGljaCBjYW4gYmUgYXR0YWNoZWQgdG8gdGhlIGhlYXJ0YmVhdC1zcGVjaWZpYyBoZWFkZXIgZGlyZWN0bHkuXG4gICAgICogSXQgYWxzbyBjbGVhcnMgYWxsIGhlYXJ0YmVhdHMgZnJvbSBtZW1vcnkgYXMgd2VsbCBhcyBpbiBJbmRleGVkREIuXG4gICAgICpcbiAgICAgKiBOT1RFOiBDb25zdW1pbmcgcHJvZHVjdCBTREtzIHNob3VsZCBub3Qgc2VuZCB0aGUgaGVhZGVyIGlmIHRoaXMgbWV0aG9kXG4gICAgICogcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0SGVhcnRiZWF0c0hlYWRlcigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZVByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBpdCdzIHN0aWxsIG51bGwgb3IgdGhlIGFycmF5IGlzIGVtcHR5LCB0aGVyZSBpcyBubyBkYXRhIHRvIHNlbmQuXG4gICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYXJ0YmVhdHMpID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRlID0gZ2V0VVRDRGF0ZVN0cmluZygpO1xuICAgICAgICAgICAgLy8gRXh0cmFjdCBhcyBtYW55IGhlYXJ0YmVhdHMgZnJvbSB0aGUgY2FjaGUgYXMgd2lsbCBmaXQgdW5kZXIgdGhlIHNpemUgbGltaXQuXG4gICAgICAgICAgICBjb25zdCB7IGhlYXJ0YmVhdHNUb1NlbmQsIHVuc2VudEVudHJpZXMgfSA9IGV4dHJhY3RIZWFydGJlYXRzRm9ySGVhZGVyKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclN0cmluZyA9IGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nKEpTT04uc3RyaW5naWZ5KHsgdmVyc2lvbjogMiwgaGVhcnRiZWF0czogaGVhcnRiZWF0c1RvU2VuZCB9KSk7XG4gICAgICAgICAgICAvLyBTdG9yZSBsYXN0IHNlbnQgZGF0ZSB0byBwcmV2ZW50IGFub3RoZXIgYmVpbmcgbG9nZ2VkL3NlbnQgZm9yIHRoZSBzYW1lIGRheS5cbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5sYXN0U2VudEhlYXJ0YmVhdERhdGUgPSBkYXRlO1xuICAgICAgICAgICAgaWYgKHVuc2VudEVudHJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFN0b3JlIGFueSB1bnNlbnQgZW50cmllcyBpZiB0aGV5IGV4aXN0LlxuICAgICAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzID0gdW5zZW50RW50cmllcztcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNlZW1zIG1vcmUgbGlrZWx5IHRoYW4gZW1wdHlpbmcgdGhlIGFycmF5IChiZWxvdykgdG8gbGVhZCB0byBzb21lIG9kZCBzdGF0ZVxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBjYWNoZSBpc24ndCBlbXB0eSBhbmQgdGhpcyB3aWxsIGJlIGNhbGxlZCBhZ2FpbiBvbiB0aGUgbmV4dCByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIC8vIGFuZCBpcyBwcm9iYWJseSBzYWZlc3QgaWYgd2UgYXdhaXQgaXQuXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc3RvcmFnZS5vdmVyd3JpdGUodGhpcy5faGVhcnRiZWF0c0NhY2hlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzID0gW107XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IHdhaXQgZm9yIHRoaXMsIHRvIHJlZHVjZSBsYXRlbmN5LlxuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5fc3RvcmFnZS5vdmVyd3JpdGUodGhpcy5faGVhcnRiZWF0c0NhY2hlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoZWFkZXJTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGUpO1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VVRDRGF0ZVN0cmluZygpIHtcbiAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gICAgLy8gUmV0dXJucyBkYXRlIGZvcm1hdCAnWVlZWS1NTS1ERCdcbiAgICByZXR1cm4gdG9kYXkudG9JU09TdHJpbmcoKS5zdWJzdHJpbmcoMCwgMTApO1xufVxuZnVuY3Rpb24gZXh0cmFjdEhlYXJ0YmVhdHNGb3JIZWFkZXIoaGVhcnRiZWF0c0NhY2hlLCBtYXhTaXplID0gTUFYX0hFQURFUl9CWVRFUykge1xuICAgIC8vIEhlYXJ0YmVhdHMgZ3JvdXBlZCBieSB1c2VyIGFnZW50IGluIHRoZSBzdGFuZGFyZCBmb3JtYXQgdG8gYmUgc2VudCBpblxuICAgIC8vIHRoZSBoZWFkZXIuXG4gICAgY29uc3QgaGVhcnRiZWF0c1RvU2VuZCA9IFtdO1xuICAgIC8vIFNpbmdsZSBkYXRlIGZvcm1hdCBoZWFydGJlYXRzIHRoYXQgYXJlIG5vdCBzZW50LlxuICAgIGxldCB1bnNlbnRFbnRyaWVzID0gaGVhcnRiZWF0c0NhY2hlLnNsaWNlKCk7XG4gICAgZm9yIChjb25zdCBzaW5nbGVEYXRlSGVhcnRiZWF0IG9mIGhlYXJ0YmVhdHNDYWNoZSkge1xuICAgICAgICAvLyBMb29rIGZvciBhbiBleGlzdGluZyBlbnRyeSB3aXRoIHRoZSBzYW1lIHVzZXIgYWdlbnQuXG4gICAgICAgIGNvbnN0IGhlYXJ0YmVhdEVudHJ5ID0gaGVhcnRiZWF0c1RvU2VuZC5maW5kKGhiID0+IGhiLmFnZW50ID09PSBzaW5nbGVEYXRlSGVhcnRiZWF0LmFnZW50KTtcbiAgICAgICAgaWYgKCFoZWFydGJlYXRFbnRyeSkge1xuICAgICAgICAgICAgLy8gSWYgbm8gZW50cnkgZm9yIHRoaXMgdXNlciBhZ2VudCBleGlzdHMsIGNyZWF0ZSBvbmUuXG4gICAgICAgICAgICBoZWFydGJlYXRzVG9TZW5kLnB1c2goe1xuICAgICAgICAgICAgICAgIGFnZW50OiBzaW5nbGVEYXRlSGVhcnRiZWF0LmFnZW50LFxuICAgICAgICAgICAgICAgIGRhdGVzOiBbc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY291bnRCeXRlcyhoZWFydGJlYXRzVG9TZW5kKSA+IG1heFNpemUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaGVhZGVyIHdvdWxkIGV4Y2VlZCBtYXggc2l6ZSwgcmVtb3ZlIHRoZSBhZGRlZCBoZWFydGJlYXRcbiAgICAgICAgICAgICAgICAvLyBlbnRyeSBhbmQgc3RvcCBhZGRpbmcgdG8gdGhlIGhlYWRlci5cbiAgICAgICAgICAgICAgICBoZWFydGJlYXRzVG9TZW5kLnBvcCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGVhcnRiZWF0RW50cnkuZGF0ZXMucHVzaChzaW5nbGVEYXRlSGVhcnRiZWF0LmRhdGUpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGhlYWRlciB3b3VsZCBleGNlZWQgbWF4IHNpemUsIHJlbW92ZSB0aGUgYWRkZWQgZGF0ZVxuICAgICAgICAgICAgLy8gYW5kIHN0b3AgYWRkaW5nIHRvIHRoZSBoZWFkZXIuXG4gICAgICAgICAgICBpZiAoY291bnRCeXRlcyhoZWFydGJlYXRzVG9TZW5kKSA+IG1heFNpemUpIHtcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRFbnRyeS5kYXRlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBQb3AgdW5zZW50IGVudHJ5IGZyb20gcXVldWUuIChTa2lwcGVkIGlmIGFkZGluZyB0aGUgZW50cnkgZXhjZWVkZWRcbiAgICAgICAgLy8gcXVvdGEgYW5kIHRoZSBsb29wIGJyZWFrcyBlYXJseS4pXG4gICAgICAgIHVuc2VudEVudHJpZXMgPSB1bnNlbnRFbnRyaWVzLnNsaWNlKDEpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBoZWFydGJlYXRzVG9TZW5kLFxuICAgICAgICB1bnNlbnRFbnRyaWVzXG4gICAgfTtcbn1cbmNsYXNzIEhlYXJ0YmVhdFN0b3JhZ2VJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihhcHApIHtcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgICAgIHRoaXMuX2NhblVzZUluZGV4ZWREQlByb21pc2UgPSB0aGlzLnJ1bkluZGV4ZWREQkVudmlyb25tZW50Q2hlY2soKTtcbiAgICB9XG4gICAgYXN5bmMgcnVuSW5kZXhlZERCRW52aXJvbm1lbnRDaGVjaygpIHtcbiAgICAgICAgaWYgKCFpc0luZGV4ZWREQkF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSgpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdHJ1ZSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4gZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYWxsIGhlYXJ0YmVhdHMuXG4gICAgICovXG4gICAgYXN5bmMgcmVhZCgpIHtcbiAgICAgICAgY29uc3QgY2FuVXNlSW5kZXhlZERCID0gYXdhaXQgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZTtcbiAgICAgICAgaWYgKCFjYW5Vc2VJbmRleGVkREIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGhlYXJ0YmVhdHM6IFtdIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpZGJIZWFydGJlYXRPYmplY3QgPSBhd2FpdCByZWFkSGVhcnRiZWF0c0Zyb21JbmRleGVkREIodGhpcy5hcHApO1xuICAgICAgICAgICAgaWYgKGlkYkhlYXJ0YmVhdE9iamVjdCA9PT0gbnVsbCB8fCBpZGJIZWFydGJlYXRPYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlkYkhlYXJ0YmVhdE9iamVjdC5oZWFydGJlYXRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkYkhlYXJ0YmVhdE9iamVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGhlYXJ0YmVhdHM6IFtdIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gb3ZlcndyaXRlIHRoZSBzdG9yYWdlIHdpdGggdGhlIHByb3ZpZGVkIGhlYXJ0YmVhdHNcbiAgICBhc3luYyBvdmVyd3JpdGUoaGVhcnRiZWF0c09iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNhblVzZUluZGV4ZWREQiA9IGF3YWl0IHRoaXMuX2NhblVzZUluZGV4ZWREQlByb21pc2U7XG4gICAgICAgIGlmICghY2FuVXNlSW5kZXhlZERCKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QgPSBhd2FpdCB0aGlzLnJlYWQoKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQih0aGlzLmFwcCwge1xuICAgICAgICAgICAgICAgIGxhc3RTZW50SGVhcnRiZWF0RGF0ZTogKF9hID0gaGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUsXG4gICAgICAgICAgICAgICAgaGVhcnRiZWF0czogaGVhcnRiZWF0c09iamVjdC5oZWFydGJlYXRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgaGVhcnRiZWF0c1xuICAgIGFzeW5jIGFkZChoZWFydGJlYXRzT2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY2FuVXNlSW5kZXhlZERCID0gYXdhaXQgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZTtcbiAgICAgICAgaWYgKCFjYW5Vc2VJbmRleGVkREIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdCA9IGF3YWl0IHRoaXMucmVhZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCKHRoaXMuYXBwLCB7XG4gICAgICAgICAgICAgICAgbGFzdFNlbnRIZWFydGJlYXREYXRlOiAoX2EgPSBoZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSxcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRzOiBbXG4gICAgICAgICAgICAgICAgICAgIC4uLmV4aXN0aW5nSGVhcnRiZWF0c09iamVjdC5oZWFydGJlYXRzLFxuICAgICAgICAgICAgICAgICAgICAuLi5oZWFydGJlYXRzT2JqZWN0LmhlYXJ0YmVhdHNcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ2FsY3VsYXRlIGJ5dGVzIG9mIGEgSGVhcnRiZWF0c0J5VXNlckFnZW50IGFycmF5IGFmdGVyIGJlaW5nIHdyYXBwZWRcbiAqIGluIGEgcGxhdGZvcm0gbG9nZ2luZyBoZWFkZXIgSlNPTiBvYmplY3QsIHN0cmluZ2lmaWVkLCBhbmQgY29udmVydGVkXG4gKiB0byBiYXNlIDY0LlxuICovXG5mdW5jdGlvbiBjb3VudEJ5dGVzKGhlYXJ0YmVhdHNDYWNoZSkge1xuICAgIC8vIGJhc2U2NCBoYXMgYSByZXN0cmljdGVkIHNldCBvZiBjaGFyYWN0ZXJzLCBhbGwgb2Ygd2hpY2ggc2hvdWxkIGJlIDEgYnl0ZS5cbiAgICByZXR1cm4gYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoXG4gICAgLy8gaGVhcnRiZWF0c0NhY2hlIHdyYXBwZXIgcHJvcGVydGllc1xuICAgIEpTT04uc3RyaW5naWZ5KHsgdmVyc2lvbjogMiwgaGVhcnRiZWF0czogaGVhcnRiZWF0c0NhY2hlIH0pKS5sZW5ndGg7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiByZWdpc3RlckNvcmVDb21wb25lbnRzKHZhcmlhbnQpIHtcbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudCgncGxhdGZvcm0tbG9nZ2VyJywgY29udGFpbmVyID0+IG5ldyBQbGF0Zm9ybUxvZ2dlclNlcnZpY2VJbXBsKGNvbnRhaW5lciksIFwiUFJJVkFURVwiIC8qIENvbXBvbmVudFR5cGUuUFJJVkFURSAqLykpO1xuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KCdoZWFydGJlYXQnLCBjb250YWluZXIgPT4gbmV3IEhlYXJ0YmVhdFNlcnZpY2VJbXBsKGNvbnRhaW5lciksIFwiUFJJVkFURVwiIC8qIENvbXBvbmVudFR5cGUuUFJJVkFURSAqLykpO1xuICAgIC8vIFJlZ2lzdGVyIGBhcHBgIHBhY2thZ2UuXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUkcSwgdmVyc2lvbiQxLCB2YXJpYW50KTtcbiAgICAvLyBCVUlMRF9UQVJHRVQgd2lsbCBiZSByZXBsYWNlZCBieSB2YWx1ZXMgbGlrZSBlc20yMDE3LCBjanMyMDE3LCBldGMgZHVyaW5nIHRoZSBjb21waWxhdGlvblxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lJHEsIHZlcnNpb24kMSwgJ2VzbTIwMTcnKTtcbiAgICAvLyBSZWdpc3RlciBwbGF0Zm9ybSBTREsgaWRlbnRpZmllciAobm8gdmVyc2lvbikuXG4gICAgcmVnaXN0ZXJWZXJzaW9uKCdmaXJlLWpzJywgJycpO1xufVxuXG4vKipcbiAqIEZpcmViYXNlIEFwcFxuICpcbiAqIEByZW1hcmtzIFRoaXMgcGFja2FnZSBjb29yZGluYXRlcyB0aGUgY29tbXVuaWNhdGlvbiBiZXR3ZWVuIHRoZSBkaWZmZXJlbnQgRmlyZWJhc2UgY29tcG9uZW50c1xuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cbnJlZ2lzdGVyQ29yZUNvbXBvbmVudHMoJycpO1xuXG5leHBvcnQgeyBTREtfVkVSU0lPTiwgREVGQVVMVF9FTlRSWV9OQU1FIGFzIF9ERUZBVUxUX0VOVFJZX05BTUUsIF9hZGRDb21wb25lbnQsIF9hZGRPck92ZXJ3cml0ZUNvbXBvbmVudCwgX2FwcHMsIF9jbGVhckNvbXBvbmVudHMsIF9jb21wb25lbnRzLCBfZ2V0UHJvdmlkZXIsIF9pc0ZpcmViYXNlQXBwLCBfaXNGaXJlYmFzZVNlcnZlckFwcCwgX3JlZ2lzdGVyQ29tcG9uZW50LCBfcmVtb3ZlU2VydmljZUluc3RhbmNlLCBfc2VydmVyQXBwcywgZGVsZXRlQXBwLCBnZXRBcHAsIGdldEFwcHMsIGluaXRpYWxpemVBcHAsIGluaXRpYWxpemVTZXJ2ZXJBcHAsIG9uTG9nLCByZWdpc3RlclZlcnNpb24sIHNldExvZ0xldmVsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20yMDE3LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/auth/dist/node-esm/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@firebase/auth/dist/node-esm/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActionCodeOperation: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.A),\n/* harmony export */   ActionCodeURL: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.ai),\n/* harmony export */   AuthCredential: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.L),\n/* harmony export */   AuthErrorCodes: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.I),\n/* harmony export */   EmailAuthCredential: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.M),\n/* harmony export */   EmailAuthProvider: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.V),\n/* harmony export */   FacebookAuthProvider: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.W),\n/* harmony export */   FactorId: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   GithubAuthProvider: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.Y),\n/* harmony export */   GoogleAuthProvider: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.X),\n/* harmony export */   OAuthCredential: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.N),\n/* harmony export */   OAuthProvider: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.Z),\n/* harmony export */   OperationType: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.O),\n/* harmony export */   PhoneAuthCredential: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.Q),\n/* harmony export */   PhoneAuthProvider: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.P),\n/* harmony export */   PhoneMultiFactorGenerator: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   ProviderId: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   RecaptchaVerifier: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.R),\n/* harmony export */   SAMLAuthProvider: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__._),\n/* harmony export */   SignInMethod: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.S),\n/* harmony export */   TotpMultiFactorGenerator: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.T),\n/* harmony export */   TotpSecret: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   TwitterAuthProvider: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.$),\n/* harmony export */   applyActionCode: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.a7),\n/* harmony export */   beforeAuthStateChanged: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   browserLocalPersistence: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   browserPopupRedirectResolver: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   browserSessionPersistence: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.a),\n/* harmony export */   checkActionCode: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.a8),\n/* harmony export */   confirmPasswordReset: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.a6),\n/* harmony export */   connectAuthEmulator: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.K),\n/* harmony export */   createUserWithEmailAndPassword: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.aa),\n/* harmony export */   debugErrorMap: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.G),\n/* harmony export */   deleteUser: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.E),\n/* harmony export */   fetchSignInMethodsForEmail: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.af),\n/* harmony export */   getAdditionalUserInfo: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.aq),\n/* harmony export */   getAuth: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   getIdToken: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.an),\n/* harmony export */   getIdTokenResult: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.ao),\n/* harmony export */   getMultiFactorResolver: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.as),\n/* harmony export */   getRedirectResult: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   inMemoryPersistence: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.U),\n/* harmony export */   indexedDBLocalPersistence: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.i),\n/* harmony export */   initializeAuth: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.J),\n/* harmony export */   initializeRecaptchaConfig: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   isSignInWithEmailLink: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.ad),\n/* harmony export */   linkWithCredential: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.a2),\n/* harmony export */   linkWithPhoneNumber: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   linkWithPopup: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   linkWithRedirect: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   multiFactor: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.at),\n/* harmony export */   onAuthStateChanged: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.y),\n/* harmony export */   onIdTokenChanged: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   parseActionCodeURL: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.aj),\n/* harmony export */   prodErrorMap: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.H),\n/* harmony export */   reauthenticateWithCredential: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.a3),\n/* harmony export */   reauthenticateWithPhoneNumber: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   reauthenticateWithPopup: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   reauthenticateWithRedirect: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   reload: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.ar),\n/* harmony export */   revokeAccessToken: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.D),\n/* harmony export */   sendEmailVerification: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.ag),\n/* harmony export */   sendPasswordResetEmail: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.a5),\n/* harmony export */   sendSignInLinkToEmail: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.ac),\n/* harmony export */   setPersistence: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   signInAnonymously: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.a0),\n/* harmony export */   signInWithCredential: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.a1),\n/* harmony export */   signInWithCustomToken: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.a4),\n/* harmony export */   signInWithEmailAndPassword: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.ab),\n/* harmony export */   signInWithEmailLink: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.ae),\n/* harmony export */   signInWithPhoneNumber: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   signInWithPopup: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   signInWithRedirect: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   signOut: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   unlink: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.ap),\n/* harmony export */   updateCurrentUser: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.B),\n/* harmony export */   updateEmail: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.al),\n/* harmony export */   updatePassword: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.am),\n/* harmony export */   updatePhoneNumber: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.u),\n/* harmony export */   updateProfile: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.ak),\n/* harmony export */   useDeviceLanguage: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.z),\n/* harmony export */   validatePassword: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.v),\n/* harmony export */   verifyBeforeUpdateEmail: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.ah),\n/* harmony export */   verifyPasswordResetCode: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.a9)\n/* harmony export */ });\n/* harmony import */ var _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./totp-3df2f5f9.js */ \"(ssr)/./node_modules/@firebase/auth/dist/node-esm/totp-3df2f5f9.js\");\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvZGlzdC9ub2RlLWVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3bEU7QUFDamtFO0FBQ0M7QUFDVDtBQUNjO0FBQ0g7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL2Rpc3Qvbm9kZS1lc20vaW5kZXguanM/ZjdiNyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBBIGFzIEFjdGlvbkNvZGVPcGVyYXRpb24sIGFpIGFzIEFjdGlvbkNvZGVVUkwsIEwgYXMgQXV0aENyZWRlbnRpYWwsIEkgYXMgQXV0aEVycm9yQ29kZXMsIE0gYXMgRW1haWxBdXRoQ3JlZGVudGlhbCwgViBhcyBFbWFpbEF1dGhQcm92aWRlciwgVyBhcyBGYWNlYm9va0F1dGhQcm92aWRlciwgRiBhcyBGYWN0b3JJZCwgWSBhcyBHaXRodWJBdXRoUHJvdmlkZXIsIFggYXMgR29vZ2xlQXV0aFByb3ZpZGVyLCBOIGFzIE9BdXRoQ3JlZGVudGlhbCwgWiBhcyBPQXV0aFByb3ZpZGVyLCBPIGFzIE9wZXJhdGlvblR5cGUsIFEgYXMgUGhvbmVBdXRoQ3JlZGVudGlhbCwgUCBhcyBQaG9uZUF1dGhQcm92aWRlciwgbSBhcyBQaG9uZU11bHRpRmFjdG9yR2VuZXJhdG9yLCBwIGFzIFByb3ZpZGVySWQsIFIgYXMgUmVjYXB0Y2hhVmVyaWZpZXIsIF8gYXMgU0FNTEF1dGhQcm92aWRlciwgUyBhcyBTaWduSW5NZXRob2QsIFQgYXMgVG90cE11bHRpRmFjdG9yR2VuZXJhdG9yLCBuIGFzIFRvdHBTZWNyZXQsICQgYXMgVHdpdHRlckF1dGhQcm92aWRlciwgYTcgYXMgYXBwbHlBY3Rpb25Db2RlLCB4IGFzIGJlZm9yZUF1dGhTdGF0ZUNoYW5nZWQsIGIgYXMgYnJvd3NlckxvY2FsUGVyc2lzdGVuY2UsIGsgYXMgYnJvd3NlclBvcHVwUmVkaXJlY3RSZXNvbHZlciwgYSBhcyBicm93c2VyU2Vzc2lvblBlcnNpc3RlbmNlLCBhOCBhcyBjaGVja0FjdGlvbkNvZGUsIGE2IGFzIGNvbmZpcm1QYXNzd29yZFJlc2V0LCBLIGFzIGNvbm5lY3RBdXRoRW11bGF0b3IsIGFhIGFzIGNyZWF0ZVVzZXJXaXRoRW1haWxBbmRQYXNzd29yZCwgRyBhcyBkZWJ1Z0Vycm9yTWFwLCBFIGFzIGRlbGV0ZVVzZXIsIGFmIGFzIGZldGNoU2lnbkluTWV0aG9kc0ZvckVtYWlsLCBhcSBhcyBnZXRBZGRpdGlvbmFsVXNlckluZm8sIG8gYXMgZ2V0QXV0aCwgYW4gYXMgZ2V0SWRUb2tlbiwgYW8gYXMgZ2V0SWRUb2tlblJlc3VsdCwgYXMgYXMgZ2V0TXVsdGlGYWN0b3JSZXNvbHZlciwgaiBhcyBnZXRSZWRpcmVjdFJlc3VsdCwgVSBhcyBpbk1lbW9yeVBlcnNpc3RlbmNlLCBpIGFzIGluZGV4ZWREQkxvY2FsUGVyc2lzdGVuY2UsIEogYXMgaW5pdGlhbGl6ZUF1dGgsIHQgYXMgaW5pdGlhbGl6ZVJlY2FwdGNoYUNvbmZpZywgYWQgYXMgaXNTaWduSW5XaXRoRW1haWxMaW5rLCBhMiBhcyBsaW5rV2l0aENyZWRlbnRpYWwsIGwgYXMgbGlua1dpdGhQaG9uZU51bWJlciwgZCBhcyBsaW5rV2l0aFBvcHVwLCBnIGFzIGxpbmtXaXRoUmVkaXJlY3QsIGF0IGFzIG11bHRpRmFjdG9yLCB5IGFzIG9uQXV0aFN0YXRlQ2hhbmdlZCwgdyBhcyBvbklkVG9rZW5DaGFuZ2VkLCBhaiBhcyBwYXJzZUFjdGlvbkNvZGVVUkwsIEggYXMgcHJvZEVycm9yTWFwLCBhMyBhcyByZWF1dGhlbnRpY2F0ZVdpdGhDcmVkZW50aWFsLCByIGFzIHJlYXV0aGVudGljYXRlV2l0aFBob25lTnVtYmVyLCBlIGFzIHJlYXV0aGVudGljYXRlV2l0aFBvcHVwLCBoIGFzIHJlYXV0aGVudGljYXRlV2l0aFJlZGlyZWN0LCBhciBhcyByZWxvYWQsIEQgYXMgcmV2b2tlQWNjZXNzVG9rZW4sIGFnIGFzIHNlbmRFbWFpbFZlcmlmaWNhdGlvbiwgYTUgYXMgc2VuZFBhc3N3b3JkUmVzZXRFbWFpbCwgYWMgYXMgc2VuZFNpZ25JbkxpbmtUb0VtYWlsLCBxIGFzIHNldFBlcnNpc3RlbmNlLCBhMCBhcyBzaWduSW5Bbm9ueW1vdXNseSwgYTEgYXMgc2lnbkluV2l0aENyZWRlbnRpYWwsIGE0IGFzIHNpZ25JbldpdGhDdXN0b21Ub2tlbiwgYWIgYXMgc2lnbkluV2l0aEVtYWlsQW5kUGFzc3dvcmQsIGFlIGFzIHNpZ25JbldpdGhFbWFpbExpbmssIHMgYXMgc2lnbkluV2l0aFBob25lTnVtYmVyLCBjIGFzIHNpZ25JbldpdGhQb3B1cCwgZiBhcyBzaWduSW5XaXRoUmVkaXJlY3QsIEMgYXMgc2lnbk91dCwgYXAgYXMgdW5saW5rLCBCIGFzIHVwZGF0ZUN1cnJlbnRVc2VyLCBhbCBhcyB1cGRhdGVFbWFpbCwgYW0gYXMgdXBkYXRlUGFzc3dvcmQsIHUgYXMgdXBkYXRlUGhvbmVOdW1iZXIsIGFrIGFzIHVwZGF0ZVByb2ZpbGUsIHogYXMgdXNlRGV2aWNlTGFuZ3VhZ2UsIHYgYXMgdmFsaWRhdGVQYXNzd29yZCwgYWggYXMgdmVyaWZ5QmVmb3JlVXBkYXRlRW1haWwsIGE5IGFzIHZlcmlmeVBhc3N3b3JkUmVzZXRDb2RlIH0gZnJvbSAnLi90b3RwLTNkZjJmNWY5LmpzJztcbmltcG9ydCAnQGZpcmViYXNlL2FwcCc7XG5pbXBvcnQgJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCAndHNsaWInO1xuaW1wb3J0ICdAZmlyZWJhc2UvY29tcG9uZW50JztcbmltcG9ydCAnQGZpcmViYXNlL2xvZ2dlcic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/auth/dist/node-esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/auth/dist/node-esm/totp-3df2f5f9.js":
/*!********************************************************************!*\
  !*** ./node_modules/@firebase/auth/dist/node-esm/totp-3df2f5f9.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ TwitterAuthProvider),\n/* harmony export */   A: () => (/* binding */ ActionCodeOperation),\n/* harmony export */   B: () => (/* binding */ updateCurrentUser),\n/* harmony export */   C: () => (/* binding */ signOut),\n/* harmony export */   D: () => (/* binding */ revokeAccessToken),\n/* harmony export */   E: () => (/* binding */ deleteUser),\n/* harmony export */   F: () => (/* binding */ FactorId),\n/* harmony export */   G: () => (/* binding */ debugErrorMap),\n/* harmony export */   H: () => (/* binding */ prodErrorMap),\n/* harmony export */   I: () => (/* binding */ AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY),\n/* harmony export */   J: () => (/* binding */ initializeAuth),\n/* harmony export */   K: () => (/* binding */ connectAuthEmulator),\n/* harmony export */   L: () => (/* binding */ AuthCredential),\n/* harmony export */   M: () => (/* binding */ EmailAuthCredential),\n/* harmony export */   N: () => (/* binding */ OAuthCredential),\n/* harmony export */   O: () => (/* binding */ OperationType),\n/* harmony export */   P: () => (/* binding */ PhoneAuthProvider),\n/* harmony export */   Q: () => (/* binding */ PhoneAuthCredential),\n/* harmony export */   R: () => (/* binding */ RecaptchaVerifier),\n/* harmony export */   S: () => (/* binding */ SignInMethod),\n/* harmony export */   T: () => (/* binding */ TotpMultiFactorGenerator),\n/* harmony export */   U: () => (/* binding */ inMemoryPersistence),\n/* harmony export */   V: () => (/* binding */ EmailAuthProvider),\n/* harmony export */   W: () => (/* binding */ FacebookAuthProvider),\n/* harmony export */   X: () => (/* binding */ GoogleAuthProvider),\n/* harmony export */   Y: () => (/* binding */ GithubAuthProvider),\n/* harmony export */   Z: () => (/* binding */ OAuthProvider),\n/* harmony export */   _: () => (/* binding */ SAMLAuthProvider),\n/* harmony export */   a: () => (/* binding */ browserSessionPersistence),\n/* harmony export */   a0: () => (/* binding */ signInAnonymously),\n/* harmony export */   a1: () => (/* binding */ signInWithCredential),\n/* harmony export */   a2: () => (/* binding */ linkWithCredential),\n/* harmony export */   a3: () => (/* binding */ reauthenticateWithCredential),\n/* harmony export */   a4: () => (/* binding */ signInWithCustomToken),\n/* harmony export */   a5: () => (/* binding */ sendPasswordResetEmail),\n/* harmony export */   a6: () => (/* binding */ confirmPasswordReset),\n/* harmony export */   a7: () => (/* binding */ applyActionCode),\n/* harmony export */   a8: () => (/* binding */ checkActionCode),\n/* harmony export */   a9: () => (/* binding */ verifyPasswordResetCode),\n/* harmony export */   aA: () => (/* binding */ _fail),\n/* harmony export */   aB: () => (/* binding */ debugAssert),\n/* harmony export */   aC: () => (/* binding */ _persistenceKeyName),\n/* harmony export */   aD: () => (/* binding */ _serverAppCurrentUserOperationNotSupportedError),\n/* harmony export */   aE: () => (/* binding */ _castAuth),\n/* harmony export */   aF: () => (/* binding */ FederatedAuthProvider),\n/* harmony export */   aG: () => (/* binding */ BaseOAuthProvider),\n/* harmony export */   aH: () => (/* binding */ _emulatorUrl),\n/* harmony export */   aI: () => (/* binding */ _performApiRequest),\n/* harmony export */   aJ: () => (/* binding */ _isIOS),\n/* harmony export */   aK: () => (/* binding */ _isAndroid),\n/* harmony export */   aL: () => (/* binding */ _isIOS7Or8),\n/* harmony export */   aM: () => (/* binding */ _createError),\n/* harmony export */   aN: () => (/* binding */ _isMobileBrowser),\n/* harmony export */   aO: () => (/* binding */ _isIE10),\n/* harmony export */   aP: () => (/* binding */ UserImpl),\n/* harmony export */   aQ: () => (/* binding */ AuthImpl),\n/* harmony export */   aR: () => (/* binding */ _getClientVersion),\n/* harmony export */   aS: () => (/* binding */ FetchProvider),\n/* harmony export */   aT: () => (/* binding */ SAMLAuthCredential),\n/* harmony export */   aa: () => (/* binding */ createUserWithEmailAndPassword),\n/* harmony export */   ab: () => (/* binding */ signInWithEmailAndPassword),\n/* harmony export */   ac: () => (/* binding */ sendSignInLinkToEmail),\n/* harmony export */   ad: () => (/* binding */ isSignInWithEmailLink),\n/* harmony export */   ae: () => (/* binding */ signInWithEmailLink),\n/* harmony export */   af: () => (/* binding */ fetchSignInMethodsForEmail),\n/* harmony export */   ag: () => (/* binding */ sendEmailVerification),\n/* harmony export */   ah: () => (/* binding */ verifyBeforeUpdateEmail),\n/* harmony export */   ai: () => (/* binding */ ActionCodeURL),\n/* harmony export */   aj: () => (/* binding */ parseActionCodeURL),\n/* harmony export */   ak: () => (/* binding */ updateProfile),\n/* harmony export */   al: () => (/* binding */ updateEmail),\n/* harmony export */   am: () => (/* binding */ updatePassword),\n/* harmony export */   an: () => (/* binding */ getIdToken),\n/* harmony export */   ao: () => (/* binding */ getIdTokenResult),\n/* harmony export */   ap: () => (/* binding */ unlink),\n/* harmony export */   aq: () => (/* binding */ getAdditionalUserInfo),\n/* harmony export */   ar: () => (/* binding */ reload),\n/* harmony export */   as: () => (/* binding */ getMultiFactorResolver),\n/* harmony export */   at: () => (/* binding */ multiFactor),\n/* harmony export */   au: () => (/* binding */ _getInstance),\n/* harmony export */   av: () => (/* binding */ _assert),\n/* harmony export */   aw: () => (/* binding */ _signInWithCredential),\n/* harmony export */   ax: () => (/* binding */ _reauthenticate),\n/* harmony export */   ay: () => (/* binding */ _link),\n/* harmony export */   az: () => (/* binding */ signInWithIdp),\n/* harmony export */   b: () => (/* binding */ browserLocalPersistence),\n/* harmony export */   c: () => (/* binding */ signInWithPopup),\n/* harmony export */   d: () => (/* binding */ linkWithPopup),\n/* harmony export */   e: () => (/* binding */ reauthenticateWithPopup),\n/* harmony export */   f: () => (/* binding */ signInWithRedirect),\n/* harmony export */   g: () => (/* binding */ linkWithRedirect),\n/* harmony export */   h: () => (/* binding */ reauthenticateWithRedirect),\n/* harmony export */   i: () => (/* binding */ indexedDBLocalPersistence),\n/* harmony export */   j: () => (/* binding */ getRedirectResult),\n/* harmony export */   k: () => (/* binding */ browserPopupRedirectResolver),\n/* harmony export */   l: () => (/* binding */ linkWithPhoneNumber),\n/* harmony export */   m: () => (/* binding */ PhoneMultiFactorGenerator),\n/* harmony export */   n: () => (/* binding */ TotpSecret),\n/* harmony export */   o: () => (/* binding */ getAuth),\n/* harmony export */   p: () => (/* binding */ ProviderId),\n/* harmony export */   q: () => (/* binding */ setPersistence),\n/* harmony export */   r: () => (/* binding */ reauthenticateWithPhoneNumber),\n/* harmony export */   s: () => (/* binding */ signInWithPhoneNumber),\n/* harmony export */   t: () => (/* binding */ initializeRecaptchaConfig),\n/* harmony export */   u: () => (/* binding */ updatePhoneNumber),\n/* harmony export */   v: () => (/* binding */ validatePassword),\n/* harmony export */   w: () => (/* binding */ onIdTokenChanged),\n/* harmony export */   x: () => (/* binding */ beforeAuthStateChanged),\n/* harmony export */   y: () => (/* binding */ onAuthStateChanged),\n/* harmony export */   z: () => (/* binding */ useDeviceLanguage)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n\n\n\n\n\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An enum of factors that may be used for multifactor authentication.\n *\n * @public\n */\nconst FactorId = {\n    /** Phone as second factor */\n    PHONE: 'phone',\n    TOTP: 'totp'\n};\n/**\n * Enumeration of supported providers.\n *\n * @public\n */\nconst ProviderId = {\n    /** Facebook provider ID */\n    FACEBOOK: 'facebook.com',\n    /** GitHub provider ID */\n    GITHUB: 'github.com',\n    /** Google provider ID */\n    GOOGLE: 'google.com',\n    /** Password provider */\n    PASSWORD: 'password',\n    /** Phone provider */\n    PHONE: 'phone',\n    /** Twitter provider ID */\n    TWITTER: 'twitter.com'\n};\n/**\n * Enumeration of supported sign-in methods.\n *\n * @public\n */\nconst SignInMethod = {\n    /** Email link sign in method */\n    EMAIL_LINK: 'emailLink',\n    /** Email/password sign in method */\n    EMAIL_PASSWORD: 'password',\n    /** Facebook sign in method */\n    FACEBOOK: 'facebook.com',\n    /** GitHub sign in method */\n    GITHUB: 'github.com',\n    /** Google sign in method */\n    GOOGLE: 'google.com',\n    /** Phone sign in method */\n    PHONE: 'phone',\n    /** Twitter sign in method */\n    TWITTER: 'twitter.com'\n};\n/**\n * Enumeration of supported operation types.\n *\n * @public\n */\nconst OperationType = {\n    /** Operation involving linking an additional provider to an already signed-in user. */\n    LINK: 'link',\n    /** Operation involving using a provider to reauthenticate an already signed-in user. */\n    REAUTHENTICATE: 'reauthenticate',\n    /** Operation involving signing in a user. */\n    SIGN_IN: 'signIn'\n};\n/**\n * An enumeration of the possible email action types.\n *\n * @public\n */\nconst ActionCodeOperation = {\n    /** The email link sign-in action. */\n    EMAIL_SIGNIN: 'EMAIL_SIGNIN',\n    /** The password reset action. */\n    PASSWORD_RESET: 'PASSWORD_RESET',\n    /** The email revocation action. */\n    RECOVER_EMAIL: 'RECOVER_EMAIL',\n    /** The revert second factor addition email action. */\n    REVERT_SECOND_FACTOR_ADDITION: 'REVERT_SECOND_FACTOR_ADDITION',\n    /** The revert second factor addition email action. */\n    VERIFY_AND_CHANGE_EMAIL: 'VERIFY_AND_CHANGE_EMAIL',\n    /** The email verification action. */\n    VERIFY_EMAIL: 'VERIFY_EMAIL'\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _debugErrorMap() {\n    return {\n        [\"admin-restricted-operation\" /* AuthErrorCode.ADMIN_ONLY_OPERATION */]: 'This operation is restricted to administrators only.',\n        [\"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */]: '',\n        [\"app-not-authorized\" /* AuthErrorCode.APP_NOT_AUTHORIZED */]: \"This app, identified by the domain where it's hosted, is not \" +\n            'authorized to use Firebase Authentication with the provided API key. ' +\n            'Review your key configuration in the Google API console.',\n        [\"app-not-installed\" /* AuthErrorCode.APP_NOT_INSTALLED */]: 'The requested mobile application corresponding to the identifier (' +\n            'Android package name or iOS bundle ID) provided is not installed on ' +\n            'this device.',\n        [\"captcha-check-failed\" /* AuthErrorCode.CAPTCHA_CHECK_FAILED */]: 'The reCAPTCHA response token provided is either invalid, expired, ' +\n            'already used or the domain associated with it does not match the list ' +\n            'of whitelisted domains.',\n        [\"code-expired\" /* AuthErrorCode.CODE_EXPIRED */]: 'The SMS code has expired. Please re-send the verification code to try ' +\n            'again.',\n        [\"cordova-not-ready\" /* AuthErrorCode.CORDOVA_NOT_READY */]: 'Cordova framework is not ready.',\n        [\"cors-unsupported\" /* AuthErrorCode.CORS_UNSUPPORTED */]: 'This browser is not supported.',\n        [\"credential-already-in-use\" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */]: 'This credential is already associated with a different user account.',\n        [\"custom-token-mismatch\" /* AuthErrorCode.CREDENTIAL_MISMATCH */]: 'The custom token corresponds to a different audience.',\n        [\"requires-recent-login\" /* AuthErrorCode.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */]: 'This operation is sensitive and requires recent authentication. Log in ' +\n            'again before retrying this request.',\n        [\"dependent-sdk-initialized-before-auth\" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */]: 'Another Firebase SDK was initialized and is trying to use Auth before Auth is ' +\n            'initialized. Please be sure to call `initializeAuth` or `getAuth` before ' +\n            'starting any other Firebase SDK.',\n        [\"dynamic-link-not-activated\" /* AuthErrorCode.DYNAMIC_LINK_NOT_ACTIVATED */]: 'Please activate Dynamic Links in the Firebase Console and agree to the terms and ' +\n            'conditions.',\n        [\"email-change-needs-verification\" /* AuthErrorCode.EMAIL_CHANGE_NEEDS_VERIFICATION */]: 'Multi-factor users must always have a verified email.',\n        [\"email-already-in-use\" /* AuthErrorCode.EMAIL_EXISTS */]: 'The email address is already in use by another account.',\n        [\"emulator-config-failed\" /* AuthErrorCode.EMULATOR_CONFIG_FAILED */]: 'Auth instance has already been used to make a network call. Auth can ' +\n            'no longer be configured to use the emulator. Try calling ' +\n            '\"connectAuthEmulator()\" sooner.',\n        [\"expired-action-code\" /* AuthErrorCode.EXPIRED_OOB_CODE */]: 'The action code has expired.',\n        [\"cancelled-popup-request\" /* AuthErrorCode.EXPIRED_POPUP_REQUEST */]: 'This operation has been cancelled due to another conflicting popup being opened.',\n        [\"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */]: 'An internal AuthError has occurred.',\n        [\"invalid-app-credential\" /* AuthErrorCode.INVALID_APP_CREDENTIAL */]: 'The phone verification request contains an invalid application verifier.' +\n            ' The reCAPTCHA token response is either invalid or expired.',\n        [\"invalid-app-id\" /* AuthErrorCode.INVALID_APP_ID */]: 'The mobile app identifier is not registered for the current project.',\n        [\"invalid-user-token\" /* AuthErrorCode.INVALID_AUTH */]: \"This user's credential isn't valid for this project. This can happen \" +\n            \"if the user's token has been tampered with, or if the user isn't for \" +\n            'the project associated with this API key.',\n        [\"invalid-auth-event\" /* AuthErrorCode.INVALID_AUTH_EVENT */]: 'An internal AuthError has occurred.',\n        [\"invalid-verification-code\" /* AuthErrorCode.INVALID_CODE */]: 'The SMS verification code used to create the phone auth credential is ' +\n            'invalid. Please resend the verification code sms and be sure to use the ' +\n            'verification code provided by the user.',\n        [\"invalid-continue-uri\" /* AuthErrorCode.INVALID_CONTINUE_URI */]: 'The continue URL provided in the request is invalid.',\n        [\"invalid-cordova-configuration\" /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */]: 'The following Cordova plugins must be installed to enable OAuth sign-in: ' +\n            'cordova-plugin-buildinfo, cordova-universal-links-plugin, ' +\n            'cordova-plugin-browsertab, cordova-plugin-inappbrowser and ' +\n            'cordova-plugin-customurlscheme.',\n        [\"invalid-custom-token\" /* AuthErrorCode.INVALID_CUSTOM_TOKEN */]: 'The custom token format is incorrect. Please check the documentation.',\n        [\"invalid-dynamic-link-domain\" /* AuthErrorCode.INVALID_DYNAMIC_LINK_DOMAIN */]: 'The provided dynamic link domain is not configured or authorized for the current project.',\n        [\"invalid-email\" /* AuthErrorCode.INVALID_EMAIL */]: 'The email address is badly formatted.',\n        [\"invalid-emulator-scheme\" /* AuthErrorCode.INVALID_EMULATOR_SCHEME */]: 'Emulator URL must start with a valid scheme (http:// or https://).',\n        [\"invalid-api-key\" /* AuthErrorCode.INVALID_API_KEY */]: 'Your API key is invalid, please check you have copied it correctly.',\n        [\"invalid-cert-hash\" /* AuthErrorCode.INVALID_CERT_HASH */]: 'The SHA-1 certificate hash provided is invalid.',\n        [\"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */]: 'The supplied auth credential is incorrect, malformed or has expired.',\n        [\"invalid-message-payload\" /* AuthErrorCode.INVALID_MESSAGE_PAYLOAD */]: 'The email template corresponding to this action contains invalid characters in its message. ' +\n            'Please fix by going to the Auth email templates section in the Firebase Console.',\n        [\"invalid-multi-factor-session\" /* AuthErrorCode.INVALID_MFA_SESSION */]: 'The request does not contain a valid proof of first factor successful sign-in.',\n        [\"invalid-oauth-provider\" /* AuthErrorCode.INVALID_OAUTH_PROVIDER */]: 'EmailAuthProvider is not supported for this operation. This operation ' +\n            'only supports OAuth providers.',\n        [\"invalid-oauth-client-id\" /* AuthErrorCode.INVALID_OAUTH_CLIENT_ID */]: 'The OAuth client ID provided is either invalid or does not match the ' +\n            'specified API key.',\n        [\"unauthorized-domain\" /* AuthErrorCode.INVALID_ORIGIN */]: 'This domain is not authorized for OAuth operations for your Firebase ' +\n            'project. Edit the list of authorized domains from the Firebase console.',\n        [\"invalid-action-code\" /* AuthErrorCode.INVALID_OOB_CODE */]: 'The action code is invalid. This can happen if the code is malformed, ' +\n            'expired, or has already been used.',\n        [\"wrong-password\" /* AuthErrorCode.INVALID_PASSWORD */]: 'The password is invalid or the user does not have a password.',\n        [\"invalid-persistence-type\" /* AuthErrorCode.INVALID_PERSISTENCE */]: 'The specified persistence type is invalid. It can only be local, session or none.',\n        [\"invalid-phone-number\" /* AuthErrorCode.INVALID_PHONE_NUMBER */]: 'The format of the phone number provided is incorrect. Please enter the ' +\n            'phone number in a format that can be parsed into E.164 format. E.164 ' +\n            'phone numbers are written in the format [+][country code][subscriber ' +\n            'number including area code].',\n        [\"invalid-provider-id\" /* AuthErrorCode.INVALID_PROVIDER_ID */]: 'The specified provider ID is invalid.',\n        [\"invalid-recipient-email\" /* AuthErrorCode.INVALID_RECIPIENT_EMAIL */]: 'The email corresponding to this action failed to send as the provided ' +\n            'recipient email address is invalid.',\n        [\"invalid-sender\" /* AuthErrorCode.INVALID_SENDER */]: 'The email template corresponding to this action contains an invalid sender email or name. ' +\n            'Please fix by going to the Auth email templates section in the Firebase Console.',\n        [\"invalid-verification-id\" /* AuthErrorCode.INVALID_SESSION_INFO */]: 'The verification ID used to create the phone auth credential is invalid.',\n        [\"invalid-tenant-id\" /* AuthErrorCode.INVALID_TENANT_ID */]: \"The Auth instance's tenant ID is invalid.\",\n        [\"login-blocked\" /* AuthErrorCode.LOGIN_BLOCKED */]: 'Login blocked by user-provided method: {$originalMessage}',\n        [\"missing-android-pkg-name\" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */]: 'An Android Package Name must be provided if the Android App is required to be installed.',\n        [\"auth-domain-config-required\" /* AuthErrorCode.MISSING_AUTH_DOMAIN */]: 'Be sure to include authDomain when calling firebase.initializeApp(), ' +\n            'by following the instructions in the Firebase console.',\n        [\"missing-app-credential\" /* AuthErrorCode.MISSING_APP_CREDENTIAL */]: 'The phone verification request is missing an application verifier ' +\n            'assertion. A reCAPTCHA response token needs to be provided.',\n        [\"missing-verification-code\" /* AuthErrorCode.MISSING_CODE */]: 'The phone auth credential was created with an empty SMS verification code.',\n        [\"missing-continue-uri\" /* AuthErrorCode.MISSING_CONTINUE_URI */]: 'A continue URL must be provided in the request.',\n        [\"missing-iframe-start\" /* AuthErrorCode.MISSING_IFRAME_START */]: 'An internal AuthError has occurred.',\n        [\"missing-ios-bundle-id\" /* AuthErrorCode.MISSING_IOS_BUNDLE_ID */]: 'An iOS Bundle ID must be provided if an App Store ID is provided.',\n        [\"missing-or-invalid-nonce\" /* AuthErrorCode.MISSING_OR_INVALID_NONCE */]: 'The request does not contain a valid nonce. This can occur if the ' +\n            'SHA-256 hash of the provided raw nonce does not match the hashed nonce ' +\n            'in the ID token payload.',\n        [\"missing-password\" /* AuthErrorCode.MISSING_PASSWORD */]: 'A non-empty password must be provided',\n        [\"missing-multi-factor-info\" /* AuthErrorCode.MISSING_MFA_INFO */]: 'No second factor identifier is provided.',\n        [\"missing-multi-factor-session\" /* AuthErrorCode.MISSING_MFA_SESSION */]: 'The request is missing proof of first factor successful sign-in.',\n        [\"missing-phone-number\" /* AuthErrorCode.MISSING_PHONE_NUMBER */]: 'To send verification codes, provide a phone number for the recipient.',\n        [\"missing-verification-id\" /* AuthErrorCode.MISSING_SESSION_INFO */]: 'The phone auth credential was created with an empty verification ID.',\n        [\"app-deleted\" /* AuthErrorCode.MODULE_DESTROYED */]: 'This instance of FirebaseApp has been deleted.',\n        [\"multi-factor-info-not-found\" /* AuthErrorCode.MFA_INFO_NOT_FOUND */]: 'The user does not have a second factor matching the identifier provided.',\n        [\"multi-factor-auth-required\" /* AuthErrorCode.MFA_REQUIRED */]: 'Proof of ownership of a second factor is required to complete sign-in.',\n        [\"account-exists-with-different-credential\" /* AuthErrorCode.NEED_CONFIRMATION */]: 'An account already exists with the same email address but different ' +\n            'sign-in credentials. Sign in using a provider associated with this ' +\n            'email address.',\n        [\"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */]: 'A network AuthError (such as timeout, interrupted connection or unreachable host) has occurred.',\n        [\"no-auth-event\" /* AuthErrorCode.NO_AUTH_EVENT */]: 'An internal AuthError has occurred.',\n        [\"no-such-provider\" /* AuthErrorCode.NO_SUCH_PROVIDER */]: 'User was not linked to an account with the given provider.',\n        [\"null-user\" /* AuthErrorCode.NULL_USER */]: 'A null user object was provided as the argument for an operation which ' +\n            'requires a non-null user object.',\n        [\"operation-not-allowed\" /* AuthErrorCode.OPERATION_NOT_ALLOWED */]: 'The given sign-in provider is disabled for this Firebase project. ' +\n            'Enable it in the Firebase console, under the sign-in method tab of the ' +\n            'Auth section.',\n        [\"operation-not-supported-in-this-environment\" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */]: 'This operation is not supported in the environment this application is ' +\n            'running on. \"location.protocol\" must be http, https or chrome-extension' +\n            ' and web storage must be enabled.',\n        [\"popup-blocked\" /* AuthErrorCode.POPUP_BLOCKED */]: 'Unable to establish a connection with the popup. It may have been blocked by the browser.',\n        [\"popup-closed-by-user\" /* AuthErrorCode.POPUP_CLOSED_BY_USER */]: 'The popup has been closed by the user before finalizing the operation.',\n        [\"provider-already-linked\" /* AuthErrorCode.PROVIDER_ALREADY_LINKED */]: 'User can only be linked to one identity for the given provider.',\n        [\"quota-exceeded\" /* AuthErrorCode.QUOTA_EXCEEDED */]: \"The project's quota for this operation has been exceeded.\",\n        [\"redirect-cancelled-by-user\" /* AuthErrorCode.REDIRECT_CANCELLED_BY_USER */]: 'The redirect operation has been cancelled by the user before finalizing.',\n        [\"redirect-operation-pending\" /* AuthErrorCode.REDIRECT_OPERATION_PENDING */]: 'A redirect sign-in operation is already pending.',\n        [\"rejected-credential\" /* AuthErrorCode.REJECTED_CREDENTIAL */]: 'The request contains malformed or mismatching credentials.',\n        [\"second-factor-already-in-use\" /* AuthErrorCode.SECOND_FACTOR_ALREADY_ENROLLED */]: 'The second factor is already enrolled on this account.',\n        [\"maximum-second-factor-count-exceeded\" /* AuthErrorCode.SECOND_FACTOR_LIMIT_EXCEEDED */]: 'The maximum allowed number of second factors on a user has been exceeded.',\n        [\"tenant-id-mismatch\" /* AuthErrorCode.TENANT_ID_MISMATCH */]: \"The provided tenant ID does not match the Auth instance's tenant ID\",\n        [\"timeout\" /* AuthErrorCode.TIMEOUT */]: 'The operation has timed out.',\n        [\"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */]: \"The user's credential is no longer valid. The user must sign in again.\",\n        [\"too-many-requests\" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */]: 'We have blocked all requests from this device due to unusual activity. ' +\n            'Try again later.',\n        [\"unauthorized-continue-uri\" /* AuthErrorCode.UNAUTHORIZED_DOMAIN */]: 'The domain of the continue URL is not whitelisted.  Please whitelist ' +\n            'the domain in the Firebase console.',\n        [\"unsupported-first-factor\" /* AuthErrorCode.UNSUPPORTED_FIRST_FACTOR */]: 'Enrolling a second factor or signing in with a multi-factor account requires sign-in with a supported first factor.',\n        [\"unsupported-persistence-type\" /* AuthErrorCode.UNSUPPORTED_PERSISTENCE */]: 'The current environment does not support the specified persistence type.',\n        [\"unsupported-tenant-operation\" /* AuthErrorCode.UNSUPPORTED_TENANT_OPERATION */]: 'This operation is not supported in a multi-tenant context.',\n        [\"unverified-email\" /* AuthErrorCode.UNVERIFIED_EMAIL */]: 'The operation requires a verified email.',\n        [\"user-cancelled\" /* AuthErrorCode.USER_CANCELLED */]: 'The user did not grant your application the permissions it requested.',\n        [\"user-not-found\" /* AuthErrorCode.USER_DELETED */]: 'There is no user record corresponding to this identifier. The user may ' +\n            'have been deleted.',\n        [\"user-disabled\" /* AuthErrorCode.USER_DISABLED */]: 'The user account has been disabled by an administrator.',\n        [\"user-mismatch\" /* AuthErrorCode.USER_MISMATCH */]: 'The supplied credentials do not correspond to the previously signed in user.',\n        [\"user-signed-out\" /* AuthErrorCode.USER_SIGNED_OUT */]: '',\n        [\"weak-password\" /* AuthErrorCode.WEAK_PASSWORD */]: 'The password must be 6 characters long or more.',\n        [\"web-storage-unsupported\" /* AuthErrorCode.WEB_STORAGE_UNSUPPORTED */]: 'This browser is not supported or 3rd party cookies and data may be disabled.',\n        [\"already-initialized\" /* AuthErrorCode.ALREADY_INITIALIZED */]: 'initializeAuth() has already been called with ' +\n            'different options. To avoid this error, call initializeAuth() with the ' +\n            'same options as when it was originally called, or call getAuth() to return the' +\n            ' already initialized instance.',\n        [\"missing-recaptcha-token\" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */]: 'The reCAPTCHA token is missing when sending request to the backend.',\n        [\"invalid-recaptcha-token\" /* AuthErrorCode.INVALID_RECAPTCHA_TOKEN */]: 'The reCAPTCHA token is invalid when sending request to the backend.',\n        [\"invalid-recaptcha-action\" /* AuthErrorCode.INVALID_RECAPTCHA_ACTION */]: 'The reCAPTCHA action is invalid when sending request to the backend.',\n        [\"recaptcha-not-enabled\" /* AuthErrorCode.RECAPTCHA_NOT_ENABLED */]: 'reCAPTCHA Enterprise integration is not enabled for this project.',\n        [\"missing-client-type\" /* AuthErrorCode.MISSING_CLIENT_TYPE */]: 'The reCAPTCHA client type is missing when sending request to the backend.',\n        [\"missing-recaptcha-version\" /* AuthErrorCode.MISSING_RECAPTCHA_VERSION */]: 'The reCAPTCHA version is missing when sending request to the backend.',\n        [\"invalid-req-type\" /* AuthErrorCode.INVALID_REQ_TYPE */]: 'Invalid request parameters.',\n        [\"invalid-recaptcha-version\" /* AuthErrorCode.INVALID_RECAPTCHA_VERSION */]: 'The reCAPTCHA version is invalid when sending request to the backend.',\n        [\"unsupported-password-policy-schema-version\" /* AuthErrorCode.UNSUPPORTED_PASSWORD_POLICY_SCHEMA_VERSION */]: 'The password policy received from the backend uses a schema version that is not supported by this version of the Firebase SDK.',\n        [\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */]: 'The password does not meet the requirements.'\n    };\n}\nfunction _prodErrorMap() {\n    // We will include this one message in the prod error map since by the very\n    // nature of this error, developers will never be able to see the message\n    // using the debugErrorMap (which is installed during auth initialization).\n    return {\n        [\"dependent-sdk-initialized-before-auth\" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */]: 'Another Firebase SDK was initialized and is trying to use Auth before Auth is ' +\n            'initialized. Please be sure to call `initializeAuth` or `getAuth` before ' +\n            'starting any other Firebase SDK.'\n    };\n}\n/**\n * A verbose error map with detailed descriptions for most error codes.\n *\n * See discussion at {@link AuthErrorMap}\n *\n * @public\n */\nconst debugErrorMap = _debugErrorMap;\n/**\n * A minimal error map with all verbose error messages stripped.\n *\n * See discussion at {@link AuthErrorMap}\n *\n * @public\n */\nconst prodErrorMap = _prodErrorMap;\nconst _DEFAULT_AUTH_ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.ErrorFactory('auth', 'Firebase', _prodErrorMap());\n/**\n * A map of potential `Auth` error codes, for easier comparison with errors\n * thrown by the SDK.\n *\n * @remarks\n * Note that you can't tree-shake individual keys\n * in the map, so by using the map you might substantially increase your\n * bundle size.\n *\n * @public\n */\nconst AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY = {\n    ADMIN_ONLY_OPERATION: 'auth/admin-restricted-operation',\n    ARGUMENT_ERROR: 'auth/argument-error',\n    APP_NOT_AUTHORIZED: 'auth/app-not-authorized',\n    APP_NOT_INSTALLED: 'auth/app-not-installed',\n    CAPTCHA_CHECK_FAILED: 'auth/captcha-check-failed',\n    CODE_EXPIRED: 'auth/code-expired',\n    CORDOVA_NOT_READY: 'auth/cordova-not-ready',\n    CORS_UNSUPPORTED: 'auth/cors-unsupported',\n    CREDENTIAL_ALREADY_IN_USE: 'auth/credential-already-in-use',\n    CREDENTIAL_MISMATCH: 'auth/custom-token-mismatch',\n    CREDENTIAL_TOO_OLD_LOGIN_AGAIN: 'auth/requires-recent-login',\n    DEPENDENT_SDK_INIT_BEFORE_AUTH: 'auth/dependent-sdk-initialized-before-auth',\n    DYNAMIC_LINK_NOT_ACTIVATED: 'auth/dynamic-link-not-activated',\n    EMAIL_CHANGE_NEEDS_VERIFICATION: 'auth/email-change-needs-verification',\n    EMAIL_EXISTS: 'auth/email-already-in-use',\n    EMULATOR_CONFIG_FAILED: 'auth/emulator-config-failed',\n    EXPIRED_OOB_CODE: 'auth/expired-action-code',\n    EXPIRED_POPUP_REQUEST: 'auth/cancelled-popup-request',\n    INTERNAL_ERROR: 'auth/internal-error',\n    INVALID_API_KEY: 'auth/invalid-api-key',\n    INVALID_APP_CREDENTIAL: 'auth/invalid-app-credential',\n    INVALID_APP_ID: 'auth/invalid-app-id',\n    INVALID_AUTH: 'auth/invalid-user-token',\n    INVALID_AUTH_EVENT: 'auth/invalid-auth-event',\n    INVALID_CERT_HASH: 'auth/invalid-cert-hash',\n    INVALID_CODE: 'auth/invalid-verification-code',\n    INVALID_CONTINUE_URI: 'auth/invalid-continue-uri',\n    INVALID_CORDOVA_CONFIGURATION: 'auth/invalid-cordova-configuration',\n    INVALID_CUSTOM_TOKEN: 'auth/invalid-custom-token',\n    INVALID_DYNAMIC_LINK_DOMAIN: 'auth/invalid-dynamic-link-domain',\n    INVALID_EMAIL: 'auth/invalid-email',\n    INVALID_EMULATOR_SCHEME: 'auth/invalid-emulator-scheme',\n    INVALID_IDP_RESPONSE: 'auth/invalid-credential',\n    INVALID_LOGIN_CREDENTIALS: 'auth/invalid-credential',\n    INVALID_MESSAGE_PAYLOAD: 'auth/invalid-message-payload',\n    INVALID_MFA_SESSION: 'auth/invalid-multi-factor-session',\n    INVALID_OAUTH_CLIENT_ID: 'auth/invalid-oauth-client-id',\n    INVALID_OAUTH_PROVIDER: 'auth/invalid-oauth-provider',\n    INVALID_OOB_CODE: 'auth/invalid-action-code',\n    INVALID_ORIGIN: 'auth/unauthorized-domain',\n    INVALID_PASSWORD: 'auth/wrong-password',\n    INVALID_PERSISTENCE: 'auth/invalid-persistence-type',\n    INVALID_PHONE_NUMBER: 'auth/invalid-phone-number',\n    INVALID_PROVIDER_ID: 'auth/invalid-provider-id',\n    INVALID_RECIPIENT_EMAIL: 'auth/invalid-recipient-email',\n    INVALID_SENDER: 'auth/invalid-sender',\n    INVALID_SESSION_INFO: 'auth/invalid-verification-id',\n    INVALID_TENANT_ID: 'auth/invalid-tenant-id',\n    MFA_INFO_NOT_FOUND: 'auth/multi-factor-info-not-found',\n    MFA_REQUIRED: 'auth/multi-factor-auth-required',\n    MISSING_ANDROID_PACKAGE_NAME: 'auth/missing-android-pkg-name',\n    MISSING_APP_CREDENTIAL: 'auth/missing-app-credential',\n    MISSING_AUTH_DOMAIN: 'auth/auth-domain-config-required',\n    MISSING_CODE: 'auth/missing-verification-code',\n    MISSING_CONTINUE_URI: 'auth/missing-continue-uri',\n    MISSING_IFRAME_START: 'auth/missing-iframe-start',\n    MISSING_IOS_BUNDLE_ID: 'auth/missing-ios-bundle-id',\n    MISSING_OR_INVALID_NONCE: 'auth/missing-or-invalid-nonce',\n    MISSING_MFA_INFO: 'auth/missing-multi-factor-info',\n    MISSING_MFA_SESSION: 'auth/missing-multi-factor-session',\n    MISSING_PHONE_NUMBER: 'auth/missing-phone-number',\n    MISSING_SESSION_INFO: 'auth/missing-verification-id',\n    MODULE_DESTROYED: 'auth/app-deleted',\n    NEED_CONFIRMATION: 'auth/account-exists-with-different-credential',\n    NETWORK_REQUEST_FAILED: 'auth/network-request-failed',\n    NULL_USER: 'auth/null-user',\n    NO_AUTH_EVENT: 'auth/no-auth-event',\n    NO_SUCH_PROVIDER: 'auth/no-such-provider',\n    OPERATION_NOT_ALLOWED: 'auth/operation-not-allowed',\n    OPERATION_NOT_SUPPORTED: 'auth/operation-not-supported-in-this-environment',\n    POPUP_BLOCKED: 'auth/popup-blocked',\n    POPUP_CLOSED_BY_USER: 'auth/popup-closed-by-user',\n    PROVIDER_ALREADY_LINKED: 'auth/provider-already-linked',\n    QUOTA_EXCEEDED: 'auth/quota-exceeded',\n    REDIRECT_CANCELLED_BY_USER: 'auth/redirect-cancelled-by-user',\n    REDIRECT_OPERATION_PENDING: 'auth/redirect-operation-pending',\n    REJECTED_CREDENTIAL: 'auth/rejected-credential',\n    SECOND_FACTOR_ALREADY_ENROLLED: 'auth/second-factor-already-in-use',\n    SECOND_FACTOR_LIMIT_EXCEEDED: 'auth/maximum-second-factor-count-exceeded',\n    TENANT_ID_MISMATCH: 'auth/tenant-id-mismatch',\n    TIMEOUT: 'auth/timeout',\n    TOKEN_EXPIRED: 'auth/user-token-expired',\n    TOO_MANY_ATTEMPTS_TRY_LATER: 'auth/too-many-requests',\n    UNAUTHORIZED_DOMAIN: 'auth/unauthorized-continue-uri',\n    UNSUPPORTED_FIRST_FACTOR: 'auth/unsupported-first-factor',\n    UNSUPPORTED_PERSISTENCE: 'auth/unsupported-persistence-type',\n    UNSUPPORTED_TENANT_OPERATION: 'auth/unsupported-tenant-operation',\n    UNVERIFIED_EMAIL: 'auth/unverified-email',\n    USER_CANCELLED: 'auth/user-cancelled',\n    USER_DELETED: 'auth/user-not-found',\n    USER_DISABLED: 'auth/user-disabled',\n    USER_MISMATCH: 'auth/user-mismatch',\n    USER_SIGNED_OUT: 'auth/user-signed-out',\n    WEAK_PASSWORD: 'auth/weak-password',\n    WEB_STORAGE_UNSUPPORTED: 'auth/web-storage-unsupported',\n    ALREADY_INITIALIZED: 'auth/already-initialized',\n    RECAPTCHA_NOT_ENABLED: 'auth/recaptcha-not-enabled',\n    MISSING_RECAPTCHA_TOKEN: 'auth/missing-recaptcha-token',\n    INVALID_RECAPTCHA_TOKEN: 'auth/invalid-recaptcha-token',\n    INVALID_RECAPTCHA_ACTION: 'auth/invalid-recaptcha-action',\n    MISSING_CLIENT_TYPE: 'auth/missing-client-type',\n    MISSING_RECAPTCHA_VERSION: 'auth/missing-recaptcha-version',\n    INVALID_RECAPTCHA_VERSION: 'auth/invalid-recaptcha-version',\n    INVALID_REQ_TYPE: 'auth/invalid-req-type'\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst logClient = new _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.Logger('@firebase/auth');\nfunction _logWarn(msg, ...args) {\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.WARN) {\n        logClient.warn(`Auth (${_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION}): ${msg}`, ...args);\n    }\n}\nfunction _logError(msg, ...args) {\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.ERROR) {\n        logClient.error(`Auth (${_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION}): ${msg}`, ...args);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _fail(authOrCode, ...rest) {\n    throw createErrorInternal(authOrCode, ...rest);\n}\nfunction _createError(authOrCode, ...rest) {\n    return createErrorInternal(authOrCode, ...rest);\n}\nfunction _errorWithCustomMessage(auth, code, message) {\n    const errorMap = Object.assign(Object.assign({}, prodErrorMap()), { [code]: message });\n    const factory = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.ErrorFactory('auth', 'Firebase', errorMap);\n    return factory.create(code, {\n        appName: auth.name\n    });\n}\nfunction _serverAppCurrentUserOperationNotSupportedError(auth) {\n    return _errorWithCustomMessage(auth, \"operation-not-supported-in-this-environment\" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */, 'Operations that alter the current user are not supported in conjunction with FirebaseServerApp');\n}\nfunction createErrorInternal(authOrCode, ...rest) {\n    if (typeof authOrCode !== 'string') {\n        const code = rest[0];\n        const fullParams = [...rest.slice(1)];\n        if (fullParams[0]) {\n            fullParams[0].appName = authOrCode.name;\n        }\n        return authOrCode._errorFactory.create(code, ...fullParams);\n    }\n    return _DEFAULT_AUTH_ERROR_FACTORY.create(authOrCode, ...rest);\n}\nfunction _assert(assertion, authOrCode, ...rest) {\n    if (!assertion) {\n        throw createErrorInternal(authOrCode, ...rest);\n    }\n}\n/**\n * Unconditionally fails, throwing an internal error with the given message.\n *\n * @param failure type of failure encountered\n * @throws Error\n */\nfunction debugFail(failure) {\n    // Log the failure in addition to throw an exception, just in case the\n    // exception is swallowed.\n    const message = `INTERNAL ASSERTION FAILED: ` + failure;\n    _logError(message);\n    // NOTE: We don't use FirebaseError here because these are internal failures\n    // that cannot be handled by the user. (Also it would create a circular\n    // dependency between the error and assert modules which doesn't work.)\n    throw new Error(message);\n}\n/**\n * Fails if the given assertion condition is false, throwing an Error with the\n * given message if it did.\n *\n * @param assertion\n * @param message\n */\nfunction debugAssert(assertion, message) {\n    if (!assertion) {\n        debugFail(message);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _getCurrentUrl() {\n    var _a;\n    return (typeof self !== 'undefined' && ((_a = self.location) === null || _a === void 0 ? void 0 : _a.href)) || '';\n}\nfunction _isHttpOrHttps() {\n    return _getCurrentScheme() === 'http:' || _getCurrentScheme() === 'https:';\n}\nfunction _getCurrentScheme() {\n    var _a;\n    return (typeof self !== 'undefined' && ((_a = self.location) === null || _a === void 0 ? void 0 : _a.protocol)) || null;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Determine whether the browser is working online\n */\nfunction _isOnline() {\n    if (typeof navigator !== 'undefined' &&\n        navigator &&\n        'onLine' in navigator &&\n        typeof navigator.onLine === 'boolean' &&\n        // Apply only for traditional web apps and Chrome extensions.\n        // This is especially true for Cordova apps which have unreliable\n        // navigator.onLine behavior unless cordova-plugin-network-information is\n        // installed which overwrites the native navigator.onLine value and\n        // defines navigator.connection.\n        (_isHttpOrHttps() || (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isBrowserExtension)() || 'connection' in navigator)) {\n        return navigator.onLine;\n    }\n    // If we can't determine the state, assume it is online.\n    return true;\n}\nfunction _getUserLanguage() {\n    if (typeof navigator === 'undefined') {\n        return null;\n    }\n    const navigatorLanguage = navigator;\n    return (\n    // Most reliable, but only supported in Chrome/Firefox.\n    (navigatorLanguage.languages && navigatorLanguage.languages[0]) ||\n        // Supported in most browsers, but returns the language of the browser\n        // UI, not the language set in browser settings.\n        navigatorLanguage.language ||\n        // Couldn't determine language.\n        null);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A structure to help pick between a range of long and short delay durations\n * depending on the current environment. In general, the long delay is used for\n * mobile environments whereas short delays are used for desktop environments.\n */\nclass Delay {\n    constructor(shortDelay, longDelay) {\n        this.shortDelay = shortDelay;\n        this.longDelay = longDelay;\n        // Internal error when improperly initialized.\n        debugAssert(longDelay > shortDelay, 'Short delay should be less than long delay!');\n        this.isMobile = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isMobileCordova)() || (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isReactNative)();\n    }\n    get() {\n        if (!_isOnline()) {\n            // Pick the shorter timeout.\n            return Math.min(5000 /* DelayMin.OFFLINE */, this.shortDelay);\n        }\n        // If running in a mobile environment, return the long delay, otherwise\n        // return the short delay.\n        // This could be improved in the future to dynamically change based on other\n        // variables instead of just reading the current environment.\n        return this.isMobile ? this.longDelay : this.shortDelay;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _emulatorUrl(config, path) {\n    debugAssert(config.emulator, 'Emulator should always be set here');\n    const { url } = config.emulator;\n    if (!path) {\n        return url;\n    }\n    return `${url}${path.startsWith('/') ? path.slice(1) : path}`;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass FetchProvider {\n    static initialize(fetchImpl, headersImpl, responseImpl) {\n        this.fetchImpl = fetchImpl;\n        if (headersImpl) {\n            this.headersImpl = headersImpl;\n        }\n        if (responseImpl) {\n            this.responseImpl = responseImpl;\n        }\n    }\n    static fetch() {\n        if (this.fetchImpl) {\n            return this.fetchImpl;\n        }\n        if (typeof self !== 'undefined' && 'fetch' in self) {\n            return self.fetch;\n        }\n        if (typeof globalThis !== 'undefined' && globalThis.fetch) {\n            return globalThis.fetch;\n        }\n        if (typeof fetch !== 'undefined') {\n            return fetch;\n        }\n        debugFail('Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill');\n    }\n    static headers() {\n        if (this.headersImpl) {\n            return this.headersImpl;\n        }\n        if (typeof self !== 'undefined' && 'Headers' in self) {\n            return self.Headers;\n        }\n        if (typeof globalThis !== 'undefined' && globalThis.Headers) {\n            return globalThis.Headers;\n        }\n        if (typeof Headers !== 'undefined') {\n            return Headers;\n        }\n        debugFail('Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill');\n    }\n    static response() {\n        if (this.responseImpl) {\n            return this.responseImpl;\n        }\n        if (typeof self !== 'undefined' && 'Response' in self) {\n            return self.Response;\n        }\n        if (typeof globalThis !== 'undefined' && globalThis.Response) {\n            return globalThis.Response;\n        }\n        if (typeof Response !== 'undefined') {\n            return Response;\n        }\n        debugFail('Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill');\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Map from errors returned by the server to errors to developer visible errors\n */\nconst SERVER_ERROR_MAP = {\n    // Custom token errors.\n    [\"CREDENTIAL_MISMATCH\" /* ServerError.CREDENTIAL_MISMATCH */]: \"custom-token-mismatch\" /* AuthErrorCode.CREDENTIAL_MISMATCH */,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_CUSTOM_TOKEN\" /* ServerError.MISSING_CUSTOM_TOKEN */]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */,\n    // Create Auth URI errors.\n    [\"INVALID_IDENTIFIER\" /* ServerError.INVALID_IDENTIFIER */]: \"invalid-email\" /* AuthErrorCode.INVALID_EMAIL */,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_CONTINUE_URI\" /* ServerError.MISSING_CONTINUE_URI */]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */,\n    // Sign in with email and password errors (some apply to sign up too).\n    [\"INVALID_PASSWORD\" /* ServerError.INVALID_PASSWORD */]: \"wrong-password\" /* AuthErrorCode.INVALID_PASSWORD */,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_PASSWORD\" /* ServerError.MISSING_PASSWORD */]: \"missing-password\" /* AuthErrorCode.MISSING_PASSWORD */,\n    // Thrown if Email Enumeration Protection is enabled in the project and the email or password is\n    // invalid.\n    [\"INVALID_LOGIN_CREDENTIALS\" /* ServerError.INVALID_LOGIN_CREDENTIALS */]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */,\n    // Sign up with email and password errors.\n    [\"EMAIL_EXISTS\" /* ServerError.EMAIL_EXISTS */]: \"email-already-in-use\" /* AuthErrorCode.EMAIL_EXISTS */,\n    [\"PASSWORD_LOGIN_DISABLED\" /* ServerError.PASSWORD_LOGIN_DISABLED */]: \"operation-not-allowed\" /* AuthErrorCode.OPERATION_NOT_ALLOWED */,\n    // Verify assertion for sign in with credential errors:\n    [\"INVALID_IDP_RESPONSE\" /* ServerError.INVALID_IDP_RESPONSE */]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */,\n    [\"INVALID_PENDING_TOKEN\" /* ServerError.INVALID_PENDING_TOKEN */]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */,\n    [\"FEDERATED_USER_ID_ALREADY_LINKED\" /* ServerError.FEDERATED_USER_ID_ALREADY_LINKED */]: \"credential-already-in-use\" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_REQ_TYPE\" /* ServerError.MISSING_REQ_TYPE */]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */,\n    // Send Password reset email errors:\n    [\"EMAIL_NOT_FOUND\" /* ServerError.EMAIL_NOT_FOUND */]: \"user-not-found\" /* AuthErrorCode.USER_DELETED */,\n    [\"RESET_PASSWORD_EXCEED_LIMIT\" /* ServerError.RESET_PASSWORD_EXCEED_LIMIT */]: \"too-many-requests\" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */,\n    [\"EXPIRED_OOB_CODE\" /* ServerError.EXPIRED_OOB_CODE */]: \"expired-action-code\" /* AuthErrorCode.EXPIRED_OOB_CODE */,\n    [\"INVALID_OOB_CODE\" /* ServerError.INVALID_OOB_CODE */]: \"invalid-action-code\" /* AuthErrorCode.INVALID_OOB_CODE */,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_OOB_CODE\" /* ServerError.MISSING_OOB_CODE */]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */,\n    // Operations that require ID token in request:\n    [\"CREDENTIAL_TOO_OLD_LOGIN_AGAIN\" /* ServerError.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */]: \"requires-recent-login\" /* AuthErrorCode.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */,\n    [\"INVALID_ID_TOKEN\" /* ServerError.INVALID_ID_TOKEN */]: \"invalid-user-token\" /* AuthErrorCode.INVALID_AUTH */,\n    [\"TOKEN_EXPIRED\" /* ServerError.TOKEN_EXPIRED */]: \"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */,\n    [\"USER_NOT_FOUND\" /* ServerError.USER_NOT_FOUND */]: \"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */,\n    // Other errors.\n    [\"TOO_MANY_ATTEMPTS_TRY_LATER\" /* ServerError.TOO_MANY_ATTEMPTS_TRY_LATER */]: \"too-many-requests\" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */,\n    [\"PASSWORD_DOES_NOT_MEET_REQUIREMENTS\" /* ServerError.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */]: \"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */,\n    // Phone Auth related errors.\n    [\"INVALID_CODE\" /* ServerError.INVALID_CODE */]: \"invalid-verification-code\" /* AuthErrorCode.INVALID_CODE */,\n    [\"INVALID_SESSION_INFO\" /* ServerError.INVALID_SESSION_INFO */]: \"invalid-verification-id\" /* AuthErrorCode.INVALID_SESSION_INFO */,\n    [\"INVALID_TEMPORARY_PROOF\" /* ServerError.INVALID_TEMPORARY_PROOF */]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */,\n    [\"MISSING_SESSION_INFO\" /* ServerError.MISSING_SESSION_INFO */]: \"missing-verification-id\" /* AuthErrorCode.MISSING_SESSION_INFO */,\n    [\"SESSION_EXPIRED\" /* ServerError.SESSION_EXPIRED */]: \"code-expired\" /* AuthErrorCode.CODE_EXPIRED */,\n    // Other action code errors when additional settings passed.\n    // MISSING_CONTINUE_URI is getting mapped to INTERNAL_ERROR above.\n    // This is OK as this error will be caught by client side validation.\n    [\"MISSING_ANDROID_PACKAGE_NAME\" /* ServerError.MISSING_ANDROID_PACKAGE_NAME */]: \"missing-android-pkg-name\" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */,\n    [\"UNAUTHORIZED_DOMAIN\" /* ServerError.UNAUTHORIZED_DOMAIN */]: \"unauthorized-continue-uri\" /* AuthErrorCode.UNAUTHORIZED_DOMAIN */,\n    // getProjectConfig errors when clientId is passed.\n    [\"INVALID_OAUTH_CLIENT_ID\" /* ServerError.INVALID_OAUTH_CLIENT_ID */]: \"invalid-oauth-client-id\" /* AuthErrorCode.INVALID_OAUTH_CLIENT_ID */,\n    // User actions (sign-up or deletion) disabled errors.\n    [\"ADMIN_ONLY_OPERATION\" /* ServerError.ADMIN_ONLY_OPERATION */]: \"admin-restricted-operation\" /* AuthErrorCode.ADMIN_ONLY_OPERATION */,\n    // Multi factor related errors.\n    [\"INVALID_MFA_PENDING_CREDENTIAL\" /* ServerError.INVALID_MFA_PENDING_CREDENTIAL */]: \"invalid-multi-factor-session\" /* AuthErrorCode.INVALID_MFA_SESSION */,\n    [\"MFA_ENROLLMENT_NOT_FOUND\" /* ServerError.MFA_ENROLLMENT_NOT_FOUND */]: \"multi-factor-info-not-found\" /* AuthErrorCode.MFA_INFO_NOT_FOUND */,\n    [\"MISSING_MFA_ENROLLMENT_ID\" /* ServerError.MISSING_MFA_ENROLLMENT_ID */]: \"missing-multi-factor-info\" /* AuthErrorCode.MISSING_MFA_INFO */,\n    [\"MISSING_MFA_PENDING_CREDENTIAL\" /* ServerError.MISSING_MFA_PENDING_CREDENTIAL */]: \"missing-multi-factor-session\" /* AuthErrorCode.MISSING_MFA_SESSION */,\n    [\"SECOND_FACTOR_EXISTS\" /* ServerError.SECOND_FACTOR_EXISTS */]: \"second-factor-already-in-use\" /* AuthErrorCode.SECOND_FACTOR_ALREADY_ENROLLED */,\n    [\"SECOND_FACTOR_LIMIT_EXCEEDED\" /* ServerError.SECOND_FACTOR_LIMIT_EXCEEDED */]: \"maximum-second-factor-count-exceeded\" /* AuthErrorCode.SECOND_FACTOR_LIMIT_EXCEEDED */,\n    // Blocking functions related errors.\n    [\"BLOCKING_FUNCTION_ERROR_RESPONSE\" /* ServerError.BLOCKING_FUNCTION_ERROR_RESPONSE */]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */,\n    // Recaptcha related errors.\n    [\"RECAPTCHA_NOT_ENABLED\" /* ServerError.RECAPTCHA_NOT_ENABLED */]: \"recaptcha-not-enabled\" /* AuthErrorCode.RECAPTCHA_NOT_ENABLED */,\n    [\"MISSING_RECAPTCHA_TOKEN\" /* ServerError.MISSING_RECAPTCHA_TOKEN */]: \"missing-recaptcha-token\" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */,\n    [\"INVALID_RECAPTCHA_TOKEN\" /* ServerError.INVALID_RECAPTCHA_TOKEN */]: \"invalid-recaptcha-token\" /* AuthErrorCode.INVALID_RECAPTCHA_TOKEN */,\n    [\"INVALID_RECAPTCHA_ACTION\" /* ServerError.INVALID_RECAPTCHA_ACTION */]: \"invalid-recaptcha-action\" /* AuthErrorCode.INVALID_RECAPTCHA_ACTION */,\n    [\"MISSING_CLIENT_TYPE\" /* ServerError.MISSING_CLIENT_TYPE */]: \"missing-client-type\" /* AuthErrorCode.MISSING_CLIENT_TYPE */,\n    [\"MISSING_RECAPTCHA_VERSION\" /* ServerError.MISSING_RECAPTCHA_VERSION */]: \"missing-recaptcha-version\" /* AuthErrorCode.MISSING_RECAPTCHA_VERSION */,\n    [\"INVALID_RECAPTCHA_VERSION\" /* ServerError.INVALID_RECAPTCHA_VERSION */]: \"invalid-recaptcha-version\" /* AuthErrorCode.INVALID_RECAPTCHA_VERSION */,\n    [\"INVALID_REQ_TYPE\" /* ServerError.INVALID_REQ_TYPE */]: \"invalid-req-type\" /* AuthErrorCode.INVALID_REQ_TYPE */\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_API_TIMEOUT_MS = new Delay(30000, 60000);\nfunction _addTidIfNecessary(auth, request) {\n    if (auth.tenantId && !request.tenantId) {\n        return Object.assign(Object.assign({}, request), { tenantId: auth.tenantId });\n    }\n    return request;\n}\nasync function _performApiRequest(auth, method, path, request, customErrorMap = {}) {\n    return _performFetchWithErrorHandling(auth, customErrorMap, async () => {\n        let body = {};\n        let params = {};\n        if (request) {\n            if (method === \"GET\" /* HttpMethod.GET */) {\n                params = request;\n            }\n            else {\n                body = {\n                    body: JSON.stringify(request)\n                };\n            }\n        }\n        const query = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystring)(Object.assign({ key: auth.config.apiKey }, params)).slice(1);\n        const headers = await auth._getAdditionalHeaders();\n        headers[\"Content-Type\" /* HttpHeader.CONTENT_TYPE */] = 'application/json';\n        if (auth.languageCode) {\n            headers[\"X-Firebase-Locale\" /* HttpHeader.X_FIREBASE_LOCALE */] = auth.languageCode;\n        }\n        const fetchArgs = Object.assign({ method,\n            headers }, body);\n        /* Security-conscious server-side frameworks tend to have built in mitigations for referrer\n           problems\". See the Cloudflare GitHub issue #487: Error: The 'referrerPolicy' field on\n           'RequestInitializerDict' is not implemented.\"\n           https://github.com/cloudflare/next-on-pages/issues/487 */\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isCloudflareWorker)()) {\n            fetchArgs.referrerPolicy = 'no-referrer';\n        }\n        return FetchProvider.fetch()(_getFinalTarget(auth, auth.config.apiHost, path, query), fetchArgs);\n    });\n}\nasync function _performFetchWithErrorHandling(auth, customErrorMap, fetchFn) {\n    auth._canInitEmulator = false;\n    const errorMap = Object.assign(Object.assign({}, SERVER_ERROR_MAP), customErrorMap);\n    try {\n        const networkTimeout = new NetworkTimeout(auth);\n        const response = await Promise.race([\n            fetchFn(),\n            networkTimeout.promise\n        ]);\n        // If we've reached this point, the fetch succeeded and the networkTimeout\n        // didn't throw; clear the network timeout delay so that Node won't hang\n        networkTimeout.clearNetworkTimeout();\n        const json = await response.json();\n        if ('needConfirmation' in json) {\n            throw _makeTaggedError(auth, \"account-exists-with-different-credential\" /* AuthErrorCode.NEED_CONFIRMATION */, json);\n        }\n        if (response.ok && !('errorMessage' in json)) {\n            return json;\n        }\n        else {\n            const errorMessage = response.ok ? json.errorMessage : json.error.message;\n            const [serverErrorCode, serverErrorMessage] = errorMessage.split(' : ');\n            if (serverErrorCode === \"FEDERATED_USER_ID_ALREADY_LINKED\" /* ServerError.FEDERATED_USER_ID_ALREADY_LINKED */) {\n                throw _makeTaggedError(auth, \"credential-already-in-use\" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */, json);\n            }\n            else if (serverErrorCode === \"EMAIL_EXISTS\" /* ServerError.EMAIL_EXISTS */) {\n                throw _makeTaggedError(auth, \"email-already-in-use\" /* AuthErrorCode.EMAIL_EXISTS */, json);\n            }\n            else if (serverErrorCode === \"USER_DISABLED\" /* ServerError.USER_DISABLED */) {\n                throw _makeTaggedError(auth, \"user-disabled\" /* AuthErrorCode.USER_DISABLED */, json);\n            }\n            const authError = errorMap[serverErrorCode] ||\n                serverErrorCode\n                    .toLowerCase()\n                    .replace(/[_\\s]+/g, '-');\n            if (serverErrorMessage) {\n                throw _errorWithCustomMessage(auth, authError, serverErrorMessage);\n            }\n            else {\n                _fail(auth, authError);\n            }\n        }\n    }\n    catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_1__.FirebaseError) {\n            throw e;\n        }\n        // Changing this to a different error code will log user out when there is a network error\n        // because we treat any error other than NETWORK_REQUEST_FAILED as token is invalid.\n        // https://github.com/firebase/firebase-js-sdk/blob/4fbc73610d70be4e0852e7de63a39cb7897e8546/packages/auth/src/core/auth/auth_impl.ts#L309-L316\n        _fail(auth, \"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */, { 'message': String(e) });\n    }\n}\nasync function _performSignInRequest(auth, method, path, request, customErrorMap = {}) {\n    const serverResponse = await _performApiRequest(auth, method, path, request, customErrorMap);\n    if ('mfaPendingCredential' in serverResponse) {\n        _fail(auth, \"multi-factor-auth-required\" /* AuthErrorCode.MFA_REQUIRED */, {\n            _serverResponse: serverResponse\n        });\n    }\n    return serverResponse;\n}\nfunction _getFinalTarget(auth, host, path, query) {\n    const base = `${host}${path}?${query}`;\n    if (!auth.config.emulator) {\n        return `${auth.config.apiScheme}://${base}`;\n    }\n    return _emulatorUrl(auth.config, base);\n}\nfunction _parseEnforcementState(enforcementStateStr) {\n    switch (enforcementStateStr) {\n        case 'ENFORCE':\n            return \"ENFORCE\" /* EnforcementState.ENFORCE */;\n        case 'AUDIT':\n            return \"AUDIT\" /* EnforcementState.AUDIT */;\n        case 'OFF':\n            return \"OFF\" /* EnforcementState.OFF */;\n        default:\n            return \"ENFORCEMENT_STATE_UNSPECIFIED\" /* EnforcementState.ENFORCEMENT_STATE_UNSPECIFIED */;\n    }\n}\nclass NetworkTimeout {\n    clearNetworkTimeout() {\n        clearTimeout(this.timer);\n    }\n    constructor(auth) {\n        this.auth = auth;\n        // Node timers and browser timers are fundamentally incompatible, but we\n        // don't care about the value here\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.timer = null;\n        this.promise = new Promise((_, reject) => {\n            this.timer = setTimeout(() => {\n                return reject(_createError(this.auth, \"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */));\n            }, DEFAULT_API_TIMEOUT_MS.get());\n        });\n    }\n}\nfunction _makeTaggedError(auth, code, response) {\n    const errorParams = {\n        appName: auth.name\n    };\n    if (response.email) {\n        errorParams.email = response.email;\n    }\n    if (response.phoneNumber) {\n        errorParams.phoneNumber = response.phoneNumber;\n    }\n    const error = _createError(auth, code, errorParams);\n    // We know customData is defined on error because errorParams is defined\n    error.customData._tokenResponse = response;\n    return error;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction isEnterprise(grecaptcha) {\n    return (grecaptcha !== undefined &&\n        grecaptcha.enterprise !== undefined);\n}\nclass RecaptchaConfig {\n    constructor(response) {\n        /**\n         * The reCAPTCHA site key.\n         */\n        this.siteKey = '';\n        /**\n         * The list of providers and their enablement status for reCAPTCHA Enterprise.\n         */\n        this.recaptchaEnforcementState = [];\n        if (response.recaptchaKey === undefined) {\n            throw new Error('recaptchaKey undefined');\n        }\n        // Example response.recaptchaKey: \"projects/proj123/keys/sitekey123\"\n        this.siteKey = response.recaptchaKey.split('/')[3];\n        this.recaptchaEnforcementState = response.recaptchaEnforcementState;\n    }\n    /**\n     * Returns the reCAPTCHA Enterprise enforcement state for the given provider.\n     *\n     * @param providerStr - The provider whose enforcement state is to be returned.\n     * @returns The reCAPTCHA Enterprise enforcement state for the given provider.\n     */\n    getProviderEnforcementState(providerStr) {\n        if (!this.recaptchaEnforcementState ||\n            this.recaptchaEnforcementState.length === 0) {\n            return null;\n        }\n        for (const recaptchaEnforcementState of this.recaptchaEnforcementState) {\n            if (recaptchaEnforcementState.provider &&\n                recaptchaEnforcementState.provider === providerStr) {\n                return _parseEnforcementState(recaptchaEnforcementState.enforcementState);\n            }\n        }\n        return null;\n    }\n    /**\n     * Returns true if the reCAPTCHA Enterprise enforcement state for the provider is set to ENFORCE or AUDIT.\n     *\n     * @param providerStr - The provider whose enablement state is to be returned.\n     * @returns Whether or not reCAPTCHA Enterprise protection is enabled for the given provider.\n     */\n    isProviderEnabled(providerStr) {\n        return (this.getProviderEnforcementState(providerStr) ===\n            \"ENFORCE\" /* EnforcementState.ENFORCE */ ||\n            this.getProviderEnforcementState(providerStr) === \"AUDIT\" /* EnforcementState.AUDIT */);\n    }\n    /**\n     * Returns true if reCAPTCHA Enterprise protection is enabled in at least one provider, otherwise\n     * returns false.\n     *\n     * @returns Whether or not reCAPTCHA Enterprise protection is enabled for at least one provider.\n     */\n    isAnyProviderEnabled() {\n        return (this.isProviderEnabled(\"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */) ||\n            this.isProviderEnabled(\"PHONE_PROVIDER\" /* RecaptchaAuthProvider.PHONE_PROVIDER */));\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function getRecaptchaConfig(auth, request) {\n    return _performApiRequest(auth, \"GET\" /* HttpMethod.GET */, \"/v2/recaptchaConfig\" /* Endpoint.GET_RECAPTCHA_CONFIG */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function deleteAccount(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:delete\" /* Endpoint.DELETE_ACCOUNT */, request);\n}\nasync function deleteLinkedAccounts(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */, request);\n}\nasync function getAccountInfo(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:lookup\" /* Endpoint.GET_ACCOUNT_INFO */, request);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction utcTimestampToDateString(utcTimestamp) {\n    if (!utcTimestamp) {\n        return undefined;\n    }\n    try {\n        // Convert to date object.\n        const date = new Date(Number(utcTimestamp));\n        // Test date is valid.\n        if (!isNaN(date.getTime())) {\n            // Convert to UTC date string.\n            return date.toUTCString();\n        }\n    }\n    catch (e) {\n        // Do nothing. undefined will be returned.\n    }\n    return undefined;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns a JSON Web Token (JWT) used to identify the user to a Firebase service.\n *\n * @remarks\n * Returns the current token if it has not expired or if it will not expire in the next five\n * minutes. Otherwise, this will refresh the token and return a new one.\n *\n * @param user - The user.\n * @param forceRefresh - Force refresh regardless of token expiration.\n *\n * @public\n */\nfunction getIdToken(user, forceRefresh = false) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user).getIdToken(forceRefresh);\n}\n/**\n * Returns a deserialized JSON Web Token (JWT) used to identify the user to a Firebase service.\n *\n * @remarks\n * Returns the current token if it has not expired or if it will not expire in the next five\n * minutes. Otherwise, this will refresh the token and return a new one.\n *\n * @param user - The user.\n * @param forceRefresh - Force refresh regardless of token expiration.\n *\n * @public\n */\nasync function getIdTokenResult(user, forceRefresh = false) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    const token = await userInternal.getIdToken(forceRefresh);\n    const claims = _parseToken(token);\n    _assert(claims && claims.exp && claims.auth_time && claims.iat, userInternal.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    const firebase = typeof claims.firebase === 'object' ? claims.firebase : undefined;\n    const signInProvider = firebase === null || firebase === void 0 ? void 0 : firebase['sign_in_provider'];\n    return {\n        claims,\n        token,\n        authTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.auth_time)),\n        issuedAtTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.iat)),\n        expirationTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.exp)),\n        signInProvider: signInProvider || null,\n        signInSecondFactor: (firebase === null || firebase === void 0 ? void 0 : firebase['sign_in_second_factor']) || null\n    };\n}\nfunction secondsStringToMilliseconds(seconds) {\n    return Number(seconds) * 1000;\n}\nfunction _parseToken(token) {\n    const [algorithm, payload, signature] = token.split('.');\n    if (algorithm === undefined ||\n        payload === undefined ||\n        signature === undefined) {\n        _logError('JWT malformed, contained fewer than 3 sections');\n        return null;\n    }\n    try {\n        const decoded = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.base64Decode)(payload);\n        if (!decoded) {\n            _logError('Failed to decode base64 JWT payload');\n            return null;\n        }\n        return JSON.parse(decoded);\n    }\n    catch (e) {\n        _logError('Caught error parsing JWT payload as JSON', e === null || e === void 0 ? void 0 : e.toString());\n        return null;\n    }\n}\n/**\n * Extract expiresIn TTL from a token by subtracting the expiration from the issuance.\n */\nfunction _tokenExpiresIn(token) {\n    const parsedToken = _parseToken(token);\n    _assert(parsedToken, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    _assert(typeof parsedToken.exp !== 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    _assert(typeof parsedToken.iat !== 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    return Number(parsedToken.exp) - Number(parsedToken.iat);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function _logoutIfInvalidated(user, promise, bypassAuthState = false) {\n    if (bypassAuthState) {\n        return promise;\n    }\n    try {\n        return await promise;\n    }\n    catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_1__.FirebaseError && isUserInvalidated(e)) {\n            if (user.auth.currentUser === user) {\n                await user.auth.signOut();\n            }\n        }\n        throw e;\n    }\n}\nfunction isUserInvalidated({ code }) {\n    return (code === `auth/${\"user-disabled\" /* AuthErrorCode.USER_DISABLED */}` ||\n        code === `auth/${\"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */}`);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass ProactiveRefresh {\n    constructor(user) {\n        this.user = user;\n        this.isRunning = false;\n        // Node timers and browser timers return fundamentally different types.\n        // We don't actually care what the value is but TS won't accept unknown and\n        // we can't cast properly in both environments.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.timerId = null;\n        this.errorBackoff = 30000 /* Duration.RETRY_BACKOFF_MIN */;\n    }\n    _start() {\n        if (this.isRunning) {\n            return;\n        }\n        this.isRunning = true;\n        this.schedule();\n    }\n    _stop() {\n        if (!this.isRunning) {\n            return;\n        }\n        this.isRunning = false;\n        if (this.timerId !== null) {\n            clearTimeout(this.timerId);\n        }\n    }\n    getInterval(wasError) {\n        var _a;\n        if (wasError) {\n            const interval = this.errorBackoff;\n            this.errorBackoff = Math.min(this.errorBackoff * 2, 960000 /* Duration.RETRY_BACKOFF_MAX */);\n            return interval;\n        }\n        else {\n            // Reset the error backoff\n            this.errorBackoff = 30000 /* Duration.RETRY_BACKOFF_MIN */;\n            const expTime = (_a = this.user.stsTokenManager.expirationTime) !== null && _a !== void 0 ? _a : 0;\n            const interval = expTime - Date.now() - 300000 /* Duration.OFFSET */;\n            return Math.max(0, interval);\n        }\n    }\n    schedule(wasError = false) {\n        if (!this.isRunning) {\n            // Just in case...\n            return;\n        }\n        const interval = this.getInterval(wasError);\n        this.timerId = setTimeout(async () => {\n            await this.iteration();\n        }, interval);\n    }\n    async iteration() {\n        try {\n            await this.user.getIdToken(true);\n        }\n        catch (e) {\n            // Only retry on network errors\n            if ((e === null || e === void 0 ? void 0 : e.code) ===\n                `auth/${\"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */}`) {\n                this.schedule(/* wasError */ true);\n            }\n            return;\n        }\n        this.schedule();\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass UserMetadata {\n    constructor(createdAt, lastLoginAt) {\n        this.createdAt = createdAt;\n        this.lastLoginAt = lastLoginAt;\n        this._initializeTime();\n    }\n    _initializeTime() {\n        this.lastSignInTime = utcTimestampToDateString(this.lastLoginAt);\n        this.creationTime = utcTimestampToDateString(this.createdAt);\n    }\n    _copy(metadata) {\n        this.createdAt = metadata.createdAt;\n        this.lastLoginAt = metadata.lastLoginAt;\n        this._initializeTime();\n    }\n    toJSON() {\n        return {\n            createdAt: this.createdAt,\n            lastLoginAt: this.lastLoginAt\n        };\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function _reloadWithoutSaving(user) {\n    var _a;\n    const auth = user.auth;\n    const idToken = await user.getIdToken();\n    const response = await _logoutIfInvalidated(user, getAccountInfo(auth, { idToken }));\n    _assert(response === null || response === void 0 ? void 0 : response.users.length, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    const coreAccount = response.users[0];\n    user._notifyReloadListener(coreAccount);\n    const newProviderData = ((_a = coreAccount.providerUserInfo) === null || _a === void 0 ? void 0 : _a.length)\n        ? extractProviderData(coreAccount.providerUserInfo)\n        : [];\n    const providerData = mergeProviderData(user.providerData, newProviderData);\n    // Preserves the non-nonymous status of the stored user, even if no more\n    // credentials (federated or email/password) are linked to the user. If\n    // the user was previously anonymous, then use provider data to update.\n    // On the other hand, if it was not anonymous before, it should never be\n    // considered anonymous now.\n    const oldIsAnonymous = user.isAnonymous;\n    const newIsAnonymous = !(user.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);\n    const isAnonymous = !oldIsAnonymous ? false : newIsAnonymous;\n    const updates = {\n        uid: coreAccount.localId,\n        displayName: coreAccount.displayName || null,\n        photoURL: coreAccount.photoUrl || null,\n        email: coreAccount.email || null,\n        emailVerified: coreAccount.emailVerified || false,\n        phoneNumber: coreAccount.phoneNumber || null,\n        tenantId: coreAccount.tenantId || null,\n        providerData,\n        metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),\n        isAnonymous\n    };\n    Object.assign(user, updates);\n}\n/**\n * Reloads user account data, if signed in.\n *\n * @param user - The user.\n *\n * @public\n */\nasync function reload(user) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    await _reloadWithoutSaving(userInternal);\n    // Even though the current user hasn't changed, update\n    // current user will trigger a persistence update w/ the\n    // new info.\n    await userInternal.auth._persistUserIfCurrent(userInternal);\n    userInternal.auth._notifyListenersIfCurrent(userInternal);\n}\nfunction mergeProviderData(original, newData) {\n    const deduped = original.filter(o => !newData.some(n => n.providerId === o.providerId));\n    return [...deduped, ...newData];\n}\nfunction extractProviderData(providers) {\n    return providers.map((_a) => {\n        var { providerId } = _a, provider = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(_a, [\"providerId\"]);\n        return {\n            providerId,\n            uid: provider.rawId || '',\n            displayName: provider.displayName || null,\n            email: provider.email || null,\n            phoneNumber: provider.phoneNumber || null,\n            photoURL: provider.photoUrl || null\n        };\n    });\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function requestStsToken(auth, refreshToken) {\n    const response = await _performFetchWithErrorHandling(auth, {}, async () => {\n        const body = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystring)({\n            'grant_type': 'refresh_token',\n            'refresh_token': refreshToken\n        }).slice(1);\n        const { tokenApiHost, apiKey } = auth.config;\n        const url = _getFinalTarget(auth, tokenApiHost, \"/v1/token\" /* Endpoint.TOKEN */, `key=${apiKey}`);\n        const headers = await auth._getAdditionalHeaders();\n        headers[\"Content-Type\" /* HttpHeader.CONTENT_TYPE */] = 'application/x-www-form-urlencoded';\n        return FetchProvider.fetch()(url, {\n            method: \"POST\" /* HttpMethod.POST */,\n            headers,\n            body\n        });\n    });\n    // The response comes back in snake_case. Convert to camel:\n    return {\n        accessToken: response.access_token,\n        expiresIn: response.expires_in,\n        refreshToken: response.refresh_token\n    };\n}\nasync function revokeToken(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v2/accounts:revokeToken\" /* Endpoint.REVOKE_TOKEN */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * We need to mark this class as internal explicitly to exclude it in the public typings, because\n * it references AuthInternal which has a circular dependency with UserInternal.\n *\n * @internal\n */\nclass StsTokenManager {\n    constructor() {\n        this.refreshToken = null;\n        this.accessToken = null;\n        this.expirationTime = null;\n    }\n    get isExpired() {\n        return (!this.expirationTime ||\n            Date.now() > this.expirationTime - 30000 /* Buffer.TOKEN_REFRESH */);\n    }\n    updateFromServerResponse(response) {\n        _assert(response.idToken, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        _assert(typeof response.idToken !== 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        _assert(typeof response.refreshToken !== 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const expiresIn = 'expiresIn' in response && typeof response.expiresIn !== 'undefined'\n            ? Number(response.expiresIn)\n            : _tokenExpiresIn(response.idToken);\n        this.updateTokensAndExpiration(response.idToken, response.refreshToken, expiresIn);\n    }\n    updateFromIdToken(idToken) {\n        _assert(idToken.length !== 0, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const expiresIn = _tokenExpiresIn(idToken);\n        this.updateTokensAndExpiration(idToken, null, expiresIn);\n    }\n    async getToken(auth, forceRefresh = false) {\n        if (!forceRefresh && this.accessToken && !this.isExpired) {\n            return this.accessToken;\n        }\n        _assert(this.refreshToken, auth, \"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */);\n        if (this.refreshToken) {\n            await this.refresh(auth, this.refreshToken);\n            return this.accessToken;\n        }\n        return null;\n    }\n    clearRefreshToken() {\n        this.refreshToken = null;\n    }\n    async refresh(auth, oldToken) {\n        const { accessToken, refreshToken, expiresIn } = await requestStsToken(auth, oldToken);\n        this.updateTokensAndExpiration(accessToken, refreshToken, Number(expiresIn));\n    }\n    updateTokensAndExpiration(accessToken, refreshToken, expiresInSec) {\n        this.refreshToken = refreshToken || null;\n        this.accessToken = accessToken || null;\n        this.expirationTime = Date.now() + expiresInSec * 1000;\n    }\n    static fromJSON(appName, object) {\n        const { refreshToken, accessToken, expirationTime } = object;\n        const manager = new StsTokenManager();\n        if (refreshToken) {\n            _assert(typeof refreshToken === 'string', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */, {\n                appName\n            });\n            manager.refreshToken = refreshToken;\n        }\n        if (accessToken) {\n            _assert(typeof accessToken === 'string', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */, {\n                appName\n            });\n            manager.accessToken = accessToken;\n        }\n        if (expirationTime) {\n            _assert(typeof expirationTime === 'number', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */, {\n                appName\n            });\n            manager.expirationTime = expirationTime;\n        }\n        return manager;\n    }\n    toJSON() {\n        return {\n            refreshToken: this.refreshToken,\n            accessToken: this.accessToken,\n            expirationTime: this.expirationTime\n        };\n    }\n    _assign(stsTokenManager) {\n        this.accessToken = stsTokenManager.accessToken;\n        this.refreshToken = stsTokenManager.refreshToken;\n        this.expirationTime = stsTokenManager.expirationTime;\n    }\n    _clone() {\n        return Object.assign(new StsTokenManager(), this.toJSON());\n    }\n    _performRefresh() {\n        return debugFail('not implemented');\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction assertStringOrUndefined(assertion, appName) {\n    _assert(typeof assertion === 'string' || typeof assertion === 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */, { appName });\n}\nclass UserImpl {\n    constructor(_a) {\n        var { uid, auth, stsTokenManager } = _a, opt = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(_a, [\"uid\", \"auth\", \"stsTokenManager\"]);\n        // For the user object, provider is always Firebase.\n        this.providerId = \"firebase\" /* ProviderId.FIREBASE */;\n        this.proactiveRefresh = new ProactiveRefresh(this);\n        this.reloadUserInfo = null;\n        this.reloadListener = null;\n        this.uid = uid;\n        this.auth = auth;\n        this.stsTokenManager = stsTokenManager;\n        this.accessToken = stsTokenManager.accessToken;\n        this.displayName = opt.displayName || null;\n        this.email = opt.email || null;\n        this.emailVerified = opt.emailVerified || false;\n        this.phoneNumber = opt.phoneNumber || null;\n        this.photoURL = opt.photoURL || null;\n        this.isAnonymous = opt.isAnonymous || false;\n        this.tenantId = opt.tenantId || null;\n        this.providerData = opt.providerData ? [...opt.providerData] : [];\n        this.metadata = new UserMetadata(opt.createdAt || undefined, opt.lastLoginAt || undefined);\n    }\n    async getIdToken(forceRefresh) {\n        const accessToken = await _logoutIfInvalidated(this, this.stsTokenManager.getToken(this.auth, forceRefresh));\n        _assert(accessToken, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        if (this.accessToken !== accessToken) {\n            this.accessToken = accessToken;\n            await this.auth._persistUserIfCurrent(this);\n            this.auth._notifyListenersIfCurrent(this);\n        }\n        return accessToken;\n    }\n    getIdTokenResult(forceRefresh) {\n        return getIdTokenResult(this, forceRefresh);\n    }\n    reload() {\n        return reload(this);\n    }\n    _assign(user) {\n        if (this === user) {\n            return;\n        }\n        _assert(this.uid === user.uid, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        this.displayName = user.displayName;\n        this.photoURL = user.photoURL;\n        this.email = user.email;\n        this.emailVerified = user.emailVerified;\n        this.phoneNumber = user.phoneNumber;\n        this.isAnonymous = user.isAnonymous;\n        this.tenantId = user.tenantId;\n        this.providerData = user.providerData.map(userInfo => (Object.assign({}, userInfo)));\n        this.metadata._copy(user.metadata);\n        this.stsTokenManager._assign(user.stsTokenManager);\n    }\n    _clone(auth) {\n        const newUser = new UserImpl(Object.assign(Object.assign({}, this), { auth, stsTokenManager: this.stsTokenManager._clone() }));\n        newUser.metadata._copy(this.metadata);\n        return newUser;\n    }\n    _onReload(callback) {\n        // There should only ever be one listener, and that is a single instance of MultiFactorUser\n        _assert(!this.reloadListener, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        this.reloadListener = callback;\n        if (this.reloadUserInfo) {\n            this._notifyReloadListener(this.reloadUserInfo);\n            this.reloadUserInfo = null;\n        }\n    }\n    _notifyReloadListener(userInfo) {\n        if (this.reloadListener) {\n            this.reloadListener(userInfo);\n        }\n        else {\n            // If no listener is subscribed yet, save the result so it's available when they do subscribe\n            this.reloadUserInfo = userInfo;\n        }\n    }\n    _startProactiveRefresh() {\n        this.proactiveRefresh._start();\n    }\n    _stopProactiveRefresh() {\n        this.proactiveRefresh._stop();\n    }\n    async _updateTokensIfNecessary(response, reload = false) {\n        let tokensRefreshed = false;\n        if (response.idToken &&\n            response.idToken !== this.stsTokenManager.accessToken) {\n            this.stsTokenManager.updateFromServerResponse(response);\n            tokensRefreshed = true;\n        }\n        if (reload) {\n            await _reloadWithoutSaving(this);\n        }\n        await this.auth._persistUserIfCurrent(this);\n        if (tokensRefreshed) {\n            this.auth._notifyListenersIfCurrent(this);\n        }\n    }\n    async delete() {\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.auth.app)) {\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this.auth));\n        }\n        const idToken = await this.getIdToken();\n        await _logoutIfInvalidated(this, deleteAccount(this.auth, { idToken }));\n        this.stsTokenManager.clearRefreshToken();\n        // TODO: Determine if cancellable-promises are necessary to use in this class so that delete()\n        //       cancels pending actions...\n        return this.auth.signOut();\n    }\n    toJSON() {\n        return Object.assign(Object.assign({ uid: this.uid, email: this.email || undefined, emailVerified: this.emailVerified, displayName: this.displayName || undefined, isAnonymous: this.isAnonymous, photoURL: this.photoURL || undefined, phoneNumber: this.phoneNumber || undefined, tenantId: this.tenantId || undefined, providerData: this.providerData.map(userInfo => (Object.assign({}, userInfo))), stsTokenManager: this.stsTokenManager.toJSON(), \n            // Redirect event ID must be maintained in case there is a pending\n            // redirect event.\n            _redirectEventId: this._redirectEventId }, this.metadata.toJSON()), { \n            // Required for compatibility with the legacy SDK (go/firebase-auth-sdk-persistence-parsing):\n            apiKey: this.auth.config.apiKey, appName: this.auth.name });\n    }\n    get refreshToken() {\n        return this.stsTokenManager.refreshToken || '';\n    }\n    static _fromJSON(auth, object) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        const displayName = (_a = object.displayName) !== null && _a !== void 0 ? _a : undefined;\n        const email = (_b = object.email) !== null && _b !== void 0 ? _b : undefined;\n        const phoneNumber = (_c = object.phoneNumber) !== null && _c !== void 0 ? _c : undefined;\n        const photoURL = (_d = object.photoURL) !== null && _d !== void 0 ? _d : undefined;\n        const tenantId = (_e = object.tenantId) !== null && _e !== void 0 ? _e : undefined;\n        const _redirectEventId = (_f = object._redirectEventId) !== null && _f !== void 0 ? _f : undefined;\n        const createdAt = (_g = object.createdAt) !== null && _g !== void 0 ? _g : undefined;\n        const lastLoginAt = (_h = object.lastLoginAt) !== null && _h !== void 0 ? _h : undefined;\n        const { uid, emailVerified, isAnonymous, providerData, stsTokenManager: plainObjectTokenManager } = object;\n        _assert(uid && plainObjectTokenManager, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const stsTokenManager = StsTokenManager.fromJSON(this.name, plainObjectTokenManager);\n        _assert(typeof uid === 'string', auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        assertStringOrUndefined(displayName, auth.name);\n        assertStringOrUndefined(email, auth.name);\n        _assert(typeof emailVerified === 'boolean', auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        _assert(typeof isAnonymous === 'boolean', auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        assertStringOrUndefined(phoneNumber, auth.name);\n        assertStringOrUndefined(photoURL, auth.name);\n        assertStringOrUndefined(tenantId, auth.name);\n        assertStringOrUndefined(_redirectEventId, auth.name);\n        assertStringOrUndefined(createdAt, auth.name);\n        assertStringOrUndefined(lastLoginAt, auth.name);\n        const user = new UserImpl({\n            uid,\n            auth,\n            email,\n            emailVerified,\n            displayName,\n            isAnonymous,\n            photoURL,\n            phoneNumber,\n            tenantId,\n            stsTokenManager,\n            createdAt,\n            lastLoginAt\n        });\n        if (providerData && Array.isArray(providerData)) {\n            user.providerData = providerData.map(userInfo => (Object.assign({}, userInfo)));\n        }\n        if (_redirectEventId) {\n            user._redirectEventId = _redirectEventId;\n        }\n        return user;\n    }\n    /**\n     * Initialize a User from an idToken server response\n     * @param auth\n     * @param idTokenResponse\n     */\n    static async _fromIdTokenResponse(auth, idTokenResponse, isAnonymous = false) {\n        const stsTokenManager = new StsTokenManager();\n        stsTokenManager.updateFromServerResponse(idTokenResponse);\n        // Initialize the Firebase Auth user.\n        const user = new UserImpl({\n            uid: idTokenResponse.localId,\n            auth,\n            stsTokenManager,\n            isAnonymous\n        });\n        // Updates the user info and data and resolves with a user instance.\n        await _reloadWithoutSaving(user);\n        return user;\n    }\n    /**\n     * Initialize a User from an idToken server response\n     * @param auth\n     * @param idTokenResponse\n     */\n    static async _fromGetAccountInfoResponse(auth, response, idToken) {\n        const coreAccount = response.users[0];\n        _assert(coreAccount.localId !== undefined, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const providerData = coreAccount.providerUserInfo !== undefined\n            ? extractProviderData(coreAccount.providerUserInfo)\n            : [];\n        const isAnonymous = !(coreAccount.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);\n        const stsTokenManager = new StsTokenManager();\n        stsTokenManager.updateFromIdToken(idToken);\n        // Initialize the Firebase Auth user.\n        const user = new UserImpl({\n            uid: coreAccount.localId,\n            auth,\n            stsTokenManager,\n            isAnonymous\n        });\n        // update the user with data from the GetAccountInfo response.\n        const updates = {\n            uid: coreAccount.localId,\n            displayName: coreAccount.displayName || null,\n            photoURL: coreAccount.photoUrl || null,\n            email: coreAccount.email || null,\n            emailVerified: coreAccount.emailVerified || false,\n            phoneNumber: coreAccount.phoneNumber || null,\n            tenantId: coreAccount.tenantId || null,\n            providerData,\n            metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),\n            isAnonymous: !(coreAccount.email && coreAccount.passwordHash) &&\n                !(providerData === null || providerData === void 0 ? void 0 : providerData.length)\n        };\n        Object.assign(user, updates);\n        return user;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst instanceCache = new Map();\nfunction _getInstance(cls) {\n    debugAssert(cls instanceof Function, 'Expected a class definition');\n    let instance = instanceCache.get(cls);\n    if (instance) {\n        debugAssert(instance instanceof cls, 'Instance stored in cache mismatched with class');\n        return instance;\n    }\n    instance = new cls();\n    instanceCache.set(cls, instance);\n    return instance;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass InMemoryPersistence {\n    constructor() {\n        this.type = \"NONE\" /* PersistenceType.NONE */;\n        this.storage = {};\n    }\n    async _isAvailable() {\n        return true;\n    }\n    async _set(key, value) {\n        this.storage[key] = value;\n    }\n    async _get(key) {\n        const value = this.storage[key];\n        return value === undefined ? null : value;\n    }\n    async _remove(key) {\n        delete this.storage[key];\n    }\n    _addListener(_key, _listener) {\n        // Listeners are not supported for in-memory storage since it cannot be shared across windows/workers\n        return;\n    }\n    _removeListener(_key, _listener) {\n        // Listeners are not supported for in-memory storage since it cannot be shared across windows/workers\n        return;\n    }\n}\nInMemoryPersistence.type = 'NONE';\n/**\n * An implementation of {@link Persistence} of type 'NONE'.\n *\n * @public\n */\nconst inMemoryPersistence = InMemoryPersistence;\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _persistenceKeyName(key, apiKey, appName) {\n    return `${\"firebase\" /* Namespace.PERSISTENCE */}:${key}:${apiKey}:${appName}`;\n}\nclass PersistenceUserManager {\n    constructor(persistence, auth, userKey) {\n        this.persistence = persistence;\n        this.auth = auth;\n        this.userKey = userKey;\n        const { config, name } = this.auth;\n        this.fullUserKey = _persistenceKeyName(this.userKey, config.apiKey, name);\n        this.fullPersistenceKey = _persistenceKeyName(\"persistence\" /* KeyName.PERSISTENCE_USER */, config.apiKey, name);\n        this.boundEventHandler = auth._onStorageEvent.bind(auth);\n        this.persistence._addListener(this.fullUserKey, this.boundEventHandler);\n    }\n    setCurrentUser(user) {\n        return this.persistence._set(this.fullUserKey, user.toJSON());\n    }\n    async getCurrentUser() {\n        const blob = await this.persistence._get(this.fullUserKey);\n        return blob ? UserImpl._fromJSON(this.auth, blob) : null;\n    }\n    removeCurrentUser() {\n        return this.persistence._remove(this.fullUserKey);\n    }\n    savePersistenceForRedirect() {\n        return this.persistence._set(this.fullPersistenceKey, this.persistence.type);\n    }\n    async setPersistence(newPersistence) {\n        if (this.persistence === newPersistence) {\n            return;\n        }\n        const currentUser = await this.getCurrentUser();\n        await this.removeCurrentUser();\n        this.persistence = newPersistence;\n        if (currentUser) {\n            return this.setCurrentUser(currentUser);\n        }\n    }\n    delete() {\n        this.persistence._removeListener(this.fullUserKey, this.boundEventHandler);\n    }\n    static async create(auth, persistenceHierarchy, userKey = \"authUser\" /* KeyName.AUTH_USER */) {\n        if (!persistenceHierarchy.length) {\n            return new PersistenceUserManager(_getInstance(inMemoryPersistence), auth, userKey);\n        }\n        // Eliminate any persistences that are not available\n        const availablePersistences = (await Promise.all(persistenceHierarchy.map(async (persistence) => {\n            if (await persistence._isAvailable()) {\n                return persistence;\n            }\n            return undefined;\n        }))).filter(persistence => persistence);\n        // Fall back to the first persistence listed, or in memory if none available\n        let selectedPersistence = availablePersistences[0] ||\n            _getInstance(inMemoryPersistence);\n        const key = _persistenceKeyName(userKey, auth.config.apiKey, auth.name);\n        // Pull out the existing user, setting the chosen persistence to that\n        // persistence if the user exists.\n        let userToMigrate = null;\n        // Note, here we check for a user in _all_ persistences, not just the\n        // ones deemed available. If we can migrate a user out of a broken\n        // persistence, we will (but only if that persistence supports migration).\n        for (const persistence of persistenceHierarchy) {\n            try {\n                const blob = await persistence._get(key);\n                if (blob) {\n                    const user = UserImpl._fromJSON(auth, blob); // throws for unparsable blob (wrong format)\n                    if (persistence !== selectedPersistence) {\n                        userToMigrate = user;\n                    }\n                    selectedPersistence = persistence;\n                    break;\n                }\n            }\n            catch (_a) { }\n        }\n        // If we find the user in a persistence that does support migration, use\n        // that migration path (of only persistences that support migration)\n        const migrationHierarchy = availablePersistences.filter(p => p._shouldAllowMigration);\n        // If the persistence does _not_ allow migration, just finish off here\n        if (!selectedPersistence._shouldAllowMigration ||\n            !migrationHierarchy.length) {\n            return new PersistenceUserManager(selectedPersistence, auth, userKey);\n        }\n        selectedPersistence = migrationHierarchy[0];\n        if (userToMigrate) {\n            // This normally shouldn't throw since chosenPersistence.isAvailable() is true, but if it does\n            // we'll just let it bubble to surface the error.\n            await selectedPersistence._set(key, userToMigrate.toJSON());\n        }\n        // Attempt to clear the key in other persistences but ignore errors. This helps prevent issues\n        // such as users getting stuck with a previous account after signing out and refreshing the tab.\n        await Promise.all(persistenceHierarchy.map(async (persistence) => {\n            if (persistence !== selectedPersistence) {\n                try {\n                    await persistence._remove(key);\n                }\n                catch (_a) { }\n            }\n        }));\n        return new PersistenceUserManager(selectedPersistence, auth, userKey);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Determine the browser for the purposes of reporting usage to the API\n */\nfunction _getBrowserName(userAgent) {\n    const ua = userAgent.toLowerCase();\n    if (ua.includes('opera/') || ua.includes('opr/') || ua.includes('opios/')) {\n        return \"Opera\" /* BrowserName.OPERA */;\n    }\n    else if (_isIEMobile(ua)) {\n        // Windows phone IEMobile browser.\n        return \"IEMobile\" /* BrowserName.IEMOBILE */;\n    }\n    else if (ua.includes('msie') || ua.includes('trident/')) {\n        return \"IE\" /* BrowserName.IE */;\n    }\n    else if (ua.includes('edge/')) {\n        return \"Edge\" /* BrowserName.EDGE */;\n    }\n    else if (_isFirefox(ua)) {\n        return \"Firefox\" /* BrowserName.FIREFOX */;\n    }\n    else if (ua.includes('silk/')) {\n        return \"Silk\" /* BrowserName.SILK */;\n    }\n    else if (_isBlackBerry(ua)) {\n        // Blackberry browser.\n        return \"Blackberry\" /* BrowserName.BLACKBERRY */;\n    }\n    else if (_isWebOS(ua)) {\n        // WebOS default browser.\n        return \"Webos\" /* BrowserName.WEBOS */;\n    }\n    else if (_isSafari(ua)) {\n        return \"Safari\" /* BrowserName.SAFARI */;\n    }\n    else if ((ua.includes('chrome/') || _isChromeIOS(ua)) &&\n        !ua.includes('edge/')) {\n        return \"Chrome\" /* BrowserName.CHROME */;\n    }\n    else if (_isAndroid(ua)) {\n        // Android stock browser.\n        return \"Android\" /* BrowserName.ANDROID */;\n    }\n    else {\n        // Most modern browsers have name/version at end of user agent string.\n        const re = /([a-zA-Z\\d\\.]+)\\/[a-zA-Z\\d\\.]*$/;\n        const matches = userAgent.match(re);\n        if ((matches === null || matches === void 0 ? void 0 : matches.length) === 2) {\n            return matches[1];\n        }\n    }\n    return \"Other\" /* BrowserName.OTHER */;\n}\nfunction _isFirefox(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /firefox\\//i.test(ua);\n}\nfunction _isSafari(userAgent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    const ua = userAgent.toLowerCase();\n    return (ua.includes('safari/') &&\n        !ua.includes('chrome/') &&\n        !ua.includes('crios/') &&\n        !ua.includes('android'));\n}\nfunction _isChromeIOS(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /crios\\//i.test(ua);\n}\nfunction _isIEMobile(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /iemobile/i.test(ua);\n}\nfunction _isAndroid(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /android/i.test(ua);\n}\nfunction _isBlackBerry(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /blackberry/i.test(ua);\n}\nfunction _isWebOS(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /webos/i.test(ua);\n}\nfunction _isIOS(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return (/iphone|ipad|ipod/i.test(ua) ||\n        (/macintosh/i.test(ua) && /mobile/i.test(ua)));\n}\nfunction _isIOS7Or8(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return (/(iPad|iPhone|iPod).*OS 7_\\d/i.test(ua) ||\n        /(iPad|iPhone|iPod).*OS 8_\\d/i.test(ua));\n}\nfunction _isIE10() {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isIE)() && document.documentMode === 10;\n}\nfunction _isMobileBrowser(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    // TODO: implement getBrowserName equivalent for OS.\n    return (_isIOS(ua) ||\n        _isAndroid(ua) ||\n        _isWebOS(ua) ||\n        _isBlackBerry(ua) ||\n        /windows phone/i.test(ua) ||\n        _isIEMobile(ua));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * Determine the SDK version string\n */\nfunction _getClientVersion(clientPlatform, frameworks = []) {\n    let reportedPlatform;\n    switch (clientPlatform) {\n        case \"Browser\" /* ClientPlatform.BROWSER */:\n            // In a browser environment, report the browser name.\n            reportedPlatform = _getBrowserName((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)());\n            break;\n        case \"Worker\" /* ClientPlatform.WORKER */:\n            // Technically a worker runs from a browser but we need to differentiate a\n            // worker from a browser.\n            // For example: Chrome-Worker/JsCore/4.9.1/FirebaseCore-web.\n            reportedPlatform = `${_getBrowserName((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)())}-${clientPlatform}`;\n            break;\n        default:\n            reportedPlatform = clientPlatform;\n    }\n    const reportedFrameworks = frameworks.length\n        ? frameworks.join(',')\n        : 'FirebaseCore-web'; /* default value if no other framework is used */\n    return `${reportedPlatform}/${\"JsCore\" /* ClientImplementation.CORE */}/${_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION}/${reportedFrameworks}`;\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass AuthMiddlewareQueue {\n    constructor(auth) {\n        this.auth = auth;\n        this.queue = [];\n    }\n    pushCallback(callback, onAbort) {\n        // The callback could be sync or async. Wrap it into a\n        // function that is always async.\n        const wrappedCallback = (user) => new Promise((resolve, reject) => {\n            try {\n                const result = callback(user);\n                // Either resolve with existing promise or wrap a non-promise\n                // return value into a promise.\n                resolve(result);\n            }\n            catch (e) {\n                // Sync callback throws.\n                reject(e);\n            }\n        });\n        // Attach the onAbort if present\n        wrappedCallback.onAbort = onAbort;\n        this.queue.push(wrappedCallback);\n        const index = this.queue.length - 1;\n        return () => {\n            // Unsubscribe. Replace with no-op. Do not remove from array, or it will disturb\n            // indexing of other elements.\n            this.queue[index] = () => Promise.resolve();\n        };\n    }\n    async runMiddleware(nextUser) {\n        if (this.auth.currentUser === nextUser) {\n            return;\n        }\n        // While running the middleware, build a temporary stack of onAbort\n        // callbacks to call if one middleware callback rejects.\n        const onAbortStack = [];\n        try {\n            for (const beforeStateCallback of this.queue) {\n                await beforeStateCallback(nextUser);\n                // Only push the onAbort if the callback succeeds\n                if (beforeStateCallback.onAbort) {\n                    onAbortStack.push(beforeStateCallback.onAbort);\n                }\n            }\n        }\n        catch (e) {\n            // Run all onAbort, with separate try/catch to ignore any errors and\n            // continue\n            onAbortStack.reverse();\n            for (const onAbort of onAbortStack) {\n                try {\n                    onAbort();\n                }\n                catch (_) {\n                    /* swallow error */\n                }\n            }\n            throw this.auth._errorFactory.create(\"login-blocked\" /* AuthErrorCode.LOGIN_BLOCKED */, {\n                originalMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Fetches the password policy for the currently set tenant or the project if no tenant is set.\n *\n * @param auth Auth object.\n * @param request Password policy request.\n * @returns Password policy response.\n */\nasync function _getPasswordPolicy(auth, request = {}) {\n    return _performApiRequest(auth, \"GET\" /* HttpMethod.GET */, \"/v2/passwordPolicy\" /* Endpoint.GET_PASSWORD_POLICY */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Minimum min password length enforced by the backend, even if no minimum length is set.\nconst MINIMUM_MIN_PASSWORD_LENGTH = 6;\n/**\n * Stores password policy requirements and provides password validation against the policy.\n *\n * @internal\n */\nclass PasswordPolicyImpl {\n    constructor(response) {\n        var _a, _b, _c, _d;\n        // Only include custom strength options defined in the response.\n        const responseOptions = response.customStrengthOptions;\n        this.customStrengthOptions = {};\n        // TODO: Remove once the backend is updated to include the minimum min password length instead of undefined when there is no minimum length set.\n        this.customStrengthOptions.minPasswordLength =\n            (_a = responseOptions.minPasswordLength) !== null && _a !== void 0 ? _a : MINIMUM_MIN_PASSWORD_LENGTH;\n        if (responseOptions.maxPasswordLength) {\n            this.customStrengthOptions.maxPasswordLength =\n                responseOptions.maxPasswordLength;\n        }\n        if (responseOptions.containsLowercaseCharacter !== undefined) {\n            this.customStrengthOptions.containsLowercaseLetter =\n                responseOptions.containsLowercaseCharacter;\n        }\n        if (responseOptions.containsUppercaseCharacter !== undefined) {\n            this.customStrengthOptions.containsUppercaseLetter =\n                responseOptions.containsUppercaseCharacter;\n        }\n        if (responseOptions.containsNumericCharacter !== undefined) {\n            this.customStrengthOptions.containsNumericCharacter =\n                responseOptions.containsNumericCharacter;\n        }\n        if (responseOptions.containsNonAlphanumericCharacter !== undefined) {\n            this.customStrengthOptions.containsNonAlphanumericCharacter =\n                responseOptions.containsNonAlphanumericCharacter;\n        }\n        this.enforcementState = response.enforcementState;\n        if (this.enforcementState === 'ENFORCEMENT_STATE_UNSPECIFIED') {\n            this.enforcementState = 'OFF';\n        }\n        // Use an empty string if no non-alphanumeric characters are specified in the response.\n        this.allowedNonAlphanumericCharacters =\n            (_c = (_b = response.allowedNonAlphanumericCharacters) === null || _b === void 0 ? void 0 : _b.join('')) !== null && _c !== void 0 ? _c : '';\n        this.forceUpgradeOnSignin = (_d = response.forceUpgradeOnSignin) !== null && _d !== void 0 ? _d : false;\n        this.schemaVersion = response.schemaVersion;\n    }\n    validatePassword(password) {\n        var _a, _b, _c, _d, _e, _f;\n        const status = {\n            isValid: true,\n            passwordPolicy: this\n        };\n        // Check the password length and character options.\n        this.validatePasswordLengthOptions(password, status);\n        this.validatePasswordCharacterOptions(password, status);\n        // Combine the status into single isValid property.\n        status.isValid && (status.isValid = (_a = status.meetsMinPasswordLength) !== null && _a !== void 0 ? _a : true);\n        status.isValid && (status.isValid = (_b = status.meetsMaxPasswordLength) !== null && _b !== void 0 ? _b : true);\n        status.isValid && (status.isValid = (_c = status.containsLowercaseLetter) !== null && _c !== void 0 ? _c : true);\n        status.isValid && (status.isValid = (_d = status.containsUppercaseLetter) !== null && _d !== void 0 ? _d : true);\n        status.isValid && (status.isValid = (_e = status.containsNumericCharacter) !== null && _e !== void 0 ? _e : true);\n        status.isValid && (status.isValid = (_f = status.containsNonAlphanumericCharacter) !== null && _f !== void 0 ? _f : true);\n        return status;\n    }\n    /**\n     * Validates that the password meets the length options for the policy.\n     *\n     * @param password Password to validate.\n     * @param status Validation status.\n     */\n    validatePasswordLengthOptions(password, status) {\n        const minPasswordLength = this.customStrengthOptions.minPasswordLength;\n        const maxPasswordLength = this.customStrengthOptions.maxPasswordLength;\n        if (minPasswordLength) {\n            status.meetsMinPasswordLength = password.length >= minPasswordLength;\n        }\n        if (maxPasswordLength) {\n            status.meetsMaxPasswordLength = password.length <= maxPasswordLength;\n        }\n    }\n    /**\n     * Validates that the password meets the character options for the policy.\n     *\n     * @param password Password to validate.\n     * @param status Validation status.\n     */\n    validatePasswordCharacterOptions(password, status) {\n        // Assign statuses for requirements even if the password is an empty string.\n        this.updatePasswordCharacterOptionsStatuses(status, \n        /* containsLowercaseCharacter= */ false, \n        /* containsUppercaseCharacter= */ false, \n        /* containsNumericCharacter= */ false, \n        /* containsNonAlphanumericCharacter= */ false);\n        let passwordChar;\n        for (let i = 0; i < password.length; i++) {\n            passwordChar = password.charAt(i);\n            this.updatePasswordCharacterOptionsStatuses(status, \n            /* containsLowercaseCharacter= */ passwordChar >= 'a' &&\n                passwordChar <= 'z', \n            /* containsUppercaseCharacter= */ passwordChar >= 'A' &&\n                passwordChar <= 'Z', \n            /* containsNumericCharacter= */ passwordChar >= '0' &&\n                passwordChar <= '9', \n            /* containsNonAlphanumericCharacter= */ this.allowedNonAlphanumericCharacters.includes(passwordChar));\n        }\n    }\n    /**\n     * Updates the running validation status with the statuses for the character options.\n     * Expected to be called each time a character is processed to update each option status\n     * based on the current character.\n     *\n     * @param status Validation status.\n     * @param containsLowercaseCharacter Whether the character is a lowercase letter.\n     * @param containsUppercaseCharacter Whether the character is an uppercase letter.\n     * @param containsNumericCharacter Whether the character is a numeric character.\n     * @param containsNonAlphanumericCharacter Whether the character is a non-alphanumeric character.\n     */\n    updatePasswordCharacterOptionsStatuses(status, containsLowercaseCharacter, containsUppercaseCharacter, containsNumericCharacter, containsNonAlphanumericCharacter) {\n        if (this.customStrengthOptions.containsLowercaseLetter) {\n            status.containsLowercaseLetter || (status.containsLowercaseLetter = containsLowercaseCharacter);\n        }\n        if (this.customStrengthOptions.containsUppercaseLetter) {\n            status.containsUppercaseLetter || (status.containsUppercaseLetter = containsUppercaseCharacter);\n        }\n        if (this.customStrengthOptions.containsNumericCharacter) {\n            status.containsNumericCharacter || (status.containsNumericCharacter = containsNumericCharacter);\n        }\n        if (this.customStrengthOptions.containsNonAlphanumericCharacter) {\n            status.containsNonAlphanumericCharacter || (status.containsNonAlphanumericCharacter = containsNonAlphanumericCharacter);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass AuthImpl {\n    constructor(app, heartbeatServiceProvider, appCheckServiceProvider, config) {\n        this.app = app;\n        this.heartbeatServiceProvider = heartbeatServiceProvider;\n        this.appCheckServiceProvider = appCheckServiceProvider;\n        this.config = config;\n        this.currentUser = null;\n        this.emulatorConfig = null;\n        this.operations = Promise.resolve();\n        this.authStateSubscription = new Subscription(this);\n        this.idTokenSubscription = new Subscription(this);\n        this.beforeStateQueue = new AuthMiddlewareQueue(this);\n        this.redirectUser = null;\n        this.isProactiveRefreshEnabled = false;\n        this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION = 1;\n        // Any network calls will set this to true and prevent subsequent emulator\n        // initialization\n        this._canInitEmulator = true;\n        this._isInitialized = false;\n        this._deleted = false;\n        this._initializationPromise = null;\n        this._popupRedirectResolver = null;\n        this._errorFactory = _DEFAULT_AUTH_ERROR_FACTORY;\n        this._agentRecaptchaConfig = null;\n        this._tenantRecaptchaConfigs = {};\n        this._projectPasswordPolicy = null;\n        this._tenantPasswordPolicies = {};\n        // Tracks the last notified UID for state change listeners to prevent\n        // repeated calls to the callbacks. Undefined means it's never been\n        // called, whereas null means it's been called with a signed out user\n        this.lastNotifiedUid = undefined;\n        this.languageCode = null;\n        this.tenantId = null;\n        this.settings = { appVerificationDisabledForTesting: false };\n        this.frameworks = [];\n        this.name = app.name;\n        this.clientVersion = config.sdkClientVersion;\n    }\n    _initializeWithPersistence(persistenceHierarchy, popupRedirectResolver) {\n        if (popupRedirectResolver) {\n            this._popupRedirectResolver = _getInstance(popupRedirectResolver);\n        }\n        // Have to check for app deletion throughout initialization (after each\n        // promise resolution)\n        this._initializationPromise = this.queue(async () => {\n            var _a, _b;\n            if (this._deleted) {\n                return;\n            }\n            this.persistenceManager = await PersistenceUserManager.create(this, persistenceHierarchy);\n            if (this._deleted) {\n                return;\n            }\n            // Initialize the resolver early if necessary (only applicable to web:\n            // this will cause the iframe to load immediately in certain cases)\n            if ((_a = this._popupRedirectResolver) === null || _a === void 0 ? void 0 : _a._shouldInitProactively) {\n                // If this fails, don't halt auth loading\n                try {\n                    await this._popupRedirectResolver._initialize(this);\n                }\n                catch (e) {\n                    /* Ignore the error */\n                }\n            }\n            await this.initializeCurrentUser(popupRedirectResolver);\n            this.lastNotifiedUid = ((_b = this.currentUser) === null || _b === void 0 ? void 0 : _b.uid) || null;\n            if (this._deleted) {\n                return;\n            }\n            this._isInitialized = true;\n        });\n        return this._initializationPromise;\n    }\n    /**\n     * If the persistence is changed in another window, the user manager will let us know\n     */\n    async _onStorageEvent() {\n        if (this._deleted) {\n            return;\n        }\n        const user = await this.assertedPersistence.getCurrentUser();\n        if (!this.currentUser && !user) {\n            // No change, do nothing (was signed out and remained signed out).\n            return;\n        }\n        // If the same user is to be synchronized.\n        if (this.currentUser && user && this.currentUser.uid === user.uid) {\n            // Data update, simply copy data changes.\n            this._currentUser._assign(user);\n            // If tokens changed from previous user tokens, this will trigger\n            // notifyAuthListeners_.\n            await this.currentUser.getIdToken();\n            return;\n        }\n        // Update current Auth state. Either a new login or logout.\n        // Skip blocking callbacks, they should not apply to a change in another tab.\n        await this._updateCurrentUser(user, /* skipBeforeStateCallbacks */ true);\n    }\n    async initializeCurrentUserFromIdToken(idToken) {\n        try {\n            const response = await getAccountInfo(this, { idToken });\n            const user = await UserImpl._fromGetAccountInfoResponse(this, response, idToken);\n            await this.directlySetCurrentUser(user);\n        }\n        catch (err) {\n            console.warn('FirebaseServerApp could not login user with provided authIdToken: ', err);\n            await this.directlySetCurrentUser(null);\n        }\n    }\n    async initializeCurrentUser(popupRedirectResolver) {\n        var _a;\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app)) {\n            const idToken = this.app.settings.authIdToken;\n            if (idToken) {\n                // Start the auth operation in the next tick to allow a moment for the customer's app to\n                // attach an emulator, if desired.\n                return new Promise(resolve => {\n                    setTimeout(() => this.initializeCurrentUserFromIdToken(idToken).then(resolve, resolve));\n                });\n            }\n            else {\n                return this.directlySetCurrentUser(null);\n            }\n        }\n        // First check to see if we have a pending redirect event.\n        const previouslyStoredUser = (await this.assertedPersistence.getCurrentUser());\n        let futureCurrentUser = previouslyStoredUser;\n        let needsTocheckMiddleware = false;\n        if (popupRedirectResolver && this.config.authDomain) {\n            await this.getOrInitRedirectPersistenceManager();\n            const redirectUserEventId = (_a = this.redirectUser) === null || _a === void 0 ? void 0 : _a._redirectEventId;\n            const storedUserEventId = futureCurrentUser === null || futureCurrentUser === void 0 ? void 0 : futureCurrentUser._redirectEventId;\n            const result = await this.tryRedirectSignIn(popupRedirectResolver);\n            // If the stored user (i.e. the old \"currentUser\") has a redirectId that\n            // matches the redirect user, then we want to initially sign in with the\n            // new user object from result.\n            // TODO(samgho): More thoroughly test all of this\n            if ((!redirectUserEventId || redirectUserEventId === storedUserEventId) &&\n                (result === null || result === void 0 ? void 0 : result.user)) {\n                futureCurrentUser = result.user;\n                needsTocheckMiddleware = true;\n            }\n        }\n        // If no user in persistence, there is no current user. Set to null.\n        if (!futureCurrentUser) {\n            return this.directlySetCurrentUser(null);\n        }\n        if (!futureCurrentUser._redirectEventId) {\n            // This isn't a redirect link operation, we can reload and bail.\n            // First though, ensure that we check the middleware is happy.\n            if (needsTocheckMiddleware) {\n                try {\n                    await this.beforeStateQueue.runMiddleware(futureCurrentUser);\n                }\n                catch (e) {\n                    futureCurrentUser = previouslyStoredUser;\n                    // We know this is available since the bit is only set when the\n                    // resolver is available\n                    this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(e));\n                }\n            }\n            if (futureCurrentUser) {\n                return this.reloadAndSetCurrentUserOrClear(futureCurrentUser);\n            }\n            else {\n                return this.directlySetCurrentUser(null);\n            }\n        }\n        _assert(this._popupRedirectResolver, this, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        await this.getOrInitRedirectPersistenceManager();\n        // If the redirect user's event ID matches the current user's event ID,\n        // DO NOT reload the current user, otherwise they'll be cleared from storage.\n        // This is important for the reauthenticateWithRedirect() flow.\n        if (this.redirectUser &&\n            this.redirectUser._redirectEventId === futureCurrentUser._redirectEventId) {\n            return this.directlySetCurrentUser(futureCurrentUser);\n        }\n        return this.reloadAndSetCurrentUserOrClear(futureCurrentUser);\n    }\n    async tryRedirectSignIn(redirectResolver) {\n        // The redirect user needs to be checked (and signed in if available)\n        // during auth initialization. All of the normal sign in and link/reauth\n        // flows call back into auth and push things onto the promise queue. We\n        // need to await the result of the redirect sign in *inside the promise\n        // queue*. This presents a problem: we run into deadlock. See:\n        //    ┌> [Initialization] ─────┐\n        //    ┌> [<other queue tasks>] │\n        //    └─ [getRedirectResult] <─┘\n        //    where [] are tasks on the queue and arrows denote awaits\n        // Initialization will never complete because it's waiting on something\n        // that's waiting for initialization to complete!\n        //\n        // Instead, this method calls getRedirectResult() (stored in\n        // _completeRedirectFn) with an optional parameter that instructs all of\n        // the underlying auth operations to skip anything that mutates auth state.\n        let result = null;\n        try {\n            // We know this._popupRedirectResolver is set since redirectResolver\n            // is passed in. The _completeRedirectFn expects the unwrapped extern.\n            result = await this._popupRedirectResolver._completeRedirectFn(this, redirectResolver, true);\n        }\n        catch (e) {\n            // Swallow any errors here; the code can retrieve them in\n            // getRedirectResult().\n            await this._setRedirectUser(null);\n        }\n        return result;\n    }\n    async reloadAndSetCurrentUserOrClear(user) {\n        try {\n            await _reloadWithoutSaving(user);\n        }\n        catch (e) {\n            if ((e === null || e === void 0 ? void 0 : e.code) !==\n                `auth/${\"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */}`) {\n                // Something's wrong with the user's token. Log them out and remove\n                // them from storage\n                return this.directlySetCurrentUser(null);\n            }\n        }\n        return this.directlySetCurrentUser(user);\n    }\n    useDeviceLanguage() {\n        this.languageCode = _getUserLanguage();\n    }\n    async _delete() {\n        this._deleted = true;\n    }\n    async updateCurrentUser(userExtern) {\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app)) {\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));\n        }\n        // The public updateCurrentUser method needs to make a copy of the user,\n        // and also check that the project matches\n        const user = userExtern\n            ? (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(userExtern)\n            : null;\n        if (user) {\n            _assert(user.auth.config.apiKey === this.config.apiKey, this, \"invalid-user-token\" /* AuthErrorCode.INVALID_AUTH */);\n        }\n        return this._updateCurrentUser(user && user._clone(this));\n    }\n    async _updateCurrentUser(user, skipBeforeStateCallbacks = false) {\n        if (this._deleted) {\n            return;\n        }\n        if (user) {\n            _assert(this.tenantId === user.tenantId, this, \"tenant-id-mismatch\" /* AuthErrorCode.TENANT_ID_MISMATCH */);\n        }\n        if (!skipBeforeStateCallbacks) {\n            await this.beforeStateQueue.runMiddleware(user);\n        }\n        return this.queue(async () => {\n            await this.directlySetCurrentUser(user);\n            this.notifyAuthListeners();\n        });\n    }\n    async signOut() {\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app)) {\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));\n        }\n        // Run first, to block _setRedirectUser() if any callbacks fail.\n        await this.beforeStateQueue.runMiddleware(null);\n        // Clear the redirect user when signOut is called\n        if (this.redirectPersistenceManager || this._popupRedirectResolver) {\n            await this._setRedirectUser(null);\n        }\n        // Prevent callbacks from being called again in _updateCurrentUser, as\n        // they were already called in the first line.\n        return this._updateCurrentUser(null, /* skipBeforeStateCallbacks */ true);\n    }\n    setPersistence(persistence) {\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app)) {\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));\n        }\n        return this.queue(async () => {\n            await this.assertedPersistence.setPersistence(_getInstance(persistence));\n        });\n    }\n    _getRecaptchaConfig() {\n        if (this.tenantId == null) {\n            return this._agentRecaptchaConfig;\n        }\n        else {\n            return this._tenantRecaptchaConfigs[this.tenantId];\n        }\n    }\n    async validatePassword(password) {\n        if (!this._getPasswordPolicyInternal()) {\n            await this._updatePasswordPolicy();\n        }\n        // Password policy will be defined after fetching.\n        const passwordPolicy = this._getPasswordPolicyInternal();\n        // Check that the policy schema version is supported by the SDK.\n        // TODO: Update this logic to use a max supported policy schema version once we have multiple schema versions.\n        if (passwordPolicy.schemaVersion !==\n            this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION) {\n            return Promise.reject(this._errorFactory.create(\"unsupported-password-policy-schema-version\" /* AuthErrorCode.UNSUPPORTED_PASSWORD_POLICY_SCHEMA_VERSION */, {}));\n        }\n        return passwordPolicy.validatePassword(password);\n    }\n    _getPasswordPolicyInternal() {\n        if (this.tenantId === null) {\n            return this._projectPasswordPolicy;\n        }\n        else {\n            return this._tenantPasswordPolicies[this.tenantId];\n        }\n    }\n    async _updatePasswordPolicy() {\n        const response = await _getPasswordPolicy(this);\n        const passwordPolicy = new PasswordPolicyImpl(response);\n        if (this.tenantId === null) {\n            this._projectPasswordPolicy = passwordPolicy;\n        }\n        else {\n            this._tenantPasswordPolicies[this.tenantId] = passwordPolicy;\n        }\n    }\n    _getPersistence() {\n        return this.assertedPersistence.persistence.type;\n    }\n    _updateErrorMap(errorMap) {\n        this._errorFactory = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.ErrorFactory('auth', 'Firebase', errorMap());\n    }\n    onAuthStateChanged(nextOrObserver, error, completed) {\n        return this.registerStateListener(this.authStateSubscription, nextOrObserver, error, completed);\n    }\n    beforeAuthStateChanged(callback, onAbort) {\n        return this.beforeStateQueue.pushCallback(callback, onAbort);\n    }\n    onIdTokenChanged(nextOrObserver, error, completed) {\n        return this.registerStateListener(this.idTokenSubscription, nextOrObserver, error, completed);\n    }\n    authStateReady() {\n        return new Promise((resolve, reject) => {\n            if (this.currentUser) {\n                resolve();\n            }\n            else {\n                const unsubscribe = this.onAuthStateChanged(() => {\n                    unsubscribe();\n                    resolve();\n                }, reject);\n            }\n        });\n    }\n    /**\n     * Revokes the given access token. Currently only supports Apple OAuth access tokens.\n     */\n    async revokeAccessToken(token) {\n        if (this.currentUser) {\n            const idToken = await this.currentUser.getIdToken();\n            // Generalize this to accept other providers once supported.\n            const request = {\n                providerId: 'apple.com',\n                tokenType: \"ACCESS_TOKEN\" /* TokenType.ACCESS_TOKEN */,\n                token,\n                idToken\n            };\n            if (this.tenantId != null) {\n                request.tenantId = this.tenantId;\n            }\n            await revokeToken(this, request);\n        }\n    }\n    toJSON() {\n        var _a;\n        return {\n            apiKey: this.config.apiKey,\n            authDomain: this.config.authDomain,\n            appName: this.name,\n            currentUser: (_a = this._currentUser) === null || _a === void 0 ? void 0 : _a.toJSON()\n        };\n    }\n    async _setRedirectUser(user, popupRedirectResolver) {\n        const redirectManager = await this.getOrInitRedirectPersistenceManager(popupRedirectResolver);\n        return user === null\n            ? redirectManager.removeCurrentUser()\n            : redirectManager.setCurrentUser(user);\n    }\n    async getOrInitRedirectPersistenceManager(popupRedirectResolver) {\n        if (!this.redirectPersistenceManager) {\n            const resolver = (popupRedirectResolver && _getInstance(popupRedirectResolver)) ||\n                this._popupRedirectResolver;\n            _assert(resolver, this, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n            this.redirectPersistenceManager = await PersistenceUserManager.create(this, [_getInstance(resolver._redirectPersistence)], \"redirectUser\" /* KeyName.REDIRECT_USER */);\n            this.redirectUser =\n                await this.redirectPersistenceManager.getCurrentUser();\n        }\n        return this.redirectPersistenceManager;\n    }\n    async _redirectUserForId(id) {\n        var _a, _b;\n        // Make sure we've cleared any pending persistence actions if we're not in\n        // the initializer\n        if (this._isInitialized) {\n            await this.queue(async () => { });\n        }\n        if (((_a = this._currentUser) === null || _a === void 0 ? void 0 : _a._redirectEventId) === id) {\n            return this._currentUser;\n        }\n        if (((_b = this.redirectUser) === null || _b === void 0 ? void 0 : _b._redirectEventId) === id) {\n            return this.redirectUser;\n        }\n        return null;\n    }\n    async _persistUserIfCurrent(user) {\n        if (user === this.currentUser) {\n            return this.queue(async () => this.directlySetCurrentUser(user));\n        }\n    }\n    /** Notifies listeners only if the user is current */\n    _notifyListenersIfCurrent(user) {\n        if (user === this.currentUser) {\n            this.notifyAuthListeners();\n        }\n    }\n    _key() {\n        return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`;\n    }\n    _startProactiveRefresh() {\n        this.isProactiveRefreshEnabled = true;\n        if (this.currentUser) {\n            this._currentUser._startProactiveRefresh();\n        }\n    }\n    _stopProactiveRefresh() {\n        this.isProactiveRefreshEnabled = false;\n        if (this.currentUser) {\n            this._currentUser._stopProactiveRefresh();\n        }\n    }\n    /** Returns the current user cast as the internal type */\n    get _currentUser() {\n        return this.currentUser;\n    }\n    notifyAuthListeners() {\n        var _a, _b;\n        if (!this._isInitialized) {\n            return;\n        }\n        this.idTokenSubscription.next(this.currentUser);\n        const currentUid = (_b = (_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.uid) !== null && _b !== void 0 ? _b : null;\n        if (this.lastNotifiedUid !== currentUid) {\n            this.lastNotifiedUid = currentUid;\n            this.authStateSubscription.next(this.currentUser);\n        }\n    }\n    registerStateListener(subscription, nextOrObserver, error, completed) {\n        if (this._deleted) {\n            return () => { };\n        }\n        const cb = typeof nextOrObserver === 'function'\n            ? nextOrObserver\n            : nextOrObserver.next.bind(nextOrObserver);\n        let isUnsubscribed = false;\n        const promise = this._isInitialized\n            ? Promise.resolve()\n            : this._initializationPromise;\n        _assert(promise, this, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        // The callback needs to be called asynchronously per the spec.\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        promise.then(() => {\n            if (isUnsubscribed) {\n                return;\n            }\n            cb(this.currentUser);\n        });\n        if (typeof nextOrObserver === 'function') {\n            const unsubscribe = subscription.addObserver(nextOrObserver, error, completed);\n            return () => {\n                isUnsubscribed = true;\n                unsubscribe();\n            };\n        }\n        else {\n            const unsubscribe = subscription.addObserver(nextOrObserver);\n            return () => {\n                isUnsubscribed = true;\n                unsubscribe();\n            };\n        }\n    }\n    /**\n     * Unprotected (from race conditions) method to set the current user. This\n     * should only be called from within a queued callback. This is necessary\n     * because the queue shouldn't rely on another queued callback.\n     */\n    async directlySetCurrentUser(user) {\n        if (this.currentUser && this.currentUser !== user) {\n            this._currentUser._stopProactiveRefresh();\n        }\n        if (user && this.isProactiveRefreshEnabled) {\n            user._startProactiveRefresh();\n        }\n        this.currentUser = user;\n        if (user) {\n            await this.assertedPersistence.setCurrentUser(user);\n        }\n        else {\n            await this.assertedPersistence.removeCurrentUser();\n        }\n    }\n    queue(action) {\n        // In case something errors, the callback still should be called in order\n        // to keep the promise chain alive\n        this.operations = this.operations.then(action, action);\n        return this.operations;\n    }\n    get assertedPersistence() {\n        _assert(this.persistenceManager, this, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        return this.persistenceManager;\n    }\n    _logFramework(framework) {\n        if (!framework || this.frameworks.includes(framework)) {\n            return;\n        }\n        this.frameworks.push(framework);\n        // Sort alphabetically so that \"FirebaseCore-web,FirebaseUI-web\" and\n        // \"FirebaseUI-web,FirebaseCore-web\" aren't viewed as different.\n        this.frameworks.sort();\n        this.clientVersion = _getClientVersion(this.config.clientPlatform, this._getFrameworks());\n    }\n    _getFrameworks() {\n        return this.frameworks;\n    }\n    async _getAdditionalHeaders() {\n        var _a;\n        // Additional headers on every request\n        const headers = {\n            [\"X-Client-Version\" /* HttpHeader.X_CLIENT_VERSION */]: this.clientVersion\n        };\n        if (this.app.options.appId) {\n            headers[\"X-Firebase-gmpid\" /* HttpHeader.X_FIREBASE_GMPID */] = this.app.options.appId;\n        }\n        // If the heartbeat service exists, add the heartbeat string\n        const heartbeatsHeader = await ((_a = this.heartbeatServiceProvider\n            .getImmediate({\n            optional: true\n        })) === null || _a === void 0 ? void 0 : _a.getHeartbeatsHeader());\n        if (heartbeatsHeader) {\n            headers[\"X-Firebase-Client\" /* HttpHeader.X_FIREBASE_CLIENT */] = heartbeatsHeader;\n        }\n        // If the App Check service exists, add the App Check token in the headers\n        const appCheckToken = await this._getAppCheckToken();\n        if (appCheckToken) {\n            headers[\"X-Firebase-AppCheck\" /* HttpHeader.X_FIREBASE_APP_CHECK */] = appCheckToken;\n        }\n        return headers;\n    }\n    async _getAppCheckToken() {\n        var _a;\n        const appCheckTokenResult = await ((_a = this.appCheckServiceProvider\n            .getImmediate({ optional: true })) === null || _a === void 0 ? void 0 : _a.getToken());\n        if (appCheckTokenResult === null || appCheckTokenResult === void 0 ? void 0 : appCheckTokenResult.error) {\n            // Context: appCheck.getToken() will never throw even if an error happened.\n            // In the error case, a dummy token will be returned along with an error field describing\n            // the error. In general, we shouldn't care about the error condition and just use\n            // the token (actual or dummy) to send requests.\n            _logWarn(`Error while retrieving App Check token: ${appCheckTokenResult.error}`);\n        }\n        return appCheckTokenResult === null || appCheckTokenResult === void 0 ? void 0 : appCheckTokenResult.token;\n    }\n}\n/**\n * Method to be used to cast down to our private implementation of Auth.\n * It will also handle unwrapping from the compat type if necessary\n *\n * @param auth Auth object passed in from developer\n */\nfunction _castAuth(auth) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth);\n}\n/** Helper class to wrap subscriber logic */\nclass Subscription {\n    constructor(auth) {\n        this.auth = auth;\n        this.observer = null;\n        this.addObserver = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.createSubscribe)(observer => (this.observer = observer));\n    }\n    get next() {\n        _assert(this.observer, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        return this.observer.next.bind(this.observer);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nlet externalJSProvider = {\n    async loadJS() {\n        throw new Error('Unable to load external scripts');\n    },\n    recaptchaV2Script: '',\n    recaptchaEnterpriseScript: '',\n    gapiScript: ''\n};\nfunction _loadJS(url) {\n    return externalJSProvider.loadJS(url);\n}\nfunction _recaptchaEnterpriseScriptUrl() {\n    return externalJSProvider.recaptchaEnterpriseScript;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MockGreCAPTCHATopLevel {\n    constructor() {\n        this.enterprise = new MockGreCAPTCHA();\n    }\n    ready(callback) {\n        callback();\n    }\n    execute(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _siteKey, _options) {\n        return Promise.resolve('token');\n    }\n    render(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _container, _parameters) {\n        return '';\n    }\n}\nclass MockGreCAPTCHA {\n    ready(callback) {\n        callback();\n    }\n    execute(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _siteKey, _options) {\n        return Promise.resolve('token');\n    }\n    render(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _container, _parameters) {\n        return '';\n    }\n}\n\n/* eslint-disable @typescript-eslint/no-require-imports */\nconst RECAPTCHA_ENTERPRISE_VERIFIER_TYPE = 'recaptcha-enterprise';\nconst FAKE_TOKEN = 'NO_RECAPTCHA';\nclass RecaptchaEnterpriseVerifier {\n    /**\n     *\n     * @param authExtern - The corresponding Firebase {@link Auth} instance.\n     *\n     */\n    constructor(authExtern) {\n        /**\n         * Identifies the type of application verifier (e.g. \"recaptcha-enterprise\").\n         */\n        this.type = RECAPTCHA_ENTERPRISE_VERIFIER_TYPE;\n        this.auth = _castAuth(authExtern);\n    }\n    /**\n     * Executes the verification process.\n     *\n     * @returns A Promise for a token that can be used to assert the validity of a request.\n     */\n    async verify(action = 'verify', forceRefresh = false) {\n        async function retrieveSiteKey(auth) {\n            if (!forceRefresh) {\n                if (auth.tenantId == null && auth._agentRecaptchaConfig != null) {\n                    return auth._agentRecaptchaConfig.siteKey;\n                }\n                if (auth.tenantId != null &&\n                    auth._tenantRecaptchaConfigs[auth.tenantId] !== undefined) {\n                    return auth._tenantRecaptchaConfigs[auth.tenantId].siteKey;\n                }\n            }\n            return new Promise(async (resolve, reject) => {\n                getRecaptchaConfig(auth, {\n                    clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */,\n                    version: \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */\n                })\n                    .then(response => {\n                    if (response.recaptchaKey === undefined) {\n                        reject(new Error('recaptcha Enterprise site key undefined'));\n                    }\n                    else {\n                        const config = new RecaptchaConfig(response);\n                        if (auth.tenantId == null) {\n                            auth._agentRecaptchaConfig = config;\n                        }\n                        else {\n                            auth._tenantRecaptchaConfigs[auth.tenantId] = config;\n                        }\n                        return resolve(config.siteKey);\n                    }\n                })\n                    .catch(error => {\n                    reject(error);\n                });\n            });\n        }\n        function retrieveRecaptchaToken(siteKey, resolve, reject) {\n            const grecaptcha = window.grecaptcha;\n            if (isEnterprise(grecaptcha)) {\n                grecaptcha.enterprise.ready(() => {\n                    grecaptcha.enterprise\n                        .execute(siteKey, { action })\n                        .then(token => {\n                        resolve(token);\n                    })\n                        .catch(() => {\n                        resolve(FAKE_TOKEN);\n                    });\n                });\n            }\n            else {\n                reject(Error('No reCAPTCHA enterprise script loaded.'));\n            }\n        }\n        // Returns Promise for a mock token when appVerificationDisabledForTesting is true.\n        if (this.auth.settings.appVerificationDisabledForTesting) {\n            const mockRecaptcha = new MockGreCAPTCHATopLevel();\n            return mockRecaptcha.execute('siteKey', { action: 'verify' });\n        }\n        return new Promise((resolve, reject) => {\n            retrieveSiteKey(this.auth)\n                .then(siteKey => {\n                if (!forceRefresh && isEnterprise(window.grecaptcha)) {\n                    retrieveRecaptchaToken(siteKey, resolve, reject);\n                }\n                else {\n                    if (typeof window === 'undefined') {\n                        reject(new Error('RecaptchaVerifier is only supported in browser'));\n                        return;\n                    }\n                    let url = _recaptchaEnterpriseScriptUrl();\n                    if (url.length !== 0) {\n                        url += siteKey;\n                    }\n                    _loadJS(url)\n                        .then(() => {\n                        retrieveRecaptchaToken(siteKey, resolve, reject);\n                    })\n                        .catch(error => {\n                        reject(error);\n                    });\n                }\n            })\n                .catch(error => {\n                reject(error);\n            });\n        });\n    }\n}\nasync function injectRecaptchaFields(auth, request, action, isCaptchaResp = false, isFakeToken = false) {\n    const verifier = new RecaptchaEnterpriseVerifier(auth);\n    let captchaResponse;\n    if (isFakeToken) {\n        captchaResponse = FAKE_TOKEN;\n    }\n    else {\n        try {\n            captchaResponse = await verifier.verify(action);\n        }\n        catch (error) {\n            captchaResponse = await verifier.verify(action, true);\n        }\n    }\n    const newRequest = Object.assign({}, request);\n    if (action === \"mfaSmsEnrollment\" /* RecaptchaActionName.MFA_SMS_ENROLLMENT */ ||\n        action === \"mfaSmsSignIn\" /* RecaptchaActionName.MFA_SMS_SIGNIN */) {\n        if ('phoneEnrollmentInfo' in newRequest) {\n            const phoneNumber = newRequest.phoneEnrollmentInfo.phoneNumber;\n            const recaptchaToken = newRequest.phoneEnrollmentInfo.recaptchaToken;\n            Object.assign(newRequest, {\n                'phoneEnrollmentInfo': {\n                    phoneNumber,\n                    recaptchaToken,\n                    captchaResponse,\n                    'clientType': \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */,\n                    'recaptchaVersion': \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */\n                }\n            });\n        }\n        else if ('phoneSignInInfo' in newRequest) {\n            const recaptchaToken = newRequest.phoneSignInInfo.recaptchaToken;\n            Object.assign(newRequest, {\n                'phoneSignInInfo': {\n                    recaptchaToken,\n                    captchaResponse,\n                    'clientType': \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */,\n                    'recaptchaVersion': \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */\n                }\n            });\n        }\n        return newRequest;\n    }\n    if (!isCaptchaResp) {\n        Object.assign(newRequest, { captchaResponse });\n    }\n    else {\n        Object.assign(newRequest, { 'captchaResp': captchaResponse });\n    }\n    Object.assign(newRequest, { 'clientType': \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */ });\n    Object.assign(newRequest, {\n        'recaptchaVersion': \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */\n    });\n    return newRequest;\n}\nasync function handleRecaptchaFlow(authInstance, request, actionName, actionMethod, recaptchaAuthProvider) {\n    var _a, _b;\n    if (recaptchaAuthProvider === \"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */) {\n        if ((_a = authInstance\n            ._getRecaptchaConfig()) === null || _a === void 0 ? void 0 : _a.isProviderEnabled(\"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */)) {\n            const requestWithRecaptcha = await injectRecaptchaFields(authInstance, request, actionName, actionName === \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */);\n            return actionMethod(authInstance, requestWithRecaptcha);\n        }\n        else {\n            return actionMethod(authInstance, request).catch(async (error) => {\n                if (error.code === `auth/${\"missing-recaptcha-token\" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */}`) {\n                    console.log(`${actionName} is protected by reCAPTCHA Enterprise for this project. Automatically triggering the reCAPTCHA flow and restarting the flow.`);\n                    const requestWithRecaptcha = await injectRecaptchaFields(authInstance, request, actionName, actionName === \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */);\n                    return actionMethod(authInstance, requestWithRecaptcha);\n                }\n                else {\n                    return Promise.reject(error);\n                }\n            });\n        }\n    }\n    else if (recaptchaAuthProvider === \"PHONE_PROVIDER\" /* RecaptchaAuthProvider.PHONE_PROVIDER */) {\n        if ((_b = authInstance\n            ._getRecaptchaConfig()) === null || _b === void 0 ? void 0 : _b.isProviderEnabled(\"PHONE_PROVIDER\" /* RecaptchaAuthProvider.PHONE_PROVIDER */)) {\n            const requestWithRecaptcha = await injectRecaptchaFields(authInstance, request, actionName);\n            return actionMethod(authInstance, requestWithRecaptcha).catch(async (error) => {\n                var _a;\n                if (((_a = authInstance\n                    ._getRecaptchaConfig()) === null || _a === void 0 ? void 0 : _a.getProviderEnforcementState(\"PHONE_PROVIDER\" /* RecaptchaAuthProvider.PHONE_PROVIDER */)) === \"AUDIT\" /* EnforcementState.AUDIT */) {\n                    // AUDIT mode\n                    if (error.code === `auth/${\"missing-recaptcha-token\" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */}` ||\n                        error.code === `auth/${\"invalid-app-credential\" /* AuthErrorCode.INVALID_APP_CREDENTIAL */}`) {\n                        console.log(`Failed to verify with reCAPTCHA Enterprise. Automatically triggering the reCAPTCHA v2 flow to complete the ${actionName} flow.`);\n                        // reCAPTCHA Enterprise token is missing or reCAPTCHA Enterprise token\n                        // check fails.\n                        // Fallback to reCAPTCHA v2 flow.\n                        const requestWithRecaptchaFields = await injectRecaptchaFields(authInstance, request, actionName, false, // isCaptchaResp\n                        true // isFakeToken\n                        );\n                        // This will call the PhoneApiCaller to fetch and inject reCAPTCHA v2 token.\n                        return actionMethod(authInstance, requestWithRecaptchaFields);\n                    }\n                }\n                // ENFORCE mode or AUDIT mode with any other error.\n                return Promise.reject(error);\n            });\n        }\n        else {\n            // Do reCAPTCHA v2 flow.\n            const requestWithRecaptchaFields = await injectRecaptchaFields(authInstance, request, actionName, false, // isCaptchaResp\n            true // isFakeToken\n            );\n            // This will call the PhoneApiCaller to fetch and inject v2 token.\n            return actionMethod(authInstance, requestWithRecaptchaFields);\n        }\n    }\n    else {\n        return Promise.reject(recaptchaAuthProvider + ' provider is not supported.');\n    }\n}\nasync function _initializeRecaptchaConfig(auth) {\n    const authInternal = _castAuth(auth);\n    const response = await getRecaptchaConfig(authInternal, {\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */,\n        version: \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */\n    });\n    const config = new RecaptchaConfig(response);\n    if (authInternal.tenantId == null) {\n        authInternal._agentRecaptchaConfig = config;\n    }\n    else {\n        authInternal._tenantRecaptchaConfigs[authInternal.tenantId] = config;\n    }\n    if (config.isAnyProviderEnabled()) {\n        const verifier = new RecaptchaEnterpriseVerifier(authInternal);\n        void verifier.verify();\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Initializes an {@link Auth} instance with fine-grained control over\n * {@link Dependencies}.\n *\n * @remarks\n *\n * This function allows more control over the {@link Auth} instance than\n * {@link getAuth}. `getAuth` uses platform-specific defaults to supply\n * the {@link Dependencies}. In general, `getAuth` is the easiest way to\n * initialize Auth and works for most use cases. Use `initializeAuth` if you\n * need control over which persistence layer is used, or to minimize bundle\n * size if you're not using either `signInWithPopup` or `signInWithRedirect`.\n *\n * For example, if your app only uses anonymous accounts and you only want\n * accounts saved for the current session, initialize `Auth` with:\n *\n * ```js\n * const auth = initializeAuth(app, {\n *   persistence: browserSessionPersistence,\n *   popupRedirectResolver: undefined,\n * });\n * ```\n *\n * @public\n */\nfunction initializeAuth(app, deps) {\n    const provider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'auth');\n    if (provider.isInitialized()) {\n        const auth = provider.getImmediate();\n        const initialOptions = provider.getOptions();\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.deepEqual)(initialOptions, deps !== null && deps !== void 0 ? deps : {})) {\n            return auth;\n        }\n        else {\n            _fail(auth, \"already-initialized\" /* AuthErrorCode.ALREADY_INITIALIZED */);\n        }\n    }\n    const auth = provider.initialize({ options: deps });\n    return auth;\n}\nfunction _initializeAuthInstance(auth, deps) {\n    const persistence = (deps === null || deps === void 0 ? void 0 : deps.persistence) || [];\n    const hierarchy = (Array.isArray(persistence) ? persistence : [persistence]).map(_getInstance);\n    if (deps === null || deps === void 0 ? void 0 : deps.errorMap) {\n        auth._updateErrorMap(deps.errorMap);\n    }\n    // This promise is intended to float; auth initialization happens in the\n    // background, meanwhile the auth object may be used by the app.\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    auth._initializeWithPersistence(hierarchy, deps === null || deps === void 0 ? void 0 : deps.popupRedirectResolver);\n}\n\n/**\n * Changes the {@link Auth} instance to communicate with the Firebase Auth Emulator, instead of production\n * Firebase Auth services.\n *\n * @remarks\n * This must be called synchronously immediately following the first call to\n * {@link initializeAuth}.  Do not use with production credentials as emulator\n * traffic is not encrypted.\n *\n *\n * @example\n * ```javascript\n * connectAuthEmulator(auth, 'http://127.0.0.1:9099', { disableWarnings: true });\n * ```\n *\n * @param auth - The {@link Auth} instance.\n * @param url - The URL at which the emulator is running (eg, 'http://localhost:9099').\n * @param options - Optional. `options.disableWarnings` defaults to `false`. Set it to\n * `true` to disable the warning banner attached to the DOM.\n *\n * @public\n */\nfunction connectAuthEmulator(auth, url, options) {\n    const authInternal = _castAuth(auth);\n    _assert(authInternal._canInitEmulator, authInternal, \"emulator-config-failed\" /* AuthErrorCode.EMULATOR_CONFIG_FAILED */);\n    _assert(/^https?:\\/\\//.test(url), authInternal, \"invalid-emulator-scheme\" /* AuthErrorCode.INVALID_EMULATOR_SCHEME */);\n    const disableWarnings = !!(options === null || options === void 0 ? void 0 : options.disableWarnings);\n    const protocol = extractProtocol(url);\n    const { host, port } = extractHostAndPort(url);\n    const portStr = port === null ? '' : `:${port}`;\n    // Always replace path with \"/\" (even if input url had no path at all, or had a different one).\n    authInternal.config.emulator = { url: `${protocol}//${host}${portStr}/` };\n    authInternal.settings.appVerificationDisabledForTesting = true;\n    authInternal.emulatorConfig = Object.freeze({\n        host,\n        port,\n        protocol: protocol.replace(':', ''),\n        options: Object.freeze({ disableWarnings })\n    });\n    if (!disableWarnings) {\n        emitEmulatorWarning();\n    }\n}\nfunction extractProtocol(url) {\n    const protocolEnd = url.indexOf(':');\n    return protocolEnd < 0 ? '' : url.substr(0, protocolEnd + 1);\n}\nfunction extractHostAndPort(url) {\n    const protocol = extractProtocol(url);\n    const authority = /(\\/\\/)?([^?#/]+)/.exec(url.substr(protocol.length)); // Between // and /, ? or #.\n    if (!authority) {\n        return { host: '', port: null };\n    }\n    const hostAndPort = authority[2].split('@').pop() || ''; // Strip out \"username:password@\".\n    const bracketedIPv6 = /^(\\[[^\\]]+\\])(:|$)/.exec(hostAndPort);\n    if (bracketedIPv6) {\n        const host = bracketedIPv6[1];\n        return { host, port: parsePort(hostAndPort.substr(host.length + 1)) };\n    }\n    else {\n        const [host, port] = hostAndPort.split(':');\n        return { host, port: parsePort(port) };\n    }\n}\nfunction parsePort(portStr) {\n    if (!portStr) {\n        return null;\n    }\n    const port = Number(portStr);\n    if (isNaN(port)) {\n        return null;\n    }\n    return port;\n}\nfunction emitEmulatorWarning() {\n    function attachBanner() {\n        const el = document.createElement('p');\n        const sty = el.style;\n        el.innerText =\n            'Running in emulator mode. Do not use with production credentials.';\n        sty.position = 'fixed';\n        sty.width = '100%';\n        sty.backgroundColor = '#ffffff';\n        sty.border = '.1em solid #000000';\n        sty.color = '#b50000';\n        sty.bottom = '0px';\n        sty.left = '0px';\n        sty.margin = '0px';\n        sty.zIndex = '10000';\n        sty.textAlign = 'center';\n        el.classList.add('firebase-emulator-warning');\n        document.body.appendChild(el);\n    }\n    if (typeof console !== 'undefined' && typeof console.info === 'function') {\n        console.info('WARNING: You are using the Auth Emulator,' +\n            ' which is intended for local testing only.  Do not use with' +\n            ' production credentials.');\n    }\n    if (typeof window !== 'undefined' && typeof document !== 'undefined') {\n        if (document.readyState === 'loading') {\n            window.addEventListener('DOMContentLoaded', attachBanner);\n        }\n        else {\n            attachBanner();\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Interface that represents the credentials returned by an {@link AuthProvider}.\n *\n * @remarks\n * Implementations specify the details about each auth provider's credential requirements.\n *\n * @public\n */\nclass AuthCredential {\n    /** @internal */\n    constructor(\n    /**\n     * The authentication provider ID for the credential.\n     *\n     * @remarks\n     * For example, 'facebook.com', or 'google.com'.\n     */\n    providerId, \n    /**\n     * The authentication sign in method for the credential.\n     *\n     * @remarks\n     * For example, {@link SignInMethod}.EMAIL_PASSWORD, or\n     * {@link SignInMethod}.EMAIL_LINK. This corresponds to the sign-in method\n     * identifier as returned in {@link fetchSignInMethodsForEmail}.\n     */\n    signInMethod) {\n        this.providerId = providerId;\n        this.signInMethod = signInMethod;\n    }\n    /**\n     * Returns a JSON-serializable representation of this object.\n     *\n     * @returns a JSON-serializable representation of this object.\n     */\n    toJSON() {\n        return debugFail('not implemented');\n    }\n    /** @internal */\n    _getIdTokenResponse(_auth) {\n        return debugFail('not implemented');\n    }\n    /** @internal */\n    _linkToIdToken(_auth, _idToken) {\n        return debugFail('not implemented');\n    }\n    /** @internal */\n    _getReauthenticationResolver(_auth) {\n        return debugFail('not implemented');\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function resetPassword(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:resetPassword\" /* Endpoint.RESET_PASSWORD */, _addTidIfNecessary(auth, request));\n}\nasync function updateEmailPassword(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */, request);\n}\n// Used for linking an email/password account to an existing idToken. Uses the same request/response\n// format as updateEmailPassword.\nasync function linkEmailPassword(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signUp\" /* Endpoint.SIGN_UP */, request);\n}\nasync function applyActionCode$1(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function signInWithPassword(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithPassword\" /* Endpoint.SIGN_IN_WITH_PASSWORD */, _addTidIfNecessary(auth, request));\n}\nasync function sendOobCode(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:sendOobCode\" /* Endpoint.SEND_OOB_CODE */, _addTidIfNecessary(auth, request));\n}\nasync function sendEmailVerification$1(auth, request) {\n    return sendOobCode(auth, request);\n}\nasync function sendPasswordResetEmail$1(auth, request) {\n    return sendOobCode(auth, request);\n}\nasync function sendSignInLinkToEmail$1(auth, request) {\n    return sendOobCode(auth, request);\n}\nasync function verifyAndChangeEmail(auth, request) {\n    return sendOobCode(auth, request);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function signInWithEmailLink$1(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithEmailLink\" /* Endpoint.SIGN_IN_WITH_EMAIL_LINK */, _addTidIfNecessary(auth, request));\n}\nasync function signInWithEmailLinkForLinking(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithEmailLink\" /* Endpoint.SIGN_IN_WITH_EMAIL_LINK */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Interface that represents the credentials returned by {@link EmailAuthProvider} for\n * {@link ProviderId}.PASSWORD\n *\n * @remarks\n * Covers both {@link SignInMethod}.EMAIL_PASSWORD and\n * {@link SignInMethod}.EMAIL_LINK.\n *\n * @public\n */\nclass EmailAuthCredential extends AuthCredential {\n    /** @internal */\n    constructor(\n    /** @internal */\n    _email, \n    /** @internal */\n    _password, signInMethod, \n    /** @internal */\n    _tenantId = null) {\n        super(\"password\" /* ProviderId.PASSWORD */, signInMethod);\n        this._email = _email;\n        this._password = _password;\n        this._tenantId = _tenantId;\n    }\n    /** @internal */\n    static _fromEmailAndPassword(email, password) {\n        return new EmailAuthCredential(email, password, \"password\" /* SignInMethod.EMAIL_PASSWORD */);\n    }\n    /** @internal */\n    static _fromEmailAndCode(email, oobCode, tenantId = null) {\n        return new EmailAuthCredential(email, oobCode, \"emailLink\" /* SignInMethod.EMAIL_LINK */, tenantId);\n    }\n    /** {@inheritdoc AuthCredential.toJSON} */\n    toJSON() {\n        return {\n            email: this._email,\n            password: this._password,\n            signInMethod: this.signInMethod,\n            tenantId: this._tenantId\n        };\n    }\n    /**\n     * Static method to deserialize a JSON representation of an object into an {@link  AuthCredential}.\n     *\n     * @param json - Either `object` or the stringified representation of the object. When string is\n     * provided, `JSON.parse` would be called first.\n     *\n     * @returns If the JSON input does not represent an {@link AuthCredential}, null is returned.\n     */\n    static fromJSON(json) {\n        const obj = typeof json === 'string' ? JSON.parse(json) : json;\n        if ((obj === null || obj === void 0 ? void 0 : obj.email) && (obj === null || obj === void 0 ? void 0 : obj.password)) {\n            if (obj.signInMethod === \"password\" /* SignInMethod.EMAIL_PASSWORD */) {\n                return this._fromEmailAndPassword(obj.email, obj.password);\n            }\n            else if (obj.signInMethod === \"emailLink\" /* SignInMethod.EMAIL_LINK */) {\n                return this._fromEmailAndCode(obj.email, obj.password, obj.tenantId);\n            }\n        }\n        return null;\n    }\n    /** @internal */\n    async _getIdTokenResponse(auth) {\n        switch (this.signInMethod) {\n            case \"password\" /* SignInMethod.EMAIL_PASSWORD */:\n                const request = {\n                    returnSecureToken: true,\n                    email: this._email,\n                    password: this._password,\n                    clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */\n                };\n                return handleRecaptchaFlow(auth, request, \"signInWithPassword\" /* RecaptchaActionName.SIGN_IN_WITH_PASSWORD */, signInWithPassword, \"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */);\n            case \"emailLink\" /* SignInMethod.EMAIL_LINK */:\n                return signInWithEmailLink$1(auth, {\n                    email: this._email,\n                    oobCode: this._password\n                });\n            default:\n                _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        }\n    }\n    /** @internal */\n    async _linkToIdToken(auth, idToken) {\n        switch (this.signInMethod) {\n            case \"password\" /* SignInMethod.EMAIL_PASSWORD */:\n                const request = {\n                    idToken,\n                    returnSecureToken: true,\n                    email: this._email,\n                    password: this._password,\n                    clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */\n                };\n                return handleRecaptchaFlow(auth, request, \"signUpPassword\" /* RecaptchaActionName.SIGN_UP_PASSWORD */, linkEmailPassword, \"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */);\n            case \"emailLink\" /* SignInMethod.EMAIL_LINK */:\n                return signInWithEmailLinkForLinking(auth, {\n                    idToken,\n                    email: this._email,\n                    oobCode: this._password\n                });\n            default:\n                _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        }\n    }\n    /** @internal */\n    _getReauthenticationResolver(auth) {\n        return this._getIdTokenResponse(auth);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function signInWithIdp(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithIdp\" /* Endpoint.SIGN_IN_WITH_IDP */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst IDP_REQUEST_URI$1 = 'http://localhost';\n/**\n * Represents the OAuth credentials returned by an {@link OAuthProvider}.\n *\n * @remarks\n * Implementations specify the details about each auth provider's credential requirements.\n *\n * @public\n */\nclass OAuthCredential extends AuthCredential {\n    constructor() {\n        super(...arguments);\n        this.pendingToken = null;\n    }\n    /** @internal */\n    static _fromParams(params) {\n        const cred = new OAuthCredential(params.providerId, params.signInMethod);\n        if (params.idToken || params.accessToken) {\n            // OAuth 2 and either ID token or access token.\n            if (params.idToken) {\n                cred.idToken = params.idToken;\n            }\n            if (params.accessToken) {\n                cred.accessToken = params.accessToken;\n            }\n            // Add nonce if available and no pendingToken is present.\n            if (params.nonce && !params.pendingToken) {\n                cred.nonce = params.nonce;\n            }\n            if (params.pendingToken) {\n                cred.pendingToken = params.pendingToken;\n            }\n        }\n        else if (params.oauthToken && params.oauthTokenSecret) {\n            // OAuth 1 and OAuth token with token secret\n            cred.accessToken = params.oauthToken;\n            cred.secret = params.oauthTokenSecret;\n        }\n        else {\n            _fail(\"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        }\n        return cred;\n    }\n    /** {@inheritdoc AuthCredential.toJSON}  */\n    toJSON() {\n        return {\n            idToken: this.idToken,\n            accessToken: this.accessToken,\n            secret: this.secret,\n            nonce: this.nonce,\n            pendingToken: this.pendingToken,\n            providerId: this.providerId,\n            signInMethod: this.signInMethod\n        };\n    }\n    /**\n     * Static method to deserialize a JSON representation of an object into an\n     * {@link  AuthCredential}.\n     *\n     * @param json - Input can be either Object or the stringified representation of the object.\n     * When string is provided, JSON.parse would be called first.\n     *\n     * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.\n     */\n    static fromJSON(json) {\n        const obj = typeof json === 'string' ? JSON.parse(json) : json;\n        const { providerId, signInMethod } = obj, rest = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(obj, [\"providerId\", \"signInMethod\"]);\n        if (!providerId || !signInMethod) {\n            return null;\n        }\n        const cred = new OAuthCredential(providerId, signInMethod);\n        cred.idToken = rest.idToken || undefined;\n        cred.accessToken = rest.accessToken || undefined;\n        cred.secret = rest.secret;\n        cred.nonce = rest.nonce;\n        cred.pendingToken = rest.pendingToken || null;\n        return cred;\n    }\n    /** @internal */\n    _getIdTokenResponse(auth) {\n        const request = this.buildRequest();\n        return signInWithIdp(auth, request);\n    }\n    /** @internal */\n    _linkToIdToken(auth, idToken) {\n        const request = this.buildRequest();\n        request.idToken = idToken;\n        return signInWithIdp(auth, request);\n    }\n    /** @internal */\n    _getReauthenticationResolver(auth) {\n        const request = this.buildRequest();\n        request.autoCreate = false;\n        return signInWithIdp(auth, request);\n    }\n    buildRequest() {\n        const request = {\n            requestUri: IDP_REQUEST_URI$1,\n            returnSecureToken: true\n        };\n        if (this.pendingToken) {\n            request.pendingToken = this.pendingToken;\n        }\n        else {\n            const postBody = {};\n            if (this.idToken) {\n                postBody['id_token'] = this.idToken;\n            }\n            if (this.accessToken) {\n                postBody['access_token'] = this.accessToken;\n            }\n            if (this.secret) {\n                postBody['oauth_token_secret'] = this.secret;\n            }\n            postBody['providerId'] = this.providerId;\n            if (this.nonce && !this.pendingToken) {\n                postBody['nonce'] = this.nonce;\n            }\n            request.postBody = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystring)(postBody);\n        }\n        return request;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function signInWithPhoneNumber$1(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithPhoneNumber\" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */, _addTidIfNecessary(auth, request));\n}\nasync function linkWithPhoneNumber$1(auth, request) {\n    const response = await _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithPhoneNumber\" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */, _addTidIfNecessary(auth, request));\n    if (response.temporaryProof) {\n        throw _makeTaggedError(auth, \"account-exists-with-different-credential\" /* AuthErrorCode.NEED_CONFIRMATION */, response);\n    }\n    return response;\n}\nconst VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_ = {\n    [\"USER_NOT_FOUND\" /* ServerError.USER_NOT_FOUND */]: \"user-not-found\" /* AuthErrorCode.USER_DELETED */\n};\nasync function verifyPhoneNumberForExisting(auth, request) {\n    const apiRequest = Object.assign(Object.assign({}, request), { operation: 'REAUTH' });\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithPhoneNumber\" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */, _addTidIfNecessary(auth, apiRequest), VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents the credentials returned by {@link PhoneAuthProvider}.\n *\n * @public\n */\nclass PhoneAuthCredential extends AuthCredential {\n    constructor(params) {\n        super(\"phone\" /* ProviderId.PHONE */, \"phone\" /* SignInMethod.PHONE */);\n        this.params = params;\n    }\n    /** @internal */\n    static _fromVerification(verificationId, verificationCode) {\n        return new PhoneAuthCredential({ verificationId, verificationCode });\n    }\n    /** @internal */\n    static _fromTokenResponse(phoneNumber, temporaryProof) {\n        return new PhoneAuthCredential({ phoneNumber, temporaryProof });\n    }\n    /** @internal */\n    _getIdTokenResponse(auth) {\n        return signInWithPhoneNumber$1(auth, this._makeVerificationRequest());\n    }\n    /** @internal */\n    _linkToIdToken(auth, idToken) {\n        return linkWithPhoneNumber$1(auth, Object.assign({ idToken }, this._makeVerificationRequest()));\n    }\n    /** @internal */\n    _getReauthenticationResolver(auth) {\n        return verifyPhoneNumberForExisting(auth, this._makeVerificationRequest());\n    }\n    /** @internal */\n    _makeVerificationRequest() {\n        const { temporaryProof, phoneNumber, verificationId, verificationCode } = this.params;\n        if (temporaryProof && phoneNumber) {\n            return { temporaryProof, phoneNumber };\n        }\n        return {\n            sessionInfo: verificationId,\n            code: verificationCode\n        };\n    }\n    /** {@inheritdoc AuthCredential.toJSON} */\n    toJSON() {\n        const obj = {\n            providerId: this.providerId\n        };\n        if (this.params.phoneNumber) {\n            obj.phoneNumber = this.params.phoneNumber;\n        }\n        if (this.params.temporaryProof) {\n            obj.temporaryProof = this.params.temporaryProof;\n        }\n        if (this.params.verificationCode) {\n            obj.verificationCode = this.params.verificationCode;\n        }\n        if (this.params.verificationId) {\n            obj.verificationId = this.params.verificationId;\n        }\n        return obj;\n    }\n    /** Generates a phone credential based on a plain object or a JSON string. */\n    static fromJSON(json) {\n        if (typeof json === 'string') {\n            json = JSON.parse(json);\n        }\n        const { verificationId, verificationCode, phoneNumber, temporaryProof } = json;\n        if (!verificationCode &&\n            !verificationId &&\n            !phoneNumber &&\n            !temporaryProof) {\n            return null;\n        }\n        return new PhoneAuthCredential({\n            verificationId,\n            verificationCode,\n            phoneNumber,\n            temporaryProof\n        });\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Maps the mode string in action code URL to Action Code Info operation.\n *\n * @param mode\n */\nfunction parseMode(mode) {\n    switch (mode) {\n        case 'recoverEmail':\n            return \"RECOVER_EMAIL\" /* ActionCodeOperation.RECOVER_EMAIL */;\n        case 'resetPassword':\n            return \"PASSWORD_RESET\" /* ActionCodeOperation.PASSWORD_RESET */;\n        case 'signIn':\n            return \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */;\n        case 'verifyEmail':\n            return \"VERIFY_EMAIL\" /* ActionCodeOperation.VERIFY_EMAIL */;\n        case 'verifyAndChangeEmail':\n            return \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */;\n        case 'revertSecondFactorAddition':\n            return \"REVERT_SECOND_FACTOR_ADDITION\" /* ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION */;\n        default:\n            return null;\n    }\n}\n/**\n * Helper to parse FDL links\n *\n * @param url\n */\nfunction parseDeepLink(url) {\n    const link = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(url))['link'];\n    // Double link case (automatic redirect).\n    const doubleDeepLink = link\n        ? (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(link))['deep_link_id']\n        : null;\n    // iOS custom scheme links.\n    const iOSDeepLink = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(url))['deep_link_id'];\n    const iOSDoubleDeepLink = iOSDeepLink\n        ? (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(iOSDeepLink))['link']\n        : null;\n    return iOSDoubleDeepLink || iOSDeepLink || doubleDeepLink || link || url;\n}\n/**\n * A utility class to parse email action URLs such as password reset, email verification,\n * email link sign in, etc.\n *\n * @public\n */\nclass ActionCodeURL {\n    /**\n     * @param actionLink - The link from which to extract the URL.\n     * @returns The {@link ActionCodeURL} object, or null if the link is invalid.\n     *\n     * @internal\n     */\n    constructor(actionLink) {\n        var _a, _b, _c, _d, _e, _f;\n        const searchParams = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(actionLink));\n        const apiKey = (_a = searchParams[\"apiKey\" /* QueryField.API_KEY */]) !== null && _a !== void 0 ? _a : null;\n        const code = (_b = searchParams[\"oobCode\" /* QueryField.CODE */]) !== null && _b !== void 0 ? _b : null;\n        const operation = parseMode((_c = searchParams[\"mode\" /* QueryField.MODE */]) !== null && _c !== void 0 ? _c : null);\n        // Validate API key, code and mode.\n        _assert(apiKey && code && operation, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        this.apiKey = apiKey;\n        this.operation = operation;\n        this.code = code;\n        this.continueUrl = (_d = searchParams[\"continueUrl\" /* QueryField.CONTINUE_URL */]) !== null && _d !== void 0 ? _d : null;\n        this.languageCode = (_e = searchParams[\"languageCode\" /* QueryField.LANGUAGE_CODE */]) !== null && _e !== void 0 ? _e : null;\n        this.tenantId = (_f = searchParams[\"tenantId\" /* QueryField.TENANT_ID */]) !== null && _f !== void 0 ? _f : null;\n    }\n    /**\n     * Parses the email action link string and returns an {@link ActionCodeURL} if the link is valid,\n     * otherwise returns null.\n     *\n     * @param link  - The email action link string.\n     * @returns The {@link ActionCodeURL} object, or null if the link is invalid.\n     *\n     * @public\n     */\n    static parseLink(link) {\n        const actionLink = parseDeepLink(link);\n        try {\n            return new ActionCodeURL(actionLink);\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n}\n/**\n * Parses the email action link string and returns an {@link ActionCodeURL} if\n * the link is valid, otherwise returns null.\n *\n * @public\n */\nfunction parseActionCodeURL(link) {\n    return ActionCodeURL.parseLink(link);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for generating {@link EmailAuthCredential}.\n *\n * @public\n */\nclass EmailAuthProvider {\n    constructor() {\n        /**\n         * Always set to {@link ProviderId}.PASSWORD, even for email link.\n         */\n        this.providerId = EmailAuthProvider.PROVIDER_ID;\n    }\n    /**\n     * Initialize an {@link AuthCredential} using an email and password.\n     *\n     * @example\n     * ```javascript\n     * const authCredential = EmailAuthProvider.credential(email, password);\n     * const userCredential = await signInWithCredential(auth, authCredential);\n     * ```\n     *\n     * @example\n     * ```javascript\n     * const userCredential = await signInWithEmailAndPassword(auth, email, password);\n     * ```\n     *\n     * @param email - Email address.\n     * @param password - User account password.\n     * @returns The auth provider credential.\n     */\n    static credential(email, password) {\n        return EmailAuthCredential._fromEmailAndPassword(email, password);\n    }\n    /**\n     * Initialize an {@link AuthCredential} using an email and an email link after a sign in with\n     * email link operation.\n     *\n     * @example\n     * ```javascript\n     * const authCredential = EmailAuthProvider.credentialWithLink(auth, email, emailLink);\n     * const userCredential = await signInWithCredential(auth, authCredential);\n     * ```\n     *\n     * @example\n     * ```javascript\n     * await sendSignInLinkToEmail(auth, email);\n     * // Obtain emailLink from user.\n     * const userCredential = await signInWithEmailLink(auth, email, emailLink);\n     * ```\n     *\n     * @param auth - The {@link Auth} instance used to verify the link.\n     * @param email - Email address.\n     * @param emailLink - Sign-in email link.\n     * @returns - The auth provider credential.\n     */\n    static credentialWithLink(email, emailLink) {\n        const actionCodeUrl = ActionCodeURL.parseLink(emailLink);\n        _assert(actionCodeUrl, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        return EmailAuthCredential._fromEmailAndCode(email, actionCodeUrl.code, actionCodeUrl.tenantId);\n    }\n}\n/**\n * Always set to {@link ProviderId}.PASSWORD, even for email link.\n */\nEmailAuthProvider.PROVIDER_ID = \"password\" /* ProviderId.PASSWORD */;\n/**\n * Always set to {@link SignInMethod}.EMAIL_PASSWORD.\n */\nEmailAuthProvider.EMAIL_PASSWORD_SIGN_IN_METHOD = \"password\" /* SignInMethod.EMAIL_PASSWORD */;\n/**\n * Always set to {@link SignInMethod}.EMAIL_LINK.\n */\nEmailAuthProvider.EMAIL_LINK_SIGN_IN_METHOD = \"emailLink\" /* SignInMethod.EMAIL_LINK */;\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The base class for all Federated providers (OAuth (including OIDC), SAML).\n *\n * This class is not meant to be instantiated directly.\n *\n * @public\n */\nclass FederatedAuthProvider {\n    /**\n     * Constructor for generic OAuth providers.\n     *\n     * @param providerId - Provider for which credentials should be generated.\n     */\n    constructor(providerId) {\n        this.providerId = providerId;\n        /** @internal */\n        this.defaultLanguageCode = null;\n        /** @internal */\n        this.customParameters = {};\n    }\n    /**\n     * Set the language gode.\n     *\n     * @param languageCode - language code\n     */\n    setDefaultLanguage(languageCode) {\n        this.defaultLanguageCode = languageCode;\n    }\n    /**\n     * Sets the OAuth custom parameters to pass in an OAuth request for popup and redirect sign-in\n     * operations.\n     *\n     * @remarks\n     * For a detailed list, check the reserved required OAuth 2.0 parameters such as `client_id`,\n     * `redirect_uri`, `scope`, `response_type`, and `state` are not allowed and will be ignored.\n     *\n     * @param customOAuthParameters - The custom OAuth parameters to pass in the OAuth request.\n     */\n    setCustomParameters(customOAuthParameters) {\n        this.customParameters = customOAuthParameters;\n        return this;\n    }\n    /**\n     * Retrieve the current list of {@link CustomParameters}.\n     */\n    getCustomParameters() {\n        return this.customParameters;\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Common code to all OAuth providers. This is separate from the\n * {@link OAuthProvider} so that child providers (like\n * {@link GoogleAuthProvider}) don't inherit the `credential` instance method.\n * Instead, they rely on a static `credential` method.\n */\nclass BaseOAuthProvider extends FederatedAuthProvider {\n    constructor() {\n        super(...arguments);\n        /** @internal */\n        this.scopes = [];\n    }\n    /**\n     * Add an OAuth scope to the credential.\n     *\n     * @param scope - Provider OAuth scope to add.\n     */\n    addScope(scope) {\n        // If not already added, add scope to list.\n        if (!this.scopes.includes(scope)) {\n            this.scopes.push(scope);\n        }\n        return this;\n    }\n    /**\n     * Retrieve the current list of OAuth scopes.\n     */\n    getScopes() {\n        return [...this.scopes];\n    }\n}\n/**\n * Provider for generating generic {@link OAuthCredential}.\n *\n * @example\n * ```javascript\n * // Sign in using a redirect.\n * const provider = new OAuthProvider('google.com');\n * // Start a sign in process for an unauthenticated user.\n * provider.addScope('profile');\n * provider.addScope('email');\n * await signInWithRedirect(auth, provider);\n * // This will trigger a full page redirect away from your app\n *\n * // After returning from the redirect when your app initializes you can obtain the result\n * const result = await getRedirectResult(auth);\n * if (result) {\n *   // This is the signed-in user\n *   const user = result.user;\n *   // This gives you a OAuth Access Token for the provider.\n *   const credential = provider.credentialFromResult(auth, result);\n *   const token = credential.accessToken;\n * }\n * ```\n *\n * @example\n * ```javascript\n * // Sign in using a popup.\n * const provider = new OAuthProvider('google.com');\n * provider.addScope('profile');\n * provider.addScope('email');\n * const result = await signInWithPopup(auth, provider);\n *\n * // The signed-in user info.\n * const user = result.user;\n * // This gives you a OAuth Access Token for the provider.\n * const credential = provider.credentialFromResult(auth, result);\n * const token = credential.accessToken;\n * ```\n * @public\n */\nclass OAuthProvider extends BaseOAuthProvider {\n    /**\n     * Creates an {@link OAuthCredential} from a JSON string or a plain object.\n     * @param json - A plain object or a JSON string\n     */\n    static credentialFromJSON(json) {\n        const obj = typeof json === 'string' ? JSON.parse(json) : json;\n        _assert('providerId' in obj && 'signInMethod' in obj, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        return OAuthCredential._fromParams(obj);\n    }\n    /**\n     * Creates a {@link OAuthCredential} from a generic OAuth provider's access token or ID token.\n     *\n     * @remarks\n     * The raw nonce is required when an ID token with a nonce field is provided. The SHA-256 hash of\n     * the raw nonce must match the nonce field in the ID token.\n     *\n     * @example\n     * ```javascript\n     * // `googleUser` from the onsuccess Google Sign In callback.\n     * // Initialize a generate OAuth provider with a `google.com` providerId.\n     * const provider = new OAuthProvider('google.com');\n     * const credential = provider.credential({\n     *   idToken: googleUser.getAuthResponse().id_token,\n     * });\n     * const result = await signInWithCredential(credential);\n     * ```\n     *\n     * @param params - Either the options object containing the ID token, access token and raw nonce\n     * or the ID token string.\n     */\n    credential(params) {\n        return this._credential(Object.assign(Object.assign({}, params), { nonce: params.rawNonce }));\n    }\n    /** An internal credential method that accepts more permissive options */\n    _credential(params) {\n        _assert(params.idToken || params.accessToken, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        // For OAuthCredential, sign in method is same as providerId.\n        return OAuthCredential._fromParams(Object.assign(Object.assign({}, params), { providerId: this.providerId, signInMethod: this.providerId }));\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromResult(userCredential) {\n        return OAuthProvider.oauthCredentialFromTaggedObject(userCredential);\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\n     * thrown during a sign-in, link, or reauthenticate operation.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromError(error) {\n        return OAuthProvider.oauthCredentialFromTaggedObject((error.customData || {}));\n    }\n    static oauthCredentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse) {\n            return null;\n        }\n        const { oauthIdToken, oauthAccessToken, oauthTokenSecret, pendingToken, nonce, providerId } = tokenResponse;\n        if (!oauthAccessToken &&\n            !oauthTokenSecret &&\n            !oauthIdToken &&\n            !pendingToken) {\n            return null;\n        }\n        if (!providerId) {\n            return null;\n        }\n        try {\n            return new OAuthProvider(providerId)._credential({\n                idToken: oauthIdToken,\n                accessToken: oauthAccessToken,\n                nonce,\n                pendingToken\n            });\n        }\n        catch (e) {\n            return null;\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.FACEBOOK.\n *\n * @example\n * ```javascript\n * // Sign in using a redirect.\n * const provider = new FacebookAuthProvider();\n * // Start a sign in process for an unauthenticated user.\n * provider.addScope('user_birthday');\n * await signInWithRedirect(auth, provider);\n * // This will trigger a full page redirect away from your app\n *\n * // After returning from the redirect when your app initializes you can obtain the result\n * const result = await getRedirectResult(auth);\n * if (result) {\n *   // This is the signed-in user\n *   const user = result.user;\n *   // This gives you a Facebook Access Token.\n *   const credential = FacebookAuthProvider.credentialFromResult(result);\n *   const token = credential.accessToken;\n * }\n * ```\n *\n * @example\n * ```javascript\n * // Sign in using a popup.\n * const provider = new FacebookAuthProvider();\n * provider.addScope('user_birthday');\n * const result = await signInWithPopup(auth, provider);\n *\n * // The signed-in user info.\n * const user = result.user;\n * // This gives you a Facebook Access Token.\n * const credential = FacebookAuthProvider.credentialFromResult(result);\n * const token = credential.accessToken;\n * ```\n *\n * @public\n */\nclass FacebookAuthProvider extends BaseOAuthProvider {\n    constructor() {\n        super(\"facebook.com\" /* ProviderId.FACEBOOK */);\n    }\n    /**\n     * Creates a credential for Facebook.\n     *\n     * @example\n     * ```javascript\n     * // `event` from the Facebook auth.authResponseChange callback.\n     * const credential = FacebookAuthProvider.credential(event.authResponse.accessToken);\n     * const result = await signInWithCredential(credential);\n     * ```\n     *\n     * @param accessToken - Facebook access token.\n     */\n    static credential(accessToken) {\n        return OAuthCredential._fromParams({\n            providerId: FacebookAuthProvider.PROVIDER_ID,\n            signInMethod: FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD,\n            accessToken\n        });\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromResult(userCredential) {\n        return FacebookAuthProvider.credentialFromTaggedObject(userCredential);\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\n     * thrown during a sign-in, link, or reauthenticate operation.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromError(error) {\n        return FacebookAuthProvider.credentialFromTaggedObject((error.customData || {}));\n    }\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse || !('oauthAccessToken' in tokenResponse)) {\n            return null;\n        }\n        if (!tokenResponse.oauthAccessToken) {\n            return null;\n        }\n        try {\n            return FacebookAuthProvider.credential(tokenResponse.oauthAccessToken);\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n}\n/** Always set to {@link SignInMethod}.FACEBOOK. */\nFacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD = \"facebook.com\" /* SignInMethod.FACEBOOK */;\n/** Always set to {@link ProviderId}.FACEBOOK. */\nFacebookAuthProvider.PROVIDER_ID = \"facebook.com\" /* ProviderId.FACEBOOK */;\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.GOOGLE.\n *\n * @example\n * ```javascript\n * // Sign in using a redirect.\n * const provider = new GoogleAuthProvider();\n * // Start a sign in process for an unauthenticated user.\n * provider.addScope('profile');\n * provider.addScope('email');\n * await signInWithRedirect(auth, provider);\n * // This will trigger a full page redirect away from your app\n *\n * // After returning from the redirect when your app initializes you can obtain the result\n * const result = await getRedirectResult(auth);\n * if (result) {\n *   // This is the signed-in user\n *   const user = result.user;\n *   // This gives you a Google Access Token.\n *   const credential = GoogleAuthProvider.credentialFromResult(result);\n *   const token = credential.accessToken;\n * }\n * ```\n *\n * @example\n * ```javascript\n * // Sign in using a popup.\n * const provider = new GoogleAuthProvider();\n * provider.addScope('profile');\n * provider.addScope('email');\n * const result = await signInWithPopup(auth, provider);\n *\n * // The signed-in user info.\n * const user = result.user;\n * // This gives you a Google Access Token.\n * const credential = GoogleAuthProvider.credentialFromResult(result);\n * const token = credential.accessToken;\n * ```\n *\n * @public\n */\nclass GoogleAuthProvider extends BaseOAuthProvider {\n    constructor() {\n        super(\"google.com\" /* ProviderId.GOOGLE */);\n        this.addScope('profile');\n    }\n    /**\n     * Creates a credential for Google. At least one of ID token and access token is required.\n     *\n     * @example\n     * ```javascript\n     * // \\`googleUser\\` from the onsuccess Google Sign In callback.\n     * const credential = GoogleAuthProvider.credential(googleUser.getAuthResponse().id_token);\n     * const result = await signInWithCredential(credential);\n     * ```\n     *\n     * @param idToken - Google ID token.\n     * @param accessToken - Google access token.\n     */\n    static credential(idToken, accessToken) {\n        return OAuthCredential._fromParams({\n            providerId: GoogleAuthProvider.PROVIDER_ID,\n            signInMethod: GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD,\n            idToken,\n            accessToken\n        });\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromResult(userCredential) {\n        return GoogleAuthProvider.credentialFromTaggedObject(userCredential);\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\n     * thrown during a sign-in, link, or reauthenticate operation.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromError(error) {\n        return GoogleAuthProvider.credentialFromTaggedObject((error.customData || {}));\n    }\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse) {\n            return null;\n        }\n        const { oauthIdToken, oauthAccessToken } = tokenResponse;\n        if (!oauthIdToken && !oauthAccessToken) {\n            // This could be an oauth 1 credential or a phone credential\n            return null;\n        }\n        try {\n            return GoogleAuthProvider.credential(oauthIdToken, oauthAccessToken);\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n}\n/** Always set to {@link SignInMethod}.GOOGLE. */\nGoogleAuthProvider.GOOGLE_SIGN_IN_METHOD = \"google.com\" /* SignInMethod.GOOGLE */;\n/** Always set to {@link ProviderId}.GOOGLE. */\nGoogleAuthProvider.PROVIDER_ID = \"google.com\" /* ProviderId.GOOGLE */;\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.GITHUB.\n *\n * @remarks\n * GitHub requires an OAuth 2.0 redirect, so you can either handle the redirect directly, or use\n * the {@link signInWithPopup} handler:\n *\n * @example\n * ```javascript\n * // Sign in using a redirect.\n * const provider = new GithubAuthProvider();\n * // Start a sign in process for an unauthenticated user.\n * provider.addScope('repo');\n * await signInWithRedirect(auth, provider);\n * // This will trigger a full page redirect away from your app\n *\n * // After returning from the redirect when your app initializes you can obtain the result\n * const result = await getRedirectResult(auth);\n * if (result) {\n *   // This is the signed-in user\n *   const user = result.user;\n *   // This gives you a GitHub Access Token.\n *   const credential = GithubAuthProvider.credentialFromResult(result);\n *   const token = credential.accessToken;\n * }\n * ```\n *\n * @example\n * ```javascript\n * // Sign in using a popup.\n * const provider = new GithubAuthProvider();\n * provider.addScope('repo');\n * const result = await signInWithPopup(auth, provider);\n *\n * // The signed-in user info.\n * const user = result.user;\n * // This gives you a GitHub Access Token.\n * const credential = GithubAuthProvider.credentialFromResult(result);\n * const token = credential.accessToken;\n * ```\n * @public\n */\nclass GithubAuthProvider extends BaseOAuthProvider {\n    constructor() {\n        super(\"github.com\" /* ProviderId.GITHUB */);\n    }\n    /**\n     * Creates a credential for GitHub.\n     *\n     * @param accessToken - GitHub access token.\n     */\n    static credential(accessToken) {\n        return OAuthCredential._fromParams({\n            providerId: GithubAuthProvider.PROVIDER_ID,\n            signInMethod: GithubAuthProvider.GITHUB_SIGN_IN_METHOD,\n            accessToken\n        });\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromResult(userCredential) {\n        return GithubAuthProvider.credentialFromTaggedObject(userCredential);\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\n     * thrown during a sign-in, link, or reauthenticate operation.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromError(error) {\n        return GithubAuthProvider.credentialFromTaggedObject((error.customData || {}));\n    }\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse || !('oauthAccessToken' in tokenResponse)) {\n            return null;\n        }\n        if (!tokenResponse.oauthAccessToken) {\n            return null;\n        }\n        try {\n            return GithubAuthProvider.credential(tokenResponse.oauthAccessToken);\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n}\n/** Always set to {@link SignInMethod}.GITHUB. */\nGithubAuthProvider.GITHUB_SIGN_IN_METHOD = \"github.com\" /* SignInMethod.GITHUB */;\n/** Always set to {@link ProviderId}.GITHUB. */\nGithubAuthProvider.PROVIDER_ID = \"github.com\" /* ProviderId.GITHUB */;\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst IDP_REQUEST_URI = 'http://localhost';\n/**\n * @public\n */\nclass SAMLAuthCredential extends AuthCredential {\n    /** @internal */\n    constructor(providerId, pendingToken) {\n        super(providerId, providerId);\n        this.pendingToken = pendingToken;\n    }\n    /** @internal */\n    _getIdTokenResponse(auth) {\n        const request = this.buildRequest();\n        return signInWithIdp(auth, request);\n    }\n    /** @internal */\n    _linkToIdToken(auth, idToken) {\n        const request = this.buildRequest();\n        request.idToken = idToken;\n        return signInWithIdp(auth, request);\n    }\n    /** @internal */\n    _getReauthenticationResolver(auth) {\n        const request = this.buildRequest();\n        request.autoCreate = false;\n        return signInWithIdp(auth, request);\n    }\n    /** {@inheritdoc AuthCredential.toJSON}  */\n    toJSON() {\n        return {\n            signInMethod: this.signInMethod,\n            providerId: this.providerId,\n            pendingToken: this.pendingToken\n        };\n    }\n    /**\n     * Static method to deserialize a JSON representation of an object into an\n     * {@link  AuthCredential}.\n     *\n     * @param json - Input can be either Object or the stringified representation of the object.\n     * When string is provided, JSON.parse would be called first.\n     *\n     * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.\n     */\n    static fromJSON(json) {\n        const obj = typeof json === 'string' ? JSON.parse(json) : json;\n        const { providerId, signInMethod, pendingToken } = obj;\n        if (!providerId ||\n            !signInMethod ||\n            !pendingToken ||\n            providerId !== signInMethod) {\n            return null;\n        }\n        return new SAMLAuthCredential(providerId, pendingToken);\n    }\n    /**\n     * Helper static method to avoid exposing the constructor to end users.\n     *\n     * @internal\n     */\n    static _create(providerId, pendingToken) {\n        return new SAMLAuthCredential(providerId, pendingToken);\n    }\n    buildRequest() {\n        return {\n            requestUri: IDP_REQUEST_URI,\n            returnSecureToken: true,\n            pendingToken: this.pendingToken\n        };\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst SAML_PROVIDER_PREFIX = 'saml.';\n/**\n * An {@link AuthProvider} for SAML.\n *\n * @public\n */\nclass SAMLAuthProvider extends FederatedAuthProvider {\n    /**\n     * Constructor. The providerId must start with \"saml.\"\n     * @param providerId - SAML provider ID.\n     */\n    constructor(providerId) {\n        _assert(providerId.startsWith(SAML_PROVIDER_PREFIX), \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        super(providerId);\n    }\n    /**\n     * Generates an {@link AuthCredential} from a {@link UserCredential} after a\n     * successful SAML flow completes.\n     *\n     * @remarks\n     *\n     * For example, to get an {@link AuthCredential}, you could write the\n     * following code:\n     *\n     * ```js\n     * const userCredential = await signInWithPopup(auth, samlProvider);\n     * const credential = SAMLAuthProvider.credentialFromResult(userCredential);\n     * ```\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromResult(userCredential) {\n        return SAMLAuthProvider.samlCredentialFromTaggedObject(userCredential);\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\n     * thrown during a sign-in, link, or reauthenticate operation.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromError(error) {\n        return SAMLAuthProvider.samlCredentialFromTaggedObject((error.customData || {}));\n    }\n    /**\n     * Creates an {@link AuthCredential} from a JSON string or a plain object.\n     * @param json - A plain object or a JSON string\n     */\n    static credentialFromJSON(json) {\n        const credential = SAMLAuthCredential.fromJSON(json);\n        _assert(credential, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        return credential;\n    }\n    static samlCredentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse) {\n            return null;\n        }\n        const { pendingToken, providerId } = tokenResponse;\n        if (!pendingToken || !providerId) {\n            return null;\n        }\n        try {\n            return SAMLAuthCredential._create(providerId, pendingToken);\n        }\n        catch (e) {\n            return null;\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.TWITTER.\n *\n * @example\n * ```javascript\n * // Sign in using a redirect.\n * const provider = new TwitterAuthProvider();\n * // Start a sign in process for an unauthenticated user.\n * await signInWithRedirect(auth, provider);\n * // This will trigger a full page redirect away from your app\n *\n * // After returning from the redirect when your app initializes you can obtain the result\n * const result = await getRedirectResult(auth);\n * if (result) {\n *   // This is the signed-in user\n *   const user = result.user;\n *   // This gives you a Twitter Access Token and Secret.\n *   const credential = TwitterAuthProvider.credentialFromResult(result);\n *   const token = credential.accessToken;\n *   const secret = credential.secret;\n * }\n * ```\n *\n * @example\n * ```javascript\n * // Sign in using a popup.\n * const provider = new TwitterAuthProvider();\n * const result = await signInWithPopup(auth, provider);\n *\n * // The signed-in user info.\n * const user = result.user;\n * // This gives you a Twitter Access Token and Secret.\n * const credential = TwitterAuthProvider.credentialFromResult(result);\n * const token = credential.accessToken;\n * const secret = credential.secret;\n * ```\n *\n * @public\n */\nclass TwitterAuthProvider extends BaseOAuthProvider {\n    constructor() {\n        super(\"twitter.com\" /* ProviderId.TWITTER */);\n    }\n    /**\n     * Creates a credential for Twitter.\n     *\n     * @param token - Twitter access token.\n     * @param secret - Twitter secret.\n     */\n    static credential(token, secret) {\n        return OAuthCredential._fromParams({\n            providerId: TwitterAuthProvider.PROVIDER_ID,\n            signInMethod: TwitterAuthProvider.TWITTER_SIGN_IN_METHOD,\n            oauthToken: token,\n            oauthTokenSecret: secret\n        });\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromResult(userCredential) {\n        return TwitterAuthProvider.credentialFromTaggedObject(userCredential);\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\n     * thrown during a sign-in, link, or reauthenticate operation.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromError(error) {\n        return TwitterAuthProvider.credentialFromTaggedObject((error.customData || {}));\n    }\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse) {\n            return null;\n        }\n        const { oauthAccessToken, oauthTokenSecret } = tokenResponse;\n        if (!oauthAccessToken || !oauthTokenSecret) {\n            return null;\n        }\n        try {\n            return TwitterAuthProvider.credential(oauthAccessToken, oauthTokenSecret);\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n}\n/** Always set to {@link SignInMethod}.TWITTER. */\nTwitterAuthProvider.TWITTER_SIGN_IN_METHOD = \"twitter.com\" /* SignInMethod.TWITTER */;\n/** Always set to {@link ProviderId}.TWITTER. */\nTwitterAuthProvider.PROVIDER_ID = \"twitter.com\" /* ProviderId.TWITTER */;\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function signUp(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signUp\" /* Endpoint.SIGN_UP */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass UserCredentialImpl {\n    constructor(params) {\n        this.user = params.user;\n        this.providerId = params.providerId;\n        this._tokenResponse = params._tokenResponse;\n        this.operationType = params.operationType;\n    }\n    static async _fromIdTokenResponse(auth, operationType, idTokenResponse, isAnonymous = false) {\n        const user = await UserImpl._fromIdTokenResponse(auth, idTokenResponse, isAnonymous);\n        const providerId = providerIdForResponse(idTokenResponse);\n        const userCred = new UserCredentialImpl({\n            user,\n            providerId,\n            _tokenResponse: idTokenResponse,\n            operationType\n        });\n        return userCred;\n    }\n    static async _forOperation(user, operationType, response) {\n        await user._updateTokensIfNecessary(response, /* reload */ true);\n        const providerId = providerIdForResponse(response);\n        return new UserCredentialImpl({\n            user,\n            providerId,\n            _tokenResponse: response,\n            operationType\n        });\n    }\n}\nfunction providerIdForResponse(response) {\n    if (response.providerId) {\n        return response.providerId;\n    }\n    if ('phoneNumber' in response) {\n        return \"phone\" /* ProviderId.PHONE */;\n    }\n    return null;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Asynchronously signs in as an anonymous user.\n *\n * @remarks\n * If there is already an anonymous user signed in, that user will be returned; otherwise, a\n * new anonymous user identity will be created and returned.\n *\n * This method is not supported by {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * @param auth - The {@link Auth} instance.\n *\n * @public\n */\nasync function signInAnonymously(auth) {\n    var _a;\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const authInternal = _castAuth(auth);\n    await authInternal._initializationPromise;\n    if ((_a = authInternal.currentUser) === null || _a === void 0 ? void 0 : _a.isAnonymous) {\n        // If an anonymous user is already signed in, no need to sign them in again.\n        return new UserCredentialImpl({\n            user: authInternal.currentUser,\n            providerId: null,\n            operationType: \"signIn\" /* OperationType.SIGN_IN */\n        });\n    }\n    const response = await signUp(authInternal, {\n        returnSecureToken: true\n    });\n    const userCredential = await UserCredentialImpl._fromIdTokenResponse(authInternal, \"signIn\" /* OperationType.SIGN_IN */, response, true);\n    await authInternal._updateCurrentUser(userCredential.user);\n    return userCredential;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MultiFactorError extends _firebase_util__WEBPACK_IMPORTED_MODULE_1__.FirebaseError {\n    constructor(auth, error, operationType, user) {\n        var _a;\n        super(error.code, error.message);\n        this.operationType = operationType;\n        this.user = user;\n        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, MultiFactorError.prototype);\n        this.customData = {\n            appName: auth.name,\n            tenantId: (_a = auth.tenantId) !== null && _a !== void 0 ? _a : undefined,\n            _serverResponse: error.customData._serverResponse,\n            operationType\n        };\n    }\n    static _fromErrorAndOperation(auth, error, operationType, user) {\n        return new MultiFactorError(auth, error, operationType, user);\n    }\n}\nfunction _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user) {\n    const idTokenProvider = operationType === \"reauthenticate\" /* OperationType.REAUTHENTICATE */\n        ? credential._getReauthenticationResolver(auth)\n        : credential._getIdTokenResponse(auth);\n    return idTokenProvider.catch(error => {\n        if (error.code === `auth/${\"multi-factor-auth-required\" /* AuthErrorCode.MFA_REQUIRED */}`) {\n            throw MultiFactorError._fromErrorAndOperation(auth, error, operationType, user);\n        }\n        throw error;\n    });\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Takes a set of UserInfo provider data and converts it to a set of names\n */\nfunction providerDataAsNames(providerData) {\n    return new Set(providerData\n        .map(({ providerId }) => providerId)\n        .filter(pid => !!pid));\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Unlinks a provider from a user account.\n *\n * @param user - The user.\n * @param providerId - The provider to unlink.\n *\n * @public\n */\nasync function unlink(user, providerId) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    await _assertLinkedStatus(true, userInternal, providerId);\n    const { providerUserInfo } = await deleteLinkedAccounts(userInternal.auth, {\n        idToken: await userInternal.getIdToken(),\n        deleteProvider: [providerId]\n    });\n    const providersLeft = providerDataAsNames(providerUserInfo || []);\n    userInternal.providerData = userInternal.providerData.filter(pd => providersLeft.has(pd.providerId));\n    if (!providersLeft.has(\"phone\" /* ProviderId.PHONE */)) {\n        userInternal.phoneNumber = null;\n    }\n    await userInternal.auth._persistUserIfCurrent(userInternal);\n    return userInternal;\n}\nasync function _link(user, credential, bypassAuthState = false) {\n    const response = await _logoutIfInvalidated(user, credential._linkToIdToken(user.auth, await user.getIdToken()), bypassAuthState);\n    return UserCredentialImpl._forOperation(user, \"link\" /* OperationType.LINK */, response);\n}\nasync function _assertLinkedStatus(expected, user, provider) {\n    await _reloadWithoutSaving(user);\n    const providerIds = providerDataAsNames(user.providerData);\n    const code = expected === false\n        ? \"provider-already-linked\" /* AuthErrorCode.PROVIDER_ALREADY_LINKED */\n        : \"no-such-provider\" /* AuthErrorCode.NO_SUCH_PROVIDER */;\n    _assert(providerIds.has(provider) === expected, user.auth, code);\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function _reauthenticate(user, credential, bypassAuthState = false) {\n    const { auth } = user;\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const operationType = \"reauthenticate\" /* OperationType.REAUTHENTICATE */;\n    try {\n        const response = await _logoutIfInvalidated(user, _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user), bypassAuthState);\n        _assert(response.idToken, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const parsed = _parseToken(response.idToken);\n        _assert(parsed, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const { sub: localId } = parsed;\n        _assert(user.uid === localId, auth, \"user-mismatch\" /* AuthErrorCode.USER_MISMATCH */);\n        return UserCredentialImpl._forOperation(user, operationType, response);\n    }\n    catch (e) {\n        // Convert user deleted error into user mismatch\n        if ((e === null || e === void 0 ? void 0 : e.code) === `auth/${\"user-not-found\" /* AuthErrorCode.USER_DELETED */}`) {\n            _fail(auth, \"user-mismatch\" /* AuthErrorCode.USER_MISMATCH */);\n        }\n        throw e;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function _signInWithCredential(auth, credential, bypassAuthState = false) {\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const operationType = \"signIn\" /* OperationType.SIGN_IN */;\n    const response = await _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential);\n    const userCredential = await UserCredentialImpl._fromIdTokenResponse(auth, operationType, response);\n    if (!bypassAuthState) {\n        await auth._updateCurrentUser(userCredential.user);\n    }\n    return userCredential;\n}\n/**\n * Asynchronously signs in with the given credentials.\n *\n * @remarks\n * An {@link AuthProvider} can be used to generate the credential.\n *\n * This method is not supported by {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * @param auth - The {@link Auth} instance.\n * @param credential - The auth credential.\n *\n * @public\n */\nasync function signInWithCredential(auth, credential) {\n    return _signInWithCredential(_castAuth(auth), credential);\n}\n/**\n * Links the user account with the given credentials.\n *\n * @remarks\n * An {@link AuthProvider} can be used to generate the credential.\n *\n * @param user - The user.\n * @param credential - The auth credential.\n *\n * @public\n */\nasync function linkWithCredential(user, credential) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    await _assertLinkedStatus(false, userInternal, credential.providerId);\n    return _link(userInternal, credential);\n}\n/**\n * Re-authenticates a user using a fresh credential.\n *\n * @remarks\n * Use before operations such as {@link updatePassword} that require tokens from recent sign-in\n * attempts. This method can be used to recover from a `CREDENTIAL_TOO_OLD_LOGIN_AGAIN` error\n * or a `TOKEN_EXPIRED` error.\n *\n * This method is not supported on any {@link User} signed in by {@link Auth} instances\n * created with a {@link @firebase/app#FirebaseServerApp}.\n *\n * @param user - The user.\n * @param credential - The auth credential.\n *\n * @public\n */\nasync function reauthenticateWithCredential(user, credential) {\n    return _reauthenticate((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user), credential);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function signInWithCustomToken$1(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithCustomToken\" /* Endpoint.SIGN_IN_WITH_CUSTOM_TOKEN */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Asynchronously signs in using a custom token.\n *\n * @remarks\n * Custom tokens are used to integrate Firebase Auth with existing auth systems, and must\n * be generated by an auth backend using the\n * {@link https://firebase.google.com/docs/reference/admin/node/admin.auth.Auth#createcustomtoken | createCustomToken}\n * method in the {@link https://firebase.google.com/docs/auth/admin | Admin SDK} .\n *\n * Fails with an error if the token is invalid, expired, or not accepted by the Firebase Auth service.\n *\n * This method is not supported by {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * @param auth - The {@link Auth} instance.\n * @param customToken - The custom token to sign in with.\n *\n * @public\n */\nasync function signInWithCustomToken(auth, customToken) {\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const authInternal = _castAuth(auth);\n    const response = await signInWithCustomToken$1(authInternal, {\n        token: customToken,\n        returnSecureToken: true\n    });\n    const cred = await UserCredentialImpl._fromIdTokenResponse(authInternal, \"signIn\" /* OperationType.SIGN_IN */, response);\n    await authInternal._updateCurrentUser(cred.user);\n    return cred;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MultiFactorInfoImpl {\n    constructor(factorId, response) {\n        this.factorId = factorId;\n        this.uid = response.mfaEnrollmentId;\n        this.enrollmentTime = new Date(response.enrolledAt).toUTCString();\n        this.displayName = response.displayName;\n    }\n    static _fromServerResponse(auth, enrollment) {\n        if ('phoneInfo' in enrollment) {\n            return PhoneMultiFactorInfoImpl._fromServerResponse(auth, enrollment);\n        }\n        else if ('totpInfo' in enrollment) {\n            return TotpMultiFactorInfoImpl._fromServerResponse(auth, enrollment);\n        }\n        return _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    }\n}\nclass PhoneMultiFactorInfoImpl extends MultiFactorInfoImpl {\n    constructor(response) {\n        super(\"phone\" /* FactorId.PHONE */, response);\n        this.phoneNumber = response.phoneInfo;\n    }\n    static _fromServerResponse(_auth, enrollment) {\n        return new PhoneMultiFactorInfoImpl(enrollment);\n    }\n}\nclass TotpMultiFactorInfoImpl extends MultiFactorInfoImpl {\n    constructor(response) {\n        super(\"totp\" /* FactorId.TOTP */, response);\n    }\n    static _fromServerResponse(_auth, enrollment) {\n        return new TotpMultiFactorInfoImpl(enrollment);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _setActionCodeSettingsOnRequest(auth, request, actionCodeSettings) {\n    var _a;\n    _assert(((_a = actionCodeSettings.url) === null || _a === void 0 ? void 0 : _a.length) > 0, auth, \"invalid-continue-uri\" /* AuthErrorCode.INVALID_CONTINUE_URI */);\n    _assert(typeof actionCodeSettings.dynamicLinkDomain === 'undefined' ||\n        actionCodeSettings.dynamicLinkDomain.length > 0, auth, \"invalid-dynamic-link-domain\" /* AuthErrorCode.INVALID_DYNAMIC_LINK_DOMAIN */);\n    request.continueUrl = actionCodeSettings.url;\n    request.dynamicLinkDomain = actionCodeSettings.dynamicLinkDomain;\n    request.canHandleCodeInApp = actionCodeSettings.handleCodeInApp;\n    if (actionCodeSettings.iOS) {\n        _assert(actionCodeSettings.iOS.bundleId.length > 0, auth, \"missing-ios-bundle-id\" /* AuthErrorCode.MISSING_IOS_BUNDLE_ID */);\n        request.iOSBundleId = actionCodeSettings.iOS.bundleId;\n    }\n    if (actionCodeSettings.android) {\n        _assert(actionCodeSettings.android.packageName.length > 0, auth, \"missing-android-pkg-name\" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */);\n        request.androidInstallApp = actionCodeSettings.android.installApp;\n        request.androidMinimumVersionCode =\n            actionCodeSettings.android.minimumVersion;\n        request.androidPackageName = actionCodeSettings.android.packageName;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Updates the password policy cached in the {@link Auth} instance if a policy is already\n * cached for the project or tenant.\n *\n * @remarks\n * We only fetch the password policy if the password did not meet policy requirements and\n * there is an existing policy cached. A developer must call validatePassword at least\n * once for the cache to be automatically updated.\n *\n * @param auth - The {@link Auth} instance.\n *\n * @private\n */\nasync function recachePasswordPolicy(auth) {\n    const authInternal = _castAuth(auth);\n    if (authInternal._getPasswordPolicyInternal()) {\n        await authInternal._updatePasswordPolicy();\n    }\n}\n/**\n * Sends a password reset email to the given email address. This method does not throw an error when\n * there's no user account with the given email address and\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\n * is enabled.\n *\n * @remarks\n * To complete the password reset, call {@link confirmPasswordReset} with the code supplied in\n * the email sent to the user, along with the new password specified by the user.\n *\n * @example\n * ```javascript\n * const actionCodeSettings = {\n *   url: 'https://www.example.com/?email=user@example.com',\n *   iOS: {\n *      bundleId: 'com.example.ios'\n *   },\n *   android: {\n *     packageName: 'com.example.android',\n *     installApp: true,\n *     minimumVersion: '12'\n *   },\n *   handleCodeInApp: true\n * };\n * await sendPasswordResetEmail(auth, 'user@example.com', actionCodeSettings);\n * // Obtain code from user.\n * await confirmPasswordReset('user@example.com', code);\n * ```\n *\n * @param auth - The {@link Auth} instance.\n * @param email - The user's email address.\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\n *\n * @public\n */\nasync function sendPasswordResetEmail(auth, email, actionCodeSettings) {\n    const authInternal = _castAuth(auth);\n    const request = {\n        requestType: \"PASSWORD_RESET\" /* ActionCodeOperation.PASSWORD_RESET */,\n        email,\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */\n    };\n    if (actionCodeSettings) {\n        _setActionCodeSettingsOnRequest(authInternal, request, actionCodeSettings);\n    }\n    await handleRecaptchaFlow(authInternal, request, \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */, sendPasswordResetEmail$1, \"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */);\n}\n/**\n * Completes the password reset process, given a confirmation code and new password.\n *\n * @param auth - The {@link Auth} instance.\n * @param oobCode - A confirmation code sent to the user.\n * @param newPassword - The new password.\n *\n * @public\n */\nasync function confirmPasswordReset(auth, oobCode, newPassword) {\n    await resetPassword((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), {\n        oobCode,\n        newPassword\n    })\n        .catch(async (error) => {\n        if (error.code ===\n            `auth/${\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */}`) {\n            void recachePasswordPolicy(auth);\n        }\n        throw error;\n    });\n    // Do not return the email.\n}\n/**\n * Applies a verification code sent to the user by email or other out-of-band mechanism.\n *\n * @param auth - The {@link Auth} instance.\n * @param oobCode - A verification code sent to the user.\n *\n * @public\n */\nasync function applyActionCode(auth, oobCode) {\n    await applyActionCode$1((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), { oobCode });\n}\n/**\n * Checks a verification code sent to the user by email or other out-of-band mechanism.\n *\n * @returns metadata about the code.\n *\n * @param auth - The {@link Auth} instance.\n * @param oobCode - A verification code sent to the user.\n *\n * @public\n */\nasync function checkActionCode(auth, oobCode) {\n    const authModular = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth);\n    const response = await resetPassword(authModular, { oobCode });\n    // Email could be empty only if the request type is EMAIL_SIGNIN or\n    // VERIFY_AND_CHANGE_EMAIL.\n    // New email should not be empty if the request type is\n    // VERIFY_AND_CHANGE_EMAIL.\n    // Multi-factor info could not be empty if the request type is\n    // REVERT_SECOND_FACTOR_ADDITION.\n    const operation = response.requestType;\n    _assert(operation, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    switch (operation) {\n        case \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */:\n            break;\n        case \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */:\n            _assert(response.newEmail, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n            break;\n        case \"REVERT_SECOND_FACTOR_ADDITION\" /* ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION */:\n            _assert(response.mfaInfo, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        // fall through\n        default:\n            _assert(response.email, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    }\n    // The multi-factor info for revert second factor addition\n    let multiFactorInfo = null;\n    if (response.mfaInfo) {\n        multiFactorInfo = MultiFactorInfoImpl._fromServerResponse(_castAuth(authModular), response.mfaInfo);\n    }\n    return {\n        data: {\n            email: (response.requestType === \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */\n                ? response.newEmail\n                : response.email) || null,\n            previousEmail: (response.requestType === \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */\n                ? response.email\n                : response.newEmail) || null,\n            multiFactorInfo\n        },\n        operation\n    };\n}\n/**\n * Checks a password reset code sent to the user by email or other out-of-band mechanism.\n *\n * @returns the user's email address if valid.\n *\n * @param auth - The {@link Auth} instance.\n * @param code - A verification code sent to the user.\n *\n * @public\n */\nasync function verifyPasswordResetCode(auth, code) {\n    const { data } = await checkActionCode((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), code);\n    // Email should always be present since a code was sent to it\n    return data.email;\n}\n/**\n * Creates a new user account associated with the specified email address and password.\n *\n * @remarks\n * On successful creation of the user account, this user will also be signed in to your application.\n *\n * User account creation can fail if the account already exists or the password is invalid.\n *\n * This method is not supported on {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * Note: The email address acts as a unique identifier for the user and enables an email-based\n * password reset. This function will create a new user account and set the initial user password.\n *\n * @param auth - The {@link Auth} instance.\n * @param email - The user's email address.\n * @param password - The user's chosen password.\n *\n * @public\n */\nasync function createUserWithEmailAndPassword(auth, email, password) {\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const authInternal = _castAuth(auth);\n    const request = {\n        returnSecureToken: true,\n        email,\n        password,\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */\n    };\n    const signUpResponse = handleRecaptchaFlow(authInternal, request, \"signUpPassword\" /* RecaptchaActionName.SIGN_UP_PASSWORD */, signUp, \"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */);\n    const response = await signUpResponse.catch(error => {\n        if (error.code === `auth/${\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */}`) {\n            void recachePasswordPolicy(auth);\n        }\n        throw error;\n    });\n    const userCredential = await UserCredentialImpl._fromIdTokenResponse(authInternal, \"signIn\" /* OperationType.SIGN_IN */, response);\n    await authInternal._updateCurrentUser(userCredential.user);\n    return userCredential;\n}\n/**\n * Asynchronously signs in using an email and password.\n *\n * @remarks\n * Fails with an error if the email address and password do not match. When\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\n * is enabled, this method fails with \"auth/invalid-credential\" in case of an invalid\n * email/password.\n *\n * This method is not supported on {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * Note: The user's password is NOT the password used to access the user's email account. The\n * email address serves as a unique identifier for the user, and the password is used to access\n * the user's account in your Firebase project. See also: {@link createUserWithEmailAndPassword}.\n *\n *\n * @param auth - The {@link Auth} instance.\n * @param email - The users email address.\n * @param password - The users password.\n *\n * @public\n */\nfunction signInWithEmailAndPassword(auth, email, password) {\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    return signInWithCredential((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), EmailAuthProvider.credential(email, password)).catch(async (error) => {\n        if (error.code === `auth/${\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */}`) {\n            void recachePasswordPolicy(auth);\n        }\n        throw error;\n    });\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Sends a sign-in email link to the user with the specified email.\n *\n * @remarks\n * The sign-in operation has to always be completed in the app unlike other out of band email\n * actions (password reset and email verifications). This is because, at the end of the flow,\n * the user is expected to be signed in and their Auth state persisted within the app.\n *\n * To complete sign in with the email link, call {@link signInWithEmailLink} with the email\n * address and the email link supplied in the email sent to the user.\n *\n * @example\n * ```javascript\n * const actionCodeSettings = {\n *   url: 'https://www.example.com/?email=user@example.com',\n *   iOS: {\n *      bundleId: 'com.example.ios'\n *   },\n *   android: {\n *     packageName: 'com.example.android',\n *     installApp: true,\n *     minimumVersion: '12'\n *   },\n *   handleCodeInApp: true\n * };\n * await sendSignInLinkToEmail(auth, 'user@example.com', actionCodeSettings);\n * // Obtain emailLink from the user.\n * if(isSignInWithEmailLink(auth, emailLink)) {\n *   await signInWithEmailLink(auth, 'user@example.com', emailLink);\n * }\n * ```\n *\n * @param authInternal - The {@link Auth} instance.\n * @param email - The user's email address.\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\n *\n * @public\n */\nasync function sendSignInLinkToEmail(auth, email, actionCodeSettings) {\n    const authInternal = _castAuth(auth);\n    const request = {\n        requestType: \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */,\n        email,\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */\n    };\n    function setActionCodeSettings(request, actionCodeSettings) {\n        _assert(actionCodeSettings.handleCodeInApp, authInternal, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        if (actionCodeSettings) {\n            _setActionCodeSettingsOnRequest(authInternal, request, actionCodeSettings);\n        }\n    }\n    setActionCodeSettings(request, actionCodeSettings);\n    await handleRecaptchaFlow(authInternal, request, \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */, sendSignInLinkToEmail$1, \"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */);\n}\n/**\n * Checks if an incoming link is a sign-in with email link suitable for {@link signInWithEmailLink}.\n *\n * @param auth - The {@link Auth} instance.\n * @param emailLink - The link sent to the user's email address.\n *\n * @public\n */\nfunction isSignInWithEmailLink(auth, emailLink) {\n    const actionCodeUrl = ActionCodeURL.parseLink(emailLink);\n    return (actionCodeUrl === null || actionCodeUrl === void 0 ? void 0 : actionCodeUrl.operation) === \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */;\n}\n/**\n * Asynchronously signs in using an email and sign-in email link.\n *\n * @remarks\n * If no link is passed, the link is inferred from the current URL.\n *\n * Fails with an error if the email address is invalid or OTP in email link expires.\n *\n * This method is not supported by {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * Note: Confirm the link is a sign-in email link before calling this method firebase.auth.Auth.isSignInWithEmailLink.\n *\n * @example\n * ```javascript\n * const actionCodeSettings = {\n *   url: 'https://www.example.com/?email=user@example.com',\n *   iOS: {\n *      bundleId: 'com.example.ios'\n *   },\n *   android: {\n *     packageName: 'com.example.android',\n *     installApp: true,\n *     minimumVersion: '12'\n *   },\n *   handleCodeInApp: true\n * };\n * await sendSignInLinkToEmail(auth, 'user@example.com', actionCodeSettings);\n * // Obtain emailLink from the user.\n * if(isSignInWithEmailLink(auth, emailLink)) {\n *   await signInWithEmailLink(auth, 'user@example.com', emailLink);\n * }\n * ```\n *\n *\n * @param auth - The {@link Auth} instance.\n * @param email - The user's email address.\n * @param emailLink - The link sent to the user's email address.\n *\n * @public\n */\nasync function signInWithEmailLink(auth, email, emailLink) {\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const authModular = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth);\n    const credential = EmailAuthProvider.credentialWithLink(email, emailLink || _getCurrentUrl());\n    // Check if the tenant ID in the email link matches the tenant ID on Auth\n    // instance.\n    _assert(credential._tenantId === (authModular.tenantId || null), authModular, \"tenant-id-mismatch\" /* AuthErrorCode.TENANT_ID_MISMATCH */);\n    return signInWithCredential(authModular, credential);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function createAuthUri(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:createAuthUri\" /* Endpoint.CREATE_AUTH_URI */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Gets the list of possible sign in methods for the given email address. This method returns an\n * empty list when\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\n * is enabled, irrespective of the number of authentication methods available for the given email.\n *\n * @remarks\n * This is useful to differentiate methods of sign-in for the same provider, eg.\n * {@link EmailAuthProvider} which has 2 methods of sign-in,\n * {@link SignInMethod}.EMAIL_PASSWORD and\n * {@link SignInMethod}.EMAIL_LINK.\n *\n * @param auth - The {@link Auth} instance.\n * @param email - The user's email address.\n *\n * Deprecated. Migrating off of this method is recommended as a security best-practice.\n * Learn more in the Identity Platform documentation for\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}.\n * @public\n */\nasync function fetchSignInMethodsForEmail(auth, email) {\n    // createAuthUri returns an error if continue URI is not http or https.\n    // For environments like Cordova, Chrome extensions, native frameworks, file\n    // systems, etc, use http://localhost as continue URL.\n    const continueUri = _isHttpOrHttps() ? _getCurrentUrl() : 'http://localhost';\n    const request = {\n        identifier: email,\n        continueUri\n    };\n    const { signinMethods } = await createAuthUri((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), request);\n    return signinMethods || [];\n}\n/**\n * Sends a verification email to a user.\n *\n * @remarks\n * The verification process is completed by calling {@link applyActionCode}.\n *\n * @example\n * ```javascript\n * const actionCodeSettings = {\n *   url: 'https://www.example.com/?email=user@example.com',\n *   iOS: {\n *      bundleId: 'com.example.ios'\n *   },\n *   android: {\n *     packageName: 'com.example.android',\n *     installApp: true,\n *     minimumVersion: '12'\n *   },\n *   handleCodeInApp: true\n * };\n * await sendEmailVerification(user, actionCodeSettings);\n * // Obtain code from the user.\n * await applyActionCode(auth, code);\n * ```\n *\n * @param user - The user.\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\n *\n * @public\n */\nasync function sendEmailVerification(user, actionCodeSettings) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    const idToken = await user.getIdToken();\n    const request = {\n        requestType: \"VERIFY_EMAIL\" /* ActionCodeOperation.VERIFY_EMAIL */,\n        idToken\n    };\n    if (actionCodeSettings) {\n        _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);\n    }\n    const { email } = await sendEmailVerification$1(userInternal.auth, request);\n    if (email !== user.email) {\n        await user.reload();\n    }\n}\n/**\n * Sends a verification email to a new email address.\n *\n * @remarks\n * The user's email will be updated to the new one after being verified.\n *\n * If you have a custom email action handler, you can complete the verification process by calling\n * {@link applyActionCode}.\n *\n * @example\n * ```javascript\n * const actionCodeSettings = {\n *   url: 'https://www.example.com/?email=user@example.com',\n *   iOS: {\n *      bundleId: 'com.example.ios'\n *   },\n *   android: {\n *     packageName: 'com.example.android',\n *     installApp: true,\n *     minimumVersion: '12'\n *   },\n *   handleCodeInApp: true\n * };\n * await verifyBeforeUpdateEmail(user, 'newemail@example.com', actionCodeSettings);\n * // Obtain code from the user.\n * await applyActionCode(auth, code);\n * ```\n *\n * @param user - The user.\n * @param newEmail - The new email address to be verified before update.\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\n *\n * @public\n */\nasync function verifyBeforeUpdateEmail(user, newEmail, actionCodeSettings) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    const idToken = await user.getIdToken();\n    const request = {\n        requestType: \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */,\n        idToken,\n        newEmail\n    };\n    if (actionCodeSettings) {\n        _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);\n    }\n    const { email } = await verifyAndChangeEmail(userInternal.auth, request);\n    if (email !== user.email) {\n        // If the local copy of the email on user is outdated, reload the\n        // user.\n        await user.reload();\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function updateProfile$1(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */, request);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Updates a user's profile data.\n *\n * @param user - The user.\n * @param profile - The profile's `displayName` and `photoURL` to update.\n *\n * @public\n */\nasync function updateProfile(user, { displayName, photoURL: photoUrl }) {\n    if (displayName === undefined && photoUrl === undefined) {\n        return;\n    }\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    const idToken = await userInternal.getIdToken();\n    const profileRequest = {\n        idToken,\n        displayName,\n        photoUrl,\n        returnSecureToken: true\n    };\n    const response = await _logoutIfInvalidated(userInternal, updateProfile$1(userInternal.auth, profileRequest));\n    userInternal.displayName = response.displayName || null;\n    userInternal.photoURL = response.photoUrl || null;\n    // Update the password provider as well\n    const passwordProvider = userInternal.providerData.find(({ providerId }) => providerId === \"password\" /* ProviderId.PASSWORD */);\n    if (passwordProvider) {\n        passwordProvider.displayName = userInternal.displayName;\n        passwordProvider.photoURL = userInternal.photoURL;\n    }\n    await userInternal._updateTokensIfNecessary(response);\n}\n/**\n * Updates the user's email address.\n *\n * @remarks\n * An email will be sent to the original email address (if it was set) that allows to revoke the\n * email address change, in order to protect them from account hijacking.\n *\n * This method is not supported on any {@link User} signed in by {@link Auth} instances\n * created with a {@link @firebase/app#FirebaseServerApp}.\n *\n * Important: this is a security sensitive operation that requires the user to have recently signed\n * in. If this requirement isn't met, ask the user to authenticate again and then call\n * {@link reauthenticateWithCredential}.\n *\n * @param user - The user.\n * @param newEmail - The new email address.\n *\n * Throws \"auth/operation-not-allowed\" error when\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\n * is enabled.\n * Deprecated - Use {@link verifyBeforeUpdateEmail} instead.\n *\n * @public\n */\nfunction updateEmail(user, newEmail) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(userInternal.auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(userInternal.auth));\n    }\n    return updateEmailOrPassword(userInternal, newEmail, null);\n}\n/**\n * Updates the user's password.\n *\n * @remarks\n * Important: this is a security sensitive operation that requires the user to have recently signed\n * in. If this requirement isn't met, ask the user to authenticate again and then call\n * {@link reauthenticateWithCredential}.\n *\n * @param user - The user.\n * @param newPassword - The new password.\n *\n * @public\n */\nfunction updatePassword(user, newPassword) {\n    return updateEmailOrPassword((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user), null, newPassword);\n}\nasync function updateEmailOrPassword(user, email, password) {\n    const { auth } = user;\n    const idToken = await user.getIdToken();\n    const request = {\n        idToken,\n        returnSecureToken: true\n    };\n    if (email) {\n        request.email = email;\n    }\n    if (password) {\n        request.password = password;\n    }\n    const response = await _logoutIfInvalidated(user, updateEmailPassword(auth, request));\n    await user._updateTokensIfNecessary(response, /* reload */ true);\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Parse the `AdditionalUserInfo` from the ID token response.\n *\n */\nfunction _fromIdTokenResponse(idTokenResponse) {\n    var _a, _b;\n    if (!idTokenResponse) {\n        return null;\n    }\n    const { providerId } = idTokenResponse;\n    const profile = idTokenResponse.rawUserInfo\n        ? JSON.parse(idTokenResponse.rawUserInfo)\n        : {};\n    const isNewUser = idTokenResponse.isNewUser ||\n        idTokenResponse.kind === \"identitytoolkit#SignupNewUserResponse\" /* IdTokenResponseKind.SignupNewUser */;\n    if (!providerId && (idTokenResponse === null || idTokenResponse === void 0 ? void 0 : idTokenResponse.idToken)) {\n        const signInProvider = (_b = (_a = _parseToken(idTokenResponse.idToken)) === null || _a === void 0 ? void 0 : _a.firebase) === null || _b === void 0 ? void 0 : _b['sign_in_provider'];\n        if (signInProvider) {\n            const filteredProviderId = signInProvider !== \"anonymous\" /* ProviderId.ANONYMOUS */ &&\n                signInProvider !== \"custom\" /* ProviderId.CUSTOM */\n                ? signInProvider\n                : null;\n            // Uses generic class in accordance with the legacy SDK.\n            return new GenericAdditionalUserInfo(isNewUser, filteredProviderId);\n        }\n    }\n    if (!providerId) {\n        return null;\n    }\n    switch (providerId) {\n        case \"facebook.com\" /* ProviderId.FACEBOOK */:\n            return new FacebookAdditionalUserInfo(isNewUser, profile);\n        case \"github.com\" /* ProviderId.GITHUB */:\n            return new GithubAdditionalUserInfo(isNewUser, profile);\n        case \"google.com\" /* ProviderId.GOOGLE */:\n            return new GoogleAdditionalUserInfo(isNewUser, profile);\n        case \"twitter.com\" /* ProviderId.TWITTER */:\n            return new TwitterAdditionalUserInfo(isNewUser, profile, idTokenResponse.screenName || null);\n        case \"custom\" /* ProviderId.CUSTOM */:\n        case \"anonymous\" /* ProviderId.ANONYMOUS */:\n            return new GenericAdditionalUserInfo(isNewUser, null);\n        default:\n            return new GenericAdditionalUserInfo(isNewUser, providerId, profile);\n    }\n}\nclass GenericAdditionalUserInfo {\n    constructor(isNewUser, providerId, profile = {}) {\n        this.isNewUser = isNewUser;\n        this.providerId = providerId;\n        this.profile = profile;\n    }\n}\nclass FederatedAdditionalUserInfoWithUsername extends GenericAdditionalUserInfo {\n    constructor(isNewUser, providerId, profile, username) {\n        super(isNewUser, providerId, profile);\n        this.username = username;\n    }\n}\nclass FacebookAdditionalUserInfo extends GenericAdditionalUserInfo {\n    constructor(isNewUser, profile) {\n        super(isNewUser, \"facebook.com\" /* ProviderId.FACEBOOK */, profile);\n    }\n}\nclass GithubAdditionalUserInfo extends FederatedAdditionalUserInfoWithUsername {\n    constructor(isNewUser, profile) {\n        super(isNewUser, \"github.com\" /* ProviderId.GITHUB */, profile, typeof (profile === null || profile === void 0 ? void 0 : profile.login) === 'string' ? profile === null || profile === void 0 ? void 0 : profile.login : null);\n    }\n}\nclass GoogleAdditionalUserInfo extends GenericAdditionalUserInfo {\n    constructor(isNewUser, profile) {\n        super(isNewUser, \"google.com\" /* ProviderId.GOOGLE */, profile);\n    }\n}\nclass TwitterAdditionalUserInfo extends FederatedAdditionalUserInfoWithUsername {\n    constructor(isNewUser, profile, screenName) {\n        super(isNewUser, \"twitter.com\" /* ProviderId.TWITTER */, profile, screenName);\n    }\n}\n/**\n * Extracts provider specific {@link AdditionalUserInfo} for the given credential.\n *\n * @param userCredential - The user credential.\n *\n * @public\n */\nfunction getAdditionalUserInfo(userCredential) {\n    const { user, _tokenResponse } = userCredential;\n    if (user.isAnonymous && !_tokenResponse) {\n        // Handle the special case where signInAnonymously() gets called twice.\n        // No network call is made so there's nothing to actually fill this in\n        return {\n            providerId: null,\n            isNewUser: false,\n            profile: null\n        };\n    }\n    return _fromIdTokenResponse(_tokenResponse);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Non-optional auth methods.\n/**\n * Changes the type of persistence on the {@link Auth} instance for the currently saved\n * `Auth` session and applies this type of persistence for future sign-in requests, including\n * sign-in with redirect requests.\n *\n * @remarks\n * This makes it easy for a user signing in to specify whether their session should be\n * remembered or not. It also makes it easier to never persist the `Auth` state for applications\n * that are shared by other users or have sensitive data.\n *\n * This method does not work in a Node.js environment or with {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * @example\n * ```javascript\n * setPersistence(auth, browserSessionPersistence);\n * ```\n *\n * @param auth - The {@link Auth} instance.\n * @param persistence - The {@link Persistence} to use.\n * @returns A `Promise` that resolves once the persistence change has completed\n *\n * @public\n */\nfunction setPersistence(auth, persistence) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).setPersistence(persistence);\n}\n/**\n * Loads the reCAPTCHA configuration into the `Auth` instance.\n *\n * @remarks\n * This will load the reCAPTCHA config, which indicates whether the reCAPTCHA\n * verification flow should be triggered for each auth provider, into the\n * current Auth session.\n *\n * If initializeRecaptchaConfig() is not invoked, the auth flow will always start\n * without reCAPTCHA verification. If the provider is configured to require reCAPTCHA\n * verification, the SDK will transparently load the reCAPTCHA config and restart the\n * auth flows.\n *\n * Thus, by calling this optional method, you will reduce the latency of future auth flows.\n * Loading the reCAPTCHA config early will also enhance the signal collected by reCAPTCHA.\n *\n * This method does not work in a Node.js environment.\n *\n * @example\n * ```javascript\n * initializeRecaptchaConfig(auth);\n * ```\n *\n * @param auth - The {@link Auth} instance.\n *\n * @public\n */\nfunction initializeRecaptchaConfig(auth) {\n    return _initializeRecaptchaConfig(auth);\n}\n/**\n * Validates the password against the password policy configured for the project or tenant.\n *\n * @remarks\n * If no tenant ID is set on the `Auth` instance, then this method will use the password\n * policy configured for the project. Otherwise, this method will use the policy configured\n * for the tenant. If a password policy has not been configured, then the default policy\n * configured for all projects will be used.\n *\n * If an auth flow fails because a submitted password does not meet the password policy\n * requirements and this method has previously been called, then this method will use the\n * most recent policy available when called again.\n *\n * @example\n * ```javascript\n * validatePassword(auth, 'some-password');\n * ```\n *\n * @param auth The {@link Auth} instance.\n * @param password The password to validate.\n *\n * @public\n */\nasync function validatePassword(auth, password) {\n    const authInternal = _castAuth(auth);\n    return authInternal.validatePassword(password);\n}\n/**\n * Adds an observer for changes to the signed-in user's ID token.\n *\n * @remarks\n * This includes sign-in, sign-out, and token refresh events.\n * This will not be triggered automatically upon ID token expiration. Use {@link User.getIdToken} to refresh the ID token.\n *\n * @param auth - The {@link Auth} instance.\n * @param nextOrObserver - callback triggered on change.\n * @param error - Deprecated. This callback is never triggered. Errors\n * on signing in/out can be caught in promises returned from\n * sign-in/sign-out functions.\n * @param completed - Deprecated. This callback is never triggered.\n *\n * @public\n */\nfunction onIdTokenChanged(auth, nextOrObserver, error, completed) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).onIdTokenChanged(nextOrObserver, error, completed);\n}\n/**\n * Adds a blocking callback that runs before an auth state change\n * sets a new user.\n *\n * @param auth - The {@link Auth} instance.\n * @param callback - callback triggered before new user value is set.\n *   If this throws, it blocks the user from being set.\n * @param onAbort - callback triggered if a later `beforeAuthStateChanged()`\n *   callback throws, allowing you to undo any side effects.\n */\nfunction beforeAuthStateChanged(auth, callback, onAbort) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).beforeAuthStateChanged(callback, onAbort);\n}\n/**\n * Adds an observer for changes to the user's sign-in state.\n *\n * @remarks\n * To keep the old behavior, see {@link onIdTokenChanged}.\n *\n * @param auth - The {@link Auth} instance.\n * @param nextOrObserver - callback triggered on change.\n * @param error - Deprecated. This callback is never triggered. Errors\n * on signing in/out can be caught in promises returned from\n * sign-in/sign-out functions.\n * @param completed - Deprecated. This callback is never triggered.\n *\n * @public\n */\nfunction onAuthStateChanged(auth, nextOrObserver, error, completed) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).onAuthStateChanged(nextOrObserver, error, completed);\n}\n/**\n * Sets the current language to the default device/browser preference.\n *\n * @param auth - The {@link Auth} instance.\n *\n * @public\n */\nfunction useDeviceLanguage(auth) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).useDeviceLanguage();\n}\n/**\n * Asynchronously sets the provided user as {@link Auth.currentUser} on the\n * {@link Auth} instance.\n *\n * @remarks\n * A new instance copy of the user provided will be made and set as currentUser.\n *\n * This will trigger {@link onAuthStateChanged} and {@link onIdTokenChanged} listeners\n * like other sign in methods.\n *\n * The operation fails with an error if the user to be updated belongs to a different Firebase\n * project.\n *\n * This method is not supported by {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * @param auth - The {@link Auth} instance.\n * @param user - The new {@link User}.\n *\n * @public\n */\nfunction updateCurrentUser(auth, user) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).updateCurrentUser(user);\n}\n/**\n * Signs out the current user.\n *\n * @remarks\n * This method is not supported by {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * @param auth - The {@link Auth} instance.\n *\n * @public\n */\nfunction signOut(auth) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).signOut();\n}\n/**\n * Revokes the given access token. Currently only supports Apple OAuth access tokens.\n *\n * @param auth - The {@link Auth} instance.\n * @param token - The Apple OAuth access token.\n *\n * @public\n */\nfunction revokeAccessToken(auth, token) {\n    const authInternal = _castAuth(auth);\n    return authInternal.revokeAccessToken(token);\n}\n/**\n * Deletes and signs out the user.\n *\n * @remarks\n * Important: this is a security-sensitive operation that requires the user to have recently\n * signed in. If this requirement isn't met, ask the user to authenticate again and then call\n * {@link reauthenticateWithCredential}.\n *\n * @param user - The user.\n *\n * @public\n */\nasync function deleteUser(user) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user).delete();\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MultiFactorSessionImpl {\n    constructor(type, credential, user) {\n        this.type = type;\n        this.credential = credential;\n        this.user = user;\n    }\n    static _fromIdtoken(idToken, user) {\n        return new MultiFactorSessionImpl(\"enroll\" /* MultiFactorSessionType.ENROLL */, idToken, user);\n    }\n    static _fromMfaPendingCredential(mfaPendingCredential) {\n        return new MultiFactorSessionImpl(\"signin\" /* MultiFactorSessionType.SIGN_IN */, mfaPendingCredential);\n    }\n    toJSON() {\n        const key = this.type === \"enroll\" /* MultiFactorSessionType.ENROLL */\n            ? 'idToken'\n            : 'pendingCredential';\n        return {\n            multiFactorSession: {\n                [key]: this.credential\n            }\n        };\n    }\n    static fromJSON(obj) {\n        var _a, _b;\n        if (obj === null || obj === void 0 ? void 0 : obj.multiFactorSession) {\n            if ((_a = obj.multiFactorSession) === null || _a === void 0 ? void 0 : _a.pendingCredential) {\n                return MultiFactorSessionImpl._fromMfaPendingCredential(obj.multiFactorSession.pendingCredential);\n            }\n            else if ((_b = obj.multiFactorSession) === null || _b === void 0 ? void 0 : _b.idToken) {\n                return MultiFactorSessionImpl._fromIdtoken(obj.multiFactorSession.idToken);\n            }\n        }\n        return null;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MultiFactorResolverImpl {\n    constructor(session, hints, signInResolver) {\n        this.session = session;\n        this.hints = hints;\n        this.signInResolver = signInResolver;\n    }\n    /** @internal */\n    static _fromError(authExtern, error) {\n        const auth = _castAuth(authExtern);\n        const serverResponse = error.customData._serverResponse;\n        const hints = (serverResponse.mfaInfo || []).map(enrollment => MultiFactorInfoImpl._fromServerResponse(auth, enrollment));\n        _assert(serverResponse.mfaPendingCredential, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const session = MultiFactorSessionImpl._fromMfaPendingCredential(serverResponse.mfaPendingCredential);\n        return new MultiFactorResolverImpl(session, hints, async (assertion) => {\n            const mfaResponse = await assertion._process(auth, session);\n            // Clear out the unneeded fields from the old login response\n            delete serverResponse.mfaInfo;\n            delete serverResponse.mfaPendingCredential;\n            // Use in the new token & refresh token in the old response\n            const idTokenResponse = Object.assign(Object.assign({}, serverResponse), { idToken: mfaResponse.idToken, refreshToken: mfaResponse.refreshToken });\n            // TODO: we should collapse this switch statement into UserCredentialImpl._forOperation and have it support the SIGN_IN case\n            switch (error.operationType) {\n                case \"signIn\" /* OperationType.SIGN_IN */:\n                    const userCredential = await UserCredentialImpl._fromIdTokenResponse(auth, error.operationType, idTokenResponse);\n                    await auth._updateCurrentUser(userCredential.user);\n                    return userCredential;\n                case \"reauthenticate\" /* OperationType.REAUTHENTICATE */:\n                    _assert(error.user, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n                    return UserCredentialImpl._forOperation(error.user, error.operationType, idTokenResponse);\n                default:\n                    _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n            }\n        });\n    }\n    async resolveSignIn(assertionExtern) {\n        const assertion = assertionExtern;\n        return this.signInResolver(assertion);\n    }\n}\n/**\n * Provides a {@link MultiFactorResolver} suitable for completion of a\n * multi-factor flow.\n *\n * @param auth - The {@link Auth} instance.\n * @param error - The {@link MultiFactorError} raised during a sign-in, or\n * reauthentication operation.\n *\n * @public\n */\nfunction getMultiFactorResolver(auth, error) {\n    var _a;\n    const authModular = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth);\n    const errorInternal = error;\n    _assert(error.customData.operationType, authModular, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n    _assert((_a = errorInternal.customData._serverResponse) === null || _a === void 0 ? void 0 : _a.mfaPendingCredential, authModular, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n    return MultiFactorResolverImpl._fromError(authModular, errorInternal);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction startEnrollTotpMfa(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v2/accounts/mfaEnrollment:start\" /* Endpoint.START_MFA_ENROLLMENT */, _addTidIfNecessary(auth, request));\n}\nfunction finalizeEnrollTotpMfa(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v2/accounts/mfaEnrollment:finalize\" /* Endpoint.FINALIZE_MFA_ENROLLMENT */, _addTidIfNecessary(auth, request));\n}\nfunction withdrawMfa(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v2/accounts/mfaEnrollment:withdraw\" /* Endpoint.WITHDRAW_MFA */, _addTidIfNecessary(auth, request));\n}\n\nclass MultiFactorUserImpl {\n    constructor(user) {\n        this.user = user;\n        this.enrolledFactors = [];\n        user._onReload(userInfo => {\n            if (userInfo.mfaInfo) {\n                this.enrolledFactors = userInfo.mfaInfo.map(enrollment => MultiFactorInfoImpl._fromServerResponse(user.auth, enrollment));\n            }\n        });\n    }\n    static _fromUser(user) {\n        return new MultiFactorUserImpl(user);\n    }\n    async getSession() {\n        return MultiFactorSessionImpl._fromIdtoken(await this.user.getIdToken(), this.user);\n    }\n    async enroll(assertionExtern, displayName) {\n        const assertion = assertionExtern;\n        const session = (await this.getSession());\n        const finalizeMfaResponse = await _logoutIfInvalidated(this.user, assertion._process(this.user.auth, session, displayName));\n        // New tokens will be issued after enrollment of the new second factors.\n        // They need to be updated on the user.\n        await this.user._updateTokensIfNecessary(finalizeMfaResponse);\n        // The user needs to be reloaded to get the new multi-factor information\n        // from server. USER_RELOADED event will be triggered and `enrolledFactors`\n        // will be updated.\n        return this.user.reload();\n    }\n    async unenroll(infoOrUid) {\n        const mfaEnrollmentId = typeof infoOrUid === 'string' ? infoOrUid : infoOrUid.uid;\n        const idToken = await this.user.getIdToken();\n        try {\n            const idTokenResponse = await _logoutIfInvalidated(this.user, withdrawMfa(this.user.auth, {\n                idToken,\n                mfaEnrollmentId\n            }));\n            // Remove the second factor from the user's list.\n            this.enrolledFactors = this.enrolledFactors.filter(({ uid }) => uid !== mfaEnrollmentId);\n            // Depending on whether the backend decided to revoke the user's session,\n            // the tokenResponse may be empty. If the tokens were not updated (and they\n            // are now invalid), reloading the user will discover this and invalidate\n            // the user's state accordingly.\n            await this.user._updateTokensIfNecessary(idTokenResponse);\n            await this.user.reload();\n        }\n        catch (e) {\n            throw e;\n        }\n    }\n}\nconst multiFactorUserCache = new WeakMap();\n/**\n * The {@link MultiFactorUser} corresponding to the user.\n *\n * @remarks\n * This is used to access all multi-factor properties and operations related to the user.\n *\n * @param user - The user.\n *\n * @public\n */\nfunction multiFactor(user) {\n    const userModular = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    if (!multiFactorUserCache.has(userModular)) {\n        multiFactorUserCache.set(userModular, MultiFactorUserImpl._fromUser(userModular));\n    }\n    return multiFactorUserCache.get(userModular);\n}\n\nvar name = \"@firebase/auth\";\nvar version = \"1.8.1\";\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass AuthInterop {\n    constructor(auth) {\n        this.auth = auth;\n        this.internalListeners = new Map();\n    }\n    getUid() {\n        var _a;\n        this.assertAuthConfigured();\n        return ((_a = this.auth.currentUser) === null || _a === void 0 ? void 0 : _a.uid) || null;\n    }\n    async getToken(forceRefresh) {\n        this.assertAuthConfigured();\n        await this.auth._initializationPromise;\n        if (!this.auth.currentUser) {\n            return null;\n        }\n        const accessToken = await this.auth.currentUser.getIdToken(forceRefresh);\n        return { accessToken };\n    }\n    addAuthTokenListener(listener) {\n        this.assertAuthConfigured();\n        if (this.internalListeners.has(listener)) {\n            return;\n        }\n        const unsubscribe = this.auth.onIdTokenChanged(user => {\n            listener((user === null || user === void 0 ? void 0 : user.stsTokenManager.accessToken) || null);\n        });\n        this.internalListeners.set(listener, unsubscribe);\n        this.updateProactiveRefresh();\n    }\n    removeAuthTokenListener(listener) {\n        this.assertAuthConfigured();\n        const unsubscribe = this.internalListeners.get(listener);\n        if (!unsubscribe) {\n            return;\n        }\n        this.internalListeners.delete(listener);\n        unsubscribe();\n        this.updateProactiveRefresh();\n    }\n    assertAuthConfigured() {\n        _assert(this.auth._initializationPromise, \"dependent-sdk-initialized-before-auth\" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */);\n    }\n    updateProactiveRefresh() {\n        if (this.internalListeners.size > 0) {\n            this.auth._startProactiveRefresh();\n        }\n        else {\n            this.auth._stopProactiveRefresh();\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction getVersionForPlatform(clientPlatform) {\n    switch (clientPlatform) {\n        case \"Node\" /* ClientPlatform.NODE */:\n            return 'node';\n        case \"ReactNative\" /* ClientPlatform.REACT_NATIVE */:\n            return 'rn';\n        case \"Worker\" /* ClientPlatform.WORKER */:\n            return 'webworker';\n        case \"Cordova\" /* ClientPlatform.CORDOVA */:\n            return 'cordova';\n        case \"WebExtension\" /* ClientPlatform.WEB_EXTENSION */:\n            return 'web-extension';\n        default:\n            return undefined;\n    }\n}\n/** @internal */\nfunction registerAuth(clientPlatform) {\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_2__.Component(\"auth\" /* _ComponentName.AUTH */, (container, { options: deps }) => {\n        const app = container.getProvider('app').getImmediate();\n        const heartbeatServiceProvider = container.getProvider('heartbeat');\n        const appCheckServiceProvider = container.getProvider('app-check-internal');\n        const { apiKey, authDomain } = app.options;\n        _assert(apiKey && !apiKey.includes(':'), \"invalid-api-key\" /* AuthErrorCode.INVALID_API_KEY */, { appName: app.name });\n        const config = {\n            apiKey,\n            authDomain,\n            clientPlatform,\n            apiHost: \"identitytoolkit.googleapis.com\" /* DefaultConfig.API_HOST */,\n            tokenApiHost: \"securetoken.googleapis.com\" /* DefaultConfig.TOKEN_API_HOST */,\n            apiScheme: \"https\" /* DefaultConfig.API_SCHEME */,\n            sdkClientVersion: _getClientVersion(clientPlatform)\n        };\n        const authInstance = new AuthImpl(app, heartbeatServiceProvider, appCheckServiceProvider, config);\n        _initializeAuthInstance(authInstance, deps);\n        return authInstance;\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */)\n        /**\n         * Auth can only be initialized by explicitly calling getAuth() or initializeAuth()\n         * For why we do this, See go/firebase-next-auth-init\n         */\n        .setInstantiationMode(\"EXPLICIT\" /* InstantiationMode.EXPLICIT */)\n        /**\n         * Because all firebase products that depend on auth depend on auth-internal directly,\n         * we need to initialize auth-internal after auth is initialized to make it available to other firebase products.\n         */\n        .setInstanceCreatedCallback((container, _instanceIdentifier, _instance) => {\n        const authInternalProvider = container.getProvider(\"auth-internal\" /* _ComponentName.AUTH_INTERNAL */);\n        authInternalProvider.initialize();\n    }));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_2__.Component(\"auth-internal\" /* _ComponentName.AUTH_INTERNAL */, container => {\n        const auth = _castAuth(container.getProvider(\"auth\" /* _ComponentName.AUTH */).getImmediate());\n        return (auth => new AuthInterop(auth))(auth);\n    }, \"PRIVATE\" /* ComponentType.PRIVATE */).setInstantiationMode(\"EXPLICIT\" /* InstantiationMode.EXPLICIT */));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, getVersionForPlatform(clientPlatform));\n    // BUILD_TARGET will be replaced by values like esm2017, cjs2017, etc during the compilation\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, 'esm2017');\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Initialize the fetch polyfill, the types are slightly off so just cast and hope for the best\nFetchProvider.initialize(fetch, Headers, Response);\n// First, we set up the various platform-specific features for Node (register\n// the version and declare the Node getAuth function)\nfunction getAuth(app = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)()) {\n    const provider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'auth');\n    if (provider.isInitialized()) {\n        return provider.getImmediate();\n    }\n    const auth = initializeAuth(app);\n    const authEmulatorHost = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getDefaultEmulatorHost)('auth');\n    if (authEmulatorHost) {\n        connectAuthEmulator(auth, `http://${authEmulatorHost}`);\n    }\n    return auth;\n}\nregisterAuth(\"Node\" /* ClientPlatform.NODE */);\n// The rest of this file contains no-ops and errors for browser-specific\n// methods. We keep the browser and Node entry points the same, but features\n// that only work in browsers are set to either do nothing (setPersistence) or\n// to reject with an auth/operation-not-supported-in-this-environment error.\n// The below exports are pulled into the main entry point by a rollup alias\n// plugin (overwriting the default browser imports).\n/** auth/operation-not-supported-in-this-environment */\nconst NOT_AVAILABLE_ERROR = _createError(\"operation-not-supported-in-this-environment\" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */);\n/** Reject with auth/operation-not-supported-in-this-environment */\nasync function fail() {\n    throw NOT_AVAILABLE_ERROR;\n}\n/**\n * A class which will throw with\n * auth/operation-not-supported-in-this-environment if instantiated\n */\nclass FailClass {\n    constructor() {\n        throw NOT_AVAILABLE_ERROR;\n    }\n}\nconst browserLocalPersistence = inMemoryPersistence;\nconst browserSessionPersistence = inMemoryPersistence;\nconst indexedDBLocalPersistence = inMemoryPersistence;\nconst browserPopupRedirectResolver = NOT_AVAILABLE_ERROR;\nconst PhoneAuthProvider = FailClass;\nconst signInWithPhoneNumber = fail;\nconst linkWithPhoneNumber = fail;\nconst reauthenticateWithPhoneNumber = fail;\nconst updatePhoneNumber = fail;\nconst signInWithPopup = fail;\nconst linkWithPopup = fail;\nconst reauthenticateWithPopup = fail;\nconst signInWithRedirect = fail;\nconst linkWithRedirect = fail;\nconst reauthenticateWithRedirect = fail;\nconst getRedirectResult = fail;\nconst RecaptchaVerifier = FailClass;\nclass PhoneMultiFactorGenerator {\n    static assertion() {\n        throw NOT_AVAILABLE_ERROR;\n    }\n}\n// Set persistence should no-op instead of fail. Changing the prototype will\n// make sure both setPersistence(auth, persistence) and\n// auth.setPersistence(persistence) are covered.\nAuthImpl.prototype.setPersistence = async () => { };\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction finalizeSignInTotpMfa(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v2/accounts/mfaSignIn:finalize\" /* Endpoint.FINALIZE_MFA_SIGN_IN */, _addTidIfNecessary(auth, request));\n}\n\nclass MultiFactorAssertionImpl {\n    constructor(factorId) {\n        this.factorId = factorId;\n    }\n    _process(auth, session, displayName) {\n        switch (session.type) {\n            case \"enroll\" /* MultiFactorSessionType.ENROLL */:\n                return this._finalizeEnroll(auth, session.credential, displayName);\n            case \"signin\" /* MultiFactorSessionType.SIGN_IN */:\n                return this._finalizeSignIn(auth, session.credential);\n            default:\n                return debugFail('unexpected MultiFactorSessionType');\n        }\n    }\n}\n\n/**\n * Provider for generating a {@link TotpMultiFactorAssertion}.\n *\n * @public\n */\nclass TotpMultiFactorGenerator {\n    /**\n     * Provides a {@link TotpMultiFactorAssertion} to confirm ownership of\n     * the TOTP (time-based one-time password) second factor.\n     * This assertion is used to complete enrollment in TOTP second factor.\n     *\n     * @param secret A {@link TotpSecret} containing the shared secret key and other TOTP parameters.\n     * @param oneTimePassword One-time password from TOTP App.\n     * @returns A {@link TotpMultiFactorAssertion} which can be used with\n     * {@link MultiFactorUser.enroll}.\n     */\n    static assertionForEnrollment(secret, oneTimePassword) {\n        return TotpMultiFactorAssertionImpl._fromSecret(secret, oneTimePassword);\n    }\n    /**\n     * Provides a {@link TotpMultiFactorAssertion} to confirm ownership of the TOTP second factor.\n     * This assertion is used to complete signIn with TOTP as the second factor.\n     *\n     * @param enrollmentId identifies the enrolled TOTP second factor.\n     * @param oneTimePassword One-time password from TOTP App.\n     * @returns A {@link TotpMultiFactorAssertion} which can be used with\n     * {@link MultiFactorResolver.resolveSignIn}.\n     */\n    static assertionForSignIn(enrollmentId, oneTimePassword) {\n        return TotpMultiFactorAssertionImpl._fromEnrollmentId(enrollmentId, oneTimePassword);\n    }\n    /**\n     * Returns a promise to {@link TotpSecret} which contains the TOTP shared secret key and other parameters.\n     * Creates a TOTP secret as part of enrolling a TOTP second factor.\n     * Used for generating a QR code URL or inputting into a TOTP app.\n     * This method uses the auth instance corresponding to the user in the multiFactorSession.\n     *\n     * @param session The {@link MultiFactorSession} that the user is part of.\n     * @returns A promise to {@link TotpSecret}.\n     */\n    static async generateSecret(session) {\n        var _a;\n        const mfaSession = session;\n        _assert(typeof ((_a = mfaSession.user) === null || _a === void 0 ? void 0 : _a.auth) !== 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const response = await startEnrollTotpMfa(mfaSession.user.auth, {\n            idToken: mfaSession.credential,\n            totpEnrollmentInfo: {}\n        });\n        return TotpSecret._fromStartTotpMfaEnrollmentResponse(response, mfaSession.user.auth);\n    }\n}\n/**\n * The identifier of the TOTP second factor: `totp`.\n */\nTotpMultiFactorGenerator.FACTOR_ID = \"totp\" /* FactorId.TOTP */;\nclass TotpMultiFactorAssertionImpl extends MultiFactorAssertionImpl {\n    constructor(otp, enrollmentId, secret) {\n        super(\"totp\" /* FactorId.TOTP */);\n        this.otp = otp;\n        this.enrollmentId = enrollmentId;\n        this.secret = secret;\n    }\n    /** @internal */\n    static _fromSecret(secret, otp) {\n        return new TotpMultiFactorAssertionImpl(otp, undefined, secret);\n    }\n    /** @internal */\n    static _fromEnrollmentId(enrollmentId, otp) {\n        return new TotpMultiFactorAssertionImpl(otp, enrollmentId);\n    }\n    /** @internal */\n    async _finalizeEnroll(auth, idToken, displayName) {\n        _assert(typeof this.secret !== 'undefined', auth, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        return finalizeEnrollTotpMfa(auth, {\n            idToken,\n            displayName,\n            totpVerificationInfo: this.secret._makeTotpVerificationInfo(this.otp)\n        });\n    }\n    /** @internal */\n    async _finalizeSignIn(auth, mfaPendingCredential) {\n        _assert(this.enrollmentId !== undefined && this.otp !== undefined, auth, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        const totpVerificationInfo = { verificationCode: this.otp };\n        return finalizeSignInTotpMfa(auth, {\n            mfaPendingCredential,\n            mfaEnrollmentId: this.enrollmentId,\n            totpVerificationInfo\n        });\n    }\n}\n/**\n * Provider for generating a {@link TotpMultiFactorAssertion}.\n *\n * Stores the shared secret key and other parameters to generate time-based OTPs.\n * Implements methods to retrieve the shared secret key and generate a QR code URL.\n * @public\n */\nclass TotpSecret {\n    // The public members are declared outside the constructor so the docs can be generated.\n    constructor(secretKey, hashingAlgorithm, codeLength, codeIntervalSeconds, enrollmentCompletionDeadline, sessionInfo, auth) {\n        this.sessionInfo = sessionInfo;\n        this.auth = auth;\n        this.secretKey = secretKey;\n        this.hashingAlgorithm = hashingAlgorithm;\n        this.codeLength = codeLength;\n        this.codeIntervalSeconds = codeIntervalSeconds;\n        this.enrollmentCompletionDeadline = enrollmentCompletionDeadline;\n    }\n    /** @internal */\n    static _fromStartTotpMfaEnrollmentResponse(response, auth) {\n        return new TotpSecret(response.totpSessionInfo.sharedSecretKey, response.totpSessionInfo.hashingAlgorithm, response.totpSessionInfo.verificationCodeLength, response.totpSessionInfo.periodSec, new Date(response.totpSessionInfo.finalizeEnrollmentTime).toUTCString(), response.totpSessionInfo.sessionInfo, auth);\n    }\n    /** @internal */\n    _makeTotpVerificationInfo(otp) {\n        return { sessionInfo: this.sessionInfo, verificationCode: otp };\n    }\n    /**\n     * Returns a QR code URL as described in\n     * https://github.com/google/google-authenticator/wiki/Key-Uri-Format\n     * This can be displayed to the user as a QR code to be scanned into a TOTP app like Google Authenticator.\n     * If the optional parameters are unspecified, an accountName of <userEmail> and issuer of <firebaseAppName> are used.\n     *\n     * @param accountName the name of the account/app along with a user identifier.\n     * @param issuer issuer of the TOTP (likely the app name).\n     * @returns A QR code URL string.\n     */\n    generateQrCodeUrl(accountName, issuer) {\n        var _a;\n        let useDefaults = false;\n        if (_isEmptyString(accountName) || _isEmptyString(issuer)) {\n            useDefaults = true;\n        }\n        if (useDefaults) {\n            if (_isEmptyString(accountName)) {\n                accountName = ((_a = this.auth.currentUser) === null || _a === void 0 ? void 0 : _a.email) || 'unknownuser';\n            }\n            if (_isEmptyString(issuer)) {\n                issuer = this.auth.name;\n            }\n        }\n        return `otpauth://totp/${issuer}:${accountName}?secret=${this.secretKey}&issuer=${issuer}&algorithm=${this.hashingAlgorithm}&digits=${this.codeLength}`;\n    }\n}\n/** @internal */\nfunction _isEmptyString(input) {\n    return typeof input === 'undefined' || (input === null || input === void 0 ? void 0 : input.length) === 0;\n}\n\n\n//# sourceMappingURL=totp-3df2f5f9.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvZGlzdC9ub2RlLWVzbS90b3RwLTNkZjJmNWY5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkg7QUFDK0o7QUFDN1A7QUFDaUI7QUFDSTs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0csaUJBQWlCO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHdEQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvREFBTTtBQUM1QjtBQUNBLDhCQUE4QixzREFBUTtBQUN0QyxnQ0FBZ0Msc0RBQVcsQ0FBQyxLQUFLLElBQUk7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNEQUFRO0FBQ3RDLGlDQUFpQyxzREFBVyxDQUFDLEtBQUssSUFBSTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQscUJBQXFCLGlCQUFpQjtBQUN6Rix3QkFBd0Isd0RBQVk7QUFDcEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0VBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrREFBZSxNQUFNLDZEQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUksRUFBRSw0Q0FBNEM7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjLHlCQUF5QjtBQUNwRjtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkRBQVcsaUJBQWlCLHlCQUF5QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0VBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlEQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsc0JBQXNCO0FBQ2pIO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSyxFQUFFLEtBQUssR0FBRyxNQUFNO0FBQ3pDO0FBQ0Esa0JBQWtCLHNCQUFzQixLQUFLLEtBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtFQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtFQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNERBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5REFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixNQUFNO0FBQ25DLDZCQUE2QixrREFBa0Q7QUFDL0UseUJBQXlCLHVEQUF1RDtBQUNoRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvRUFBb0U7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLFNBQVM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0VBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhLGlCQUFpQiw2Q0FBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEUscUJBQXFCLDJEQUFXO0FBQ2hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0JBQWdCLHVCQUF1QjtBQUN2QyxpR0FBaUcsT0FBTztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVDQUF1QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRDQUE0QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0lBQXNJLFNBQVM7QUFDL0k7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2QkFBNkIsWUFBWSw2Q0FBTTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFdBQVcsc0RBQXNEO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtRUFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFNBQVM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHNWQUFzVjtBQUNuWTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEZBQTBGO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUNBQXVDLEdBQUcsSUFBSSxHQUFHLE9BQU8sR0FBRyxRQUFRO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxREFBSztBQUM5QjtBQUNBO0FBQ0EsK0JBQStCLHFEQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxREFBSztBQUNoQztBQUNBO0FBQ0EsMEJBQTBCLHFEQUFLO0FBQy9CO0FBQ0E7QUFDQSx5QkFBeUIscURBQUs7QUFDOUI7QUFDQTtBQUNBLDRCQUE0QixxREFBSztBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLHFEQUFLO0FBQzVCO0FBQ0E7QUFDQSxxQkFBcUIscURBQUs7QUFDMUI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFEQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvREFBSTtBQUNmO0FBQ0EsK0JBQStCLHFEQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHFEQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0JBQWdCLHFEQUFLLElBQUksR0FBRyxlQUFlO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixjQUFjLGlCQUFpQixHQUFHLHlDQUF5QyxHQUFHLHNEQUFXLENBQUMsR0FBRyxtQkFBbUI7QUFDaEg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFNBQVM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1FQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9FQUFvRTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtRUFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0VBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxZQUFZLG1FQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUVBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMktBQTJLO0FBQzNLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHdEQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCLEdBQUcsbUJBQW1CLEdBQUcsVUFBVTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSwwQkFBMEI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0VBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwrREFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFlBQVk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxrQkFBa0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQTtBQUNBLG9DQUFvQyxnQ0FBZ0M7QUFDcEU7QUFDQSxnQ0FBZ0MsK0RBQStEO0FBQy9GO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHNFQUFzRTtBQUNqSCxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxzRUFBc0U7QUFDckgsK0NBQStDLG9FQUFvRTtBQUNuSCxrSkFBa0osWUFBWTtBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQixJQUFJLG1CQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsWUFBWTtBQUMzRCxJQUFJLGNBQWM7QUFDbEIsUUFBUSxtQkFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJEQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQVMsNkRBQTZEO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxlQUFlO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsdUJBQXVCO0FBQy9FO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekIsNkNBQTZDLEtBQUs7QUFDbEQ7QUFDQSxxQ0FBcUMsUUFBUSxTQUFTLElBQUksS0FBSyxFQUFFLFFBQVE7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsbUJBQW1CO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDLFFBQVEsbUJBQW1CO0FBQzNCLGtDQUFrQyxpQ0FBaUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx5QkFBeUI7QUFDbkYsSUFBSSxpQkFBaUI7QUFDckI7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkMsSUFBSSxtQkFBbUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1DQUFtQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Ysc0JBQXNCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHFCQUFxQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxvQkFBb0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9DQUFvQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0JBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHNCQUFzQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQTJCLGNBQWMsNkNBQU07QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDJEQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxjQUFjLHFCQUFxQjtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsd0JBQXdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGtDQUFrQztBQUMzRTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsNkJBQTZCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFNBQVM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0VBQWdFO0FBQ2hGO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUNBQW1DO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0VBQWdFO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUVBQWlCLENBQUMsa0VBQWtCO0FBQ3JEO0FBQ0E7QUFDQSxVQUFVLGlFQUFpQixDQUFDLGtFQUFrQjtBQUM5QztBQUNBO0FBQ0Esd0JBQXdCLGlFQUFpQixDQUFDLGtFQUFrQjtBQUM1RDtBQUNBLFVBQVUsaUVBQWlCLENBQUMsa0VBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpRUFBaUIsQ0FBQyxrRUFBa0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQscUJBQXFCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxxQkFBcUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx1QkFBdUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QixJQUFJLHlCQUF5QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzQkFBc0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxhQUFhLHdCQUF3QjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGFBQWEsNERBQTREO0FBQ2xKO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCLFFBQVEscUJBQXFCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVCQUF1QixRQUFRLGlCQUFpQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0EsNkNBQTZDLCtCQUErQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0ZBQW9GO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1QkFBdUIsS0FBSyxpQkFBaUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUIsUUFBUSxxQkFBcUI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCLFFBQVEsaUJBQWlCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQSx3Q0FBd0MsK0JBQStCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHVCQUF1QixLQUFLLGlCQUFpQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUIsUUFBUSxxQkFBcUI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCLFFBQVEsaUJBQWlCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQSx3Q0FBd0MsK0JBQStCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQ0FBaUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1QkFBdUIsS0FBSyxpQkFBaUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUNBQXVDLHVCQUF1QixRQUFRLHFCQUFxQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUIsUUFBUSxpQkFBaUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBLHdDQUF3QywrQkFBK0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxvQ0FBb0M7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzQkFBc0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsc0JBQXNCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5Q0FBeUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sb0JBQW9CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQixRQUFRLHNCQUFzQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCLFFBQVEsaUJBQWlCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsK0JBQStCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHVCQUF1QixLQUFLLGlCQUFpQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCLFFBQVEscUJBQXFCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVCQUF1QixRQUFRLGlCQUFpQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0Esd0NBQXdDLCtCQUErQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUNBQXFDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hELElBQUksc0NBQXNDO0FBQzFDO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbUVBQW9CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5REFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDhEQUE4RDtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrRUFBa0I7QUFDM0M7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixRQUFRLG1FQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxrREFBa0Q7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtRUFBb0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sb0JBQW9CO0FBQzNCO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQsSUFBSSxzQ0FBc0M7QUFDMUM7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxvQkFBb0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0VBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHNCQUFzQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWSxjQUFjLFlBQVk7QUFDOUUsbUJBQW1CLHNDQUFzQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrRUFBa0I7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osa0JBQWtCLCtEQUErRDtBQUNqRjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRCxJQUFJLHNDQUFzQztBQUMxQztBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1FQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw0QkFBNEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0Esb0NBQW9DLHlCQUF5QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0VBQWtCO0FBQzFDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9CQUFvQiw4RkFBOEY7QUFDbEg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtFQUFrQixVQUFVLFNBQVM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrRUFBa0I7QUFDMUMsd0RBQXdELFNBQVM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU8sd0JBQXdCLGtFQUFrQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQsSUFBSSxzQ0FBc0M7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1FQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDhGQUE4RjtBQUNqSTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hELElBQUksc0NBQXNDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxxQ0FBcUM7QUFDaEc7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbUVBQW9CO0FBQzVCO0FBQ0E7QUFDQSxnQ0FBZ0Msa0VBQWtCO0FBQ2xELG1DQUFtQyw4RkFBOEY7QUFDakk7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwyQkFBMkI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsWUFBWTtBQUMxQztBQUNBLG9DQUFvQyx5QkFBeUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSwwQkFBMEI7QUFDbkc7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hELElBQUksc0NBQXNDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbUVBQW9CO0FBQzVCO0FBQ0E7QUFDQSx3QkFBd0Isa0VBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkseUJBQXlCO0FBQzdCLElBQUksbUJBQW1CO0FBQ3ZCLElBQUksbUJBQW1CO0FBQ3ZCO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdIQUF3SDtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0Isc0JBQXNCLGtFQUFrQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsc0JBQXNCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MseUJBQXlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtFQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNCQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MseUJBQXlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtFQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpQ0FBaUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtFQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFlBQVk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWSxjQUFjLFlBQVk7QUFDOUUsbUJBQW1CLHNDQUFzQztBQUN6RDtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1DQUFtQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EscUJBQXFCLCtCQUErQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrRUFBa0I7QUFDM0MsUUFBUSxtRUFBb0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1DQUFtQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrRUFBa0I7QUFDbkQ7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsWUFBWTtBQUMzRSxJQUFJLHNDQUFzQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQyw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtFQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSx1QkFBdUI7QUFDbEc7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtFQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrRUFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtFQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrRUFBa0I7QUFDdEI7QUFDQTtBQUNBLDZDQUE2Qyx3QkFBd0I7QUFDckUsSUFBSSxZQUFZO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBCQUEwQixLQUFLLHdCQUF3QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQsSUFBSSxzQ0FBc0M7QUFDMUM7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQywwQkFBMEIsV0FBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0VBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRCxJQUFJLHNDQUFzQztBQUMxQztBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrRUFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtQ0FBbUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrRUFBa0I7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UscUJBQXFCLHNFQUFzRTtBQUM3SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQztBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEMsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0VBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esa0VBQWtFLEtBQUs7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUJBQXVCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrRUFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpRUFBa0IsS0FBSywwREFBUyxpREFBaUQsZUFBZTtBQUNwRztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDLDBHQUEwRyxtQkFBbUI7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGlFQUFrQixLQUFLLDBEQUFTO0FBQ3BDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSw4REFBZTtBQUNuQjtBQUNBLElBQUksOERBQWU7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxREFBTTtBQUM3QixxQkFBcUIsMkRBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0VBQXNCO0FBQ25EO0FBQ0EsNENBQTRDLGlCQUFpQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLCtCQUErQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdDQUFnQztBQUNuRDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0EsbUJBQW1CLGdDQUFnQztBQUNuRCxRQUFRLDZCQUE2QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdDQUFnQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQ0FBZ0M7QUFDbkQsUUFBUSx3Q0FBd0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQTBCO0FBQ3JELDhCQUE4QixpQkFBaUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrQkFBK0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTyxHQUFHLFlBQVksVUFBVSxlQUFlLFVBQVUsT0FBTyxhQUFhLHNCQUFzQixVQUFVLGdCQUFnQjtBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStvRjtBQUMvb0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL2Rpc3Qvbm9kZS1lc20vdG90cC0zZGYyZjVmOS5qcz8yZDI1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNES19WRVJTSU9OLCBfaXNGaXJlYmFzZVNlcnZlckFwcCwgX2dldFByb3ZpZGVyLCBfcmVnaXN0ZXJDb21wb25lbnQsIHJlZ2lzdGVyVmVyc2lvbiwgZ2V0QXBwIH0gZnJvbSAnQGZpcmViYXNlL2FwcCc7XG5pbXBvcnQgeyBFcnJvckZhY3RvcnksIGlzQnJvd3NlckV4dGVuc2lvbiwgaXNNb2JpbGVDb3Jkb3ZhLCBpc1JlYWN0TmF0aXZlLCBGaXJlYmFzZUVycm9yLCBxdWVyeXN0cmluZywgaXNDbG91ZGZsYXJlV29ya2VyLCBnZXRNb2R1bGFySW5zdGFuY2UsIGJhc2U2NERlY29kZSwgZ2V0VUEsIGlzSUUsIGNyZWF0ZVN1YnNjcmliZSwgZGVlcEVxdWFsLCBxdWVyeXN0cmluZ0RlY29kZSwgZXh0cmFjdFF1ZXJ5c3RyaW5nLCBnZXREZWZhdWx0RW11bGF0b3JIb3N0IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgX19yZXN0IH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBMb2dnZXIsIExvZ0xldmVsIH0gZnJvbSAnQGZpcmViYXNlL2xvZ2dlcic7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuIGVudW0gb2YgZmFjdG9ycyB0aGF0IG1heSBiZSB1c2VkIGZvciBtdWx0aWZhY3RvciBhdXRoZW50aWNhdGlvbi5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IEZhY3RvcklkID0ge1xuICAgIC8qKiBQaG9uZSBhcyBzZWNvbmQgZmFjdG9yICovXG4gICAgUEhPTkU6ICdwaG9uZScsXG4gICAgVE9UUDogJ3RvdHAnXG59O1xuLyoqXG4gKiBFbnVtZXJhdGlvbiBvZiBzdXBwb3J0ZWQgcHJvdmlkZXJzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgUHJvdmlkZXJJZCA9IHtcbiAgICAvKiogRmFjZWJvb2sgcHJvdmlkZXIgSUQgKi9cbiAgICBGQUNFQk9PSzogJ2ZhY2Vib29rLmNvbScsXG4gICAgLyoqIEdpdEh1YiBwcm92aWRlciBJRCAqL1xuICAgIEdJVEhVQjogJ2dpdGh1Yi5jb20nLFxuICAgIC8qKiBHb29nbGUgcHJvdmlkZXIgSUQgKi9cbiAgICBHT09HTEU6ICdnb29nbGUuY29tJyxcbiAgICAvKiogUGFzc3dvcmQgcHJvdmlkZXIgKi9cbiAgICBQQVNTV09SRDogJ3Bhc3N3b3JkJyxcbiAgICAvKiogUGhvbmUgcHJvdmlkZXIgKi9cbiAgICBQSE9ORTogJ3Bob25lJyxcbiAgICAvKiogVHdpdHRlciBwcm92aWRlciBJRCAqL1xuICAgIFRXSVRURVI6ICd0d2l0dGVyLmNvbSdcbn07XG4vKipcbiAqIEVudW1lcmF0aW9uIG9mIHN1cHBvcnRlZCBzaWduLWluIG1ldGhvZHMuXG4gKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBTaWduSW5NZXRob2QgPSB7XG4gICAgLyoqIEVtYWlsIGxpbmsgc2lnbiBpbiBtZXRob2QgKi9cbiAgICBFTUFJTF9MSU5LOiAnZW1haWxMaW5rJyxcbiAgICAvKiogRW1haWwvcGFzc3dvcmQgc2lnbiBpbiBtZXRob2QgKi9cbiAgICBFTUFJTF9QQVNTV09SRDogJ3Bhc3N3b3JkJyxcbiAgICAvKiogRmFjZWJvb2sgc2lnbiBpbiBtZXRob2QgKi9cbiAgICBGQUNFQk9PSzogJ2ZhY2Vib29rLmNvbScsXG4gICAgLyoqIEdpdEh1YiBzaWduIGluIG1ldGhvZCAqL1xuICAgIEdJVEhVQjogJ2dpdGh1Yi5jb20nLFxuICAgIC8qKiBHb29nbGUgc2lnbiBpbiBtZXRob2QgKi9cbiAgICBHT09HTEU6ICdnb29nbGUuY29tJyxcbiAgICAvKiogUGhvbmUgc2lnbiBpbiBtZXRob2QgKi9cbiAgICBQSE9ORTogJ3Bob25lJyxcbiAgICAvKiogVHdpdHRlciBzaWduIGluIG1ldGhvZCAqL1xuICAgIFRXSVRURVI6ICd0d2l0dGVyLmNvbSdcbn07XG4vKipcbiAqIEVudW1lcmF0aW9uIG9mIHN1cHBvcnRlZCBvcGVyYXRpb24gdHlwZXMuXG4gKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBPcGVyYXRpb25UeXBlID0ge1xuICAgIC8qKiBPcGVyYXRpb24gaW52b2x2aW5nIGxpbmtpbmcgYW4gYWRkaXRpb25hbCBwcm92aWRlciB0byBhbiBhbHJlYWR5IHNpZ25lZC1pbiB1c2VyLiAqL1xuICAgIExJTks6ICdsaW5rJyxcbiAgICAvKiogT3BlcmF0aW9uIGludm9sdmluZyB1c2luZyBhIHByb3ZpZGVyIHRvIHJlYXV0aGVudGljYXRlIGFuIGFscmVhZHkgc2lnbmVkLWluIHVzZXIuICovXG4gICAgUkVBVVRIRU5USUNBVEU6ICdyZWF1dGhlbnRpY2F0ZScsXG4gICAgLyoqIE9wZXJhdGlvbiBpbnZvbHZpbmcgc2lnbmluZyBpbiBhIHVzZXIuICovXG4gICAgU0lHTl9JTjogJ3NpZ25Jbidcbn07XG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHRoZSBwb3NzaWJsZSBlbWFpbCBhY3Rpb24gdHlwZXMuXG4gKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBBY3Rpb25Db2RlT3BlcmF0aW9uID0ge1xuICAgIC8qKiBUaGUgZW1haWwgbGluayBzaWduLWluIGFjdGlvbi4gKi9cbiAgICBFTUFJTF9TSUdOSU46ICdFTUFJTF9TSUdOSU4nLFxuICAgIC8qKiBUaGUgcGFzc3dvcmQgcmVzZXQgYWN0aW9uLiAqL1xuICAgIFBBU1NXT1JEX1JFU0VUOiAnUEFTU1dPUkRfUkVTRVQnLFxuICAgIC8qKiBUaGUgZW1haWwgcmV2b2NhdGlvbiBhY3Rpb24uICovXG4gICAgUkVDT1ZFUl9FTUFJTDogJ1JFQ09WRVJfRU1BSUwnLFxuICAgIC8qKiBUaGUgcmV2ZXJ0IHNlY29uZCBmYWN0b3IgYWRkaXRpb24gZW1haWwgYWN0aW9uLiAqL1xuICAgIFJFVkVSVF9TRUNPTkRfRkFDVE9SX0FERElUSU9OOiAnUkVWRVJUX1NFQ09ORF9GQUNUT1JfQURESVRJT04nLFxuICAgIC8qKiBUaGUgcmV2ZXJ0IHNlY29uZCBmYWN0b3IgYWRkaXRpb24gZW1haWwgYWN0aW9uLiAqL1xuICAgIFZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMOiAnVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwnLFxuICAgIC8qKiBUaGUgZW1haWwgdmVyaWZpY2F0aW9uIGFjdGlvbi4gKi9cbiAgICBWRVJJRllfRU1BSUw6ICdWRVJJRllfRU1BSUwnXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gX2RlYnVnRXJyb3JNYXAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgW1wiYWRtaW4tcmVzdHJpY3RlZC1vcGVyYXRpb25cIiAvKiBBdXRoRXJyb3JDb2RlLkFETUlOX09OTFlfT1BFUkFUSU9OICovXTogJ1RoaXMgb3BlcmF0aW9uIGlzIHJlc3RyaWN0ZWQgdG8gYWRtaW5pc3RyYXRvcnMgb25seS4nLFxuICAgICAgICBbXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi9dOiAnJyxcbiAgICAgICAgW1wiYXBwLW5vdC1hdXRob3JpemVkXCIgLyogQXV0aEVycm9yQ29kZS5BUFBfTk9UX0FVVEhPUklaRUQgKi9dOiBcIlRoaXMgYXBwLCBpZGVudGlmaWVkIGJ5IHRoZSBkb21haW4gd2hlcmUgaXQncyBob3N0ZWQsIGlzIG5vdCBcIiArXG4gICAgICAgICAgICAnYXV0aG9yaXplZCB0byB1c2UgRmlyZWJhc2UgQXV0aGVudGljYXRpb24gd2l0aCB0aGUgcHJvdmlkZWQgQVBJIGtleS4gJyArXG4gICAgICAgICAgICAnUmV2aWV3IHlvdXIga2V5IGNvbmZpZ3VyYXRpb24gaW4gdGhlIEdvb2dsZSBBUEkgY29uc29sZS4nLFxuICAgICAgICBbXCJhcHAtbm90LWluc3RhbGxlZFwiIC8qIEF1dGhFcnJvckNvZGUuQVBQX05PVF9JTlNUQUxMRUQgKi9dOiAnVGhlIHJlcXVlc3RlZCBtb2JpbGUgYXBwbGljYXRpb24gY29ycmVzcG9uZGluZyB0byB0aGUgaWRlbnRpZmllciAoJyArXG4gICAgICAgICAgICAnQW5kcm9pZCBwYWNrYWdlIG5hbWUgb3IgaU9TIGJ1bmRsZSBJRCkgcHJvdmlkZWQgaXMgbm90IGluc3RhbGxlZCBvbiAnICtcbiAgICAgICAgICAgICd0aGlzIGRldmljZS4nLFxuICAgICAgICBbXCJjYXB0Y2hhLWNoZWNrLWZhaWxlZFwiIC8qIEF1dGhFcnJvckNvZGUuQ0FQVENIQV9DSEVDS19GQUlMRUQgKi9dOiAnVGhlIHJlQ0FQVENIQSByZXNwb25zZSB0b2tlbiBwcm92aWRlZCBpcyBlaXRoZXIgaW52YWxpZCwgZXhwaXJlZCwgJyArXG4gICAgICAgICAgICAnYWxyZWFkeSB1c2VkIG9yIHRoZSBkb21haW4gYXNzb2NpYXRlZCB3aXRoIGl0IGRvZXMgbm90IG1hdGNoIHRoZSBsaXN0ICcgK1xuICAgICAgICAgICAgJ29mIHdoaXRlbGlzdGVkIGRvbWFpbnMuJyxcbiAgICAgICAgW1wiY29kZS1leHBpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5DT0RFX0VYUElSRUQgKi9dOiAnVGhlIFNNUyBjb2RlIGhhcyBleHBpcmVkLiBQbGVhc2UgcmUtc2VuZCB0aGUgdmVyaWZpY2F0aW9uIGNvZGUgdG8gdHJ5ICcgK1xuICAgICAgICAgICAgJ2FnYWluLicsXG4gICAgICAgIFtcImNvcmRvdmEtbm90LXJlYWR5XCIgLyogQXV0aEVycm9yQ29kZS5DT1JET1ZBX05PVF9SRUFEWSAqL106ICdDb3Jkb3ZhIGZyYW1ld29yayBpcyBub3QgcmVhZHkuJyxcbiAgICAgICAgW1wiY29ycy11bnN1cHBvcnRlZFwiIC8qIEF1dGhFcnJvckNvZGUuQ09SU19VTlNVUFBPUlRFRCAqL106ICdUaGlzIGJyb3dzZXIgaXMgbm90IHN1cHBvcnRlZC4nLFxuICAgICAgICBbXCJjcmVkZW50aWFsLWFscmVhZHktaW4tdXNlXCIgLyogQXV0aEVycm9yQ29kZS5DUkVERU5USUFMX0FMUkVBRFlfSU5fVVNFICovXTogJ1RoaXMgY3JlZGVudGlhbCBpcyBhbHJlYWR5IGFzc29jaWF0ZWQgd2l0aCBhIGRpZmZlcmVudCB1c2VyIGFjY291bnQuJyxcbiAgICAgICAgW1wiY3VzdG9tLXRva2VuLW1pc21hdGNoXCIgLyogQXV0aEVycm9yQ29kZS5DUkVERU5USUFMX01JU01BVENIICovXTogJ1RoZSBjdXN0b20gdG9rZW4gY29ycmVzcG9uZHMgdG8gYSBkaWZmZXJlbnQgYXVkaWVuY2UuJyxcbiAgICAgICAgW1wicmVxdWlyZXMtcmVjZW50LWxvZ2luXCIgLyogQXV0aEVycm9yQ29kZS5DUkVERU5USUFMX1RPT19PTERfTE9HSU5fQUdBSU4gKi9dOiAnVGhpcyBvcGVyYXRpb24gaXMgc2Vuc2l0aXZlIGFuZCByZXF1aXJlcyByZWNlbnQgYXV0aGVudGljYXRpb24uIExvZyBpbiAnICtcbiAgICAgICAgICAgICdhZ2FpbiBiZWZvcmUgcmV0cnlpbmcgdGhpcyByZXF1ZXN0LicsXG4gICAgICAgIFtcImRlcGVuZGVudC1zZGstaW5pdGlhbGl6ZWQtYmVmb3JlLWF1dGhcIiAvKiBBdXRoRXJyb3JDb2RlLkRFUEVOREVOVF9TREtfSU5JVF9CRUZPUkVfQVVUSCAqL106ICdBbm90aGVyIEZpcmViYXNlIFNESyB3YXMgaW5pdGlhbGl6ZWQgYW5kIGlzIHRyeWluZyB0byB1c2UgQXV0aCBiZWZvcmUgQXV0aCBpcyAnICtcbiAgICAgICAgICAgICdpbml0aWFsaXplZC4gUGxlYXNlIGJlIHN1cmUgdG8gY2FsbCBgaW5pdGlhbGl6ZUF1dGhgIG9yIGBnZXRBdXRoYCBiZWZvcmUgJyArXG4gICAgICAgICAgICAnc3RhcnRpbmcgYW55IG90aGVyIEZpcmViYXNlIFNESy4nLFxuICAgICAgICBbXCJkeW5hbWljLWxpbmstbm90LWFjdGl2YXRlZFwiIC8qIEF1dGhFcnJvckNvZGUuRFlOQU1JQ19MSU5LX05PVF9BQ1RJVkFURUQgKi9dOiAnUGxlYXNlIGFjdGl2YXRlIER5bmFtaWMgTGlua3MgaW4gdGhlIEZpcmViYXNlIENvbnNvbGUgYW5kIGFncmVlIHRvIHRoZSB0ZXJtcyBhbmQgJyArXG4gICAgICAgICAgICAnY29uZGl0aW9ucy4nLFxuICAgICAgICBbXCJlbWFpbC1jaGFuZ2UtbmVlZHMtdmVyaWZpY2F0aW9uXCIgLyogQXV0aEVycm9yQ29kZS5FTUFJTF9DSEFOR0VfTkVFRFNfVkVSSUZJQ0FUSU9OICovXTogJ011bHRpLWZhY3RvciB1c2VycyBtdXN0IGFsd2F5cyBoYXZlIGEgdmVyaWZpZWQgZW1haWwuJyxcbiAgICAgICAgW1wiZW1haWwtYWxyZWFkeS1pbi11c2VcIiAvKiBBdXRoRXJyb3JDb2RlLkVNQUlMX0VYSVNUUyAqL106ICdUaGUgZW1haWwgYWRkcmVzcyBpcyBhbHJlYWR5IGluIHVzZSBieSBhbm90aGVyIGFjY291bnQuJyxcbiAgICAgICAgW1wiZW11bGF0b3ItY29uZmlnLWZhaWxlZFwiIC8qIEF1dGhFcnJvckNvZGUuRU1VTEFUT1JfQ09ORklHX0ZBSUxFRCAqL106ICdBdXRoIGluc3RhbmNlIGhhcyBhbHJlYWR5IGJlZW4gdXNlZCB0byBtYWtlIGEgbmV0d29yayBjYWxsLiBBdXRoIGNhbiAnICtcbiAgICAgICAgICAgICdubyBsb25nZXIgYmUgY29uZmlndXJlZCB0byB1c2UgdGhlIGVtdWxhdG9yLiBUcnkgY2FsbGluZyAnICtcbiAgICAgICAgICAgICdcImNvbm5lY3RBdXRoRW11bGF0b3IoKVwiIHNvb25lci4nLFxuICAgICAgICBbXCJleHBpcmVkLWFjdGlvbi1jb2RlXCIgLyogQXV0aEVycm9yQ29kZS5FWFBJUkVEX09PQl9DT0RFICovXTogJ1RoZSBhY3Rpb24gY29kZSBoYXMgZXhwaXJlZC4nLFxuICAgICAgICBbXCJjYW5jZWxsZWQtcG9wdXAtcmVxdWVzdFwiIC8qIEF1dGhFcnJvckNvZGUuRVhQSVJFRF9QT1BVUF9SRVFVRVNUICovXTogJ1RoaXMgb3BlcmF0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZCBkdWUgdG8gYW5vdGhlciBjb25mbGljdGluZyBwb3B1cCBiZWluZyBvcGVuZWQuJyxcbiAgICAgICAgW1wiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovXTogJ0FuIGludGVybmFsIEF1dGhFcnJvciBoYXMgb2NjdXJyZWQuJyxcbiAgICAgICAgW1wiaW52YWxpZC1hcHAtY3JlZGVudGlhbFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BUFBfQ1JFREVOVElBTCAqL106ICdUaGUgcGhvbmUgdmVyaWZpY2F0aW9uIHJlcXVlc3QgY29udGFpbnMgYW4gaW52YWxpZCBhcHBsaWNhdGlvbiB2ZXJpZmllci4nICtcbiAgICAgICAgICAgICcgVGhlIHJlQ0FQVENIQSB0b2tlbiByZXNwb25zZSBpcyBlaXRoZXIgaW52YWxpZCBvciBleHBpcmVkLicsXG4gICAgICAgIFtcImludmFsaWQtYXBwLWlkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0FQUF9JRCAqL106ICdUaGUgbW9iaWxlIGFwcCBpZGVudGlmaWVyIGlzIG5vdCByZWdpc3RlcmVkIGZvciB0aGUgY3VycmVudCBwcm9qZWN0LicsXG4gICAgICAgIFtcImludmFsaWQtdXNlci10b2tlblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BVVRIICovXTogXCJUaGlzIHVzZXIncyBjcmVkZW50aWFsIGlzbid0IHZhbGlkIGZvciB0aGlzIHByb2plY3QuIFRoaXMgY2FuIGhhcHBlbiBcIiArXG4gICAgICAgICAgICBcImlmIHRoZSB1c2VyJ3MgdG9rZW4gaGFzIGJlZW4gdGFtcGVyZWQgd2l0aCwgb3IgaWYgdGhlIHVzZXIgaXNuJ3QgZm9yIFwiICtcbiAgICAgICAgICAgICd0aGUgcHJvamVjdCBhc3NvY2lhdGVkIHdpdGggdGhpcyBBUEkga2V5LicsXG4gICAgICAgIFtcImludmFsaWQtYXV0aC1ldmVudFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BVVRIX0VWRU5UICovXTogJ0FuIGludGVybmFsIEF1dGhFcnJvciBoYXMgb2NjdXJyZWQuJyxcbiAgICAgICAgW1wiaW52YWxpZC12ZXJpZmljYXRpb24tY29kZVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DT0RFICovXTogJ1RoZSBTTVMgdmVyaWZpY2F0aW9uIGNvZGUgdXNlZCB0byBjcmVhdGUgdGhlIHBob25lIGF1dGggY3JlZGVudGlhbCBpcyAnICtcbiAgICAgICAgICAgICdpbnZhbGlkLiBQbGVhc2UgcmVzZW5kIHRoZSB2ZXJpZmljYXRpb24gY29kZSBzbXMgYW5kIGJlIHN1cmUgdG8gdXNlIHRoZSAnICtcbiAgICAgICAgICAgICd2ZXJpZmljYXRpb24gY29kZSBwcm92aWRlZCBieSB0aGUgdXNlci4nLFxuICAgICAgICBbXCJpbnZhbGlkLWNvbnRpbnVlLXVyaVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DT05USU5VRV9VUkkgKi9dOiAnVGhlIGNvbnRpbnVlIFVSTCBwcm92aWRlZCBpbiB0aGUgcmVxdWVzdCBpcyBpbnZhbGlkLicsXG4gICAgICAgIFtcImludmFsaWQtY29yZG92YS1jb25maWd1cmF0aW9uXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NPUkRPVkFfQ09ORklHVVJBVElPTiAqL106ICdUaGUgZm9sbG93aW5nIENvcmRvdmEgcGx1Z2lucyBtdXN0IGJlIGluc3RhbGxlZCB0byBlbmFibGUgT0F1dGggc2lnbi1pbjogJyArXG4gICAgICAgICAgICAnY29yZG92YS1wbHVnaW4tYnVpbGRpbmZvLCBjb3Jkb3ZhLXVuaXZlcnNhbC1saW5rcy1wbHVnaW4sICcgK1xuICAgICAgICAgICAgJ2NvcmRvdmEtcGx1Z2luLWJyb3dzZXJ0YWIsIGNvcmRvdmEtcGx1Z2luLWluYXBwYnJvd3NlciBhbmQgJyArXG4gICAgICAgICAgICAnY29yZG92YS1wbHVnaW4tY3VzdG9tdXJsc2NoZW1lLicsXG4gICAgICAgIFtcImludmFsaWQtY3VzdG9tLXRva2VuXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NVU1RPTV9UT0tFTiAqL106ICdUaGUgY3VzdG9tIHRva2VuIGZvcm1hdCBpcyBpbmNvcnJlY3QuIFBsZWFzZSBjaGVjayB0aGUgZG9jdW1lbnRhdGlvbi4nLFxuICAgICAgICBbXCJpbnZhbGlkLWR5bmFtaWMtbGluay1kb21haW5cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfRFlOQU1JQ19MSU5LX0RPTUFJTiAqL106ICdUaGUgcHJvdmlkZWQgZHluYW1pYyBsaW5rIGRvbWFpbiBpcyBub3QgY29uZmlndXJlZCBvciBhdXRob3JpemVkIGZvciB0aGUgY3VycmVudCBwcm9qZWN0LicsXG4gICAgICAgIFtcImludmFsaWQtZW1haWxcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfRU1BSUwgKi9dOiAnVGhlIGVtYWlsIGFkZHJlc3MgaXMgYmFkbHkgZm9ybWF0dGVkLicsXG4gICAgICAgIFtcImludmFsaWQtZW11bGF0b3Itc2NoZW1lXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0VNVUxBVE9SX1NDSEVNRSAqL106ICdFbXVsYXRvciBVUkwgbXVzdCBzdGFydCB3aXRoIGEgdmFsaWQgc2NoZW1lIChodHRwOi8vIG9yIGh0dHBzOi8vKS4nLFxuICAgICAgICBbXCJpbnZhbGlkLWFwaS1rZXlcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQVBJX0tFWSAqL106ICdZb3VyIEFQSSBrZXkgaXMgaW52YWxpZCwgcGxlYXNlIGNoZWNrIHlvdSBoYXZlIGNvcGllZCBpdCBjb3JyZWN0bHkuJyxcbiAgICAgICAgW1wiaW52YWxpZC1jZXJ0LWhhc2hcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ0VSVF9IQVNIICovXTogJ1RoZSBTSEEtMSBjZXJ0aWZpY2F0ZSBoYXNoIHByb3ZpZGVkIGlzIGludmFsaWQuJyxcbiAgICAgICAgW1wiaW52YWxpZC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NSRURFTlRJQUwgKi9dOiAnVGhlIHN1cHBsaWVkIGF1dGggY3JlZGVudGlhbCBpcyBpbmNvcnJlY3QsIG1hbGZvcm1lZCBvciBoYXMgZXhwaXJlZC4nLFxuICAgICAgICBbXCJpbnZhbGlkLW1lc3NhZ2UtcGF5bG9hZFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9NRVNTQUdFX1BBWUxPQUQgKi9dOiAnVGhlIGVtYWlsIHRlbXBsYXRlIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBhY3Rpb24gY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIGluIGl0cyBtZXNzYWdlLiAnICtcbiAgICAgICAgICAgICdQbGVhc2UgZml4IGJ5IGdvaW5nIHRvIHRoZSBBdXRoIGVtYWlsIHRlbXBsYXRlcyBzZWN0aW9uIGluIHRoZSBGaXJlYmFzZSBDb25zb2xlLicsXG4gICAgICAgIFtcImludmFsaWQtbXVsdGktZmFjdG9yLXNlc3Npb25cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfTUZBX1NFU1NJT04gKi9dOiAnVGhlIHJlcXVlc3QgZG9lcyBub3QgY29udGFpbiBhIHZhbGlkIHByb29mIG9mIGZpcnN0IGZhY3RvciBzdWNjZXNzZnVsIHNpZ24taW4uJyxcbiAgICAgICAgW1wiaW52YWxpZC1vYXV0aC1wcm92aWRlclwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9PQVVUSF9QUk9WSURFUiAqL106ICdFbWFpbEF1dGhQcm92aWRlciBpcyBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIG9wZXJhdGlvbi4gVGhpcyBvcGVyYXRpb24gJyArXG4gICAgICAgICAgICAnb25seSBzdXBwb3J0cyBPQXV0aCBwcm92aWRlcnMuJyxcbiAgICAgICAgW1wiaW52YWxpZC1vYXV0aC1jbGllbnQtaWRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfT0FVVEhfQ0xJRU5UX0lEICovXTogJ1RoZSBPQXV0aCBjbGllbnQgSUQgcHJvdmlkZWQgaXMgZWl0aGVyIGludmFsaWQgb3IgZG9lcyBub3QgbWF0Y2ggdGhlICcgK1xuICAgICAgICAgICAgJ3NwZWNpZmllZCBBUEkga2V5LicsXG4gICAgICAgIFtcInVuYXV0aG9yaXplZC1kb21haW5cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfT1JJR0lOICovXTogJ1RoaXMgZG9tYWluIGlzIG5vdCBhdXRob3JpemVkIGZvciBPQXV0aCBvcGVyYXRpb25zIGZvciB5b3VyIEZpcmViYXNlICcgK1xuICAgICAgICAgICAgJ3Byb2plY3QuIEVkaXQgdGhlIGxpc3Qgb2YgYXV0aG9yaXplZCBkb21haW5zIGZyb20gdGhlIEZpcmViYXNlIGNvbnNvbGUuJyxcbiAgICAgICAgW1wiaW52YWxpZC1hY3Rpb24tY29kZVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9PT0JfQ09ERSAqL106ICdUaGUgYWN0aW9uIGNvZGUgaXMgaW52YWxpZC4gVGhpcyBjYW4gaGFwcGVuIGlmIHRoZSBjb2RlIGlzIG1hbGZvcm1lZCwgJyArXG4gICAgICAgICAgICAnZXhwaXJlZCwgb3IgaGFzIGFscmVhZHkgYmVlbiB1c2VkLicsXG4gICAgICAgIFtcIndyb25nLXBhc3N3b3JkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1BBU1NXT1JEICovXTogJ1RoZSBwYXNzd29yZCBpcyBpbnZhbGlkIG9yIHRoZSB1c2VyIGRvZXMgbm90IGhhdmUgYSBwYXNzd29yZC4nLFxuICAgICAgICBbXCJpbnZhbGlkLXBlcnNpc3RlbmNlLXR5cGVcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUEVSU0lTVEVOQ0UgKi9dOiAnVGhlIHNwZWNpZmllZCBwZXJzaXN0ZW5jZSB0eXBlIGlzIGludmFsaWQuIEl0IGNhbiBvbmx5IGJlIGxvY2FsLCBzZXNzaW9uIG9yIG5vbmUuJyxcbiAgICAgICAgW1wiaW52YWxpZC1waG9uZS1udW1iZXJcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUEhPTkVfTlVNQkVSICovXTogJ1RoZSBmb3JtYXQgb2YgdGhlIHBob25lIG51bWJlciBwcm92aWRlZCBpcyBpbmNvcnJlY3QuIFBsZWFzZSBlbnRlciB0aGUgJyArXG4gICAgICAgICAgICAncGhvbmUgbnVtYmVyIGluIGEgZm9ybWF0IHRoYXQgY2FuIGJlIHBhcnNlZCBpbnRvIEUuMTY0IGZvcm1hdC4gRS4xNjQgJyArXG4gICAgICAgICAgICAncGhvbmUgbnVtYmVycyBhcmUgd3JpdHRlbiBpbiB0aGUgZm9ybWF0IFsrXVtjb3VudHJ5IGNvZGVdW3N1YnNjcmliZXIgJyArXG4gICAgICAgICAgICAnbnVtYmVyIGluY2x1ZGluZyBhcmVhIGNvZGVdLicsXG4gICAgICAgIFtcImludmFsaWQtcHJvdmlkZXItaWRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUFJPVklERVJfSUQgKi9dOiAnVGhlIHNwZWNpZmllZCBwcm92aWRlciBJRCBpcyBpbnZhbGlkLicsXG4gICAgICAgIFtcImludmFsaWQtcmVjaXBpZW50LWVtYWlsXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1JFQ0lQSUVOVF9FTUFJTCAqL106ICdUaGUgZW1haWwgY29ycmVzcG9uZGluZyB0byB0aGlzIGFjdGlvbiBmYWlsZWQgdG8gc2VuZCBhcyB0aGUgcHJvdmlkZWQgJyArXG4gICAgICAgICAgICAncmVjaXBpZW50IGVtYWlsIGFkZHJlc3MgaXMgaW52YWxpZC4nLFxuICAgICAgICBbXCJpbnZhbGlkLXNlbmRlclwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9TRU5ERVIgKi9dOiAnVGhlIGVtYWlsIHRlbXBsYXRlIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBhY3Rpb24gY29udGFpbnMgYW4gaW52YWxpZCBzZW5kZXIgZW1haWwgb3IgbmFtZS4gJyArXG4gICAgICAgICAgICAnUGxlYXNlIGZpeCBieSBnb2luZyB0byB0aGUgQXV0aCBlbWFpbCB0ZW1wbGF0ZXMgc2VjdGlvbiBpbiB0aGUgRmlyZWJhc2UgQ29uc29sZS4nLFxuICAgICAgICBbXCJpbnZhbGlkLXZlcmlmaWNhdGlvbi1pZFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9TRVNTSU9OX0lORk8gKi9dOiAnVGhlIHZlcmlmaWNhdGlvbiBJRCB1c2VkIHRvIGNyZWF0ZSB0aGUgcGhvbmUgYXV0aCBjcmVkZW50aWFsIGlzIGludmFsaWQuJyxcbiAgICAgICAgW1wiaW52YWxpZC10ZW5hbnQtaWRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfVEVOQU5UX0lEICovXTogXCJUaGUgQXV0aCBpbnN0YW5jZSdzIHRlbmFudCBJRCBpcyBpbnZhbGlkLlwiLFxuICAgICAgICBbXCJsb2dpbi1ibG9ja2VkXCIgLyogQXV0aEVycm9yQ29kZS5MT0dJTl9CTE9DS0VEICovXTogJ0xvZ2luIGJsb2NrZWQgYnkgdXNlci1wcm92aWRlZCBtZXRob2Q6IHskb3JpZ2luYWxNZXNzYWdlfScsXG4gICAgICAgIFtcIm1pc3NpbmctYW5kcm9pZC1wa2ctbmFtZVwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19BTkRST0lEX1BBQ0tBR0VfTkFNRSAqL106ICdBbiBBbmRyb2lkIFBhY2thZ2UgTmFtZSBtdXN0IGJlIHByb3ZpZGVkIGlmIHRoZSBBbmRyb2lkIEFwcCBpcyByZXF1aXJlZCB0byBiZSBpbnN0YWxsZWQuJyxcbiAgICAgICAgW1wiYXV0aC1kb21haW4tY29uZmlnLXJlcXVpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX0FVVEhfRE9NQUlOICovXTogJ0JlIHN1cmUgdG8gaW5jbHVkZSBhdXRoRG9tYWluIHdoZW4gY2FsbGluZyBmaXJlYmFzZS5pbml0aWFsaXplQXBwKCksICcgK1xuICAgICAgICAgICAgJ2J5IGZvbGxvd2luZyB0aGUgaW5zdHJ1Y3Rpb25zIGluIHRoZSBGaXJlYmFzZSBjb25zb2xlLicsXG4gICAgICAgIFtcIm1pc3NpbmctYXBwLWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQVBQX0NSRURFTlRJQUwgKi9dOiAnVGhlIHBob25lIHZlcmlmaWNhdGlvbiByZXF1ZXN0IGlzIG1pc3NpbmcgYW4gYXBwbGljYXRpb24gdmVyaWZpZXIgJyArXG4gICAgICAgICAgICAnYXNzZXJ0aW9uLiBBIHJlQ0FQVENIQSByZXNwb25zZSB0b2tlbiBuZWVkcyB0byBiZSBwcm92aWRlZC4nLFxuICAgICAgICBbXCJtaXNzaW5nLXZlcmlmaWNhdGlvbi1jb2RlXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX0NPREUgKi9dOiAnVGhlIHBob25lIGF1dGggY3JlZGVudGlhbCB3YXMgY3JlYXRlZCB3aXRoIGFuIGVtcHR5IFNNUyB2ZXJpZmljYXRpb24gY29kZS4nLFxuICAgICAgICBbXCJtaXNzaW5nLWNvbnRpbnVlLXVyaVwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19DT05USU5VRV9VUkkgKi9dOiAnQSBjb250aW51ZSBVUkwgbXVzdCBiZSBwcm92aWRlZCBpbiB0aGUgcmVxdWVzdC4nLFxuICAgICAgICBbXCJtaXNzaW5nLWlmcmFtZS1zdGFydFwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19JRlJBTUVfU1RBUlQgKi9dOiAnQW4gaW50ZXJuYWwgQXV0aEVycm9yIGhhcyBvY2N1cnJlZC4nLFxuICAgICAgICBbXCJtaXNzaW5nLWlvcy1idW5kbGUtaWRcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfSU9TX0JVTkRMRV9JRCAqL106ICdBbiBpT1MgQnVuZGxlIElEIG11c3QgYmUgcHJvdmlkZWQgaWYgYW4gQXBwIFN0b3JlIElEIGlzIHByb3ZpZGVkLicsXG4gICAgICAgIFtcIm1pc3Npbmctb3ItaW52YWxpZC1ub25jZVwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19PUl9JTlZBTElEX05PTkNFICovXTogJ1RoZSByZXF1ZXN0IGRvZXMgbm90IGNvbnRhaW4gYSB2YWxpZCBub25jZS4gVGhpcyBjYW4gb2NjdXIgaWYgdGhlICcgK1xuICAgICAgICAgICAgJ1NIQS0yNTYgaGFzaCBvZiB0aGUgcHJvdmlkZWQgcmF3IG5vbmNlIGRvZXMgbm90IG1hdGNoIHRoZSBoYXNoZWQgbm9uY2UgJyArXG4gICAgICAgICAgICAnaW4gdGhlIElEIHRva2VuIHBheWxvYWQuJyxcbiAgICAgICAgW1wibWlzc2luZy1wYXNzd29yZFwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19QQVNTV09SRCAqL106ICdBIG5vbi1lbXB0eSBwYXNzd29yZCBtdXN0IGJlIHByb3ZpZGVkJyxcbiAgICAgICAgW1wibWlzc2luZy1tdWx0aS1mYWN0b3ItaW5mb1wiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19NRkFfSU5GTyAqL106ICdObyBzZWNvbmQgZmFjdG9yIGlkZW50aWZpZXIgaXMgcHJvdmlkZWQuJyxcbiAgICAgICAgW1wibWlzc2luZy1tdWx0aS1mYWN0b3Itc2Vzc2lvblwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19NRkFfU0VTU0lPTiAqL106ICdUaGUgcmVxdWVzdCBpcyBtaXNzaW5nIHByb29mIG9mIGZpcnN0IGZhY3RvciBzdWNjZXNzZnVsIHNpZ24taW4uJyxcbiAgICAgICAgW1wibWlzc2luZy1waG9uZS1udW1iZXJcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfUEhPTkVfTlVNQkVSICovXTogJ1RvIHNlbmQgdmVyaWZpY2F0aW9uIGNvZGVzLCBwcm92aWRlIGEgcGhvbmUgbnVtYmVyIGZvciB0aGUgcmVjaXBpZW50LicsXG4gICAgICAgIFtcIm1pc3NpbmctdmVyaWZpY2F0aW9uLWlkXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1NFU1NJT05fSU5GTyAqL106ICdUaGUgcGhvbmUgYXV0aCBjcmVkZW50aWFsIHdhcyBjcmVhdGVkIHdpdGggYW4gZW1wdHkgdmVyaWZpY2F0aW9uIElELicsXG4gICAgICAgIFtcImFwcC1kZWxldGVkXCIgLyogQXV0aEVycm9yQ29kZS5NT0RVTEVfREVTVFJPWUVEICovXTogJ1RoaXMgaW5zdGFuY2Ugb2YgRmlyZWJhc2VBcHAgaGFzIGJlZW4gZGVsZXRlZC4nLFxuICAgICAgICBbXCJtdWx0aS1mYWN0b3ItaW5mby1ub3QtZm91bmRcIiAvKiBBdXRoRXJyb3JDb2RlLk1GQV9JTkZPX05PVF9GT1VORCAqL106ICdUaGUgdXNlciBkb2VzIG5vdCBoYXZlIGEgc2Vjb25kIGZhY3RvciBtYXRjaGluZyB0aGUgaWRlbnRpZmllciBwcm92aWRlZC4nLFxuICAgICAgICBbXCJtdWx0aS1mYWN0b3ItYXV0aC1yZXF1aXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuTUZBX1JFUVVJUkVEICovXTogJ1Byb29mIG9mIG93bmVyc2hpcCBvZiBhIHNlY29uZCBmYWN0b3IgaXMgcmVxdWlyZWQgdG8gY29tcGxldGUgc2lnbi1pbi4nLFxuICAgICAgICBbXCJhY2NvdW50LWV4aXN0cy13aXRoLWRpZmZlcmVudC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5ORUVEX0NPTkZJUk1BVElPTiAqL106ICdBbiBhY2NvdW50IGFscmVhZHkgZXhpc3RzIHdpdGggdGhlIHNhbWUgZW1haWwgYWRkcmVzcyBidXQgZGlmZmVyZW50ICcgK1xuICAgICAgICAgICAgJ3NpZ24taW4gY3JlZGVudGlhbHMuIFNpZ24gaW4gdXNpbmcgYSBwcm92aWRlciBhc3NvY2lhdGVkIHdpdGggdGhpcyAnICtcbiAgICAgICAgICAgICdlbWFpbCBhZGRyZXNzLicsXG4gICAgICAgIFtcIm5ldHdvcmstcmVxdWVzdC1mYWlsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk5FVFdPUktfUkVRVUVTVF9GQUlMRUQgKi9dOiAnQSBuZXR3b3JrIEF1dGhFcnJvciAoc3VjaCBhcyB0aW1lb3V0LCBpbnRlcnJ1cHRlZCBjb25uZWN0aW9uIG9yIHVucmVhY2hhYmxlIGhvc3QpIGhhcyBvY2N1cnJlZC4nLFxuICAgICAgICBbXCJuby1hdXRoLWV2ZW50XCIgLyogQXV0aEVycm9yQ29kZS5OT19BVVRIX0VWRU5UICovXTogJ0FuIGludGVybmFsIEF1dGhFcnJvciBoYXMgb2NjdXJyZWQuJyxcbiAgICAgICAgW1wibm8tc3VjaC1wcm92aWRlclwiIC8qIEF1dGhFcnJvckNvZGUuTk9fU1VDSF9QUk9WSURFUiAqL106ICdVc2VyIHdhcyBub3QgbGlua2VkIHRvIGFuIGFjY291bnQgd2l0aCB0aGUgZ2l2ZW4gcHJvdmlkZXIuJyxcbiAgICAgICAgW1wibnVsbC11c2VyXCIgLyogQXV0aEVycm9yQ29kZS5OVUxMX1VTRVIgKi9dOiAnQSBudWxsIHVzZXIgb2JqZWN0IHdhcyBwcm92aWRlZCBhcyB0aGUgYXJndW1lbnQgZm9yIGFuIG9wZXJhdGlvbiB3aGljaCAnICtcbiAgICAgICAgICAgICdyZXF1aXJlcyBhIG5vbi1udWxsIHVzZXIgb2JqZWN0LicsXG4gICAgICAgIFtcIm9wZXJhdGlvbi1ub3QtYWxsb3dlZFwiIC8qIEF1dGhFcnJvckNvZGUuT1BFUkFUSU9OX05PVF9BTExPV0VEICovXTogJ1RoZSBnaXZlbiBzaWduLWluIHByb3ZpZGVyIGlzIGRpc2FibGVkIGZvciB0aGlzIEZpcmViYXNlIHByb2plY3QuICcgK1xuICAgICAgICAgICAgJ0VuYWJsZSBpdCBpbiB0aGUgRmlyZWJhc2UgY29uc29sZSwgdW5kZXIgdGhlIHNpZ24taW4gbWV0aG9kIHRhYiBvZiB0aGUgJyArXG4gICAgICAgICAgICAnQXV0aCBzZWN0aW9uLicsXG4gICAgICAgIFtcIm9wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnRcIiAvKiBBdXRoRXJyb3JDb2RlLk9QRVJBVElPTl9OT1RfU1VQUE9SVEVEICovXTogJ1RoaXMgb3BlcmF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGVudmlyb25tZW50IHRoaXMgYXBwbGljYXRpb24gaXMgJyArXG4gICAgICAgICAgICAncnVubmluZyBvbi4gXCJsb2NhdGlvbi5wcm90b2NvbFwiIG11c3QgYmUgaHR0cCwgaHR0cHMgb3IgY2hyb21lLWV4dGVuc2lvbicgK1xuICAgICAgICAgICAgJyBhbmQgd2ViIHN0b3JhZ2UgbXVzdCBiZSBlbmFibGVkLicsXG4gICAgICAgIFtcInBvcHVwLWJsb2NrZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlBPUFVQX0JMT0NLRUQgKi9dOiAnVW5hYmxlIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gd2l0aCB0aGUgcG9wdXAuIEl0IG1heSBoYXZlIGJlZW4gYmxvY2tlZCBieSB0aGUgYnJvd3Nlci4nLFxuICAgICAgICBbXCJwb3B1cC1jbG9zZWQtYnktdXNlclwiIC8qIEF1dGhFcnJvckNvZGUuUE9QVVBfQ0xPU0VEX0JZX1VTRVIgKi9dOiAnVGhlIHBvcHVwIGhhcyBiZWVuIGNsb3NlZCBieSB0aGUgdXNlciBiZWZvcmUgZmluYWxpemluZyB0aGUgb3BlcmF0aW9uLicsXG4gICAgICAgIFtcInByb3ZpZGVyLWFscmVhZHktbGlua2VkXCIgLyogQXV0aEVycm9yQ29kZS5QUk9WSURFUl9BTFJFQURZX0xJTktFRCAqL106ICdVc2VyIGNhbiBvbmx5IGJlIGxpbmtlZCB0byBvbmUgaWRlbnRpdHkgZm9yIHRoZSBnaXZlbiBwcm92aWRlci4nLFxuICAgICAgICBbXCJxdW90YS1leGNlZWRlZFwiIC8qIEF1dGhFcnJvckNvZGUuUVVPVEFfRVhDRUVERUQgKi9dOiBcIlRoZSBwcm9qZWN0J3MgcXVvdGEgZm9yIHRoaXMgb3BlcmF0aW9uIGhhcyBiZWVuIGV4Y2VlZGVkLlwiLFxuICAgICAgICBbXCJyZWRpcmVjdC1jYW5jZWxsZWQtYnktdXNlclwiIC8qIEF1dGhFcnJvckNvZGUuUkVESVJFQ1RfQ0FOQ0VMTEVEX0JZX1VTRVIgKi9dOiAnVGhlIHJlZGlyZWN0IG9wZXJhdGlvbiBoYXMgYmVlbiBjYW5jZWxsZWQgYnkgdGhlIHVzZXIgYmVmb3JlIGZpbmFsaXppbmcuJyxcbiAgICAgICAgW1wicmVkaXJlY3Qtb3BlcmF0aW9uLXBlbmRpbmdcIiAvKiBBdXRoRXJyb3JDb2RlLlJFRElSRUNUX09QRVJBVElPTl9QRU5ESU5HICovXTogJ0EgcmVkaXJlY3Qgc2lnbi1pbiBvcGVyYXRpb24gaXMgYWxyZWFkeSBwZW5kaW5nLicsXG4gICAgICAgIFtcInJlamVjdGVkLWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLlJFSkVDVEVEX0NSRURFTlRJQUwgKi9dOiAnVGhlIHJlcXVlc3QgY29udGFpbnMgbWFsZm9ybWVkIG9yIG1pc21hdGNoaW5nIGNyZWRlbnRpYWxzLicsXG4gICAgICAgIFtcInNlY29uZC1mYWN0b3ItYWxyZWFkeS1pbi11c2VcIiAvKiBBdXRoRXJyb3JDb2RlLlNFQ09ORF9GQUNUT1JfQUxSRUFEWV9FTlJPTExFRCAqL106ICdUaGUgc2Vjb25kIGZhY3RvciBpcyBhbHJlYWR5IGVucm9sbGVkIG9uIHRoaXMgYWNjb3VudC4nLFxuICAgICAgICBbXCJtYXhpbXVtLXNlY29uZC1mYWN0b3ItY291bnQtZXhjZWVkZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlNFQ09ORF9GQUNUT1JfTElNSVRfRVhDRUVERUQgKi9dOiAnVGhlIG1heGltdW0gYWxsb3dlZCBudW1iZXIgb2Ygc2Vjb25kIGZhY3RvcnMgb24gYSB1c2VyIGhhcyBiZWVuIGV4Y2VlZGVkLicsXG4gICAgICAgIFtcInRlbmFudC1pZC1taXNtYXRjaFwiIC8qIEF1dGhFcnJvckNvZGUuVEVOQU5UX0lEX01JU01BVENIICovXTogXCJUaGUgcHJvdmlkZWQgdGVuYW50IElEIGRvZXMgbm90IG1hdGNoIHRoZSBBdXRoIGluc3RhbmNlJ3MgdGVuYW50IElEXCIsXG4gICAgICAgIFtcInRpbWVvdXRcIiAvKiBBdXRoRXJyb3JDb2RlLlRJTUVPVVQgKi9dOiAnVGhlIG9wZXJhdGlvbiBoYXMgdGltZWQgb3V0LicsXG4gICAgICAgIFtcInVzZXItdG9rZW4tZXhwaXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuVE9LRU5fRVhQSVJFRCAqL106IFwiVGhlIHVzZXIncyBjcmVkZW50aWFsIGlzIG5vIGxvbmdlciB2YWxpZC4gVGhlIHVzZXIgbXVzdCBzaWduIGluIGFnYWluLlwiLFxuICAgICAgICBbXCJ0b28tbWFueS1yZXF1ZXN0c1wiIC8qIEF1dGhFcnJvckNvZGUuVE9PX01BTllfQVRURU1QVFNfVFJZX0xBVEVSICovXTogJ1dlIGhhdmUgYmxvY2tlZCBhbGwgcmVxdWVzdHMgZnJvbSB0aGlzIGRldmljZSBkdWUgdG8gdW51c3VhbCBhY3Rpdml0eS4gJyArXG4gICAgICAgICAgICAnVHJ5IGFnYWluIGxhdGVyLicsXG4gICAgICAgIFtcInVuYXV0aG9yaXplZC1jb250aW51ZS11cmlcIiAvKiBBdXRoRXJyb3JDb2RlLlVOQVVUSE9SSVpFRF9ET01BSU4gKi9dOiAnVGhlIGRvbWFpbiBvZiB0aGUgY29udGludWUgVVJMIGlzIG5vdCB3aGl0ZWxpc3RlZC4gIFBsZWFzZSB3aGl0ZWxpc3QgJyArXG4gICAgICAgICAgICAndGhlIGRvbWFpbiBpbiB0aGUgRmlyZWJhc2UgY29uc29sZS4nLFxuICAgICAgICBbXCJ1bnN1cHBvcnRlZC1maXJzdC1mYWN0b3JcIiAvKiBBdXRoRXJyb3JDb2RlLlVOU1VQUE9SVEVEX0ZJUlNUX0ZBQ1RPUiAqL106ICdFbnJvbGxpbmcgYSBzZWNvbmQgZmFjdG9yIG9yIHNpZ25pbmcgaW4gd2l0aCBhIG11bHRpLWZhY3RvciBhY2NvdW50IHJlcXVpcmVzIHNpZ24taW4gd2l0aCBhIHN1cHBvcnRlZCBmaXJzdCBmYWN0b3IuJyxcbiAgICAgICAgW1widW5zdXBwb3J0ZWQtcGVyc2lzdGVuY2UtdHlwZVwiIC8qIEF1dGhFcnJvckNvZGUuVU5TVVBQT1JURURfUEVSU0lTVEVOQ0UgKi9dOiAnVGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgc3BlY2lmaWVkIHBlcnNpc3RlbmNlIHR5cGUuJyxcbiAgICAgICAgW1widW5zdXBwb3J0ZWQtdGVuYW50LW9wZXJhdGlvblwiIC8qIEF1dGhFcnJvckNvZGUuVU5TVVBQT1JURURfVEVOQU5UX09QRVJBVElPTiAqL106ICdUaGlzIG9wZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIGEgbXVsdGktdGVuYW50IGNvbnRleHQuJyxcbiAgICAgICAgW1widW52ZXJpZmllZC1lbWFpbFwiIC8qIEF1dGhFcnJvckNvZGUuVU5WRVJJRklFRF9FTUFJTCAqL106ICdUaGUgb3BlcmF0aW9uIHJlcXVpcmVzIGEgdmVyaWZpZWQgZW1haWwuJyxcbiAgICAgICAgW1widXNlci1jYW5jZWxsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlVTRVJfQ0FOQ0VMTEVEICovXTogJ1RoZSB1c2VyIGRpZCBub3QgZ3JhbnQgeW91ciBhcHBsaWNhdGlvbiB0aGUgcGVybWlzc2lvbnMgaXQgcmVxdWVzdGVkLicsXG4gICAgICAgIFtcInVzZXItbm90LWZvdW5kXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX0RFTEVURUQgKi9dOiAnVGhlcmUgaXMgbm8gdXNlciByZWNvcmQgY29ycmVzcG9uZGluZyB0byB0aGlzIGlkZW50aWZpZXIuIFRoZSB1c2VyIG1heSAnICtcbiAgICAgICAgICAgICdoYXZlIGJlZW4gZGVsZXRlZC4nLFxuICAgICAgICBbXCJ1c2VyLWRpc2FibGVkXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX0RJU0FCTEVEICovXTogJ1RoZSB1c2VyIGFjY291bnQgaGFzIGJlZW4gZGlzYWJsZWQgYnkgYW4gYWRtaW5pc3RyYXRvci4nLFxuICAgICAgICBbXCJ1c2VyLW1pc21hdGNoXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX01JU01BVENIICovXTogJ1RoZSBzdXBwbGllZCBjcmVkZW50aWFscyBkbyBub3QgY29ycmVzcG9uZCB0byB0aGUgcHJldmlvdXNseSBzaWduZWQgaW4gdXNlci4nLFxuICAgICAgICBbXCJ1c2VyLXNpZ25lZC1vdXRcIiAvKiBBdXRoRXJyb3JDb2RlLlVTRVJfU0lHTkVEX09VVCAqL106ICcnLFxuICAgICAgICBbXCJ3ZWFrLXBhc3N3b3JkXCIgLyogQXV0aEVycm9yQ29kZS5XRUFLX1BBU1NXT1JEICovXTogJ1RoZSBwYXNzd29yZCBtdXN0IGJlIDYgY2hhcmFjdGVycyBsb25nIG9yIG1vcmUuJyxcbiAgICAgICAgW1wid2ViLXN0b3JhZ2UtdW5zdXBwb3J0ZWRcIiAvKiBBdXRoRXJyb3JDb2RlLldFQl9TVE9SQUdFX1VOU1VQUE9SVEVEICovXTogJ1RoaXMgYnJvd3NlciBpcyBub3Qgc3VwcG9ydGVkIG9yIDNyZCBwYXJ0eSBjb29raWVzIGFuZCBkYXRhIG1heSBiZSBkaXNhYmxlZC4nLFxuICAgICAgICBbXCJhbHJlYWR5LWluaXRpYWxpemVkXCIgLyogQXV0aEVycm9yQ29kZS5BTFJFQURZX0lOSVRJQUxJWkVEICovXTogJ2luaXRpYWxpemVBdXRoKCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQgd2l0aCAnICtcbiAgICAgICAgICAgICdkaWZmZXJlbnQgb3B0aW9ucy4gVG8gYXZvaWQgdGhpcyBlcnJvciwgY2FsbCBpbml0aWFsaXplQXV0aCgpIHdpdGggdGhlICcgK1xuICAgICAgICAgICAgJ3NhbWUgb3B0aW9ucyBhcyB3aGVuIGl0IHdhcyBvcmlnaW5hbGx5IGNhbGxlZCwgb3IgY2FsbCBnZXRBdXRoKCkgdG8gcmV0dXJuIHRoZScgK1xuICAgICAgICAgICAgJyBhbHJlYWR5IGluaXRpYWxpemVkIGluc3RhbmNlLicsXG4gICAgICAgIFtcIm1pc3NpbmctcmVjYXB0Y2hhLXRva2VuXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1JFQ0FQVENIQV9UT0tFTiAqL106ICdUaGUgcmVDQVBUQ0hBIHRva2VuIGlzIG1pc3Npbmcgd2hlbiBzZW5kaW5nIHJlcXVlc3QgdG8gdGhlIGJhY2tlbmQuJyxcbiAgICAgICAgW1wiaW52YWxpZC1yZWNhcHRjaGEtdG9rZW5cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDQVBUQ0hBX1RPS0VOICovXTogJ1RoZSByZUNBUFRDSEEgdG9rZW4gaXMgaW52YWxpZCB3aGVuIHNlbmRpbmcgcmVxdWVzdCB0byB0aGUgYmFja2VuZC4nLFxuICAgICAgICBbXCJpbnZhbGlkLXJlY2FwdGNoYS1hY3Rpb25cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDQVBUQ0hBX0FDVElPTiAqL106ICdUaGUgcmVDQVBUQ0hBIGFjdGlvbiBpcyBpbnZhbGlkIHdoZW4gc2VuZGluZyByZXF1ZXN0IHRvIHRoZSBiYWNrZW5kLicsXG4gICAgICAgIFtcInJlY2FwdGNoYS1ub3QtZW5hYmxlZFwiIC8qIEF1dGhFcnJvckNvZGUuUkVDQVBUQ0hBX05PVF9FTkFCTEVEICovXTogJ3JlQ0FQVENIQSBFbnRlcnByaXNlIGludGVncmF0aW9uIGlzIG5vdCBlbmFibGVkIGZvciB0aGlzIHByb2plY3QuJyxcbiAgICAgICAgW1wibWlzc2luZy1jbGllbnQtdHlwZVwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19DTElFTlRfVFlQRSAqL106ICdUaGUgcmVDQVBUQ0hBIGNsaWVudCB0eXBlIGlzIG1pc3Npbmcgd2hlbiBzZW5kaW5nIHJlcXVlc3QgdG8gdGhlIGJhY2tlbmQuJyxcbiAgICAgICAgW1wibWlzc2luZy1yZWNhcHRjaGEtdmVyc2lvblwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19SRUNBUFRDSEFfVkVSU0lPTiAqL106ICdUaGUgcmVDQVBUQ0hBIHZlcnNpb24gaXMgbWlzc2luZyB3aGVuIHNlbmRpbmcgcmVxdWVzdCB0byB0aGUgYmFja2VuZC4nLFxuICAgICAgICBbXCJpbnZhbGlkLXJlcS10eXBlXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1JFUV9UWVBFICovXTogJ0ludmFsaWQgcmVxdWVzdCBwYXJhbWV0ZXJzLicsXG4gICAgICAgIFtcImludmFsaWQtcmVjYXB0Y2hhLXZlcnNpb25cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDQVBUQ0hBX1ZFUlNJT04gKi9dOiAnVGhlIHJlQ0FQVENIQSB2ZXJzaW9uIGlzIGludmFsaWQgd2hlbiBzZW5kaW5nIHJlcXVlc3QgdG8gdGhlIGJhY2tlbmQuJyxcbiAgICAgICAgW1widW5zdXBwb3J0ZWQtcGFzc3dvcmQtcG9saWN5LXNjaGVtYS12ZXJzaW9uXCIgLyogQXV0aEVycm9yQ29kZS5VTlNVUFBPUlRFRF9QQVNTV09SRF9QT0xJQ1lfU0NIRU1BX1ZFUlNJT04gKi9dOiAnVGhlIHBhc3N3b3JkIHBvbGljeSByZWNlaXZlZCBmcm9tIHRoZSBiYWNrZW5kIHVzZXMgYSBzY2hlbWEgdmVyc2lvbiB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyB2ZXJzaW9uIG9mIHRoZSBGaXJlYmFzZSBTREsuJyxcbiAgICAgICAgW1wicGFzc3dvcmQtZG9lcy1ub3QtbWVldC1yZXF1aXJlbWVudHNcIiAvKiBBdXRoRXJyb3JDb2RlLlBBU1NXT1JEX0RPRVNfTk9UX01FRVRfUkVRVUlSRU1FTlRTICovXTogJ1RoZSBwYXNzd29yZCBkb2VzIG5vdCBtZWV0IHRoZSByZXF1aXJlbWVudHMuJ1xuICAgIH07XG59XG5mdW5jdGlvbiBfcHJvZEVycm9yTWFwKCkge1xuICAgIC8vIFdlIHdpbGwgaW5jbHVkZSB0aGlzIG9uZSBtZXNzYWdlIGluIHRoZSBwcm9kIGVycm9yIG1hcCBzaW5jZSBieSB0aGUgdmVyeVxuICAgIC8vIG5hdHVyZSBvZiB0aGlzIGVycm9yLCBkZXZlbG9wZXJzIHdpbGwgbmV2ZXIgYmUgYWJsZSB0byBzZWUgdGhlIG1lc3NhZ2VcbiAgICAvLyB1c2luZyB0aGUgZGVidWdFcnJvck1hcCAod2hpY2ggaXMgaW5zdGFsbGVkIGR1cmluZyBhdXRoIGluaXRpYWxpemF0aW9uKS5cbiAgICByZXR1cm4ge1xuICAgICAgICBbXCJkZXBlbmRlbnQtc2RrLWluaXRpYWxpemVkLWJlZm9yZS1hdXRoXCIgLyogQXV0aEVycm9yQ29kZS5ERVBFTkRFTlRfU0RLX0lOSVRfQkVGT1JFX0FVVEggKi9dOiAnQW5vdGhlciBGaXJlYmFzZSBTREsgd2FzIGluaXRpYWxpemVkIGFuZCBpcyB0cnlpbmcgdG8gdXNlIEF1dGggYmVmb3JlIEF1dGggaXMgJyArXG4gICAgICAgICAgICAnaW5pdGlhbGl6ZWQuIFBsZWFzZSBiZSBzdXJlIHRvIGNhbGwgYGluaXRpYWxpemVBdXRoYCBvciBgZ2V0QXV0aGAgYmVmb3JlICcgK1xuICAgICAgICAgICAgJ3N0YXJ0aW5nIGFueSBvdGhlciBGaXJlYmFzZSBTREsuJ1xuICAgIH07XG59XG4vKipcbiAqIEEgdmVyYm9zZSBlcnJvciBtYXAgd2l0aCBkZXRhaWxlZCBkZXNjcmlwdGlvbnMgZm9yIG1vc3QgZXJyb3IgY29kZXMuXG4gKlxuICogU2VlIGRpc2N1c3Npb24gYXQge0BsaW5rIEF1dGhFcnJvck1hcH1cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IGRlYnVnRXJyb3JNYXAgPSBfZGVidWdFcnJvck1hcDtcbi8qKlxuICogQSBtaW5pbWFsIGVycm9yIG1hcCB3aXRoIGFsbCB2ZXJib3NlIGVycm9yIG1lc3NhZ2VzIHN0cmlwcGVkLlxuICpcbiAqIFNlZSBkaXNjdXNzaW9uIGF0IHtAbGluayBBdXRoRXJyb3JNYXB9XG4gKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBwcm9kRXJyb3JNYXAgPSBfcHJvZEVycm9yTWFwO1xuY29uc3QgX0RFRkFVTFRfQVVUSF9FUlJPUl9GQUNUT1JZID0gbmV3IEVycm9yRmFjdG9yeSgnYXV0aCcsICdGaXJlYmFzZScsIF9wcm9kRXJyb3JNYXAoKSk7XG4vKipcbiAqIEEgbWFwIG9mIHBvdGVudGlhbCBgQXV0aGAgZXJyb3IgY29kZXMsIGZvciBlYXNpZXIgY29tcGFyaXNvbiB3aXRoIGVycm9yc1xuICogdGhyb3duIGJ5IHRoZSBTREsuXG4gKlxuICogQHJlbWFya3NcbiAqIE5vdGUgdGhhdCB5b3UgY2FuJ3QgdHJlZS1zaGFrZSBpbmRpdmlkdWFsIGtleXNcbiAqIGluIHRoZSBtYXAsIHNvIGJ5IHVzaW5nIHRoZSBtYXAgeW91IG1pZ2h0IHN1YnN0YW50aWFsbHkgaW5jcmVhc2UgeW91clxuICogYnVuZGxlIHNpemUuXG4gKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBBVVRIX0VSUk9SX0NPREVTX01BUF9ET19OT1RfVVNFX0lOVEVSTkFMTFkgPSB7XG4gICAgQURNSU5fT05MWV9PUEVSQVRJT046ICdhdXRoL2FkbWluLXJlc3RyaWN0ZWQtb3BlcmF0aW9uJyxcbiAgICBBUkdVTUVOVF9FUlJPUjogJ2F1dGgvYXJndW1lbnQtZXJyb3InLFxuICAgIEFQUF9OT1RfQVVUSE9SSVpFRDogJ2F1dGgvYXBwLW5vdC1hdXRob3JpemVkJyxcbiAgICBBUFBfTk9UX0lOU1RBTExFRDogJ2F1dGgvYXBwLW5vdC1pbnN0YWxsZWQnLFxuICAgIENBUFRDSEFfQ0hFQ0tfRkFJTEVEOiAnYXV0aC9jYXB0Y2hhLWNoZWNrLWZhaWxlZCcsXG4gICAgQ09ERV9FWFBJUkVEOiAnYXV0aC9jb2RlLWV4cGlyZWQnLFxuICAgIENPUkRPVkFfTk9UX1JFQURZOiAnYXV0aC9jb3Jkb3ZhLW5vdC1yZWFkeScsXG4gICAgQ09SU19VTlNVUFBPUlRFRDogJ2F1dGgvY29ycy11bnN1cHBvcnRlZCcsXG4gICAgQ1JFREVOVElBTF9BTFJFQURZX0lOX1VTRTogJ2F1dGgvY3JlZGVudGlhbC1hbHJlYWR5LWluLXVzZScsXG4gICAgQ1JFREVOVElBTF9NSVNNQVRDSDogJ2F1dGgvY3VzdG9tLXRva2VuLW1pc21hdGNoJyxcbiAgICBDUkVERU5USUFMX1RPT19PTERfTE9HSU5fQUdBSU46ICdhdXRoL3JlcXVpcmVzLXJlY2VudC1sb2dpbicsXG4gICAgREVQRU5ERU5UX1NES19JTklUX0JFRk9SRV9BVVRIOiAnYXV0aC9kZXBlbmRlbnQtc2RrLWluaXRpYWxpemVkLWJlZm9yZS1hdXRoJyxcbiAgICBEWU5BTUlDX0xJTktfTk9UX0FDVElWQVRFRDogJ2F1dGgvZHluYW1pYy1saW5rLW5vdC1hY3RpdmF0ZWQnLFxuICAgIEVNQUlMX0NIQU5HRV9ORUVEU19WRVJJRklDQVRJT046ICdhdXRoL2VtYWlsLWNoYW5nZS1uZWVkcy12ZXJpZmljYXRpb24nLFxuICAgIEVNQUlMX0VYSVNUUzogJ2F1dGgvZW1haWwtYWxyZWFkeS1pbi11c2UnLFxuICAgIEVNVUxBVE9SX0NPTkZJR19GQUlMRUQ6ICdhdXRoL2VtdWxhdG9yLWNvbmZpZy1mYWlsZWQnLFxuICAgIEVYUElSRURfT09CX0NPREU6ICdhdXRoL2V4cGlyZWQtYWN0aW9uLWNvZGUnLFxuICAgIEVYUElSRURfUE9QVVBfUkVRVUVTVDogJ2F1dGgvY2FuY2VsbGVkLXBvcHVwLXJlcXVlc3QnLFxuICAgIElOVEVSTkFMX0VSUk9SOiAnYXV0aC9pbnRlcm5hbC1lcnJvcicsXG4gICAgSU5WQUxJRF9BUElfS0VZOiAnYXV0aC9pbnZhbGlkLWFwaS1rZXknLFxuICAgIElOVkFMSURfQVBQX0NSRURFTlRJQUw6ICdhdXRoL2ludmFsaWQtYXBwLWNyZWRlbnRpYWwnLFxuICAgIElOVkFMSURfQVBQX0lEOiAnYXV0aC9pbnZhbGlkLWFwcC1pZCcsXG4gICAgSU5WQUxJRF9BVVRIOiAnYXV0aC9pbnZhbGlkLXVzZXItdG9rZW4nLFxuICAgIElOVkFMSURfQVVUSF9FVkVOVDogJ2F1dGgvaW52YWxpZC1hdXRoLWV2ZW50JyxcbiAgICBJTlZBTElEX0NFUlRfSEFTSDogJ2F1dGgvaW52YWxpZC1jZXJ0LWhhc2gnLFxuICAgIElOVkFMSURfQ09ERTogJ2F1dGgvaW52YWxpZC12ZXJpZmljYXRpb24tY29kZScsXG4gICAgSU5WQUxJRF9DT05USU5VRV9VUkk6ICdhdXRoL2ludmFsaWQtY29udGludWUtdXJpJyxcbiAgICBJTlZBTElEX0NPUkRPVkFfQ09ORklHVVJBVElPTjogJ2F1dGgvaW52YWxpZC1jb3Jkb3ZhLWNvbmZpZ3VyYXRpb24nLFxuICAgIElOVkFMSURfQ1VTVE9NX1RPS0VOOiAnYXV0aC9pbnZhbGlkLWN1c3RvbS10b2tlbicsXG4gICAgSU5WQUxJRF9EWU5BTUlDX0xJTktfRE9NQUlOOiAnYXV0aC9pbnZhbGlkLWR5bmFtaWMtbGluay1kb21haW4nLFxuICAgIElOVkFMSURfRU1BSUw6ICdhdXRoL2ludmFsaWQtZW1haWwnLFxuICAgIElOVkFMSURfRU1VTEFUT1JfU0NIRU1FOiAnYXV0aC9pbnZhbGlkLWVtdWxhdG9yLXNjaGVtZScsXG4gICAgSU5WQUxJRF9JRFBfUkVTUE9OU0U6ICdhdXRoL2ludmFsaWQtY3JlZGVudGlhbCcsXG4gICAgSU5WQUxJRF9MT0dJTl9DUkVERU5USUFMUzogJ2F1dGgvaW52YWxpZC1jcmVkZW50aWFsJyxcbiAgICBJTlZBTElEX01FU1NBR0VfUEFZTE9BRDogJ2F1dGgvaW52YWxpZC1tZXNzYWdlLXBheWxvYWQnLFxuICAgIElOVkFMSURfTUZBX1NFU1NJT046ICdhdXRoL2ludmFsaWQtbXVsdGktZmFjdG9yLXNlc3Npb24nLFxuICAgIElOVkFMSURfT0FVVEhfQ0xJRU5UX0lEOiAnYXV0aC9pbnZhbGlkLW9hdXRoLWNsaWVudC1pZCcsXG4gICAgSU5WQUxJRF9PQVVUSF9QUk9WSURFUjogJ2F1dGgvaW52YWxpZC1vYXV0aC1wcm92aWRlcicsXG4gICAgSU5WQUxJRF9PT0JfQ09ERTogJ2F1dGgvaW52YWxpZC1hY3Rpb24tY29kZScsXG4gICAgSU5WQUxJRF9PUklHSU46ICdhdXRoL3VuYXV0aG9yaXplZC1kb21haW4nLFxuICAgIElOVkFMSURfUEFTU1dPUkQ6ICdhdXRoL3dyb25nLXBhc3N3b3JkJyxcbiAgICBJTlZBTElEX1BFUlNJU1RFTkNFOiAnYXV0aC9pbnZhbGlkLXBlcnNpc3RlbmNlLXR5cGUnLFxuICAgIElOVkFMSURfUEhPTkVfTlVNQkVSOiAnYXV0aC9pbnZhbGlkLXBob25lLW51bWJlcicsXG4gICAgSU5WQUxJRF9QUk9WSURFUl9JRDogJ2F1dGgvaW52YWxpZC1wcm92aWRlci1pZCcsXG4gICAgSU5WQUxJRF9SRUNJUElFTlRfRU1BSUw6ICdhdXRoL2ludmFsaWQtcmVjaXBpZW50LWVtYWlsJyxcbiAgICBJTlZBTElEX1NFTkRFUjogJ2F1dGgvaW52YWxpZC1zZW5kZXInLFxuICAgIElOVkFMSURfU0VTU0lPTl9JTkZPOiAnYXV0aC9pbnZhbGlkLXZlcmlmaWNhdGlvbi1pZCcsXG4gICAgSU5WQUxJRF9URU5BTlRfSUQ6ICdhdXRoL2ludmFsaWQtdGVuYW50LWlkJyxcbiAgICBNRkFfSU5GT19OT1RfRk9VTkQ6ICdhdXRoL211bHRpLWZhY3Rvci1pbmZvLW5vdC1mb3VuZCcsXG4gICAgTUZBX1JFUVVJUkVEOiAnYXV0aC9tdWx0aS1mYWN0b3ItYXV0aC1yZXF1aXJlZCcsXG4gICAgTUlTU0lOR19BTkRST0lEX1BBQ0tBR0VfTkFNRTogJ2F1dGgvbWlzc2luZy1hbmRyb2lkLXBrZy1uYW1lJyxcbiAgICBNSVNTSU5HX0FQUF9DUkVERU5USUFMOiAnYXV0aC9taXNzaW5nLWFwcC1jcmVkZW50aWFsJyxcbiAgICBNSVNTSU5HX0FVVEhfRE9NQUlOOiAnYXV0aC9hdXRoLWRvbWFpbi1jb25maWctcmVxdWlyZWQnLFxuICAgIE1JU1NJTkdfQ09ERTogJ2F1dGgvbWlzc2luZy12ZXJpZmljYXRpb24tY29kZScsXG4gICAgTUlTU0lOR19DT05USU5VRV9VUkk6ICdhdXRoL21pc3NpbmctY29udGludWUtdXJpJyxcbiAgICBNSVNTSU5HX0lGUkFNRV9TVEFSVDogJ2F1dGgvbWlzc2luZy1pZnJhbWUtc3RhcnQnLFxuICAgIE1JU1NJTkdfSU9TX0JVTkRMRV9JRDogJ2F1dGgvbWlzc2luZy1pb3MtYnVuZGxlLWlkJyxcbiAgICBNSVNTSU5HX09SX0lOVkFMSURfTk9OQ0U6ICdhdXRoL21pc3Npbmctb3ItaW52YWxpZC1ub25jZScsXG4gICAgTUlTU0lOR19NRkFfSU5GTzogJ2F1dGgvbWlzc2luZy1tdWx0aS1mYWN0b3ItaW5mbycsXG4gICAgTUlTU0lOR19NRkFfU0VTU0lPTjogJ2F1dGgvbWlzc2luZy1tdWx0aS1mYWN0b3Itc2Vzc2lvbicsXG4gICAgTUlTU0lOR19QSE9ORV9OVU1CRVI6ICdhdXRoL21pc3NpbmctcGhvbmUtbnVtYmVyJyxcbiAgICBNSVNTSU5HX1NFU1NJT05fSU5GTzogJ2F1dGgvbWlzc2luZy12ZXJpZmljYXRpb24taWQnLFxuICAgIE1PRFVMRV9ERVNUUk9ZRUQ6ICdhdXRoL2FwcC1kZWxldGVkJyxcbiAgICBORUVEX0NPTkZJUk1BVElPTjogJ2F1dGgvYWNjb3VudC1leGlzdHMtd2l0aC1kaWZmZXJlbnQtY3JlZGVudGlhbCcsXG4gICAgTkVUV09SS19SRVFVRVNUX0ZBSUxFRDogJ2F1dGgvbmV0d29yay1yZXF1ZXN0LWZhaWxlZCcsXG4gICAgTlVMTF9VU0VSOiAnYXV0aC9udWxsLXVzZXInLFxuICAgIE5PX0FVVEhfRVZFTlQ6ICdhdXRoL25vLWF1dGgtZXZlbnQnLFxuICAgIE5PX1NVQ0hfUFJPVklERVI6ICdhdXRoL25vLXN1Y2gtcHJvdmlkZXInLFxuICAgIE9QRVJBVElPTl9OT1RfQUxMT1dFRDogJ2F1dGgvb3BlcmF0aW9uLW5vdC1hbGxvd2VkJyxcbiAgICBPUEVSQVRJT05fTk9UX1NVUFBPUlRFRDogJ2F1dGgvb3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudCcsXG4gICAgUE9QVVBfQkxPQ0tFRDogJ2F1dGgvcG9wdXAtYmxvY2tlZCcsXG4gICAgUE9QVVBfQ0xPU0VEX0JZX1VTRVI6ICdhdXRoL3BvcHVwLWNsb3NlZC1ieS11c2VyJyxcbiAgICBQUk9WSURFUl9BTFJFQURZX0xJTktFRDogJ2F1dGgvcHJvdmlkZXItYWxyZWFkeS1saW5rZWQnLFxuICAgIFFVT1RBX0VYQ0VFREVEOiAnYXV0aC9xdW90YS1leGNlZWRlZCcsXG4gICAgUkVESVJFQ1RfQ0FOQ0VMTEVEX0JZX1VTRVI6ICdhdXRoL3JlZGlyZWN0LWNhbmNlbGxlZC1ieS11c2VyJyxcbiAgICBSRURJUkVDVF9PUEVSQVRJT05fUEVORElORzogJ2F1dGgvcmVkaXJlY3Qtb3BlcmF0aW9uLXBlbmRpbmcnLFxuICAgIFJFSkVDVEVEX0NSRURFTlRJQUw6ICdhdXRoL3JlamVjdGVkLWNyZWRlbnRpYWwnLFxuICAgIFNFQ09ORF9GQUNUT1JfQUxSRUFEWV9FTlJPTExFRDogJ2F1dGgvc2Vjb25kLWZhY3Rvci1hbHJlYWR5LWluLXVzZScsXG4gICAgU0VDT05EX0ZBQ1RPUl9MSU1JVF9FWENFRURFRDogJ2F1dGgvbWF4aW11bS1zZWNvbmQtZmFjdG9yLWNvdW50LWV4Y2VlZGVkJyxcbiAgICBURU5BTlRfSURfTUlTTUFUQ0g6ICdhdXRoL3RlbmFudC1pZC1taXNtYXRjaCcsXG4gICAgVElNRU9VVDogJ2F1dGgvdGltZW91dCcsXG4gICAgVE9LRU5fRVhQSVJFRDogJ2F1dGgvdXNlci10b2tlbi1leHBpcmVkJyxcbiAgICBUT09fTUFOWV9BVFRFTVBUU19UUllfTEFURVI6ICdhdXRoL3Rvby1tYW55LXJlcXVlc3RzJyxcbiAgICBVTkFVVEhPUklaRURfRE9NQUlOOiAnYXV0aC91bmF1dGhvcml6ZWQtY29udGludWUtdXJpJyxcbiAgICBVTlNVUFBPUlRFRF9GSVJTVF9GQUNUT1I6ICdhdXRoL3Vuc3VwcG9ydGVkLWZpcnN0LWZhY3RvcicsXG4gICAgVU5TVVBQT1JURURfUEVSU0lTVEVOQ0U6ICdhdXRoL3Vuc3VwcG9ydGVkLXBlcnNpc3RlbmNlLXR5cGUnLFxuICAgIFVOU1VQUE9SVEVEX1RFTkFOVF9PUEVSQVRJT046ICdhdXRoL3Vuc3VwcG9ydGVkLXRlbmFudC1vcGVyYXRpb24nLFxuICAgIFVOVkVSSUZJRURfRU1BSUw6ICdhdXRoL3VudmVyaWZpZWQtZW1haWwnLFxuICAgIFVTRVJfQ0FOQ0VMTEVEOiAnYXV0aC91c2VyLWNhbmNlbGxlZCcsXG4gICAgVVNFUl9ERUxFVEVEOiAnYXV0aC91c2VyLW5vdC1mb3VuZCcsXG4gICAgVVNFUl9ESVNBQkxFRDogJ2F1dGgvdXNlci1kaXNhYmxlZCcsXG4gICAgVVNFUl9NSVNNQVRDSDogJ2F1dGgvdXNlci1taXNtYXRjaCcsXG4gICAgVVNFUl9TSUdORURfT1VUOiAnYXV0aC91c2VyLXNpZ25lZC1vdXQnLFxuICAgIFdFQUtfUEFTU1dPUkQ6ICdhdXRoL3dlYWstcGFzc3dvcmQnLFxuICAgIFdFQl9TVE9SQUdFX1VOU1VQUE9SVEVEOiAnYXV0aC93ZWItc3RvcmFnZS11bnN1cHBvcnRlZCcsXG4gICAgQUxSRUFEWV9JTklUSUFMSVpFRDogJ2F1dGgvYWxyZWFkeS1pbml0aWFsaXplZCcsXG4gICAgUkVDQVBUQ0hBX05PVF9FTkFCTEVEOiAnYXV0aC9yZWNhcHRjaGEtbm90LWVuYWJsZWQnLFxuICAgIE1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOOiAnYXV0aC9taXNzaW5nLXJlY2FwdGNoYS10b2tlbicsXG4gICAgSU5WQUxJRF9SRUNBUFRDSEFfVE9LRU46ICdhdXRoL2ludmFsaWQtcmVjYXB0Y2hhLXRva2VuJyxcbiAgICBJTlZBTElEX1JFQ0FQVENIQV9BQ1RJT046ICdhdXRoL2ludmFsaWQtcmVjYXB0Y2hhLWFjdGlvbicsXG4gICAgTUlTU0lOR19DTElFTlRfVFlQRTogJ2F1dGgvbWlzc2luZy1jbGllbnQtdHlwZScsXG4gICAgTUlTU0lOR19SRUNBUFRDSEFfVkVSU0lPTjogJ2F1dGgvbWlzc2luZy1yZWNhcHRjaGEtdmVyc2lvbicsXG4gICAgSU5WQUxJRF9SRUNBUFRDSEFfVkVSU0lPTjogJ2F1dGgvaW52YWxpZC1yZWNhcHRjaGEtdmVyc2lvbicsXG4gICAgSU5WQUxJRF9SRVFfVFlQRTogJ2F1dGgvaW52YWxpZC1yZXEtdHlwZSdcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBsb2dDbGllbnQgPSBuZXcgTG9nZ2VyKCdAZmlyZWJhc2UvYXV0aCcpO1xuZnVuY3Rpb24gX2xvZ1dhcm4obXNnLCAuLi5hcmdzKSB7XG4gICAgaWYgKGxvZ0NsaWVudC5sb2dMZXZlbCA8PSBMb2dMZXZlbC5XQVJOKSB7XG4gICAgICAgIGxvZ0NsaWVudC53YXJuKGBBdXRoICgke1NES19WRVJTSU9OfSk6ICR7bXNnfWAsIC4uLmFyZ3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9sb2dFcnJvcihtc2csIC4uLmFyZ3MpIHtcbiAgICBpZiAobG9nQ2xpZW50LmxvZ0xldmVsIDw9IExvZ0xldmVsLkVSUk9SKSB7XG4gICAgICAgIGxvZ0NsaWVudC5lcnJvcihgQXV0aCAoJHtTREtfVkVSU0lPTn0pOiAke21zZ31gLCAuLi5hcmdzKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBfZmFpbChhdXRoT3JDb2RlLCAuLi5yZXN0KSB7XG4gICAgdGhyb3cgY3JlYXRlRXJyb3JJbnRlcm5hbChhdXRoT3JDb2RlLCAuLi5yZXN0KTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVFcnJvcihhdXRoT3JDb2RlLCAuLi5yZXN0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVycm9ySW50ZXJuYWwoYXV0aE9yQ29kZSwgLi4ucmVzdCk7XG59XG5mdW5jdGlvbiBfZXJyb3JXaXRoQ3VzdG9tTWVzc2FnZShhdXRoLCBjb2RlLCBtZXNzYWdlKSB7XG4gICAgY29uc3QgZXJyb3JNYXAgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb2RFcnJvck1hcCgpKSwgeyBbY29kZV06IG1lc3NhZ2UgfSk7XG4gICAgY29uc3QgZmFjdG9yeSA9IG5ldyBFcnJvckZhY3RvcnkoJ2F1dGgnLCAnRmlyZWJhc2UnLCBlcnJvck1hcCk7XG4gICAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlKGNvZGUsIHtcbiAgICAgICAgYXBwTmFtZTogYXV0aC5uYW1lXG4gICAgfSk7XG59XG5mdW5jdGlvbiBfc2VydmVyQXBwQ3VycmVudFVzZXJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvcihhdXRoKSB7XG4gICAgcmV0dXJuIF9lcnJvcldpdGhDdXN0b21NZXNzYWdlKGF1dGgsIFwib3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiIC8qIEF1dGhFcnJvckNvZGUuT1BFUkFUSU9OX05PVF9TVVBQT1JURUQgKi8sICdPcGVyYXRpb25zIHRoYXQgYWx0ZXIgdGhlIGN1cnJlbnQgdXNlciBhcmUgbm90IHN1cHBvcnRlZCBpbiBjb25qdW5jdGlvbiB3aXRoIEZpcmViYXNlU2VydmVyQXBwJyk7XG59XG5mdW5jdGlvbiBjcmVhdGVFcnJvckludGVybmFsKGF1dGhPckNvZGUsIC4uLnJlc3QpIHtcbiAgICBpZiAodHlwZW9mIGF1dGhPckNvZGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSByZXN0WzBdO1xuICAgICAgICBjb25zdCBmdWxsUGFyYW1zID0gWy4uLnJlc3Quc2xpY2UoMSldO1xuICAgICAgICBpZiAoZnVsbFBhcmFtc1swXSkge1xuICAgICAgICAgICAgZnVsbFBhcmFtc1swXS5hcHBOYW1lID0gYXV0aE9yQ29kZS5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdXRoT3JDb2RlLl9lcnJvckZhY3RvcnkuY3JlYXRlKGNvZGUsIC4uLmZ1bGxQYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4gX0RFRkFVTFRfQVVUSF9FUlJPUl9GQUNUT1JZLmNyZWF0ZShhdXRoT3JDb2RlLCAuLi5yZXN0KTtcbn1cbmZ1bmN0aW9uIF9hc3NlcnQoYXNzZXJ0aW9uLCBhdXRoT3JDb2RlLCAuLi5yZXN0KSB7XG4gICAgaWYgKCFhc3NlcnRpb24pIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3JJbnRlcm5hbChhdXRoT3JDb2RlLCAuLi5yZXN0KTtcbiAgICB9XG59XG4vKipcbiAqIFVuY29uZGl0aW9uYWxseSBmYWlscywgdGhyb3dpbmcgYW4gaW50ZXJuYWwgZXJyb3Igd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gZmFpbHVyZSB0eXBlIG9mIGZhaWx1cmUgZW5jb3VudGVyZWRcbiAqIEB0aHJvd3MgRXJyb3JcbiAqL1xuZnVuY3Rpb24gZGVidWdGYWlsKGZhaWx1cmUpIHtcbiAgICAvLyBMb2cgdGhlIGZhaWx1cmUgaW4gYWRkaXRpb24gdG8gdGhyb3cgYW4gZXhjZXB0aW9uLCBqdXN0IGluIGNhc2UgdGhlXG4gICAgLy8gZXhjZXB0aW9uIGlzIHN3YWxsb3dlZC5cbiAgICBjb25zdCBtZXNzYWdlID0gYElOVEVSTkFMIEFTU0VSVElPTiBGQUlMRUQ6IGAgKyBmYWlsdXJlO1xuICAgIF9sb2dFcnJvcihtZXNzYWdlKTtcbiAgICAvLyBOT1RFOiBXZSBkb24ndCB1c2UgRmlyZWJhc2VFcnJvciBoZXJlIGJlY2F1c2UgdGhlc2UgYXJlIGludGVybmFsIGZhaWx1cmVzXG4gICAgLy8gdGhhdCBjYW5ub3QgYmUgaGFuZGxlZCBieSB0aGUgdXNlci4gKEFsc28gaXQgd291bGQgY3JlYXRlIGEgY2lyY3VsYXJcbiAgICAvLyBkZXBlbmRlbmN5IGJldHdlZW4gdGhlIGVycm9yIGFuZCBhc3NlcnQgbW9kdWxlcyB3aGljaCBkb2Vzbid0IHdvcmsuKVxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cbi8qKlxuICogRmFpbHMgaWYgdGhlIGdpdmVuIGFzc2VydGlvbiBjb25kaXRpb24gaXMgZmFsc2UsIHRocm93aW5nIGFuIEVycm9yIHdpdGggdGhlXG4gKiBnaXZlbiBtZXNzYWdlIGlmIGl0IGRpZC5cbiAqXG4gKiBAcGFyYW0gYXNzZXJ0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZVxuICovXG5mdW5jdGlvbiBkZWJ1Z0Fzc2VydChhc3NlcnRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWFzc2VydGlvbikge1xuICAgICAgICBkZWJ1Z0ZhaWwobWVzc2FnZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gX2dldEN1cnJlbnRVcmwoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICgoX2EgPSBzZWxmLmxvY2F0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHJlZikpIHx8ICcnO1xufVxuZnVuY3Rpb24gX2lzSHR0cE9ySHR0cHMoKSB7XG4gICAgcmV0dXJuIF9nZXRDdXJyZW50U2NoZW1lKCkgPT09ICdodHRwOicgfHwgX2dldEN1cnJlbnRTY2hlbWUoKSA9PT0gJ2h0dHBzOic7XG59XG5mdW5jdGlvbiBfZ2V0Q3VycmVudFNjaGVtZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgKChfYSA9IHNlbGYubG9jYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcm90b2NvbCkpIHx8IG51bGw7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIHRoZSBicm93c2VyIGlzIHdvcmtpbmcgb25saW5lXG4gKi9cbmZ1bmN0aW9uIF9pc09ubGluZSgpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgbmF2aWdhdG9yICYmXG4gICAgICAgICdvbkxpbmUnIGluIG5hdmlnYXRvciAmJlxuICAgICAgICB0eXBlb2YgbmF2aWdhdG9yLm9uTGluZSA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgICAgIC8vIEFwcGx5IG9ubHkgZm9yIHRyYWRpdGlvbmFsIHdlYiBhcHBzIGFuZCBDaHJvbWUgZXh0ZW5zaW9ucy5cbiAgICAgICAgLy8gVGhpcyBpcyBlc3BlY2lhbGx5IHRydWUgZm9yIENvcmRvdmEgYXBwcyB3aGljaCBoYXZlIHVucmVsaWFibGVcbiAgICAgICAgLy8gbmF2aWdhdG9yLm9uTGluZSBiZWhhdmlvciB1bmxlc3MgY29yZG92YS1wbHVnaW4tbmV0d29yay1pbmZvcm1hdGlvbiBpc1xuICAgICAgICAvLyBpbnN0YWxsZWQgd2hpY2ggb3ZlcndyaXRlcyB0aGUgbmF0aXZlIG5hdmlnYXRvci5vbkxpbmUgdmFsdWUgYW5kXG4gICAgICAgIC8vIGRlZmluZXMgbmF2aWdhdG9yLmNvbm5lY3Rpb24uXG4gICAgICAgIChfaXNIdHRwT3JIdHRwcygpIHx8IGlzQnJvd3NlckV4dGVuc2lvbigpIHx8ICdjb25uZWN0aW9uJyBpbiBuYXZpZ2F0b3IpKSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3Iub25MaW5lO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBjYW4ndCBkZXRlcm1pbmUgdGhlIHN0YXRlLCBhc3N1bWUgaXQgaXMgb25saW5lLlxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gX2dldFVzZXJMYW5ndWFnZSgpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG5hdmlnYXRvckxhbmd1YWdlID0gbmF2aWdhdG9yO1xuICAgIHJldHVybiAoXG4gICAgLy8gTW9zdCByZWxpYWJsZSwgYnV0IG9ubHkgc3VwcG9ydGVkIGluIENocm9tZS9GaXJlZm94LlxuICAgIChuYXZpZ2F0b3JMYW5ndWFnZS5sYW5ndWFnZXMgJiYgbmF2aWdhdG9yTGFuZ3VhZ2UubGFuZ3VhZ2VzWzBdKSB8fFxuICAgICAgICAvLyBTdXBwb3J0ZWQgaW4gbW9zdCBicm93c2VycywgYnV0IHJldHVybnMgdGhlIGxhbmd1YWdlIG9mIHRoZSBicm93c2VyXG4gICAgICAgIC8vIFVJLCBub3QgdGhlIGxhbmd1YWdlIHNldCBpbiBicm93c2VyIHNldHRpbmdzLlxuICAgICAgICBuYXZpZ2F0b3JMYW5ndWFnZS5sYW5ndWFnZSB8fFxuICAgICAgICAvLyBDb3VsZG4ndCBkZXRlcm1pbmUgbGFuZ3VhZ2UuXG4gICAgICAgIG51bGwpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIHN0cnVjdHVyZSB0byBoZWxwIHBpY2sgYmV0d2VlbiBhIHJhbmdlIG9mIGxvbmcgYW5kIHNob3J0IGRlbGF5IGR1cmF0aW9uc1xuICogZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IGVudmlyb25tZW50LiBJbiBnZW5lcmFsLCB0aGUgbG9uZyBkZWxheSBpcyB1c2VkIGZvclxuICogbW9iaWxlIGVudmlyb25tZW50cyB3aGVyZWFzIHNob3J0IGRlbGF5cyBhcmUgdXNlZCBmb3IgZGVza3RvcCBlbnZpcm9ubWVudHMuXG4gKi9cbmNsYXNzIERlbGF5IHtcbiAgICBjb25zdHJ1Y3RvcihzaG9ydERlbGF5LCBsb25nRGVsYXkpIHtcbiAgICAgICAgdGhpcy5zaG9ydERlbGF5ID0gc2hvcnREZWxheTtcbiAgICAgICAgdGhpcy5sb25nRGVsYXkgPSBsb25nRGVsYXk7XG4gICAgICAgIC8vIEludGVybmFsIGVycm9yIHdoZW4gaW1wcm9wZXJseSBpbml0aWFsaXplZC5cbiAgICAgICAgZGVidWdBc3NlcnQobG9uZ0RlbGF5ID4gc2hvcnREZWxheSwgJ1Nob3J0IGRlbGF5IHNob3VsZCBiZSBsZXNzIHRoYW4gbG9uZyBkZWxheSEnKTtcbiAgICAgICAgdGhpcy5pc01vYmlsZSA9IGlzTW9iaWxlQ29yZG92YSgpIHx8IGlzUmVhY3ROYXRpdmUoKTtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBpZiAoIV9pc09ubGluZSgpKSB7XG4gICAgICAgICAgICAvLyBQaWNrIHRoZSBzaG9ydGVyIHRpbWVvdXQuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4oNTAwMCAvKiBEZWxheU1pbi5PRkZMSU5FICovLCB0aGlzLnNob3J0RGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHJ1bm5pbmcgaW4gYSBtb2JpbGUgZW52aXJvbm1lbnQsIHJldHVybiB0aGUgbG9uZyBkZWxheSwgb3RoZXJ3aXNlXG4gICAgICAgIC8vIHJldHVybiB0aGUgc2hvcnQgZGVsYXkuXG4gICAgICAgIC8vIFRoaXMgY291bGQgYmUgaW1wcm92ZWQgaW4gdGhlIGZ1dHVyZSB0byBkeW5hbWljYWxseSBjaGFuZ2UgYmFzZWQgb24gb3RoZXJcbiAgICAgICAgLy8gdmFyaWFibGVzIGluc3RlYWQgb2YganVzdCByZWFkaW5nIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlxuICAgICAgICByZXR1cm4gdGhpcy5pc01vYmlsZSA/IHRoaXMubG9uZ0RlbGF5IDogdGhpcy5zaG9ydERlbGF5O1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIF9lbXVsYXRvclVybChjb25maWcsIHBhdGgpIHtcbiAgICBkZWJ1Z0Fzc2VydChjb25maWcuZW11bGF0b3IsICdFbXVsYXRvciBzaG91bGQgYWx3YXlzIGJlIHNldCBoZXJlJyk7XG4gICAgY29uc3QgeyB1cmwgfSA9IGNvbmZpZy5lbXVsYXRvcjtcbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgcmV0dXJuIGAke3VybH0ke3BhdGguc3RhcnRzV2l0aCgnLycpID8gcGF0aC5zbGljZSgxKSA6IHBhdGh9YDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIEZldGNoUHJvdmlkZXIge1xuICAgIHN0YXRpYyBpbml0aWFsaXplKGZldGNoSW1wbCwgaGVhZGVyc0ltcGwsIHJlc3BvbnNlSW1wbCkge1xuICAgICAgICB0aGlzLmZldGNoSW1wbCA9IGZldGNoSW1wbDtcbiAgICAgICAgaWYgKGhlYWRlcnNJbXBsKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnNJbXBsID0gaGVhZGVyc0ltcGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbnNlSW1wbCkge1xuICAgICAgICAgICAgdGhpcy5yZXNwb25zZUltcGwgPSByZXNwb25zZUltcGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZldGNoKCkge1xuICAgICAgICBpZiAodGhpcy5mZXRjaEltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoSW1wbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICdmZXRjaCcgaW4gc2VsZikge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuZmV0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWxUaGlzLmZldGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5mZXRjaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZldGNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnRmFpbCgnQ291bGQgbm90IGZpbmQgZmV0Y2ggaW1wbGVtZW50YXRpb24sIG1ha2Ugc3VyZSB5b3UgY2FsbCBGZXRjaFByb3ZpZGVyLmluaXRpYWxpemUoKSB3aXRoIGFuIGFwcHJvcHJpYXRlIHBvbHlmaWxsJyk7XG4gICAgfVxuICAgIHN0YXRpYyBoZWFkZXJzKCkge1xuICAgICAgICBpZiAodGhpcy5oZWFkZXJzSW1wbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyc0ltcGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAnSGVhZGVycycgaW4gc2VsZikge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuSGVhZGVycztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMuSGVhZGVycykge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuSGVhZGVycztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIEhlYWRlcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gSGVhZGVycztcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Z0ZhaWwoJ0NvdWxkIG5vdCBmaW5kIEhlYWRlcnMgaW1wbGVtZW50YXRpb24sIG1ha2Ugc3VyZSB5b3UgY2FsbCBGZXRjaFByb3ZpZGVyLmluaXRpYWxpemUoKSB3aXRoIGFuIGFwcHJvcHJpYXRlIHBvbHlmaWxsJyk7XG4gICAgfVxuICAgIHN0YXRpYyByZXNwb25zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzcG9uc2VJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZUltcGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAnUmVzcG9uc2UnIGluIHNlbGYpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLlJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcy5SZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBSZXNwb25zZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBSZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Z0ZhaWwoJ0NvdWxkIG5vdCBmaW5kIFJlc3BvbnNlIGltcGxlbWVudGF0aW9uLCBtYWtlIHN1cmUgeW91IGNhbGwgRmV0Y2hQcm92aWRlci5pbml0aWFsaXplKCkgd2l0aCBhbiBhcHByb3ByaWF0ZSBwb2x5ZmlsbCcpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogTWFwIGZyb20gZXJyb3JzIHJldHVybmVkIGJ5IHRoZSBzZXJ2ZXIgdG8gZXJyb3JzIHRvIGRldmVsb3BlciB2aXNpYmxlIGVycm9yc1xuICovXG5jb25zdCBTRVJWRVJfRVJST1JfTUFQID0ge1xuICAgIC8vIEN1c3RvbSB0b2tlbiBlcnJvcnMuXG4gICAgW1wiQ1JFREVOVElBTF9NSVNNQVRDSFwiIC8qIFNlcnZlckVycm9yLkNSRURFTlRJQUxfTUlTTUFUQ0ggKi9dOiBcImN1c3RvbS10b2tlbi1taXNtYXRjaFwiIC8qIEF1dGhFcnJvckNvZGUuQ1JFREVOVElBTF9NSVNNQVRDSCAqLyxcbiAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbiBpZiB0aGUgU0RLIHNlbmRzIGEgYmFkIHJlcXVlc3QuXG4gICAgW1wiTUlTU0lOR19DVVNUT01fVE9LRU5cIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX0NVU1RPTV9UT0tFTiAqL106IFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovLFxuICAgIC8vIENyZWF0ZSBBdXRoIFVSSSBlcnJvcnMuXG4gICAgW1wiSU5WQUxJRF9JREVOVElGSUVSXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9JREVOVElGSUVSICovXTogXCJpbnZhbGlkLWVtYWlsXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0VNQUlMICovLFxuICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBTREsgc2VuZHMgYSBiYWQgcmVxdWVzdC5cbiAgICBbXCJNSVNTSU5HX0NPTlRJTlVFX1VSSVwiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfQ09OVElOVUVfVVJJICovXTogXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8sXG4gICAgLy8gU2lnbiBpbiB3aXRoIGVtYWlsIGFuZCBwYXNzd29yZCBlcnJvcnMgKHNvbWUgYXBwbHkgdG8gc2lnbiB1cCB0b28pLlxuICAgIFtcIklOVkFMSURfUEFTU1dPUkRcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX1BBU1NXT1JEICovXTogXCJ3cm9uZy1wYXNzd29yZFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9QQVNTV09SRCAqLyxcbiAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbiBpZiB0aGUgU0RLIHNlbmRzIGEgYmFkIHJlcXVlc3QuXG4gICAgW1wiTUlTU0lOR19QQVNTV09SRFwiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfUEFTU1dPUkQgKi9dOiBcIm1pc3NpbmctcGFzc3dvcmRcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfUEFTU1dPUkQgKi8sXG4gICAgLy8gVGhyb3duIGlmIEVtYWlsIEVudW1lcmF0aW9uIFByb3RlY3Rpb24gaXMgZW5hYmxlZCBpbiB0aGUgcHJvamVjdCBhbmQgdGhlIGVtYWlsIG9yIHBhc3N3b3JkIGlzXG4gICAgLy8gaW52YWxpZC5cbiAgICBbXCJJTlZBTElEX0xPR0lOX0NSRURFTlRJQUxTXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9MT0dJTl9DUkVERU5USUFMUyAqL106IFwiaW52YWxpZC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NSRURFTlRJQUwgKi8sXG4gICAgLy8gU2lnbiB1cCB3aXRoIGVtYWlsIGFuZCBwYXNzd29yZCBlcnJvcnMuXG4gICAgW1wiRU1BSUxfRVhJU1RTXCIgLyogU2VydmVyRXJyb3IuRU1BSUxfRVhJU1RTICovXTogXCJlbWFpbC1hbHJlYWR5LWluLXVzZVwiIC8qIEF1dGhFcnJvckNvZGUuRU1BSUxfRVhJU1RTICovLFxuICAgIFtcIlBBU1NXT1JEX0xPR0lOX0RJU0FCTEVEXCIgLyogU2VydmVyRXJyb3IuUEFTU1dPUkRfTE9HSU5fRElTQUJMRUQgKi9dOiBcIm9wZXJhdGlvbi1ub3QtYWxsb3dlZFwiIC8qIEF1dGhFcnJvckNvZGUuT1BFUkFUSU9OX05PVF9BTExPV0VEICovLFxuICAgIC8vIFZlcmlmeSBhc3NlcnRpb24gZm9yIHNpZ24gaW4gd2l0aCBjcmVkZW50aWFsIGVycm9yczpcbiAgICBbXCJJTlZBTElEX0lEUF9SRVNQT05TRVwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfSURQX1JFU1BPTlNFICovXTogXCJpbnZhbGlkLWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ1JFREVOVElBTCAqLyxcbiAgICBbXCJJTlZBTElEX1BFTkRJTkdfVE9LRU5cIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX1BFTkRJTkdfVE9LRU4gKi9dOiBcImludmFsaWQtY3JlZGVudGlhbFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DUkVERU5USUFMICovLFxuICAgIFtcIkZFREVSQVRFRF9VU0VSX0lEX0FMUkVBRFlfTElOS0VEXCIgLyogU2VydmVyRXJyb3IuRkVERVJBVEVEX1VTRVJfSURfQUxSRUFEWV9MSU5LRUQgKi9dOiBcImNyZWRlbnRpYWwtYWxyZWFkeS1pbi11c2VcIiAvKiBBdXRoRXJyb3JDb2RlLkNSRURFTlRJQUxfQUxSRUFEWV9JTl9VU0UgKi8sXG4gICAgLy8gVGhpcyBjYW4gb25seSBoYXBwZW4gaWYgdGhlIFNESyBzZW5kcyBhIGJhZCByZXF1ZXN0LlxuICAgIFtcIk1JU1NJTkdfUkVRX1RZUEVcIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX1JFUV9UWVBFICovXTogXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8sXG4gICAgLy8gU2VuZCBQYXNzd29yZCByZXNldCBlbWFpbCBlcnJvcnM6XG4gICAgW1wiRU1BSUxfTk9UX0ZPVU5EXCIgLyogU2VydmVyRXJyb3IuRU1BSUxfTk9UX0ZPVU5EICovXTogXCJ1c2VyLW5vdC1mb3VuZFwiIC8qIEF1dGhFcnJvckNvZGUuVVNFUl9ERUxFVEVEICovLFxuICAgIFtcIlJFU0VUX1BBU1NXT1JEX0VYQ0VFRF9MSU1JVFwiIC8qIFNlcnZlckVycm9yLlJFU0VUX1BBU1NXT1JEX0VYQ0VFRF9MSU1JVCAqL106IFwidG9vLW1hbnktcmVxdWVzdHNcIiAvKiBBdXRoRXJyb3JDb2RlLlRPT19NQU5ZX0FUVEVNUFRTX1RSWV9MQVRFUiAqLyxcbiAgICBbXCJFWFBJUkVEX09PQl9DT0RFXCIgLyogU2VydmVyRXJyb3IuRVhQSVJFRF9PT0JfQ09ERSAqL106IFwiZXhwaXJlZC1hY3Rpb24tY29kZVwiIC8qIEF1dGhFcnJvckNvZGUuRVhQSVJFRF9PT0JfQ09ERSAqLyxcbiAgICBbXCJJTlZBTElEX09PQl9DT0RFXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9PT0JfQ09ERSAqL106IFwiaW52YWxpZC1hY3Rpb24tY29kZVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9PT0JfQ09ERSAqLyxcbiAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbiBpZiB0aGUgU0RLIHNlbmRzIGEgYmFkIHJlcXVlc3QuXG4gICAgW1wiTUlTU0lOR19PT0JfQ09ERVwiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfT09CX0NPREUgKi9dOiBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyxcbiAgICAvLyBPcGVyYXRpb25zIHRoYXQgcmVxdWlyZSBJRCB0b2tlbiBpbiByZXF1ZXN0OlxuICAgIFtcIkNSRURFTlRJQUxfVE9PX09MRF9MT0dJTl9BR0FJTlwiIC8qIFNlcnZlckVycm9yLkNSRURFTlRJQUxfVE9PX09MRF9MT0dJTl9BR0FJTiAqL106IFwicmVxdWlyZXMtcmVjZW50LWxvZ2luXCIgLyogQXV0aEVycm9yQ29kZS5DUkVERU5USUFMX1RPT19PTERfTE9HSU5fQUdBSU4gKi8sXG4gICAgW1wiSU5WQUxJRF9JRF9UT0tFTlwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfSURfVE9LRU4gKi9dOiBcImludmFsaWQtdXNlci10b2tlblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BVVRIICovLFxuICAgIFtcIlRPS0VOX0VYUElSRURcIiAvKiBTZXJ2ZXJFcnJvci5UT0tFTl9FWFBJUkVEICovXTogXCJ1c2VyLXRva2VuLWV4cGlyZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlRPS0VOX0VYUElSRUQgKi8sXG4gICAgW1wiVVNFUl9OT1RfRk9VTkRcIiAvKiBTZXJ2ZXJFcnJvci5VU0VSX05PVF9GT1VORCAqL106IFwidXNlci10b2tlbi1leHBpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5UT0tFTl9FWFBJUkVEICovLFxuICAgIC8vIE90aGVyIGVycm9ycy5cbiAgICBbXCJUT09fTUFOWV9BVFRFTVBUU19UUllfTEFURVJcIiAvKiBTZXJ2ZXJFcnJvci5UT09fTUFOWV9BVFRFTVBUU19UUllfTEFURVIgKi9dOiBcInRvby1tYW55LXJlcXVlc3RzXCIgLyogQXV0aEVycm9yQ29kZS5UT09fTUFOWV9BVFRFTVBUU19UUllfTEFURVIgKi8sXG4gICAgW1wiUEFTU1dPUkRfRE9FU19OT1RfTUVFVF9SRVFVSVJFTUVOVFNcIiAvKiBTZXJ2ZXJFcnJvci5QQVNTV09SRF9ET0VTX05PVF9NRUVUX1JFUVVJUkVNRU5UUyAqL106IFwicGFzc3dvcmQtZG9lcy1ub3QtbWVldC1yZXF1aXJlbWVudHNcIiAvKiBBdXRoRXJyb3JDb2RlLlBBU1NXT1JEX0RPRVNfTk9UX01FRVRfUkVRVUlSRU1FTlRTICovLFxuICAgIC8vIFBob25lIEF1dGggcmVsYXRlZCBlcnJvcnMuXG4gICAgW1wiSU5WQUxJRF9DT0RFXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9DT0RFICovXTogXCJpbnZhbGlkLXZlcmlmaWNhdGlvbi1jb2RlXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NPREUgKi8sXG4gICAgW1wiSU5WQUxJRF9TRVNTSU9OX0lORk9cIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX1NFU1NJT05fSU5GTyAqL106IFwiaW52YWxpZC12ZXJpZmljYXRpb24taWRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfU0VTU0lPTl9JTkZPICovLFxuICAgIFtcIklOVkFMSURfVEVNUE9SQVJZX1BST09GXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9URU1QT1JBUllfUFJPT0YgKi9dOiBcImludmFsaWQtY3JlZGVudGlhbFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DUkVERU5USUFMICovLFxuICAgIFtcIk1JU1NJTkdfU0VTU0lPTl9JTkZPXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19TRVNTSU9OX0lORk8gKi9dOiBcIm1pc3NpbmctdmVyaWZpY2F0aW9uLWlkXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1NFU1NJT05fSU5GTyAqLyxcbiAgICBbXCJTRVNTSU9OX0VYUElSRURcIiAvKiBTZXJ2ZXJFcnJvci5TRVNTSU9OX0VYUElSRUQgKi9dOiBcImNvZGUtZXhwaXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuQ09ERV9FWFBJUkVEICovLFxuICAgIC8vIE90aGVyIGFjdGlvbiBjb2RlIGVycm9ycyB3aGVuIGFkZGl0aW9uYWwgc2V0dGluZ3MgcGFzc2VkLlxuICAgIC8vIE1JU1NJTkdfQ09OVElOVUVfVVJJIGlzIGdldHRpbmcgbWFwcGVkIHRvIElOVEVSTkFMX0VSUk9SIGFib3ZlLlxuICAgIC8vIFRoaXMgaXMgT0sgYXMgdGhpcyBlcnJvciB3aWxsIGJlIGNhdWdodCBieSBjbGllbnQgc2lkZSB2YWxpZGF0aW9uLlxuICAgIFtcIk1JU1NJTkdfQU5EUk9JRF9QQUNLQUdFX05BTUVcIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX0FORFJPSURfUEFDS0FHRV9OQU1FICovXTogXCJtaXNzaW5nLWFuZHJvaWQtcGtnLW5hbWVcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQU5EUk9JRF9QQUNLQUdFX05BTUUgKi8sXG4gICAgW1wiVU5BVVRIT1JJWkVEX0RPTUFJTlwiIC8qIFNlcnZlckVycm9yLlVOQVVUSE9SSVpFRF9ET01BSU4gKi9dOiBcInVuYXV0aG9yaXplZC1jb250aW51ZS11cmlcIiAvKiBBdXRoRXJyb3JDb2RlLlVOQVVUSE9SSVpFRF9ET01BSU4gKi8sXG4gICAgLy8gZ2V0UHJvamVjdENvbmZpZyBlcnJvcnMgd2hlbiBjbGllbnRJZCBpcyBwYXNzZWQuXG4gICAgW1wiSU5WQUxJRF9PQVVUSF9DTElFTlRfSURcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX09BVVRIX0NMSUVOVF9JRCAqL106IFwiaW52YWxpZC1vYXV0aC1jbGllbnQtaWRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfT0FVVEhfQ0xJRU5UX0lEICovLFxuICAgIC8vIFVzZXIgYWN0aW9ucyAoc2lnbi11cCBvciBkZWxldGlvbikgZGlzYWJsZWQgZXJyb3JzLlxuICAgIFtcIkFETUlOX09OTFlfT1BFUkFUSU9OXCIgLyogU2VydmVyRXJyb3IuQURNSU5fT05MWV9PUEVSQVRJT04gKi9dOiBcImFkbWluLXJlc3RyaWN0ZWQtb3BlcmF0aW9uXCIgLyogQXV0aEVycm9yQ29kZS5BRE1JTl9PTkxZX09QRVJBVElPTiAqLyxcbiAgICAvLyBNdWx0aSBmYWN0b3IgcmVsYXRlZCBlcnJvcnMuXG4gICAgW1wiSU5WQUxJRF9NRkFfUEVORElOR19DUkVERU5USUFMXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9NRkFfUEVORElOR19DUkVERU5USUFMICovXTogXCJpbnZhbGlkLW11bHRpLWZhY3Rvci1zZXNzaW9uXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX01GQV9TRVNTSU9OICovLFxuICAgIFtcIk1GQV9FTlJPTExNRU5UX05PVF9GT1VORFwiIC8qIFNlcnZlckVycm9yLk1GQV9FTlJPTExNRU5UX05PVF9GT1VORCAqL106IFwibXVsdGktZmFjdG9yLWluZm8tbm90LWZvdW5kXCIgLyogQXV0aEVycm9yQ29kZS5NRkFfSU5GT19OT1RfRk9VTkQgKi8sXG4gICAgW1wiTUlTU0lOR19NRkFfRU5ST0xMTUVOVF9JRFwiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfTUZBX0VOUk9MTE1FTlRfSUQgKi9dOiBcIm1pc3NpbmctbXVsdGktZmFjdG9yLWluZm9cIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfTUZBX0lORk8gKi8sXG4gICAgW1wiTUlTU0lOR19NRkFfUEVORElOR19DUkVERU5USUFMXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19NRkFfUEVORElOR19DUkVERU5USUFMICovXTogXCJtaXNzaW5nLW11bHRpLWZhY3Rvci1zZXNzaW9uXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX01GQV9TRVNTSU9OICovLFxuICAgIFtcIlNFQ09ORF9GQUNUT1JfRVhJU1RTXCIgLyogU2VydmVyRXJyb3IuU0VDT05EX0ZBQ1RPUl9FWElTVFMgKi9dOiBcInNlY29uZC1mYWN0b3ItYWxyZWFkeS1pbi11c2VcIiAvKiBBdXRoRXJyb3JDb2RlLlNFQ09ORF9GQUNUT1JfQUxSRUFEWV9FTlJPTExFRCAqLyxcbiAgICBbXCJTRUNPTkRfRkFDVE9SX0xJTUlUX0VYQ0VFREVEXCIgLyogU2VydmVyRXJyb3IuU0VDT05EX0ZBQ1RPUl9MSU1JVF9FWENFRURFRCAqL106IFwibWF4aW11bS1zZWNvbmQtZmFjdG9yLWNvdW50LWV4Y2VlZGVkXCIgLyogQXV0aEVycm9yQ29kZS5TRUNPTkRfRkFDVE9SX0xJTUlUX0VYQ0VFREVEICovLFxuICAgIC8vIEJsb2NraW5nIGZ1bmN0aW9ucyByZWxhdGVkIGVycm9ycy5cbiAgICBbXCJCTE9DS0lOR19GVU5DVElPTl9FUlJPUl9SRVNQT05TRVwiIC8qIFNlcnZlckVycm9yLkJMT0NLSU5HX0ZVTkNUSU9OX0VSUk9SX1JFU1BPTlNFICovXTogXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8sXG4gICAgLy8gUmVjYXB0Y2hhIHJlbGF0ZWQgZXJyb3JzLlxuICAgIFtcIlJFQ0FQVENIQV9OT1RfRU5BQkxFRFwiIC8qIFNlcnZlckVycm9yLlJFQ0FQVENIQV9OT1RfRU5BQkxFRCAqL106IFwicmVjYXB0Y2hhLW5vdC1lbmFibGVkXCIgLyogQXV0aEVycm9yQ29kZS5SRUNBUFRDSEFfTk9UX0VOQUJMRUQgKi8sXG4gICAgW1wiTUlTU0lOR19SRUNBUFRDSEFfVE9LRU5cIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX1JFQ0FQVENIQV9UT0tFTiAqL106IFwibWlzc2luZy1yZWNhcHRjaGEtdG9rZW5cIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOICovLFxuICAgIFtcIklOVkFMSURfUkVDQVBUQ0hBX1RPS0VOXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9SRUNBUFRDSEFfVE9LRU4gKi9dOiBcImludmFsaWQtcmVjYXB0Y2hhLXRva2VuXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1JFQ0FQVENIQV9UT0tFTiAqLyxcbiAgICBbXCJJTlZBTElEX1JFQ0FQVENIQV9BQ1RJT05cIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX1JFQ0FQVENIQV9BQ1RJT04gKi9dOiBcImludmFsaWQtcmVjYXB0Y2hhLWFjdGlvblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9SRUNBUFRDSEFfQUNUSU9OICovLFxuICAgIFtcIk1JU1NJTkdfQ0xJRU5UX1RZUEVcIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX0NMSUVOVF9UWVBFICovXTogXCJtaXNzaW5nLWNsaWVudC10eXBlXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX0NMSUVOVF9UWVBFICovLFxuICAgIFtcIk1JU1NJTkdfUkVDQVBUQ0hBX1ZFUlNJT05cIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX1JFQ0FQVENIQV9WRVJTSU9OICovXTogXCJtaXNzaW5nLXJlY2FwdGNoYS12ZXJzaW9uXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1JFQ0FQVENIQV9WRVJTSU9OICovLFxuICAgIFtcIklOVkFMSURfUkVDQVBUQ0hBX1ZFUlNJT05cIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX1JFQ0FQVENIQV9WRVJTSU9OICovXTogXCJpbnZhbGlkLXJlY2FwdGNoYS12ZXJzaW9uXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1JFQ0FQVENIQV9WRVJTSU9OICovLFxuICAgIFtcIklOVkFMSURfUkVRX1RZUEVcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX1JFUV9UWVBFICovXTogXCJpbnZhbGlkLXJlcS10eXBlXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1JFUV9UWVBFICovXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgREVGQVVMVF9BUElfVElNRU9VVF9NUyA9IG5ldyBEZWxheSgzMDAwMCwgNjAwMDApO1xuZnVuY3Rpb24gX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpIHtcbiAgICBpZiAoYXV0aC50ZW5hbnRJZCAmJiAhcmVxdWVzdC50ZW5hbnRJZCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KSwgeyB0ZW5hbnRJZDogYXV0aC50ZW5hbnRJZCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG59XG5hc3luYyBmdW5jdGlvbiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgbWV0aG9kLCBwYXRoLCByZXF1ZXN0LCBjdXN0b21FcnJvck1hcCA9IHt9KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtRmV0Y2hXaXRoRXJyb3JIYW5kbGluZyhhdXRoLCBjdXN0b21FcnJvck1hcCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBsZXQgYm9keSA9IHt9O1xuICAgICAgICBsZXQgcGFyYW1zID0ge307XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSBcIkdFVFwiIC8qIEh0dHBNZXRob2QuR0VUICovKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gcmVxdWVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvZHkgPSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWVyeSA9IHF1ZXJ5c3RyaW5nKE9iamVjdC5hc3NpZ24oeyBrZXk6IGF1dGguY29uZmlnLmFwaUtleSB9LCBwYXJhbXMpKS5zbGljZSgxKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IGF3YWl0IGF1dGguX2dldEFkZGl0aW9uYWxIZWFkZXJzKCk7XG4gICAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIiAvKiBIdHRwSGVhZGVyLkNPTlRFTlRfVFlQRSAqL10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgIGlmIChhdXRoLmxhbmd1YWdlQ29kZSkge1xuICAgICAgICAgICAgaGVhZGVyc1tcIlgtRmlyZWJhc2UtTG9jYWxlXCIgLyogSHR0cEhlYWRlci5YX0ZJUkVCQVNFX0xPQ0FMRSAqL10gPSBhdXRoLmxhbmd1YWdlQ29kZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmZXRjaEFyZ3MgPSBPYmplY3QuYXNzaWduKHsgbWV0aG9kLFxuICAgICAgICAgICAgaGVhZGVycyB9LCBib2R5KTtcbiAgICAgICAgLyogU2VjdXJpdHktY29uc2Npb3VzIHNlcnZlci1zaWRlIGZyYW1ld29ya3MgdGVuZCB0byBoYXZlIGJ1aWx0IGluIG1pdGlnYXRpb25zIGZvciByZWZlcnJlclxuICAgICAgICAgICBwcm9ibGVtc1wiLiBTZWUgdGhlIENsb3VkZmxhcmUgR2l0SHViIGlzc3VlICM0ODc6IEVycm9yOiBUaGUgJ3JlZmVycmVyUG9saWN5JyBmaWVsZCBvblxuICAgICAgICAgICAnUmVxdWVzdEluaXRpYWxpemVyRGljdCcgaXMgbm90IGltcGxlbWVudGVkLlwiXG4gICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9jbG91ZGZsYXJlL25leHQtb24tcGFnZXMvaXNzdWVzLzQ4NyAqL1xuICAgICAgICBpZiAoIWlzQ2xvdWRmbGFyZVdvcmtlcigpKSB7XG4gICAgICAgICAgICBmZXRjaEFyZ3MucmVmZXJyZXJQb2xpY3kgPSAnbm8tcmVmZXJyZXInO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGZXRjaFByb3ZpZGVyLmZldGNoKCkoX2dldEZpbmFsVGFyZ2V0KGF1dGgsIGF1dGguY29uZmlnLmFwaUhvc3QsIHBhdGgsIHF1ZXJ5KSwgZmV0Y2hBcmdzKTtcbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9wZXJmb3JtRmV0Y2hXaXRoRXJyb3JIYW5kbGluZyhhdXRoLCBjdXN0b21FcnJvck1hcCwgZmV0Y2hGbikge1xuICAgIGF1dGguX2NhbkluaXRFbXVsYXRvciA9IGZhbHNlO1xuICAgIGNvbnN0IGVycm9yTWFwID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBTRVJWRVJfRVJST1JfTUFQKSwgY3VzdG9tRXJyb3JNYXApO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtUaW1lb3V0ID0gbmV3IE5ldHdvcmtUaW1lb3V0KGF1dGgpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICBmZXRjaEZuKCksXG4gICAgICAgICAgICBuZXR3b3JrVGltZW91dC5wcm9taXNlXG4gICAgICAgIF0pO1xuICAgICAgICAvLyBJZiB3ZSd2ZSByZWFjaGVkIHRoaXMgcG9pbnQsIHRoZSBmZXRjaCBzdWNjZWVkZWQgYW5kIHRoZSBuZXR3b3JrVGltZW91dFxuICAgICAgICAvLyBkaWRuJ3QgdGhyb3c7IGNsZWFyIHRoZSBuZXR3b3JrIHRpbWVvdXQgZGVsYXkgc28gdGhhdCBOb2RlIHdvbid0IGhhbmdcbiAgICAgICAgbmV0d29ya1RpbWVvdXQuY2xlYXJOZXR3b3JrVGltZW91dCgpO1xuICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBpZiAoJ25lZWRDb25maXJtYXRpb24nIGluIGpzb24pIHtcbiAgICAgICAgICAgIHRocm93IF9tYWtlVGFnZ2VkRXJyb3IoYXV0aCwgXCJhY2NvdW50LWV4aXN0cy13aXRoLWRpZmZlcmVudC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5ORUVEX0NPTkZJUk1BVElPTiAqLywganNvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbnNlLm9rICYmICEoJ2Vycm9yTWVzc2FnZScgaW4ganNvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gcmVzcG9uc2Uub2sgPyBqc29uLmVycm9yTWVzc2FnZSA6IGpzb24uZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgIGNvbnN0IFtzZXJ2ZXJFcnJvckNvZGUsIHNlcnZlckVycm9yTWVzc2FnZV0gPSBlcnJvck1lc3NhZ2Uuc3BsaXQoJyA6ICcpO1xuICAgICAgICAgICAgaWYgKHNlcnZlckVycm9yQ29kZSA9PT0gXCJGRURFUkFURURfVVNFUl9JRF9BTFJFQURZX0xJTktFRFwiIC8qIFNlcnZlckVycm9yLkZFREVSQVRFRF9VU0VSX0lEX0FMUkVBRFlfTElOS0VEICovKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgX21ha2VUYWdnZWRFcnJvcihhdXRoLCBcImNyZWRlbnRpYWwtYWxyZWFkeS1pbi11c2VcIiAvKiBBdXRoRXJyb3JDb2RlLkNSRURFTlRJQUxfQUxSRUFEWV9JTl9VU0UgKi8sIGpzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VydmVyRXJyb3JDb2RlID09PSBcIkVNQUlMX0VYSVNUU1wiIC8qIFNlcnZlckVycm9yLkVNQUlMX0VYSVNUUyAqLykge1xuICAgICAgICAgICAgICAgIHRocm93IF9tYWtlVGFnZ2VkRXJyb3IoYXV0aCwgXCJlbWFpbC1hbHJlYWR5LWluLXVzZVwiIC8qIEF1dGhFcnJvckNvZGUuRU1BSUxfRVhJU1RTICovLCBqc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlcnZlckVycm9yQ29kZSA9PT0gXCJVU0VSX0RJU0FCTEVEXCIgLyogU2VydmVyRXJyb3IuVVNFUl9ESVNBQkxFRCAqLykge1xuICAgICAgICAgICAgICAgIHRocm93IF9tYWtlVGFnZ2VkRXJyb3IoYXV0aCwgXCJ1c2VyLWRpc2FibGVkXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX0RJU0FCTEVEICovLCBqc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF1dGhFcnJvciA9IGVycm9yTWFwW3NlcnZlckVycm9yQ29kZV0gfHxcbiAgICAgICAgICAgICAgICBzZXJ2ZXJFcnJvckNvZGVcbiAgICAgICAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tfXFxzXSsvZywgJy0nKTtcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBfZXJyb3JXaXRoQ3VzdG9tTWVzc2FnZShhdXRoLCBhdXRoRXJyb3IsIHNlcnZlckVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfZmFpbChhdXRoLCBhdXRoRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRmlyZWJhc2VFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGFuZ2luZyB0aGlzIHRvIGEgZGlmZmVyZW50IGVycm9yIGNvZGUgd2lsbCBsb2cgdXNlciBvdXQgd2hlbiB0aGVyZSBpcyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSB0cmVhdCBhbnkgZXJyb3Igb3RoZXIgdGhhbiBORVRXT1JLX1JFUVVFU1RfRkFJTEVEIGFzIHRva2VuIGlzIGludmFsaWQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9maXJlYmFzZS9maXJlYmFzZS1qcy1zZGsvYmxvYi80ZmJjNzM2MTBkNzBiZTRlMDg1MmU3ZGU2M2EzOWNiNzg5N2U4NTQ2L3BhY2thZ2VzL2F1dGgvc3JjL2NvcmUvYXV0aC9hdXRoX2ltcGwudHMjTDMwOS1MMzE2XG4gICAgICAgIF9mYWlsKGF1dGgsIFwibmV0d29yay1yZXF1ZXN0LWZhaWxlZFwiIC8qIEF1dGhFcnJvckNvZGUuTkVUV09SS19SRVFVRVNUX0ZBSUxFRCAqLywgeyAnbWVzc2FnZSc6IFN0cmluZyhlKSB9KTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBfcGVyZm9ybVNpZ25JblJlcXVlc3QoYXV0aCwgbWV0aG9kLCBwYXRoLCByZXF1ZXN0LCBjdXN0b21FcnJvck1hcCA9IHt9KSB7XG4gICAgY29uc3Qgc2VydmVyUmVzcG9uc2UgPSBhd2FpdCBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgbWV0aG9kLCBwYXRoLCByZXF1ZXN0LCBjdXN0b21FcnJvck1hcCk7XG4gICAgaWYgKCdtZmFQZW5kaW5nQ3JlZGVudGlhbCcgaW4gc2VydmVyUmVzcG9uc2UpIHtcbiAgICAgICAgX2ZhaWwoYXV0aCwgXCJtdWx0aS1mYWN0b3ItYXV0aC1yZXF1aXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuTUZBX1JFUVVJUkVEICovLCB7XG4gICAgICAgICAgICBfc2VydmVyUmVzcG9uc2U6IHNlcnZlclJlc3BvbnNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc2VydmVyUmVzcG9uc2U7XG59XG5mdW5jdGlvbiBfZ2V0RmluYWxUYXJnZXQoYXV0aCwgaG9zdCwgcGF0aCwgcXVlcnkpIHtcbiAgICBjb25zdCBiYXNlID0gYCR7aG9zdH0ke3BhdGh9PyR7cXVlcnl9YDtcbiAgICBpZiAoIWF1dGguY29uZmlnLmVtdWxhdG9yKSB7XG4gICAgICAgIHJldHVybiBgJHthdXRoLmNvbmZpZy5hcGlTY2hlbWV9Oi8vJHtiYXNlfWA7XG4gICAgfVxuICAgIHJldHVybiBfZW11bGF0b3JVcmwoYXV0aC5jb25maWcsIGJhc2UpO1xufVxuZnVuY3Rpb24gX3BhcnNlRW5mb3JjZW1lbnRTdGF0ZShlbmZvcmNlbWVudFN0YXRlU3RyKSB7XG4gICAgc3dpdGNoIChlbmZvcmNlbWVudFN0YXRlU3RyKSB7XG4gICAgICAgIGNhc2UgJ0VORk9SQ0UnOlxuICAgICAgICAgICAgcmV0dXJuIFwiRU5GT1JDRVwiIC8qIEVuZm9yY2VtZW50U3RhdGUuRU5GT1JDRSAqLztcbiAgICAgICAgY2FzZSAnQVVESVQnOlxuICAgICAgICAgICAgcmV0dXJuIFwiQVVESVRcIiAvKiBFbmZvcmNlbWVudFN0YXRlLkFVRElUICovO1xuICAgICAgICBjYXNlICdPRkYnOlxuICAgICAgICAgICAgcmV0dXJuIFwiT0ZGXCIgLyogRW5mb3JjZW1lbnRTdGF0ZS5PRkYgKi87XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJFTkZPUkNFTUVOVF9TVEFURV9VTlNQRUNJRklFRFwiIC8qIEVuZm9yY2VtZW50U3RhdGUuRU5GT1JDRU1FTlRfU1RBVEVfVU5TUEVDSUZJRUQgKi87XG4gICAgfVxufVxuY2xhc3MgTmV0d29ya1RpbWVvdXQge1xuICAgIGNsZWFyTmV0d29ya1RpbWVvdXQoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoYXV0aCkge1xuICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgICAgICAvLyBOb2RlIHRpbWVycyBhbmQgYnJvd3NlciB0aW1lcnMgYXJlIGZ1bmRhbWVudGFsbHkgaW5jb21wYXRpYmxlLCBidXQgd2VcbiAgICAgICAgLy8gZG9uJ3QgY2FyZSBhYm91dCB0aGUgdmFsdWUgaGVyZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoX2NyZWF0ZUVycm9yKHRoaXMuYXV0aCwgXCJuZXR3b3JrLXJlcXVlc3QtZmFpbGVkXCIgLyogQXV0aEVycm9yQ29kZS5ORVRXT1JLX1JFUVVFU1RfRkFJTEVEICovKSk7XG4gICAgICAgICAgICB9LCBERUZBVUxUX0FQSV9USU1FT1VUX01TLmdldCgpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gX21ha2VUYWdnZWRFcnJvcihhdXRoLCBjb2RlLCByZXNwb25zZSkge1xuICAgIGNvbnN0IGVycm9yUGFyYW1zID0ge1xuICAgICAgICBhcHBOYW1lOiBhdXRoLm5hbWVcbiAgICB9O1xuICAgIGlmIChyZXNwb25zZS5lbWFpbCkge1xuICAgICAgICBlcnJvclBhcmFtcy5lbWFpbCA9IHJlc3BvbnNlLmVtYWlsO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2UucGhvbmVOdW1iZXIpIHtcbiAgICAgICAgZXJyb3JQYXJhbXMucGhvbmVOdW1iZXIgPSByZXNwb25zZS5waG9uZU51bWJlcjtcbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBfY3JlYXRlRXJyb3IoYXV0aCwgY29kZSwgZXJyb3JQYXJhbXMpO1xuICAgIC8vIFdlIGtub3cgY3VzdG9tRGF0YSBpcyBkZWZpbmVkIG9uIGVycm9yIGJlY2F1c2UgZXJyb3JQYXJhbXMgaXMgZGVmaW5lZFxuICAgIGVycm9yLmN1c3RvbURhdGEuX3Rva2VuUmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICByZXR1cm4gZXJyb3I7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBpc0VudGVycHJpc2UoZ3JlY2FwdGNoYSkge1xuICAgIHJldHVybiAoZ3JlY2FwdGNoYSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGdyZWNhcHRjaGEuZW50ZXJwcmlzZSAhPT0gdW5kZWZpbmVkKTtcbn1cbmNsYXNzIFJlY2FwdGNoYUNvbmZpZyB7XG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZUNBUFRDSEEgc2l0ZSBrZXkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNpdGVLZXkgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsaXN0IG9mIHByb3ZpZGVycyBhbmQgdGhlaXIgZW5hYmxlbWVudCBzdGF0dXMgZm9yIHJlQ0FQVENIQSBFbnRlcnByaXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlID0gW107XG4gICAgICAgIGlmIChyZXNwb25zZS5yZWNhcHRjaGFLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNhcHRjaGFLZXkgdW5kZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXhhbXBsZSByZXNwb25zZS5yZWNhcHRjaGFLZXk6IFwicHJvamVjdHMvcHJvajEyMy9rZXlzL3NpdGVrZXkxMjNcIlxuICAgICAgICB0aGlzLnNpdGVLZXkgPSByZXNwb25zZS5yZWNhcHRjaGFLZXkuc3BsaXQoJy8nKVszXTtcbiAgICAgICAgdGhpcy5yZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlID0gcmVzcG9uc2UucmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVDQVBUQ0hBIEVudGVycHJpc2UgZW5mb3JjZW1lbnQgc3RhdGUgZm9yIHRoZSBnaXZlbiBwcm92aWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm92aWRlclN0ciAtIFRoZSBwcm92aWRlciB3aG9zZSBlbmZvcmNlbWVudCBzdGF0ZSBpcyB0byBiZSByZXR1cm5lZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcmVDQVBUQ0hBIEVudGVycHJpc2UgZW5mb3JjZW1lbnQgc3RhdGUgZm9yIHRoZSBnaXZlbiBwcm92aWRlci5cbiAgICAgKi9cbiAgICBnZXRQcm92aWRlckVuZm9yY2VtZW50U3RhdGUocHJvdmlkZXJTdHIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGUgfHxcbiAgICAgICAgICAgIHRoaXMucmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZSBvZiB0aGlzLnJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChyZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlLnByb3ZpZGVyICYmXG4gICAgICAgICAgICAgICAgcmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZS5wcm92aWRlciA9PT0gcHJvdmlkZXJTdHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3BhcnNlRW5mb3JjZW1lbnRTdGF0ZShyZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlLmVuZm9yY2VtZW50U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJlQ0FQVENIQSBFbnRlcnByaXNlIGVuZm9yY2VtZW50IHN0YXRlIGZvciB0aGUgcHJvdmlkZXIgaXMgc2V0IHRvIEVORk9SQ0Ugb3IgQVVESVQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvdmlkZXJTdHIgLSBUaGUgcHJvdmlkZXIgd2hvc2UgZW5hYmxlbWVudCBzdGF0ZSBpcyB0byBiZSByZXR1cm5lZC5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIG9yIG5vdCByZUNBUFRDSEEgRW50ZXJwcmlzZSBwcm90ZWN0aW9uIGlzIGVuYWJsZWQgZm9yIHRoZSBnaXZlbiBwcm92aWRlci5cbiAgICAgKi9cbiAgICBpc1Byb3ZpZGVyRW5hYmxlZChwcm92aWRlclN0cikge1xuICAgICAgICByZXR1cm4gKHRoaXMuZ2V0UHJvdmlkZXJFbmZvcmNlbWVudFN0YXRlKHByb3ZpZGVyU3RyKSA9PT1cbiAgICAgICAgICAgIFwiRU5GT1JDRVwiIC8qIEVuZm9yY2VtZW50U3RhdGUuRU5GT1JDRSAqLyB8fFxuICAgICAgICAgICAgdGhpcy5nZXRQcm92aWRlckVuZm9yY2VtZW50U3RhdGUocHJvdmlkZXJTdHIpID09PSBcIkFVRElUXCIgLyogRW5mb3JjZW1lbnRTdGF0ZS5BVURJVCAqLyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiByZUNBUFRDSEEgRW50ZXJwcmlzZSBwcm90ZWN0aW9uIGlzIGVuYWJsZWQgaW4gYXQgbGVhc3Qgb25lIHByb3ZpZGVyLCBvdGhlcndpc2VcbiAgICAgKiByZXR1cm5zIGZhbHNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgV2hldGhlciBvciBub3QgcmVDQVBUQ0hBIEVudGVycHJpc2UgcHJvdGVjdGlvbiBpcyBlbmFibGVkIGZvciBhdCBsZWFzdCBvbmUgcHJvdmlkZXIuXG4gICAgICovXG4gICAgaXNBbnlQcm92aWRlckVuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pc1Byb3ZpZGVyRW5hYmxlZChcIkVNQUlMX1BBU1NXT1JEX1BST1ZJREVSXCIgLyogUmVjYXB0Y2hhQXV0aFByb3ZpZGVyLkVNQUlMX1BBU1NXT1JEX1BST1ZJREVSICovKSB8fFxuICAgICAgICAgICAgdGhpcy5pc1Byb3ZpZGVyRW5hYmxlZChcIlBIT05FX1BST1ZJREVSXCIgLyogUmVjYXB0Y2hhQXV0aFByb3ZpZGVyLlBIT05FX1BST1ZJREVSICovKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0UmVjYXB0Y2hhQ29uZmlnKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiR0VUXCIgLyogSHR0cE1ldGhvZC5HRVQgKi8sIFwiL3YyL3JlY2FwdGNoYUNvbmZpZ1wiIC8qIEVuZHBvaW50LkdFVF9SRUNBUFRDSEFfQ09ORklHICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVsZXRlQWNjb3VudChhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOmRlbGV0ZVwiIC8qIEVuZHBvaW50LkRFTEVURV9BQ0NPVU5UICovLCByZXF1ZXN0KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUxpbmtlZEFjY291bnRzKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6dXBkYXRlXCIgLyogRW5kcG9pbnQuU0VUX0FDQ09VTlRfSU5GTyAqLywgcmVxdWVzdCk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRBY2NvdW50SW5mbyhhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOmxvb2t1cFwiIC8qIEVuZHBvaW50LkdFVF9BQ0NPVU5UX0lORk8gKi8sIHJlcXVlc3QpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gdXRjVGltZXN0YW1wVG9EYXRlU3RyaW5nKHV0Y1RpbWVzdGFtcCkge1xuICAgIGlmICghdXRjVGltZXN0YW1wKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIENvbnZlcnQgdG8gZGF0ZSBvYmplY3QuXG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShOdW1iZXIodXRjVGltZXN0YW1wKSk7XG4gICAgICAgIC8vIFRlc3QgZGF0ZSBpcyB2YWxpZC5cbiAgICAgICAgaWYgKCFpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gVVRDIGRhdGUgc3RyaW5nLlxuICAgICAgICAgICAgcmV0dXJuIGRhdGUudG9VVENTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBEbyBub3RoaW5nLiB1bmRlZmluZWQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmV0dXJucyBhIEpTT04gV2ViIFRva2VuIChKV1QpIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHVzZXIgdG8gYSBGaXJlYmFzZSBzZXJ2aWNlLlxuICpcbiAqIEByZW1hcmtzXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRva2VuIGlmIGl0IGhhcyBub3QgZXhwaXJlZCBvciBpZiBpdCB3aWxsIG5vdCBleHBpcmUgaW4gdGhlIG5leHQgZml2ZVxuICogbWludXRlcy4gT3RoZXJ3aXNlLCB0aGlzIHdpbGwgcmVmcmVzaCB0aGUgdG9rZW4gYW5kIHJldHVybiBhIG5ldyBvbmUuXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqIEBwYXJhbSBmb3JjZVJlZnJlc2ggLSBGb3JjZSByZWZyZXNoIHJlZ2FyZGxlc3Mgb2YgdG9rZW4gZXhwaXJhdGlvbi5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGdldElkVG9rZW4odXNlciwgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpLmdldElkVG9rZW4oZm9yY2VSZWZyZXNoKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIGRlc2VyaWFsaXplZCBKU09OIFdlYiBUb2tlbiAoSldUKSB1c2VkIHRvIGlkZW50aWZ5IHRoZSB1c2VyIHRvIGEgRmlyZWJhc2Ugc2VydmljZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogUmV0dXJucyB0aGUgY3VycmVudCB0b2tlbiBpZiBpdCBoYXMgbm90IGV4cGlyZWQgb3IgaWYgaXQgd2lsbCBub3QgZXhwaXJlIGluIHRoZSBuZXh0IGZpdmVcbiAqIG1pbnV0ZXMuIE90aGVyd2lzZSwgdGhpcyB3aWxsIHJlZnJlc2ggdGhlIHRva2VuIGFuZCByZXR1cm4gYSBuZXcgb25lLlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gZm9yY2VSZWZyZXNoIC0gRm9yY2UgcmVmcmVzaCByZWdhcmRsZXNzIG9mIHRva2VuIGV4cGlyYXRpb24uXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBnZXRJZFRva2VuUmVzdWx0KHVzZXIsIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gICAgY29uc3QgdXNlckludGVybmFsID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xuICAgIGNvbnN0IHRva2VuID0gYXdhaXQgdXNlckludGVybmFsLmdldElkVG9rZW4oZm9yY2VSZWZyZXNoKTtcbiAgICBjb25zdCBjbGFpbXMgPSBfcGFyc2VUb2tlbih0b2tlbik7XG4gICAgX2Fzc2VydChjbGFpbXMgJiYgY2xhaW1zLmV4cCAmJiBjbGFpbXMuYXV0aF90aW1lICYmIGNsYWltcy5pYXQsIHVzZXJJbnRlcm5hbC5hdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgY29uc3QgZmlyZWJhc2UgPSB0eXBlb2YgY2xhaW1zLmZpcmViYXNlID09PSAnb2JqZWN0JyA/IGNsYWltcy5maXJlYmFzZSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBzaWduSW5Qcm92aWRlciA9IGZpcmViYXNlID09PSBudWxsIHx8IGZpcmViYXNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaXJlYmFzZVsnc2lnbl9pbl9wcm92aWRlciddO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNsYWltcyxcbiAgICAgICAgdG9rZW4sXG4gICAgICAgIGF1dGhUaW1lOiB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcoc2Vjb25kc1N0cmluZ1RvTWlsbGlzZWNvbmRzKGNsYWltcy5hdXRoX3RpbWUpKSxcbiAgICAgICAgaXNzdWVkQXRUaW1lOiB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcoc2Vjb25kc1N0cmluZ1RvTWlsbGlzZWNvbmRzKGNsYWltcy5pYXQpKSxcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IHV0Y1RpbWVzdGFtcFRvRGF0ZVN0cmluZyhzZWNvbmRzU3RyaW5nVG9NaWxsaXNlY29uZHMoY2xhaW1zLmV4cCkpLFxuICAgICAgICBzaWduSW5Qcm92aWRlcjogc2lnbkluUHJvdmlkZXIgfHwgbnVsbCxcbiAgICAgICAgc2lnbkluU2Vjb25kRmFjdG9yOiAoZmlyZWJhc2UgPT09IG51bGwgfHwgZmlyZWJhc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpcmViYXNlWydzaWduX2luX3NlY29uZF9mYWN0b3InXSkgfHwgbnVsbFxuICAgIH07XG59XG5mdW5jdGlvbiBzZWNvbmRzU3RyaW5nVG9NaWxsaXNlY29uZHMoc2Vjb25kcykge1xuICAgIHJldHVybiBOdW1iZXIoc2Vjb25kcykgKiAxMDAwO1xufVxuZnVuY3Rpb24gX3BhcnNlVG9rZW4odG9rZW4pIHtcbiAgICBjb25zdCBbYWxnb3JpdGhtLCBwYXlsb2FkLCBzaWduYXR1cmVdID0gdG9rZW4uc3BsaXQoJy4nKTtcbiAgICBpZiAoYWxnb3JpdGhtID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgcGF5bG9hZCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIHNpZ25hdHVyZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIF9sb2dFcnJvcignSldUIG1hbGZvcm1lZCwgY29udGFpbmVkIGZld2VyIHRoYW4gMyBzZWN0aW9ucycpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IGJhc2U2NERlY29kZShwYXlsb2FkKTtcbiAgICAgICAgaWYgKCFkZWNvZGVkKSB7XG4gICAgICAgICAgICBfbG9nRXJyb3IoJ0ZhaWxlZCB0byBkZWNvZGUgYmFzZTY0IEpXVCBwYXlsb2FkJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkZWNvZGVkKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgX2xvZ0Vycm9yKCdDYXVnaHQgZXJyb3IgcGFyc2luZyBKV1QgcGF5bG9hZCBhcyBKU09OJywgZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4vKipcbiAqIEV4dHJhY3QgZXhwaXJlc0luIFRUTCBmcm9tIGEgdG9rZW4gYnkgc3VidHJhY3RpbmcgdGhlIGV4cGlyYXRpb24gZnJvbSB0aGUgaXNzdWFuY2UuXG4gKi9cbmZ1bmN0aW9uIF90b2tlbkV4cGlyZXNJbih0b2tlbikge1xuICAgIGNvbnN0IHBhcnNlZFRva2VuID0gX3BhcnNlVG9rZW4odG9rZW4pO1xuICAgIF9hc3NlcnQocGFyc2VkVG9rZW4sIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICBfYXNzZXJ0KHR5cGVvZiBwYXJzZWRUb2tlbi5leHAgIT09ICd1bmRlZmluZWQnLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgX2Fzc2VydCh0eXBlb2YgcGFyc2VkVG9rZW4uaWF0ICE9PSAndW5kZWZpbmVkJywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgIHJldHVybiBOdW1iZXIocGFyc2VkVG9rZW4uZXhwKSAtIE51bWJlcihwYXJzZWRUb2tlbi5pYXQpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2xvZ291dElmSW52YWxpZGF0ZWQodXNlciwgcHJvbWlzZSwgYnlwYXNzQXV0aFN0YXRlID0gZmFsc2UpIHtcbiAgICBpZiAoYnlwYXNzQXV0aFN0YXRlKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvbWlzZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yICYmIGlzVXNlckludmFsaWRhdGVkKGUpKSB7XG4gICAgICAgICAgICBpZiAodXNlci5hdXRoLmN1cnJlbnRVc2VyID09PSB1c2VyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdXNlci5hdXRoLnNpZ25PdXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzVXNlckludmFsaWRhdGVkKHsgY29kZSB9KSB7XG4gICAgcmV0dXJuIChjb2RlID09PSBgYXV0aC8ke1widXNlci1kaXNhYmxlZFwiIC8qIEF1dGhFcnJvckNvZGUuVVNFUl9ESVNBQkxFRCAqL31gIHx8XG4gICAgICAgIGNvZGUgPT09IGBhdXRoLyR7XCJ1c2VyLXRva2VuLWV4cGlyZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlRPS0VOX0VYUElSRUQgKi99YCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBQcm9hY3RpdmVSZWZyZXNoIHtcbiAgICBjb25zdHJ1Y3Rvcih1c2VyKSB7XG4gICAgICAgIHRoaXMudXNlciA9IHVzZXI7XG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIE5vZGUgdGltZXJzIGFuZCBicm93c2VyIHRpbWVycyByZXR1cm4gZnVuZGFtZW50YWxseSBkaWZmZXJlbnQgdHlwZXMuXG4gICAgICAgIC8vIFdlIGRvbid0IGFjdHVhbGx5IGNhcmUgd2hhdCB0aGUgdmFsdWUgaXMgYnV0IFRTIHdvbid0IGFjY2VwdCB1bmtub3duIGFuZFxuICAgICAgICAvLyB3ZSBjYW4ndCBjYXN0IHByb3Blcmx5IGluIGJvdGggZW52aXJvbm1lbnRzLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB0aGlzLnRpbWVySWQgPSBudWxsO1xuICAgICAgICB0aGlzLmVycm9yQmFja29mZiA9IDMwMDAwIC8qIER1cmF0aW9uLlJFVFJZX0JBQ0tPRkZfTUlOICovO1xuICAgIH1cbiAgICBfc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZSgpO1xuICAgIH1cbiAgICBfc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnRpbWVySWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEludGVydmFsKHdhc0Vycm9yKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHdhc0Vycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnZhbCA9IHRoaXMuZXJyb3JCYWNrb2ZmO1xuICAgICAgICAgICAgdGhpcy5lcnJvckJhY2tvZmYgPSBNYXRoLm1pbih0aGlzLmVycm9yQmFja29mZiAqIDIsIDk2MDAwMCAvKiBEdXJhdGlvbi5SRVRSWV9CQUNLT0ZGX01BWCAqLyk7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJ2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgZXJyb3IgYmFja29mZlxuICAgICAgICAgICAgdGhpcy5lcnJvckJhY2tvZmYgPSAzMDAwMCAvKiBEdXJhdGlvbi5SRVRSWV9CQUNLT0ZGX01JTiAqLztcbiAgICAgICAgICAgIGNvbnN0IGV4cFRpbWUgPSAoX2EgPSB0aGlzLnVzZXIuc3RzVG9rZW5NYW5hZ2VyLmV4cGlyYXRpb25UaW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBleHBUaW1lIC0gRGF0ZS5ub3coKSAtIDMwMDAwMCAvKiBEdXJhdGlvbi5PRkZTRVQgKi87XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgaW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNjaGVkdWxlKHdhc0Vycm9yID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUnVubmluZykge1xuICAgICAgICAgICAgLy8gSnVzdCBpbiBjYXNlLi4uXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSB0aGlzLmdldEludGVydmFsKHdhc0Vycm9yKTtcbiAgICAgICAgdGhpcy50aW1lcklkID0gc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLml0ZXJhdGlvbigpO1xuICAgICAgICB9LCBpbnRlcnZhbCk7XG4gICAgfVxuICAgIGFzeW5jIGl0ZXJhdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudXNlci5nZXRJZFRva2VuKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHJldHJ5IG9uIG5ldHdvcmsgZXJyb3JzXG4gICAgICAgICAgICBpZiAoKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5jb2RlKSA9PT1cbiAgICAgICAgICAgICAgICBgYXV0aC8ke1wibmV0d29yay1yZXF1ZXN0LWZhaWxlZFwiIC8qIEF1dGhFcnJvckNvZGUuTkVUV09SS19SRVFVRVNUX0ZBSUxFRCAqL31gKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZSgvKiB3YXNFcnJvciAqLyB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjaGVkdWxlKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgVXNlck1ldGFkYXRhIHtcbiAgICBjb25zdHJ1Y3RvcihjcmVhdGVkQXQsIGxhc3RMb2dpbkF0KSB7XG4gICAgICAgIHRoaXMuY3JlYXRlZEF0ID0gY3JlYXRlZEF0O1xuICAgICAgICB0aGlzLmxhc3RMb2dpbkF0ID0gbGFzdExvZ2luQXQ7XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVUaW1lKCk7XG4gICAgfVxuICAgIF9pbml0aWFsaXplVGltZSgpIHtcbiAgICAgICAgdGhpcy5sYXN0U2lnbkluVGltZSA9IHV0Y1RpbWVzdGFtcFRvRGF0ZVN0cmluZyh0aGlzLmxhc3RMb2dpbkF0KTtcbiAgICAgICAgdGhpcy5jcmVhdGlvblRpbWUgPSB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcodGhpcy5jcmVhdGVkQXQpO1xuICAgIH1cbiAgICBfY29weShtZXRhZGF0YSkge1xuICAgICAgICB0aGlzLmNyZWF0ZWRBdCA9IG1ldGFkYXRhLmNyZWF0ZWRBdDtcbiAgICAgICAgdGhpcy5sYXN0TG9naW5BdCA9IG1ldGFkYXRhLmxhc3RMb2dpbkF0O1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplVGltZSgpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGVkQXQ6IHRoaXMuY3JlYXRlZEF0LFxuICAgICAgICAgICAgbGFzdExvZ2luQXQ6IHRoaXMubGFzdExvZ2luQXRcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBfcmVsb2FkV2l0aG91dFNhdmluZyh1c2VyKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGF1dGggPSB1c2VyLmF1dGg7XG4gICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodXNlciwgZ2V0QWNjb3VudEluZm8oYXV0aCwgeyBpZFRva2VuIH0pKTtcbiAgICBfYXNzZXJ0KHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS51c2Vycy5sZW5ndGgsIGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICBjb25zdCBjb3JlQWNjb3VudCA9IHJlc3BvbnNlLnVzZXJzWzBdO1xuICAgIHVzZXIuX25vdGlmeVJlbG9hZExpc3RlbmVyKGNvcmVBY2NvdW50KTtcbiAgICBjb25zdCBuZXdQcm92aWRlckRhdGEgPSAoKF9hID0gY29yZUFjY291bnQucHJvdmlkZXJVc2VySW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aClcbiAgICAgICAgPyBleHRyYWN0UHJvdmlkZXJEYXRhKGNvcmVBY2NvdW50LnByb3ZpZGVyVXNlckluZm8pXG4gICAgICAgIDogW107XG4gICAgY29uc3QgcHJvdmlkZXJEYXRhID0gbWVyZ2VQcm92aWRlckRhdGEodXNlci5wcm92aWRlckRhdGEsIG5ld1Byb3ZpZGVyRGF0YSk7XG4gICAgLy8gUHJlc2VydmVzIHRoZSBub24tbm9ueW1vdXMgc3RhdHVzIG9mIHRoZSBzdG9yZWQgdXNlciwgZXZlbiBpZiBubyBtb3JlXG4gICAgLy8gY3JlZGVudGlhbHMgKGZlZGVyYXRlZCBvciBlbWFpbC9wYXNzd29yZCkgYXJlIGxpbmtlZCB0byB0aGUgdXNlci4gSWZcbiAgICAvLyB0aGUgdXNlciB3YXMgcHJldmlvdXNseSBhbm9ueW1vdXMsIHRoZW4gdXNlIHByb3ZpZGVyIGRhdGEgdG8gdXBkYXRlLlxuICAgIC8vIE9uIHRoZSBvdGhlciBoYW5kLCBpZiBpdCB3YXMgbm90IGFub255bW91cyBiZWZvcmUsIGl0IHNob3VsZCBuZXZlciBiZVxuICAgIC8vIGNvbnNpZGVyZWQgYW5vbnltb3VzIG5vdy5cbiAgICBjb25zdCBvbGRJc0Fub255bW91cyA9IHVzZXIuaXNBbm9ueW1vdXM7XG4gICAgY29uc3QgbmV3SXNBbm9ueW1vdXMgPSAhKHVzZXIuZW1haWwgJiYgY29yZUFjY291bnQucGFzc3dvcmRIYXNoKSAmJiAhKHByb3ZpZGVyRGF0YSA9PT0gbnVsbCB8fCBwcm92aWRlckRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3ZpZGVyRGF0YS5sZW5ndGgpO1xuICAgIGNvbnN0IGlzQW5vbnltb3VzID0gIW9sZElzQW5vbnltb3VzID8gZmFsc2UgOiBuZXdJc0Fub255bW91cztcbiAgICBjb25zdCB1cGRhdGVzID0ge1xuICAgICAgICB1aWQ6IGNvcmVBY2NvdW50LmxvY2FsSWQsXG4gICAgICAgIGRpc3BsYXlOYW1lOiBjb3JlQWNjb3VudC5kaXNwbGF5TmFtZSB8fCBudWxsLFxuICAgICAgICBwaG90b1VSTDogY29yZUFjY291bnQucGhvdG9VcmwgfHwgbnVsbCxcbiAgICAgICAgZW1haWw6IGNvcmVBY2NvdW50LmVtYWlsIHx8IG51bGwsXG4gICAgICAgIGVtYWlsVmVyaWZpZWQ6IGNvcmVBY2NvdW50LmVtYWlsVmVyaWZpZWQgfHwgZmFsc2UsXG4gICAgICAgIHBob25lTnVtYmVyOiBjb3JlQWNjb3VudC5waG9uZU51bWJlciB8fCBudWxsLFxuICAgICAgICB0ZW5hbnRJZDogY29yZUFjY291bnQudGVuYW50SWQgfHwgbnVsbCxcbiAgICAgICAgcHJvdmlkZXJEYXRhLFxuICAgICAgICBtZXRhZGF0YTogbmV3IFVzZXJNZXRhZGF0YShjb3JlQWNjb3VudC5jcmVhdGVkQXQsIGNvcmVBY2NvdW50Lmxhc3RMb2dpbkF0KSxcbiAgICAgICAgaXNBbm9ueW1vdXNcbiAgICB9O1xuICAgIE9iamVjdC5hc3NpZ24odXNlciwgdXBkYXRlcyk7XG59XG4vKipcbiAqIFJlbG9hZHMgdXNlciBhY2NvdW50IGRhdGEsIGlmIHNpZ25lZCBpbi5cbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVsb2FkKHVzZXIpIHtcbiAgICBjb25zdCB1c2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcik7XG4gICAgYXdhaXQgX3JlbG9hZFdpdGhvdXRTYXZpbmcodXNlckludGVybmFsKTtcbiAgICAvLyBFdmVuIHRob3VnaCB0aGUgY3VycmVudCB1c2VyIGhhc24ndCBjaGFuZ2VkLCB1cGRhdGVcbiAgICAvLyBjdXJyZW50IHVzZXIgd2lsbCB0cmlnZ2VyIGEgcGVyc2lzdGVuY2UgdXBkYXRlIHcvIHRoZVxuICAgIC8vIG5ldyBpbmZvLlxuICAgIGF3YWl0IHVzZXJJbnRlcm5hbC5hdXRoLl9wZXJzaXN0VXNlcklmQ3VycmVudCh1c2VySW50ZXJuYWwpO1xuICAgIHVzZXJJbnRlcm5hbC5hdXRoLl9ub3RpZnlMaXN0ZW5lcnNJZkN1cnJlbnQodXNlckludGVybmFsKTtcbn1cbmZ1bmN0aW9uIG1lcmdlUHJvdmlkZXJEYXRhKG9yaWdpbmFsLCBuZXdEYXRhKSB7XG4gICAgY29uc3QgZGVkdXBlZCA9IG9yaWdpbmFsLmZpbHRlcihvID0+ICFuZXdEYXRhLnNvbWUobiA9PiBuLnByb3ZpZGVySWQgPT09IG8ucHJvdmlkZXJJZCkpO1xuICAgIHJldHVybiBbLi4uZGVkdXBlZCwgLi4ubmV3RGF0YV07XG59XG5mdW5jdGlvbiBleHRyYWN0UHJvdmlkZXJEYXRhKHByb3ZpZGVycykge1xuICAgIHJldHVybiBwcm92aWRlcnMubWFwKChfYSkgPT4ge1xuICAgICAgICB2YXIgeyBwcm92aWRlcklkIH0gPSBfYSwgcHJvdmlkZXIgPSBfX3Jlc3QoX2EsIFtcInByb3ZpZGVySWRcIl0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvdmlkZXJJZCxcbiAgICAgICAgICAgIHVpZDogcHJvdmlkZXIucmF3SWQgfHwgJycsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogcHJvdmlkZXIuZGlzcGxheU5hbWUgfHwgbnVsbCxcbiAgICAgICAgICAgIGVtYWlsOiBwcm92aWRlci5lbWFpbCB8fCBudWxsLFxuICAgICAgICAgICAgcGhvbmVOdW1iZXI6IHByb3ZpZGVyLnBob25lTnVtYmVyIHx8IG51bGwsXG4gICAgICAgICAgICBwaG90b1VSTDogcHJvdmlkZXIucGhvdG9VcmwgfHwgbnVsbFxuICAgICAgICB9O1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdFN0c1Rva2VuKGF1dGgsIHJlZnJlc2hUb2tlbikge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX3BlcmZvcm1GZXRjaFdpdGhFcnJvckhhbmRsaW5nKGF1dGgsIHt9LCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBxdWVyeXN0cmluZyh7XG4gICAgICAgICAgICAnZ3JhbnRfdHlwZSc6ICdyZWZyZXNoX3Rva2VuJyxcbiAgICAgICAgICAgICdyZWZyZXNoX3Rva2VuJzogcmVmcmVzaFRva2VuXG4gICAgICAgIH0pLnNsaWNlKDEpO1xuICAgICAgICBjb25zdCB7IHRva2VuQXBpSG9zdCwgYXBpS2V5IH0gPSBhdXRoLmNvbmZpZztcbiAgICAgICAgY29uc3QgdXJsID0gX2dldEZpbmFsVGFyZ2V0KGF1dGgsIHRva2VuQXBpSG9zdCwgXCIvdjEvdG9rZW5cIiAvKiBFbmRwb2ludC5UT0tFTiAqLywgYGtleT0ke2FwaUtleX1gKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IGF3YWl0IGF1dGguX2dldEFkZGl0aW9uYWxIZWFkZXJzKCk7XG4gICAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIiAvKiBIdHRwSGVhZGVyLkNPTlRFTlRfVFlQRSAqL10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgICAgICAgcmV0dXJuIEZldGNoUHJvdmlkZXIuZmV0Y2goKSh1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHlcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gVGhlIHJlc3BvbnNlIGNvbWVzIGJhY2sgaW4gc25ha2VfY2FzZS4gQ29udmVydCB0byBjYW1lbDpcbiAgICByZXR1cm4ge1xuICAgICAgICBhY2Nlc3NUb2tlbjogcmVzcG9uc2UuYWNjZXNzX3Rva2VuLFxuICAgICAgICBleHBpcmVzSW46IHJlc3BvbnNlLmV4cGlyZXNfaW4sXG4gICAgICAgIHJlZnJlc2hUb2tlbjogcmVzcG9uc2UucmVmcmVzaF90b2tlblxuICAgIH07XG59XG5hc3luYyBmdW5jdGlvbiByZXZva2VUb2tlbihhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YyL2FjY291bnRzOnJldm9rZVRva2VuXCIgLyogRW5kcG9pbnQuUkVWT0tFX1RPS0VOICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBXZSBuZWVkIHRvIG1hcmsgdGhpcyBjbGFzcyBhcyBpbnRlcm5hbCBleHBsaWNpdGx5IHRvIGV4Y2x1ZGUgaXQgaW4gdGhlIHB1YmxpYyB0eXBpbmdzLCBiZWNhdXNlXG4gKiBpdCByZWZlcmVuY2VzIEF1dGhJbnRlcm5hbCB3aGljaCBoYXMgYSBjaXJjdWxhciBkZXBlbmRlbmN5IHdpdGggVXNlckludGVybmFsLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBTdHNUb2tlbk1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnJlZnJlc2hUb2tlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBudWxsO1xuICAgICAgICB0aGlzLmV4cGlyYXRpb25UaW1lID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IGlzRXhwaXJlZCgpIHtcbiAgICAgICAgcmV0dXJuICghdGhpcy5leHBpcmF0aW9uVGltZSB8fFxuICAgICAgICAgICAgRGF0ZS5ub3coKSA+IHRoaXMuZXhwaXJhdGlvblRpbWUgLSAzMDAwMCAvKiBCdWZmZXIuVE9LRU5fUkVGUkVTSCAqLyk7XG4gICAgfVxuICAgIHVwZGF0ZUZyb21TZXJ2ZXJSZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICBfYXNzZXJ0KHJlc3BvbnNlLmlkVG9rZW4sIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgX2Fzc2VydCh0eXBlb2YgcmVzcG9uc2UuaWRUb2tlbiAhPT0gJ3VuZGVmaW5lZCcsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgX2Fzc2VydCh0eXBlb2YgcmVzcG9uc2UucmVmcmVzaFRva2VuICE9PSAndW5kZWZpbmVkJywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICBjb25zdCBleHBpcmVzSW4gPSAnZXhwaXJlc0luJyBpbiByZXNwb25zZSAmJiB0eXBlb2YgcmVzcG9uc2UuZXhwaXJlc0luICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBOdW1iZXIocmVzcG9uc2UuZXhwaXJlc0luKVxuICAgICAgICAgICAgOiBfdG9rZW5FeHBpcmVzSW4ocmVzcG9uc2UuaWRUb2tlbik7XG4gICAgICAgIHRoaXMudXBkYXRlVG9rZW5zQW5kRXhwaXJhdGlvbihyZXNwb25zZS5pZFRva2VuLCByZXNwb25zZS5yZWZyZXNoVG9rZW4sIGV4cGlyZXNJbik7XG4gICAgfVxuICAgIHVwZGF0ZUZyb21JZFRva2VuKGlkVG9rZW4pIHtcbiAgICAgICAgX2Fzc2VydChpZFRva2VuLmxlbmd0aCAhPT0gMCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICBjb25zdCBleHBpcmVzSW4gPSBfdG9rZW5FeHBpcmVzSW4oaWRUb2tlbik7XG4gICAgICAgIHRoaXMudXBkYXRlVG9rZW5zQW5kRXhwaXJhdGlvbihpZFRva2VuLCBudWxsLCBleHBpcmVzSW4pO1xuICAgIH1cbiAgICBhc3luYyBnZXRUb2tlbihhdXRoLCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xuICAgICAgICBpZiAoIWZvcmNlUmVmcmVzaCAmJiB0aGlzLmFjY2Vzc1Rva2VuICYmICF0aGlzLmlzRXhwaXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWNjZXNzVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgX2Fzc2VydCh0aGlzLnJlZnJlc2hUb2tlbiwgYXV0aCwgXCJ1c2VyLXRva2VuLWV4cGlyZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlRPS0VOX0VYUElSRUQgKi8pO1xuICAgICAgICBpZiAodGhpcy5yZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVmcmVzaChhdXRoLCB0aGlzLnJlZnJlc2hUb2tlbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY2Nlc3NUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY2xlYXJSZWZyZXNoVG9rZW4oKSB7XG4gICAgICAgIHRoaXMucmVmcmVzaFRva2VuID0gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgcmVmcmVzaChhdXRoLCBvbGRUb2tlbikge1xuICAgICAgICBjb25zdCB7IGFjY2Vzc1Rva2VuLCByZWZyZXNoVG9rZW4sIGV4cGlyZXNJbiB9ID0gYXdhaXQgcmVxdWVzdFN0c1Rva2VuKGF1dGgsIG9sZFRva2VuKTtcbiAgICAgICAgdGhpcy51cGRhdGVUb2tlbnNBbmRFeHBpcmF0aW9uKGFjY2Vzc1Rva2VuLCByZWZyZXNoVG9rZW4sIE51bWJlcihleHBpcmVzSW4pKTtcbiAgICB9XG4gICAgdXBkYXRlVG9rZW5zQW5kRXhwaXJhdGlvbihhY2Nlc3NUb2tlbiwgcmVmcmVzaFRva2VuLCBleHBpcmVzSW5TZWMpIHtcbiAgICAgICAgdGhpcy5yZWZyZXNoVG9rZW4gPSByZWZyZXNoVG9rZW4gfHwgbnVsbDtcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuIHx8IG51bGw7XG4gICAgICAgIHRoaXMuZXhwaXJhdGlvblRpbWUgPSBEYXRlLm5vdygpICsgZXhwaXJlc0luU2VjICogMTAwMDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21KU09OKGFwcE5hbWUsIG9iamVjdCkge1xuICAgICAgICBjb25zdCB7IHJlZnJlc2hUb2tlbiwgYWNjZXNzVG9rZW4sIGV4cGlyYXRpb25UaW1lIH0gPSBvYmplY3Q7XG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgU3RzVG9rZW5NYW5hZ2VyKCk7XG4gICAgICAgIGlmIChyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgIF9hc3NlcnQodHlwZW9mIHJlZnJlc2hUb2tlbiA9PT0gJ3N0cmluZycsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovLCB7XG4gICAgICAgICAgICAgICAgYXBwTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtYW5hZ2VyLnJlZnJlc2hUb2tlbiA9IHJlZnJlc2hUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIF9hc3NlcnQodHlwZW9mIGFjY2Vzc1Rva2VuID09PSAnc3RyaW5nJywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8sIHtcbiAgICAgICAgICAgICAgICBhcHBOYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1hbmFnZXIuYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgICAgIF9hc3NlcnQodHlwZW9mIGV4cGlyYXRpb25UaW1lID09PSAnbnVtYmVyJywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8sIHtcbiAgICAgICAgICAgICAgICBhcHBOYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1hbmFnZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFuYWdlcjtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVmcmVzaFRva2VuOiB0aGlzLnJlZnJlc2hUb2tlbixcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiB0aGlzLmFjY2Vzc1Rva2VuLFxuICAgICAgICAgICAgZXhwaXJhdGlvblRpbWU6IHRoaXMuZXhwaXJhdGlvblRpbWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2Fzc2lnbihzdHNUb2tlbk1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IHN0c1Rva2VuTWFuYWdlci5hY2Nlc3NUb2tlbjtcbiAgICAgICAgdGhpcy5yZWZyZXNoVG9rZW4gPSBzdHNUb2tlbk1hbmFnZXIucmVmcmVzaFRva2VuO1xuICAgICAgICB0aGlzLmV4cGlyYXRpb25UaW1lID0gc3RzVG9rZW5NYW5hZ2VyLmV4cGlyYXRpb25UaW1lO1xuICAgIH1cbiAgICBfY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBTdHNUb2tlbk1hbmFnZXIoKSwgdGhpcy50b0pTT04oKSk7XG4gICAgfVxuICAgIF9wZXJmb3JtUmVmcmVzaCgpIHtcbiAgICAgICAgcmV0dXJuIGRlYnVnRmFpbCgnbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQoYXNzZXJ0aW9uLCBhcHBOYW1lKSB7XG4gICAgX2Fzc2VydCh0eXBlb2YgYXNzZXJ0aW9uID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYXNzZXJ0aW9uID09PSAndW5kZWZpbmVkJywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8sIHsgYXBwTmFtZSB9KTtcbn1cbmNsYXNzIFVzZXJJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihfYSkge1xuICAgICAgICB2YXIgeyB1aWQsIGF1dGgsIHN0c1Rva2VuTWFuYWdlciB9ID0gX2EsIG9wdCA9IF9fcmVzdChfYSwgW1widWlkXCIsIFwiYXV0aFwiLCBcInN0c1Rva2VuTWFuYWdlclwiXSk7XG4gICAgICAgIC8vIEZvciB0aGUgdXNlciBvYmplY3QsIHByb3ZpZGVyIGlzIGFsd2F5cyBGaXJlYmFzZS5cbiAgICAgICAgdGhpcy5wcm92aWRlcklkID0gXCJmaXJlYmFzZVwiIC8qIFByb3ZpZGVySWQuRklSRUJBU0UgKi87XG4gICAgICAgIHRoaXMucHJvYWN0aXZlUmVmcmVzaCA9IG5ldyBQcm9hY3RpdmVSZWZyZXNoKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbG9hZFVzZXJJbmZvID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWxvYWRMaXN0ZW5lciA9IG51bGw7XG4gICAgICAgIHRoaXMudWlkID0gdWlkO1xuICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgICAgICB0aGlzLnN0c1Rva2VuTWFuYWdlciA9IHN0c1Rva2VuTWFuYWdlcjtcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IHN0c1Rva2VuTWFuYWdlci5hY2Nlc3NUb2tlbjtcbiAgICAgICAgdGhpcy5kaXNwbGF5TmFtZSA9IG9wdC5kaXNwbGF5TmFtZSB8fCBudWxsO1xuICAgICAgICB0aGlzLmVtYWlsID0gb3B0LmVtYWlsIHx8IG51bGw7XG4gICAgICAgIHRoaXMuZW1haWxWZXJpZmllZCA9IG9wdC5lbWFpbFZlcmlmaWVkIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLnBob25lTnVtYmVyID0gb3B0LnBob25lTnVtYmVyIHx8IG51bGw7XG4gICAgICAgIHRoaXMucGhvdG9VUkwgPSBvcHQucGhvdG9VUkwgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5pc0Fub255bW91cyA9IG9wdC5pc0Fub255bW91cyB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy50ZW5hbnRJZCA9IG9wdC50ZW5hbnRJZCB8fCBudWxsO1xuICAgICAgICB0aGlzLnByb3ZpZGVyRGF0YSA9IG9wdC5wcm92aWRlckRhdGEgPyBbLi4ub3B0LnByb3ZpZGVyRGF0YV0gOiBbXTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG5ldyBVc2VyTWV0YWRhdGEob3B0LmNyZWF0ZWRBdCB8fCB1bmRlZmluZWQsIG9wdC5sYXN0TG9naW5BdCB8fCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBhc3luYyBnZXRJZFRva2VuKGZvcmNlUmVmcmVzaCkge1xuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IGF3YWl0IF9sb2dvdXRJZkludmFsaWRhdGVkKHRoaXMsIHRoaXMuc3RzVG9rZW5NYW5hZ2VyLmdldFRva2VuKHRoaXMuYXV0aCwgZm9yY2VSZWZyZXNoKSk7XG4gICAgICAgIF9hc3NlcnQoYWNjZXNzVG9rZW4sIHRoaXMuYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICBpZiAodGhpcy5hY2Nlc3NUb2tlbiAhPT0gYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlbjtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXV0aC5fcGVyc2lzdFVzZXJJZkN1cnJlbnQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmF1dGguX25vdGlmeUxpc3RlbmVyc0lmQ3VycmVudCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjZXNzVG9rZW47XG4gICAgfVxuICAgIGdldElkVG9rZW5SZXN1bHQoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgIHJldHVybiBnZXRJZFRva2VuUmVzdWx0KHRoaXMsIGZvcmNlUmVmcmVzaCk7XG4gICAgfVxuICAgIHJlbG9hZCgpIHtcbiAgICAgICAgcmV0dXJuIHJlbG9hZCh0aGlzKTtcbiAgICB9XG4gICAgX2Fzc2lnbih1c2VyKSB7XG4gICAgICAgIGlmICh0aGlzID09PSB1c2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX2Fzc2VydCh0aGlzLnVpZCA9PT0gdXNlci51aWQsIHRoaXMuYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICB0aGlzLmRpc3BsYXlOYW1lID0gdXNlci5kaXNwbGF5TmFtZTtcbiAgICAgICAgdGhpcy5waG90b1VSTCA9IHVzZXIucGhvdG9VUkw7XG4gICAgICAgIHRoaXMuZW1haWwgPSB1c2VyLmVtYWlsO1xuICAgICAgICB0aGlzLmVtYWlsVmVyaWZpZWQgPSB1c2VyLmVtYWlsVmVyaWZpZWQ7XG4gICAgICAgIHRoaXMucGhvbmVOdW1iZXIgPSB1c2VyLnBob25lTnVtYmVyO1xuICAgICAgICB0aGlzLmlzQW5vbnltb3VzID0gdXNlci5pc0Fub255bW91cztcbiAgICAgICAgdGhpcy50ZW5hbnRJZCA9IHVzZXIudGVuYW50SWQ7XG4gICAgICAgIHRoaXMucHJvdmlkZXJEYXRhID0gdXNlci5wcm92aWRlckRhdGEubWFwKHVzZXJJbmZvID0+IChPYmplY3QuYXNzaWduKHt9LCB1c2VySW5mbykpKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5fY29weSh1c2VyLm1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5zdHNUb2tlbk1hbmFnZXIuX2Fzc2lnbih1c2VyLnN0c1Rva2VuTWFuYWdlcik7XG4gICAgfVxuICAgIF9jbG9uZShhdXRoKSB7XG4gICAgICAgIGNvbnN0IG5ld1VzZXIgPSBuZXcgVXNlckltcGwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzKSwgeyBhdXRoLCBzdHNUb2tlbk1hbmFnZXI6IHRoaXMuc3RzVG9rZW5NYW5hZ2VyLl9jbG9uZSgpIH0pKTtcbiAgICAgICAgbmV3VXNlci5tZXRhZGF0YS5fY29weSh0aGlzLm1ldGFkYXRhKTtcbiAgICAgICAgcmV0dXJuIG5ld1VzZXI7XG4gICAgfVxuICAgIF9vblJlbG9hZChjYWxsYmFjaykge1xuICAgICAgICAvLyBUaGVyZSBzaG91bGQgb25seSBldmVyIGJlIG9uZSBsaXN0ZW5lciwgYW5kIHRoYXQgaXMgYSBzaW5nbGUgaW5zdGFuY2Ugb2YgTXVsdGlGYWN0b3JVc2VyXG4gICAgICAgIF9hc3NlcnQoIXRoaXMucmVsb2FkTGlzdGVuZXIsIHRoaXMuYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICB0aGlzLnJlbG9hZExpc3RlbmVyID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0aGlzLnJlbG9hZFVzZXJJbmZvKSB7XG4gICAgICAgICAgICB0aGlzLl9ub3RpZnlSZWxvYWRMaXN0ZW5lcih0aGlzLnJlbG9hZFVzZXJJbmZvKTtcbiAgICAgICAgICAgIHRoaXMucmVsb2FkVXNlckluZm8gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9ub3RpZnlSZWxvYWRMaXN0ZW5lcih1c2VySW5mbykge1xuICAgICAgICBpZiAodGhpcy5yZWxvYWRMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5yZWxvYWRMaXN0ZW5lcih1c2VySW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBubyBsaXN0ZW5lciBpcyBzdWJzY3JpYmVkIHlldCwgc2F2ZSB0aGUgcmVzdWx0IHNvIGl0J3MgYXZhaWxhYmxlIHdoZW4gdGhleSBkbyBzdWJzY3JpYmVcbiAgICAgICAgICAgIHRoaXMucmVsb2FkVXNlckluZm8gPSB1c2VySW5mbztcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc3RhcnRQcm9hY3RpdmVSZWZyZXNoKCkge1xuICAgICAgICB0aGlzLnByb2FjdGl2ZVJlZnJlc2guX3N0YXJ0KCk7XG4gICAgfVxuICAgIF9zdG9wUHJvYWN0aXZlUmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5wcm9hY3RpdmVSZWZyZXNoLl9zdG9wKCk7XG4gICAgfVxuICAgIGFzeW5jIF91cGRhdGVUb2tlbnNJZk5lY2Vzc2FyeShyZXNwb25zZSwgcmVsb2FkID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHRva2Vuc1JlZnJlc2hlZCA9IGZhbHNlO1xuICAgICAgICBpZiAocmVzcG9uc2UuaWRUb2tlbiAmJlxuICAgICAgICAgICAgcmVzcG9uc2UuaWRUb2tlbiAhPT0gdGhpcy5zdHNUb2tlbk1hbmFnZXIuYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMuc3RzVG9rZW5NYW5hZ2VyLnVwZGF0ZUZyb21TZXJ2ZXJSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICB0b2tlbnNSZWZyZXNoZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxvYWQpIHtcbiAgICAgICAgICAgIGF3YWl0IF9yZWxvYWRXaXRob3V0U2F2aW5nKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuYXV0aC5fcGVyc2lzdFVzZXJJZkN1cnJlbnQodGhpcyk7XG4gICAgICAgIGlmICh0b2tlbnNSZWZyZXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0aC5fbm90aWZ5TGlzdGVuZXJzSWZDdXJyZW50KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZSgpIHtcbiAgICAgICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKHRoaXMuYXV0aC5hcHApKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IodGhpcy5hdXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHRoaXMuZ2V0SWRUb2tlbigpO1xuICAgICAgICBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZCh0aGlzLCBkZWxldGVBY2NvdW50KHRoaXMuYXV0aCwgeyBpZFRva2VuIH0pKTtcbiAgICAgICAgdGhpcy5zdHNUb2tlbk1hbmFnZXIuY2xlYXJSZWZyZXNoVG9rZW4oKTtcbiAgICAgICAgLy8gVE9ETzogRGV0ZXJtaW5lIGlmIGNhbmNlbGxhYmxlLXByb21pc2VzIGFyZSBuZWNlc3NhcnkgdG8gdXNlIGluIHRoaXMgY2xhc3Mgc28gdGhhdCBkZWxldGUoKVxuICAgICAgICAvLyAgICAgICBjYW5jZWxzIHBlbmRpbmcgYWN0aW9ucy4uLlxuICAgICAgICByZXR1cm4gdGhpcy5hdXRoLnNpZ25PdXQoKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdWlkOiB0aGlzLnVpZCwgZW1haWw6IHRoaXMuZW1haWwgfHwgdW5kZWZpbmVkLCBlbWFpbFZlcmlmaWVkOiB0aGlzLmVtYWlsVmVyaWZpZWQsIGRpc3BsYXlOYW1lOiB0aGlzLmRpc3BsYXlOYW1lIHx8IHVuZGVmaW5lZCwgaXNBbm9ueW1vdXM6IHRoaXMuaXNBbm9ueW1vdXMsIHBob3RvVVJMOiB0aGlzLnBob3RvVVJMIHx8IHVuZGVmaW5lZCwgcGhvbmVOdW1iZXI6IHRoaXMucGhvbmVOdW1iZXIgfHwgdW5kZWZpbmVkLCB0ZW5hbnRJZDogdGhpcy50ZW5hbnRJZCB8fCB1bmRlZmluZWQsIHByb3ZpZGVyRGF0YTogdGhpcy5wcm92aWRlckRhdGEubWFwKHVzZXJJbmZvID0+IChPYmplY3QuYXNzaWduKHt9LCB1c2VySW5mbykpKSwgc3RzVG9rZW5NYW5hZ2VyOiB0aGlzLnN0c1Rva2VuTWFuYWdlci50b0pTT04oKSwgXG4gICAgICAgICAgICAvLyBSZWRpcmVjdCBldmVudCBJRCBtdXN0IGJlIG1haW50YWluZWQgaW4gY2FzZSB0aGVyZSBpcyBhIHBlbmRpbmdcbiAgICAgICAgICAgIC8vIHJlZGlyZWN0IGV2ZW50LlxuICAgICAgICAgICAgX3JlZGlyZWN0RXZlbnRJZDogdGhpcy5fcmVkaXJlY3RFdmVudElkIH0sIHRoaXMubWV0YWRhdGEudG9KU09OKCkpLCB7IFxuICAgICAgICAgICAgLy8gUmVxdWlyZWQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgbGVnYWN5IFNESyAoZ28vZmlyZWJhc2UtYXV0aC1zZGstcGVyc2lzdGVuY2UtcGFyc2luZyk6XG4gICAgICAgICAgICBhcGlLZXk6IHRoaXMuYXV0aC5jb25maWcuYXBpS2V5LCBhcHBOYW1lOiB0aGlzLmF1dGgubmFtZSB9KTtcbiAgICB9XG4gICAgZ2V0IHJlZnJlc2hUb2tlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RzVG9rZW5NYW5hZ2VyLnJlZnJlc2hUb2tlbiB8fCAnJztcbiAgICB9XG4gICAgc3RhdGljIF9mcm9tSlNPTihhdXRoLCBvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgY29uc3QgZGlzcGxheU5hbWUgPSAoX2EgPSBvYmplY3QuZGlzcGxheU5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZW1haWwgPSAoX2IgPSBvYmplY3QuZW1haWwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcGhvbmVOdW1iZXIgPSAoX2MgPSBvYmplY3QucGhvbmVOdW1iZXIpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcGhvdG9VUkwgPSAoX2QgPSBvYmplY3QucGhvdG9VUkwpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgdGVuYW50SWQgPSAoX2UgPSBvYmplY3QudGVuYW50SWQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgX3JlZGlyZWN0RXZlbnRJZCA9IChfZiA9IG9iamVjdC5fcmVkaXJlY3RFdmVudElkKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGNyZWF0ZWRBdCA9IChfZyA9IG9iamVjdC5jcmVhdGVkQXQpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgbGFzdExvZ2luQXQgPSAoX2ggPSBvYmplY3QubGFzdExvZ2luQXQpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgeyB1aWQsIGVtYWlsVmVyaWZpZWQsIGlzQW5vbnltb3VzLCBwcm92aWRlckRhdGEsIHN0c1Rva2VuTWFuYWdlcjogcGxhaW5PYmplY3RUb2tlbk1hbmFnZXIgfSA9IG9iamVjdDtcbiAgICAgICAgX2Fzc2VydCh1aWQgJiYgcGxhaW5PYmplY3RUb2tlbk1hbmFnZXIsIGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgY29uc3Qgc3RzVG9rZW5NYW5hZ2VyID0gU3RzVG9rZW5NYW5hZ2VyLmZyb21KU09OKHRoaXMubmFtZSwgcGxhaW5PYmplY3RUb2tlbk1hbmFnZXIpO1xuICAgICAgICBfYXNzZXJ0KHR5cGVvZiB1aWQgPT09ICdzdHJpbmcnLCBhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKGRpc3BsYXlOYW1lLCBhdXRoLm5hbWUpO1xuICAgICAgICBhc3NlcnRTdHJpbmdPclVuZGVmaW5lZChlbWFpbCwgYXV0aC5uYW1lKTtcbiAgICAgICAgX2Fzc2VydCh0eXBlb2YgZW1haWxWZXJpZmllZCA9PT0gJ2Jvb2xlYW4nLCBhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIF9hc3NlcnQodHlwZW9mIGlzQW5vbnltb3VzID09PSAnYm9vbGVhbicsIGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQocGhvbmVOdW1iZXIsIGF1dGgubmFtZSk7XG4gICAgICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKHBob3RvVVJMLCBhdXRoLm5hbWUpO1xuICAgICAgICBhc3NlcnRTdHJpbmdPclVuZGVmaW5lZCh0ZW5hbnRJZCwgYXV0aC5uYW1lKTtcbiAgICAgICAgYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQoX3JlZGlyZWN0RXZlbnRJZCwgYXV0aC5uYW1lKTtcbiAgICAgICAgYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQoY3JlYXRlZEF0LCBhdXRoLm5hbWUpO1xuICAgICAgICBhc3NlcnRTdHJpbmdPclVuZGVmaW5lZChsYXN0TG9naW5BdCwgYXV0aC5uYW1lKTtcbiAgICAgICAgY29uc3QgdXNlciA9IG5ldyBVc2VySW1wbCh7XG4gICAgICAgICAgICB1aWQsXG4gICAgICAgICAgICBhdXRoLFxuICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICBlbWFpbFZlcmlmaWVkLFxuICAgICAgICAgICAgZGlzcGxheU5hbWUsXG4gICAgICAgICAgICBpc0Fub255bW91cyxcbiAgICAgICAgICAgIHBob3RvVVJMLFxuICAgICAgICAgICAgcGhvbmVOdW1iZXIsXG4gICAgICAgICAgICB0ZW5hbnRJZCxcbiAgICAgICAgICAgIHN0c1Rva2VuTWFuYWdlcixcbiAgICAgICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgICAgICAgIGxhc3RMb2dpbkF0XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJvdmlkZXJEYXRhICYmIEFycmF5LmlzQXJyYXkocHJvdmlkZXJEYXRhKSkge1xuICAgICAgICAgICAgdXNlci5wcm92aWRlckRhdGEgPSBwcm92aWRlckRhdGEubWFwKHVzZXJJbmZvID0+IChPYmplY3QuYXNzaWduKHt9LCB1c2VySW5mbykpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3JlZGlyZWN0RXZlbnRJZCkge1xuICAgICAgICAgICAgdXNlci5fcmVkaXJlY3RFdmVudElkID0gX3JlZGlyZWN0RXZlbnRJZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXNlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBhIFVzZXIgZnJvbSBhbiBpZFRva2VuIHNlcnZlciByZXNwb25zZVxuICAgICAqIEBwYXJhbSBhdXRoXG4gICAgICogQHBhcmFtIGlkVG9rZW5SZXNwb25zZVxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBfZnJvbUlkVG9rZW5SZXNwb25zZShhdXRoLCBpZFRva2VuUmVzcG9uc2UsIGlzQW5vbnltb3VzID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgc3RzVG9rZW5NYW5hZ2VyID0gbmV3IFN0c1Rva2VuTWFuYWdlcigpO1xuICAgICAgICBzdHNUb2tlbk1hbmFnZXIudXBkYXRlRnJvbVNlcnZlclJlc3BvbnNlKGlkVG9rZW5SZXNwb25zZSk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIEZpcmViYXNlIEF1dGggdXNlci5cbiAgICAgICAgY29uc3QgdXNlciA9IG5ldyBVc2VySW1wbCh7XG4gICAgICAgICAgICB1aWQ6IGlkVG9rZW5SZXNwb25zZS5sb2NhbElkLFxuICAgICAgICAgICAgYXV0aCxcbiAgICAgICAgICAgIHN0c1Rva2VuTWFuYWdlcixcbiAgICAgICAgICAgIGlzQW5vbnltb3VzXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBVcGRhdGVzIHRoZSB1c2VyIGluZm8gYW5kIGRhdGEgYW5kIHJlc29sdmVzIHdpdGggYSB1c2VyIGluc3RhbmNlLlxuICAgICAgICBhd2FpdCBfcmVsb2FkV2l0aG91dFNhdmluZyh1c2VyKTtcbiAgICAgICAgcmV0dXJuIHVzZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgYSBVc2VyIGZyb20gYW4gaWRUb2tlbiBzZXJ2ZXIgcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0gYXV0aFxuICAgICAqIEBwYXJhbSBpZFRva2VuUmVzcG9uc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgX2Zyb21HZXRBY2NvdW50SW5mb1Jlc3BvbnNlKGF1dGgsIHJlc3BvbnNlLCBpZFRva2VuKSB7XG4gICAgICAgIGNvbnN0IGNvcmVBY2NvdW50ID0gcmVzcG9uc2UudXNlcnNbMF07XG4gICAgICAgIF9hc3NlcnQoY29yZUFjY291bnQubG9jYWxJZCAhPT0gdW5kZWZpbmVkLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyRGF0YSA9IGNvcmVBY2NvdW50LnByb3ZpZGVyVXNlckluZm8gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBleHRyYWN0UHJvdmlkZXJEYXRhKGNvcmVBY2NvdW50LnByb3ZpZGVyVXNlckluZm8pXG4gICAgICAgICAgICA6IFtdO1xuICAgICAgICBjb25zdCBpc0Fub255bW91cyA9ICEoY29yZUFjY291bnQuZW1haWwgJiYgY29yZUFjY291bnQucGFzc3dvcmRIYXNoKSAmJiAhKHByb3ZpZGVyRGF0YSA9PT0gbnVsbCB8fCBwcm92aWRlckRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3ZpZGVyRGF0YS5sZW5ndGgpO1xuICAgICAgICBjb25zdCBzdHNUb2tlbk1hbmFnZXIgPSBuZXcgU3RzVG9rZW5NYW5hZ2VyKCk7XG4gICAgICAgIHN0c1Rva2VuTWFuYWdlci51cGRhdGVGcm9tSWRUb2tlbihpZFRva2VuKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgRmlyZWJhc2UgQXV0aCB1c2VyLlxuICAgICAgICBjb25zdCB1c2VyID0gbmV3IFVzZXJJbXBsKHtcbiAgICAgICAgICAgIHVpZDogY29yZUFjY291bnQubG9jYWxJZCxcbiAgICAgICAgICAgIGF1dGgsXG4gICAgICAgICAgICBzdHNUb2tlbk1hbmFnZXIsXG4gICAgICAgICAgICBpc0Fub255bW91c1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSB1c2VyIHdpdGggZGF0YSBmcm9tIHRoZSBHZXRBY2NvdW50SW5mbyByZXNwb25zZS5cbiAgICAgICAgY29uc3QgdXBkYXRlcyA9IHtcbiAgICAgICAgICAgIHVpZDogY29yZUFjY291bnQubG9jYWxJZCxcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBjb3JlQWNjb3VudC5kaXNwbGF5TmFtZSB8fCBudWxsLFxuICAgICAgICAgICAgcGhvdG9VUkw6IGNvcmVBY2NvdW50LnBob3RvVXJsIHx8IG51bGwsXG4gICAgICAgICAgICBlbWFpbDogY29yZUFjY291bnQuZW1haWwgfHwgbnVsbCxcbiAgICAgICAgICAgIGVtYWlsVmVyaWZpZWQ6IGNvcmVBY2NvdW50LmVtYWlsVmVyaWZpZWQgfHwgZmFsc2UsXG4gICAgICAgICAgICBwaG9uZU51bWJlcjogY29yZUFjY291bnQucGhvbmVOdW1iZXIgfHwgbnVsbCxcbiAgICAgICAgICAgIHRlbmFudElkOiBjb3JlQWNjb3VudC50ZW5hbnRJZCB8fCBudWxsLFxuICAgICAgICAgICAgcHJvdmlkZXJEYXRhLFxuICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBVc2VyTWV0YWRhdGEoY29yZUFjY291bnQuY3JlYXRlZEF0LCBjb3JlQWNjb3VudC5sYXN0TG9naW5BdCksXG4gICAgICAgICAgICBpc0Fub255bW91czogIShjb3JlQWNjb3VudC5lbWFpbCAmJiBjb3JlQWNjb3VudC5wYXNzd29yZEhhc2gpICYmXG4gICAgICAgICAgICAgICAgIShwcm92aWRlckRhdGEgPT09IG51bGwgfHwgcHJvdmlkZXJEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm92aWRlckRhdGEubGVuZ3RoKVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuYXNzaWduKHVzZXIsIHVwZGF0ZXMpO1xuICAgICAgICByZXR1cm4gdXNlcjtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBpbnN0YW5jZUNhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gX2dldEluc3RhbmNlKGNscykge1xuICAgIGRlYnVnQXNzZXJ0KGNscyBpbnN0YW5jZW9mIEZ1bmN0aW9uLCAnRXhwZWN0ZWQgYSBjbGFzcyBkZWZpbml0aW9uJyk7XG4gICAgbGV0IGluc3RhbmNlID0gaW5zdGFuY2VDYWNoZS5nZXQoY2xzKTtcbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgZGVidWdBc3NlcnQoaW5zdGFuY2UgaW5zdGFuY2VvZiBjbHMsICdJbnN0YW5jZSBzdG9yZWQgaW4gY2FjaGUgbWlzbWF0Y2hlZCB3aXRoIGNsYXNzJyk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG4gICAgaW5zdGFuY2UgPSBuZXcgY2xzKCk7XG4gICAgaW5zdGFuY2VDYWNoZS5zZXQoY2xzLCBpbnN0YW5jZSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgSW5NZW1vcnlQZXJzaXN0ZW5jZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiTk9ORVwiIC8qIFBlcnNpc3RlbmNlVHlwZS5OT05FICovO1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSB7fTtcbiAgICB9XG4gICAgYXN5bmMgX2lzQXZhaWxhYmxlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgX3NldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZVtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIGFzeW5jIF9nZXQoa2V5KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zdG9yYWdlW2tleV07XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHZhbHVlO1xuICAgIH1cbiAgICBhc3luYyBfcmVtb3ZlKGtleSkge1xuICAgICAgICBkZWxldGUgdGhpcy5zdG9yYWdlW2tleV07XG4gICAgfVxuICAgIF9hZGRMaXN0ZW5lcihfa2V5LCBfbGlzdGVuZXIpIHtcbiAgICAgICAgLy8gTGlzdGVuZXJzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBpbi1tZW1vcnkgc3RvcmFnZSBzaW5jZSBpdCBjYW5ub3QgYmUgc2hhcmVkIGFjcm9zcyB3aW5kb3dzL3dvcmtlcnNcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfcmVtb3ZlTGlzdGVuZXIoX2tleSwgX2xpc3RlbmVyKSB7XG4gICAgICAgIC8vIExpc3RlbmVycyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgaW4tbWVtb3J5IHN0b3JhZ2Ugc2luY2UgaXQgY2Fubm90IGJlIHNoYXJlZCBhY3Jvc3Mgd2luZG93cy93b3JrZXJzXG4gICAgICAgIHJldHVybjtcbiAgICB9XG59XG5Jbk1lbW9yeVBlcnNpc3RlbmNlLnR5cGUgPSAnTk9ORSc7XG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBQZXJzaXN0ZW5jZX0gb2YgdHlwZSAnTk9ORScuXG4gKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBpbk1lbW9yeVBlcnNpc3RlbmNlID0gSW5NZW1vcnlQZXJzaXN0ZW5jZTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIF9wZXJzaXN0ZW5jZUtleU5hbWUoa2V5LCBhcGlLZXksIGFwcE5hbWUpIHtcbiAgICByZXR1cm4gYCR7XCJmaXJlYmFzZVwiIC8qIE5hbWVzcGFjZS5QRVJTSVNURU5DRSAqL306JHtrZXl9OiR7YXBpS2V5fToke2FwcE5hbWV9YDtcbn1cbmNsYXNzIFBlcnNpc3RlbmNlVXNlck1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHBlcnNpc3RlbmNlLCBhdXRoLCB1c2VyS2V5KSB7XG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICAgICAgdGhpcy51c2VyS2V5ID0gdXNlcktleTtcbiAgICAgICAgY29uc3QgeyBjb25maWcsIG5hbWUgfSA9IHRoaXMuYXV0aDtcbiAgICAgICAgdGhpcy5mdWxsVXNlcktleSA9IF9wZXJzaXN0ZW5jZUtleU5hbWUodGhpcy51c2VyS2V5LCBjb25maWcuYXBpS2V5LCBuYW1lKTtcbiAgICAgICAgdGhpcy5mdWxsUGVyc2lzdGVuY2VLZXkgPSBfcGVyc2lzdGVuY2VLZXlOYW1lKFwicGVyc2lzdGVuY2VcIiAvKiBLZXlOYW1lLlBFUlNJU1RFTkNFX1VTRVIgKi8sIGNvbmZpZy5hcGlLZXksIG5hbWUpO1xuICAgICAgICB0aGlzLmJvdW5kRXZlbnRIYW5kbGVyID0gYXV0aC5fb25TdG9yYWdlRXZlbnQuYmluZChhdXRoKTtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZS5fYWRkTGlzdGVuZXIodGhpcy5mdWxsVXNlcktleSwgdGhpcy5ib3VuZEV2ZW50SGFuZGxlcik7XG4gICAgfVxuICAgIHNldEN1cnJlbnRVc2VyKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2UuX3NldCh0aGlzLmZ1bGxVc2VyS2V5LCB1c2VyLnRvSlNPTigpKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q3VycmVudFVzZXIoKSB7XG4gICAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCB0aGlzLnBlcnNpc3RlbmNlLl9nZXQodGhpcy5mdWxsVXNlcktleSk7XG4gICAgICAgIHJldHVybiBibG9iID8gVXNlckltcGwuX2Zyb21KU09OKHRoaXMuYXV0aCwgYmxvYikgOiBudWxsO1xuICAgIH1cbiAgICByZW1vdmVDdXJyZW50VXNlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2UuX3JlbW92ZSh0aGlzLmZ1bGxVc2VyS2V5KTtcbiAgICB9XG4gICAgc2F2ZVBlcnNpc3RlbmNlRm9yUmVkaXJlY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlLl9zZXQodGhpcy5mdWxsUGVyc2lzdGVuY2VLZXksIHRoaXMucGVyc2lzdGVuY2UudHlwZSk7XG4gICAgfVxuICAgIGFzeW5jIHNldFBlcnNpc3RlbmNlKG5ld1BlcnNpc3RlbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLnBlcnNpc3RlbmNlID09PSBuZXdQZXJzaXN0ZW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRVc2VyID0gYXdhaXQgdGhpcy5nZXRDdXJyZW50VXNlcigpO1xuICAgICAgICBhd2FpdCB0aGlzLnJlbW92ZUN1cnJlbnRVc2VyKCk7XG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UgPSBuZXdQZXJzaXN0ZW5jZTtcbiAgICAgICAgaWYgKGN1cnJlbnRVc2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRDdXJyZW50VXNlcihjdXJyZW50VXNlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlKCkge1xuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlLl9yZW1vdmVMaXN0ZW5lcih0aGlzLmZ1bGxVc2VyS2V5LCB0aGlzLmJvdW5kRXZlbnRIYW5kbGVyKTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShhdXRoLCBwZXJzaXN0ZW5jZUhpZXJhcmNoeSwgdXNlcktleSA9IFwiYXV0aFVzZXJcIiAvKiBLZXlOYW1lLkFVVEhfVVNFUiAqLykge1xuICAgICAgICBpZiAoIXBlcnNpc3RlbmNlSGllcmFyY2h5Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVVzZXJNYW5hZ2VyKF9nZXRJbnN0YW5jZShpbk1lbW9yeVBlcnNpc3RlbmNlKSwgYXV0aCwgdXNlcktleSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRWxpbWluYXRlIGFueSBwZXJzaXN0ZW5jZXMgdGhhdCBhcmUgbm90IGF2YWlsYWJsZVxuICAgICAgICBjb25zdCBhdmFpbGFibGVQZXJzaXN0ZW5jZXMgPSAoYXdhaXQgUHJvbWlzZS5hbGwocGVyc2lzdGVuY2VIaWVyYXJjaHkubWFwKGFzeW5jIChwZXJzaXN0ZW5jZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGF3YWl0IHBlcnNpc3RlbmNlLl9pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBlcnNpc3RlbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSkpKS5maWx0ZXIocGVyc2lzdGVuY2UgPT4gcGVyc2lzdGVuY2UpO1xuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIGZpcnN0IHBlcnNpc3RlbmNlIGxpc3RlZCwgb3IgaW4gbWVtb3J5IGlmIG5vbmUgYXZhaWxhYmxlXG4gICAgICAgIGxldCBzZWxlY3RlZFBlcnNpc3RlbmNlID0gYXZhaWxhYmxlUGVyc2lzdGVuY2VzWzBdIHx8XG4gICAgICAgICAgICBfZ2V0SW5zdGFuY2UoaW5NZW1vcnlQZXJzaXN0ZW5jZSk7XG4gICAgICAgIGNvbnN0IGtleSA9IF9wZXJzaXN0ZW5jZUtleU5hbWUodXNlcktleSwgYXV0aC5jb25maWcuYXBpS2V5LCBhdXRoLm5hbWUpO1xuICAgICAgICAvLyBQdWxsIG91dCB0aGUgZXhpc3RpbmcgdXNlciwgc2V0dGluZyB0aGUgY2hvc2VuIHBlcnNpc3RlbmNlIHRvIHRoYXRcbiAgICAgICAgLy8gcGVyc2lzdGVuY2UgaWYgdGhlIHVzZXIgZXhpc3RzLlxuICAgICAgICBsZXQgdXNlclRvTWlncmF0ZSA9IG51bGw7XG4gICAgICAgIC8vIE5vdGUsIGhlcmUgd2UgY2hlY2sgZm9yIGEgdXNlciBpbiBfYWxsXyBwZXJzaXN0ZW5jZXMsIG5vdCBqdXN0IHRoZVxuICAgICAgICAvLyBvbmVzIGRlZW1lZCBhdmFpbGFibGUuIElmIHdlIGNhbiBtaWdyYXRlIGEgdXNlciBvdXQgb2YgYSBicm9rZW5cbiAgICAgICAgLy8gcGVyc2lzdGVuY2UsIHdlIHdpbGwgKGJ1dCBvbmx5IGlmIHRoYXQgcGVyc2lzdGVuY2Ugc3VwcG9ydHMgbWlncmF0aW9uKS5cbiAgICAgICAgZm9yIChjb25zdCBwZXJzaXN0ZW5jZSBvZiBwZXJzaXN0ZW5jZUhpZXJhcmNoeSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBibG9iID0gYXdhaXQgcGVyc2lzdGVuY2UuX2dldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChibG9iKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBVc2VySW1wbC5fZnJvbUpTT04oYXV0aCwgYmxvYik7IC8vIHRocm93cyBmb3IgdW5wYXJzYWJsZSBibG9iICh3cm9uZyBmb3JtYXQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwZXJzaXN0ZW5jZSAhPT0gc2VsZWN0ZWRQZXJzaXN0ZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlclRvTWlncmF0ZSA9IHVzZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRQZXJzaXN0ZW5jZSA9IHBlcnNpc3RlbmNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGZpbmQgdGhlIHVzZXIgaW4gYSBwZXJzaXN0ZW5jZSB0aGF0IGRvZXMgc3VwcG9ydCBtaWdyYXRpb24sIHVzZVxuICAgICAgICAvLyB0aGF0IG1pZ3JhdGlvbiBwYXRoIChvZiBvbmx5IHBlcnNpc3RlbmNlcyB0aGF0IHN1cHBvcnQgbWlncmF0aW9uKVxuICAgICAgICBjb25zdCBtaWdyYXRpb25IaWVyYXJjaHkgPSBhdmFpbGFibGVQZXJzaXN0ZW5jZXMuZmlsdGVyKHAgPT4gcC5fc2hvdWxkQWxsb3dNaWdyYXRpb24pO1xuICAgICAgICAvLyBJZiB0aGUgcGVyc2lzdGVuY2UgZG9lcyBfbm90XyBhbGxvdyBtaWdyYXRpb24sIGp1c3QgZmluaXNoIG9mZiBoZXJlXG4gICAgICAgIGlmICghc2VsZWN0ZWRQZXJzaXN0ZW5jZS5fc2hvdWxkQWxsb3dNaWdyYXRpb24gfHxcbiAgICAgICAgICAgICFtaWdyYXRpb25IaWVyYXJjaHkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlVXNlck1hbmFnZXIoc2VsZWN0ZWRQZXJzaXN0ZW5jZSwgYXV0aCwgdXNlcktleSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0ZWRQZXJzaXN0ZW5jZSA9IG1pZ3JhdGlvbkhpZXJhcmNoeVswXTtcbiAgICAgICAgaWYgKHVzZXJUb01pZ3JhdGUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgbm9ybWFsbHkgc2hvdWxkbid0IHRocm93IHNpbmNlIGNob3NlblBlcnNpc3RlbmNlLmlzQXZhaWxhYmxlKCkgaXMgdHJ1ZSwgYnV0IGlmIGl0IGRvZXNcbiAgICAgICAgICAgIC8vIHdlJ2xsIGp1c3QgbGV0IGl0IGJ1YmJsZSB0byBzdXJmYWNlIHRoZSBlcnJvci5cbiAgICAgICAgICAgIGF3YWl0IHNlbGVjdGVkUGVyc2lzdGVuY2UuX3NldChrZXksIHVzZXJUb01pZ3JhdGUudG9KU09OKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gY2xlYXIgdGhlIGtleSBpbiBvdGhlciBwZXJzaXN0ZW5jZXMgYnV0IGlnbm9yZSBlcnJvcnMuIFRoaXMgaGVscHMgcHJldmVudCBpc3N1ZXNcbiAgICAgICAgLy8gc3VjaCBhcyB1c2VycyBnZXR0aW5nIHN0dWNrIHdpdGggYSBwcmV2aW91cyBhY2NvdW50IGFmdGVyIHNpZ25pbmcgb3V0IGFuZCByZWZyZXNoaW5nIHRoZSB0YWIuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHBlcnNpc3RlbmNlSGllcmFyY2h5Lm1hcChhc3luYyAocGVyc2lzdGVuY2UpID0+IHtcbiAgICAgICAgICAgIGlmIChwZXJzaXN0ZW5jZSAhPT0gc2VsZWN0ZWRQZXJzaXN0ZW5jZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHBlcnNpc3RlbmNlLl9yZW1vdmUoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlVXNlck1hbmFnZXIoc2VsZWN0ZWRQZXJzaXN0ZW5jZSwgYXV0aCwgdXNlcktleSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGJyb3dzZXIgZm9yIHRoZSBwdXJwb3NlcyBvZiByZXBvcnRpbmcgdXNhZ2UgdG8gdGhlIEFQSVxuICovXG5mdW5jdGlvbiBfZ2V0QnJvd3Nlck5hbWUodXNlckFnZW50KSB7XG4gICAgY29uc3QgdWEgPSB1c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAodWEuaW5jbHVkZXMoJ29wZXJhLycpIHx8IHVhLmluY2x1ZGVzKCdvcHIvJykgfHwgdWEuaW5jbHVkZXMoJ29waW9zLycpKSB7XG4gICAgICAgIHJldHVybiBcIk9wZXJhXCIgLyogQnJvd3Nlck5hbWUuT1BFUkEgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKF9pc0lFTW9iaWxlKHVhKSkge1xuICAgICAgICAvLyBXaW5kb3dzIHBob25lIElFTW9iaWxlIGJyb3dzZXIuXG4gICAgICAgIHJldHVybiBcIklFTW9iaWxlXCIgLyogQnJvd3Nlck5hbWUuSUVNT0JJTEUgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKHVhLmluY2x1ZGVzKCdtc2llJykgfHwgdWEuaW5jbHVkZXMoJ3RyaWRlbnQvJykpIHtcbiAgICAgICAgcmV0dXJuIFwiSUVcIiAvKiBCcm93c2VyTmFtZS5JRSAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAodWEuaW5jbHVkZXMoJ2VkZ2UvJykpIHtcbiAgICAgICAgcmV0dXJuIFwiRWRnZVwiIC8qIEJyb3dzZXJOYW1lLkVER0UgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKF9pc0ZpcmVmb3godWEpKSB7XG4gICAgICAgIHJldHVybiBcIkZpcmVmb3hcIiAvKiBCcm93c2VyTmFtZS5GSVJFRk9YICovO1xuICAgIH1cbiAgICBlbHNlIGlmICh1YS5pbmNsdWRlcygnc2lsay8nKSkge1xuICAgICAgICByZXR1cm4gXCJTaWxrXCIgLyogQnJvd3Nlck5hbWUuU0lMSyAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoX2lzQmxhY2tCZXJyeSh1YSkpIHtcbiAgICAgICAgLy8gQmxhY2tiZXJyeSBicm93c2VyLlxuICAgICAgICByZXR1cm4gXCJCbGFja2JlcnJ5XCIgLyogQnJvd3Nlck5hbWUuQkxBQ0tCRVJSWSAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoX2lzV2ViT1ModWEpKSB7XG4gICAgICAgIC8vIFdlYk9TIGRlZmF1bHQgYnJvd3Nlci5cbiAgICAgICAgcmV0dXJuIFwiV2Vib3NcIiAvKiBCcm93c2VyTmFtZS5XRUJPUyAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoX2lzU2FmYXJpKHVhKSkge1xuICAgICAgICByZXR1cm4gXCJTYWZhcmlcIiAvKiBCcm93c2VyTmFtZS5TQUZBUkkgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKCh1YS5pbmNsdWRlcygnY2hyb21lLycpIHx8IF9pc0Nocm9tZUlPUyh1YSkpICYmXG4gICAgICAgICF1YS5pbmNsdWRlcygnZWRnZS8nKSkge1xuICAgICAgICByZXR1cm4gXCJDaHJvbWVcIiAvKiBCcm93c2VyTmFtZS5DSFJPTUUgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKF9pc0FuZHJvaWQodWEpKSB7XG4gICAgICAgIC8vIEFuZHJvaWQgc3RvY2sgYnJvd3Nlci5cbiAgICAgICAgcmV0dXJuIFwiQW5kcm9pZFwiIC8qIEJyb3dzZXJOYW1lLkFORFJPSUQgKi87XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBNb3N0IG1vZGVybiBicm93c2VycyBoYXZlIG5hbWUvdmVyc2lvbiBhdCBlbmQgb2YgdXNlciBhZ2VudCBzdHJpbmcuXG4gICAgICAgIGNvbnN0IHJlID0gLyhbYS16QS1aXFxkXFwuXSspXFwvW2EtekEtWlxcZFxcLl0qJC87XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB1c2VyQWdlbnQubWF0Y2gocmUpO1xuICAgICAgICBpZiAoKG1hdGNoZXMgPT09IG51bGwgfHwgbWF0Y2hlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF0Y2hlcy5sZW5ndGgpID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlc1sxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJPdGhlclwiIC8qIEJyb3dzZXJOYW1lLk9USEVSICovO1xufVxuZnVuY3Rpb24gX2lzRmlyZWZveCh1YSA9IGdldFVBKCkpIHtcbiAgICByZXR1cm4gL2ZpcmVmb3hcXC8vaS50ZXN0KHVhKTtcbn1cbmZ1bmN0aW9uIF9pc1NhZmFyaSh1c2VyQWdlbnQgPSBnZXRVQSgpKSB7XG4gICAgY29uc3QgdWEgPSB1c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gKHVhLmluY2x1ZGVzKCdzYWZhcmkvJykgJiZcbiAgICAgICAgIXVhLmluY2x1ZGVzKCdjaHJvbWUvJykgJiZcbiAgICAgICAgIXVhLmluY2x1ZGVzKCdjcmlvcy8nKSAmJlxuICAgICAgICAhdWEuaW5jbHVkZXMoJ2FuZHJvaWQnKSk7XG59XG5mdW5jdGlvbiBfaXNDaHJvbWVJT1ModWEgPSBnZXRVQSgpKSB7XG4gICAgcmV0dXJuIC9jcmlvc1xcLy9pLnRlc3QodWEpO1xufVxuZnVuY3Rpb24gX2lzSUVNb2JpbGUodWEgPSBnZXRVQSgpKSB7XG4gICAgcmV0dXJuIC9pZW1vYmlsZS9pLnRlc3QodWEpO1xufVxuZnVuY3Rpb24gX2lzQW5kcm9pZCh1YSA9IGdldFVBKCkpIHtcbiAgICByZXR1cm4gL2FuZHJvaWQvaS50ZXN0KHVhKTtcbn1cbmZ1bmN0aW9uIF9pc0JsYWNrQmVycnkodWEgPSBnZXRVQSgpKSB7XG4gICAgcmV0dXJuIC9ibGFja2JlcnJ5L2kudGVzdCh1YSk7XG59XG5mdW5jdGlvbiBfaXNXZWJPUyh1YSA9IGdldFVBKCkpIHtcbiAgICByZXR1cm4gL3dlYm9zL2kudGVzdCh1YSk7XG59XG5mdW5jdGlvbiBfaXNJT1ModWEgPSBnZXRVQSgpKSB7XG4gICAgcmV0dXJuICgvaXBob25lfGlwYWR8aXBvZC9pLnRlc3QodWEpIHx8XG4gICAgICAgICgvbWFjaW50b3NoL2kudGVzdCh1YSkgJiYgL21vYmlsZS9pLnRlc3QodWEpKSk7XG59XG5mdW5jdGlvbiBfaXNJT1M3T3I4KHVhID0gZ2V0VUEoKSkge1xuICAgIHJldHVybiAoLyhpUGFkfGlQaG9uZXxpUG9kKS4qT1MgN19cXGQvaS50ZXN0KHVhKSB8fFxuICAgICAgICAvKGlQYWR8aVBob25lfGlQb2QpLipPUyA4X1xcZC9pLnRlc3QodWEpKTtcbn1cbmZ1bmN0aW9uIF9pc0lFMTAoKSB7XG4gICAgcmV0dXJuIGlzSUUoKSAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPT09IDEwO1xufVxuZnVuY3Rpb24gX2lzTW9iaWxlQnJvd3Nlcih1YSA9IGdldFVBKCkpIHtcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgZ2V0QnJvd3Nlck5hbWUgZXF1aXZhbGVudCBmb3IgT1MuXG4gICAgcmV0dXJuIChfaXNJT1ModWEpIHx8XG4gICAgICAgIF9pc0FuZHJvaWQodWEpIHx8XG4gICAgICAgIF9pc1dlYk9TKHVhKSB8fFxuICAgICAgICBfaXNCbGFja0JlcnJ5KHVhKSB8fFxuICAgICAgICAvd2luZG93cyBwaG9uZS9pLnRlc3QodWEpIHx8XG4gICAgICAgIF9pc0lFTW9iaWxlKHVhKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKlxuICogRGV0ZXJtaW5lIHRoZSBTREsgdmVyc2lvbiBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gX2dldENsaWVudFZlcnNpb24oY2xpZW50UGxhdGZvcm0sIGZyYW1ld29ya3MgPSBbXSkge1xuICAgIGxldCByZXBvcnRlZFBsYXRmb3JtO1xuICAgIHN3aXRjaCAoY2xpZW50UGxhdGZvcm0pIHtcbiAgICAgICAgY2FzZSBcIkJyb3dzZXJcIiAvKiBDbGllbnRQbGF0Zm9ybS5CUk9XU0VSICovOlxuICAgICAgICAgICAgLy8gSW4gYSBicm93c2VyIGVudmlyb25tZW50LCByZXBvcnQgdGhlIGJyb3dzZXIgbmFtZS5cbiAgICAgICAgICAgIHJlcG9ydGVkUGxhdGZvcm0gPSBfZ2V0QnJvd3Nlck5hbWUoZ2V0VUEoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIldvcmtlclwiIC8qIENsaWVudFBsYXRmb3JtLldPUktFUiAqLzpcbiAgICAgICAgICAgIC8vIFRlY2huaWNhbGx5IGEgd29ya2VyIHJ1bnMgZnJvbSBhIGJyb3dzZXIgYnV0IHdlIG5lZWQgdG8gZGlmZmVyZW50aWF0ZSBhXG4gICAgICAgICAgICAvLyB3b3JrZXIgZnJvbSBhIGJyb3dzZXIuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogQ2hyb21lLVdvcmtlci9Kc0NvcmUvNC45LjEvRmlyZWJhc2VDb3JlLXdlYi5cbiAgICAgICAgICAgIHJlcG9ydGVkUGxhdGZvcm0gPSBgJHtfZ2V0QnJvd3Nlck5hbWUoZ2V0VUEoKSl9LSR7Y2xpZW50UGxhdGZvcm19YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVwb3J0ZWRQbGF0Zm9ybSA9IGNsaWVudFBsYXRmb3JtO1xuICAgIH1cbiAgICBjb25zdCByZXBvcnRlZEZyYW1ld29ya3MgPSBmcmFtZXdvcmtzLmxlbmd0aFxuICAgICAgICA/IGZyYW1ld29ya3Muam9pbignLCcpXG4gICAgICAgIDogJ0ZpcmViYXNlQ29yZS13ZWInOyAvKiBkZWZhdWx0IHZhbHVlIGlmIG5vIG90aGVyIGZyYW1ld29yayBpcyB1c2VkICovXG4gICAgcmV0dXJuIGAke3JlcG9ydGVkUGxhdGZvcm19LyR7XCJKc0NvcmVcIiAvKiBDbGllbnRJbXBsZW1lbnRhdGlvbi5DT1JFICovfS8ke1NES19WRVJTSU9OfS8ke3JlcG9ydGVkRnJhbWV3b3Jrc31gO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgQXV0aE1pZGRsZXdhcmVRdWV1ZSB7XG4gICAgY29uc3RydWN0b3IoYXV0aCkge1xuICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgfVxuICAgIHB1c2hDYWxsYmFjayhjYWxsYmFjaywgb25BYm9ydCkge1xuICAgICAgICAvLyBUaGUgY2FsbGJhY2sgY291bGQgYmUgc3luYyBvciBhc3luYy4gV3JhcCBpdCBpbnRvIGFcbiAgICAgICAgLy8gZnVuY3Rpb24gdGhhdCBpcyBhbHdheXMgYXN5bmMuXG4gICAgICAgIGNvbnN0IHdyYXBwZWRDYWxsYmFjayA9ICh1c2VyKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNhbGxiYWNrKHVzZXIpO1xuICAgICAgICAgICAgICAgIC8vIEVpdGhlciByZXNvbHZlIHdpdGggZXhpc3RpbmcgcHJvbWlzZSBvciB3cmFwIGEgbm9uLXByb21pc2VcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgaW50byBhIHByb21pc2UuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBTeW5jIGNhbGxiYWNrIHRocm93cy5cbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBdHRhY2ggdGhlIG9uQWJvcnQgaWYgcHJlc2VudFxuICAgICAgICB3cmFwcGVkQ2FsbGJhY2sub25BYm9ydCA9IG9uQWJvcnQ7XG4gICAgICAgIHRoaXMucXVldWUucHVzaCh3cmFwcGVkQ2FsbGJhY2spO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMucXVldWUubGVuZ3RoIC0gMTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIC8vIFVuc3Vic2NyaWJlLiBSZXBsYWNlIHdpdGggbm8tb3AuIERvIG5vdCByZW1vdmUgZnJvbSBhcnJheSwgb3IgaXQgd2lsbCBkaXN0dXJiXG4gICAgICAgICAgICAvLyBpbmRleGluZyBvZiBvdGhlciBlbGVtZW50cy5cbiAgICAgICAgICAgIHRoaXMucXVldWVbaW5kZXhdID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHJ1bk1pZGRsZXdhcmUobmV4dFVzZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0aC5jdXJyZW50VXNlciA9PT0gbmV4dFVzZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGlsZSBydW5uaW5nIHRoZSBtaWRkbGV3YXJlLCBidWlsZCBhIHRlbXBvcmFyeSBzdGFjayBvZiBvbkFib3J0XG4gICAgICAgIC8vIGNhbGxiYWNrcyB0byBjYWxsIGlmIG9uZSBtaWRkbGV3YXJlIGNhbGxiYWNrIHJlamVjdHMuXG4gICAgICAgIGNvbnN0IG9uQWJvcnRTdGFjayA9IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBiZWZvcmVTdGF0ZUNhbGxiYWNrIG9mIHRoaXMucXVldWUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBiZWZvcmVTdGF0ZUNhbGxiYWNrKG5leHRVc2VyKTtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHB1c2ggdGhlIG9uQWJvcnQgaWYgdGhlIGNhbGxiYWNrIHN1Y2NlZWRzXG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZVN0YXRlQ2FsbGJhY2sub25BYm9ydCkge1xuICAgICAgICAgICAgICAgICAgICBvbkFib3J0U3RhY2sucHVzaChiZWZvcmVTdGF0ZUNhbGxiYWNrLm9uQWJvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gUnVuIGFsbCBvbkFib3J0LCB3aXRoIHNlcGFyYXRlIHRyeS9jYXRjaCB0byBpZ25vcmUgYW55IGVycm9ycyBhbmRcbiAgICAgICAgICAgIC8vIGNvbnRpbnVlXG4gICAgICAgICAgICBvbkFib3J0U3RhY2sucmV2ZXJzZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvbkFib3J0IG9mIG9uQWJvcnRTdGFjaykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgLyogc3dhbGxvdyBlcnJvciAqL1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IHRoaXMuYXV0aC5fZXJyb3JGYWN0b3J5LmNyZWF0ZShcImxvZ2luLWJsb2NrZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkxPR0lOX0JMT0NLRUQgKi8sIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbE1lc3NhZ2U6IGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5tZXNzYWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogRmV0Y2hlcyB0aGUgcGFzc3dvcmQgcG9saWN5IGZvciB0aGUgY3VycmVudGx5IHNldCB0ZW5hbnQgb3IgdGhlIHByb2plY3QgaWYgbm8gdGVuYW50IGlzIHNldC5cbiAqXG4gKiBAcGFyYW0gYXV0aCBBdXRoIG9iamVjdC5cbiAqIEBwYXJhbSByZXF1ZXN0IFBhc3N3b3JkIHBvbGljeSByZXF1ZXN0LlxuICogQHJldHVybnMgUGFzc3dvcmQgcG9saWN5IHJlc3BvbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBfZ2V0UGFzc3dvcmRQb2xpY3koYXV0aCwgcmVxdWVzdCA9IHt9KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIkdFVFwiIC8qIEh0dHBNZXRob2QuR0VUICovLCBcIi92Mi9wYXNzd29yZFBvbGljeVwiIC8qIEVuZHBvaW50LkdFVF9QQVNTV09SRF9QT0xJQ1kgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBNaW5pbXVtIG1pbiBwYXNzd29yZCBsZW5ndGggZW5mb3JjZWQgYnkgdGhlIGJhY2tlbmQsIGV2ZW4gaWYgbm8gbWluaW11bSBsZW5ndGggaXMgc2V0LlxuY29uc3QgTUlOSU1VTV9NSU5fUEFTU1dPUkRfTEVOR1RIID0gNjtcbi8qKlxuICogU3RvcmVzIHBhc3N3b3JkIHBvbGljeSByZXF1aXJlbWVudHMgYW5kIHByb3ZpZGVzIHBhc3N3b3JkIHZhbGlkYXRpb24gYWdhaW5zdCB0aGUgcG9saWN5LlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBQYXNzd29yZFBvbGljeUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgLy8gT25seSBpbmNsdWRlIGN1c3RvbSBzdHJlbmd0aCBvcHRpb25zIGRlZmluZWQgaW4gdGhlIHJlc3BvbnNlLlxuICAgICAgICBjb25zdCByZXNwb25zZU9wdGlvbnMgPSByZXNwb25zZS5jdXN0b21TdHJlbmd0aE9wdGlvbnM7XG4gICAgICAgIHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zID0ge307XG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBvbmNlIHRoZSBiYWNrZW5kIGlzIHVwZGF0ZWQgdG8gaW5jbHVkZSB0aGUgbWluaW11bSBtaW4gcGFzc3dvcmQgbGVuZ3RoIGluc3RlYWQgb2YgdW5kZWZpbmVkIHdoZW4gdGhlcmUgaXMgbm8gbWluaW11bSBsZW5ndGggc2V0LlxuICAgICAgICB0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5taW5QYXNzd29yZExlbmd0aCA9XG4gICAgICAgICAgICAoX2EgPSByZXNwb25zZU9wdGlvbnMubWluUGFzc3dvcmRMZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IE1JTklNVU1fTUlOX1BBU1NXT1JEX0xFTkdUSDtcbiAgICAgICAgaWYgKHJlc3BvbnNlT3B0aW9ucy5tYXhQYXNzd29yZExlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jdXN0b21TdHJlbmd0aE9wdGlvbnMubWF4UGFzc3dvcmRMZW5ndGggPVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlT3B0aW9ucy5tYXhQYXNzd29yZExlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2VPcHRpb25zLmNvbnRhaW5zTG93ZXJjYXNlQ2hhcmFjdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLmNvbnRhaW5zTG93ZXJjYXNlTGV0dGVyID1cbiAgICAgICAgICAgICAgICByZXNwb25zZU9wdGlvbnMuY29udGFpbnNMb3dlcmNhc2VDaGFyYWN0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbnNlT3B0aW9ucy5jb250YWluc1VwcGVyY2FzZUNoYXJhY3RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5jb250YWluc1VwcGVyY2FzZUxldHRlciA9XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VPcHRpb25zLmNvbnRhaW5zVXBwZXJjYXNlQ2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZU9wdGlvbnMuY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLmNvbnRhaW5zTnVtZXJpY0NoYXJhY3RlciA9XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VPcHRpb25zLmNvbnRhaW5zTnVtZXJpY0NoYXJhY3RlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2VPcHRpb25zLmNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLmNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyID1cbiAgICAgICAgICAgICAgICByZXNwb25zZU9wdGlvbnMuY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbmZvcmNlbWVudFN0YXRlID0gcmVzcG9uc2UuZW5mb3JjZW1lbnRTdGF0ZTtcbiAgICAgICAgaWYgKHRoaXMuZW5mb3JjZW1lbnRTdGF0ZSA9PT0gJ0VORk9SQ0VNRU5UX1NUQVRFX1VOU1BFQ0lGSUVEJykge1xuICAgICAgICAgICAgdGhpcy5lbmZvcmNlbWVudFN0YXRlID0gJ09GRic7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIGFuIGVtcHR5IHN0cmluZyBpZiBubyBub24tYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgYXJlIHNwZWNpZmllZCBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICAgIHRoaXMuYWxsb3dlZE5vbkFscGhhbnVtZXJpY0NoYXJhY3RlcnMgPVxuICAgICAgICAgICAgKF9jID0gKF9iID0gcmVzcG9uc2UuYWxsb3dlZE5vbkFscGhhbnVtZXJpY0NoYXJhY3RlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5qb2luKCcnKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJyc7XG4gICAgICAgIHRoaXMuZm9yY2VVcGdyYWRlT25TaWduaW4gPSAoX2QgPSByZXNwb25zZS5mb3JjZVVwZ3JhZGVPblNpZ25pbikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZmFsc2U7XG4gICAgICAgIHRoaXMuc2NoZW1hVmVyc2lvbiA9IHJlc3BvbnNlLnNjaGVtYVZlcnNpb247XG4gICAgfVxuICAgIHZhbGlkYXRlUGFzc3dvcmQocGFzc3dvcmQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHtcbiAgICAgICAgICAgIGlzVmFsaWQ6IHRydWUsXG4gICAgICAgICAgICBwYXNzd29yZFBvbGljeTogdGhpc1xuICAgICAgICB9O1xuICAgICAgICAvLyBDaGVjayB0aGUgcGFzc3dvcmQgbGVuZ3RoIGFuZCBjaGFyYWN0ZXIgb3B0aW9ucy5cbiAgICAgICAgdGhpcy52YWxpZGF0ZVBhc3N3b3JkTGVuZ3RoT3B0aW9ucyhwYXNzd29yZCwgc3RhdHVzKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZVBhc3N3b3JkQ2hhcmFjdGVyT3B0aW9ucyhwYXNzd29yZCwgc3RhdHVzKTtcbiAgICAgICAgLy8gQ29tYmluZSB0aGUgc3RhdHVzIGludG8gc2luZ2xlIGlzVmFsaWQgcHJvcGVydHkuXG4gICAgICAgIHN0YXR1cy5pc1ZhbGlkICYmIChzdGF0dXMuaXNWYWxpZCA9IChfYSA9IHN0YXR1cy5tZWV0c01pblBhc3N3b3JkTGVuZ3RoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlKTtcbiAgICAgICAgc3RhdHVzLmlzVmFsaWQgJiYgKHN0YXR1cy5pc1ZhbGlkID0gKF9iID0gc3RhdHVzLm1lZXRzTWF4UGFzc3dvcmRMZW5ndGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUpO1xuICAgICAgICBzdGF0dXMuaXNWYWxpZCAmJiAoc3RhdHVzLmlzVmFsaWQgPSAoX2MgPSBzdGF0dXMuY29udGFpbnNMb3dlcmNhc2VMZXR0ZXIpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHRydWUpO1xuICAgICAgICBzdGF0dXMuaXNWYWxpZCAmJiAoc3RhdHVzLmlzVmFsaWQgPSAoX2QgPSBzdGF0dXMuY29udGFpbnNVcHBlcmNhc2VMZXR0ZXIpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHRydWUpO1xuICAgICAgICBzdGF0dXMuaXNWYWxpZCAmJiAoc3RhdHVzLmlzVmFsaWQgPSAoX2UgPSBzdGF0dXMuY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB0cnVlKTtcbiAgICAgICAgc3RhdHVzLmlzVmFsaWQgJiYgKHN0YXR1cy5pc1ZhbGlkID0gKF9mID0gc3RhdHVzLmNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoYXQgdGhlIHBhc3N3b3JkIG1lZXRzIHRoZSBsZW5ndGggb3B0aW9ucyBmb3IgdGhlIHBvbGljeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXNzd29yZCBQYXNzd29yZCB0byB2YWxpZGF0ZS5cbiAgICAgKiBAcGFyYW0gc3RhdHVzIFZhbGlkYXRpb24gc3RhdHVzLlxuICAgICAqL1xuICAgIHZhbGlkYXRlUGFzc3dvcmRMZW5ndGhPcHRpb25zKHBhc3N3b3JkLCBzdGF0dXMpIHtcbiAgICAgICAgY29uc3QgbWluUGFzc3dvcmRMZW5ndGggPSB0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5taW5QYXNzd29yZExlbmd0aDtcbiAgICAgICAgY29uc3QgbWF4UGFzc3dvcmRMZW5ndGggPSB0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5tYXhQYXNzd29yZExlbmd0aDtcbiAgICAgICAgaWYgKG1pblBhc3N3b3JkTGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGF0dXMubWVldHNNaW5QYXNzd29yZExlbmd0aCA9IHBhc3N3b3JkLmxlbmd0aCA+PSBtaW5QYXNzd29yZExlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4UGFzc3dvcmRMZW5ndGgpIHtcbiAgICAgICAgICAgIHN0YXR1cy5tZWV0c01heFBhc3N3b3JkTGVuZ3RoID0gcGFzc3dvcmQubGVuZ3RoIDw9IG1heFBhc3N3b3JkTGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGF0IHRoZSBwYXNzd29yZCBtZWV0cyB0aGUgY2hhcmFjdGVyIG9wdGlvbnMgZm9yIHRoZSBwb2xpY3kuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFzc3dvcmQgUGFzc3dvcmQgdG8gdmFsaWRhdGUuXG4gICAgICogQHBhcmFtIHN0YXR1cyBWYWxpZGF0aW9uIHN0YXR1cy5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZVBhc3N3b3JkQ2hhcmFjdGVyT3B0aW9ucyhwYXNzd29yZCwgc3RhdHVzKSB7XG4gICAgICAgIC8vIEFzc2lnbiBzdGF0dXNlcyBmb3IgcmVxdWlyZW1lbnRzIGV2ZW4gaWYgdGhlIHBhc3N3b3JkIGlzIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgICAgdGhpcy51cGRhdGVQYXNzd29yZENoYXJhY3Rlck9wdGlvbnNTdGF0dXNlcyhzdGF0dXMsIFxuICAgICAgICAvKiBjb250YWluc0xvd2VyY2FzZUNoYXJhY3Rlcj0gKi8gZmFsc2UsIFxuICAgICAgICAvKiBjb250YWluc1VwcGVyY2FzZUNoYXJhY3Rlcj0gKi8gZmFsc2UsIFxuICAgICAgICAvKiBjb250YWluc051bWVyaWNDaGFyYWN0ZXI9ICovIGZhbHNlLCBcbiAgICAgICAgLyogY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXI9ICovIGZhbHNlKTtcbiAgICAgICAgbGV0IHBhc3N3b3JkQ2hhcjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXNzd29yZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFzc3dvcmRDaGFyID0gcGFzc3dvcmQuY2hhckF0KGkpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQYXNzd29yZENoYXJhY3Rlck9wdGlvbnNTdGF0dXNlcyhzdGF0dXMsIFxuICAgICAgICAgICAgLyogY29udGFpbnNMb3dlcmNhc2VDaGFyYWN0ZXI9ICovIHBhc3N3b3JkQ2hhciA+PSAnYScgJiZcbiAgICAgICAgICAgICAgICBwYXNzd29yZENoYXIgPD0gJ3onLCBcbiAgICAgICAgICAgIC8qIGNvbnRhaW5zVXBwZXJjYXNlQ2hhcmFjdGVyPSAqLyBwYXNzd29yZENoYXIgPj0gJ0EnICYmXG4gICAgICAgICAgICAgICAgcGFzc3dvcmRDaGFyIDw9ICdaJywgXG4gICAgICAgICAgICAvKiBjb250YWluc051bWVyaWNDaGFyYWN0ZXI9ICovIHBhc3N3b3JkQ2hhciA+PSAnMCcgJiZcbiAgICAgICAgICAgICAgICBwYXNzd29yZENoYXIgPD0gJzknLCBcbiAgICAgICAgICAgIC8qIGNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyPSAqLyB0aGlzLmFsbG93ZWROb25BbHBoYW51bWVyaWNDaGFyYWN0ZXJzLmluY2x1ZGVzKHBhc3N3b3JkQ2hhcikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHJ1bm5pbmcgdmFsaWRhdGlvbiBzdGF0dXMgd2l0aCB0aGUgc3RhdHVzZXMgZm9yIHRoZSBjaGFyYWN0ZXIgb3B0aW9ucy5cbiAgICAgKiBFeHBlY3RlZCB0byBiZSBjYWxsZWQgZWFjaCB0aW1lIGEgY2hhcmFjdGVyIGlzIHByb2Nlc3NlZCB0byB1cGRhdGUgZWFjaCBvcHRpb24gc3RhdHVzXG4gICAgICogYmFzZWQgb24gdGhlIGN1cnJlbnQgY2hhcmFjdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXR1cyBWYWxpZGF0aW9uIHN0YXR1cy5cbiAgICAgKiBAcGFyYW0gY29udGFpbnNMb3dlcmNhc2VDaGFyYWN0ZXIgV2hldGhlciB0aGUgY2hhcmFjdGVyIGlzIGEgbG93ZXJjYXNlIGxldHRlci5cbiAgICAgKiBAcGFyYW0gY29udGFpbnNVcHBlcmNhc2VDaGFyYWN0ZXIgV2hldGhlciB0aGUgY2hhcmFjdGVyIGlzIGFuIHVwcGVyY2FzZSBsZXR0ZXIuXG4gICAgICogQHBhcmFtIGNvbnRhaW5zTnVtZXJpY0NoYXJhY3RlciBXaGV0aGVyIHRoZSBjaGFyYWN0ZXIgaXMgYSBudW1lcmljIGNoYXJhY3Rlci5cbiAgICAgKiBAcGFyYW0gY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXIgV2hldGhlciB0aGUgY2hhcmFjdGVyIGlzIGEgbm9uLWFscGhhbnVtZXJpYyBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgdXBkYXRlUGFzc3dvcmRDaGFyYWN0ZXJPcHRpb25zU3RhdHVzZXMoc3RhdHVzLCBjb250YWluc0xvd2VyY2FzZUNoYXJhY3RlciwgY29udGFpbnNVcHBlcmNhc2VDaGFyYWN0ZXIsIGNvbnRhaW5zTnVtZXJpY0NoYXJhY3RlciwgY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLmNvbnRhaW5zTG93ZXJjYXNlTGV0dGVyKSB7XG4gICAgICAgICAgICBzdGF0dXMuY29udGFpbnNMb3dlcmNhc2VMZXR0ZXIgfHwgKHN0YXR1cy5jb250YWluc0xvd2VyY2FzZUxldHRlciA9IGNvbnRhaW5zTG93ZXJjYXNlQ2hhcmFjdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXN0b21TdHJlbmd0aE9wdGlvbnMuY29udGFpbnNVcHBlcmNhc2VMZXR0ZXIpIHtcbiAgICAgICAgICAgIHN0YXR1cy5jb250YWluc1VwcGVyY2FzZUxldHRlciB8fCAoc3RhdHVzLmNvbnRhaW5zVXBwZXJjYXNlTGV0dGVyID0gY29udGFpbnNVcHBlcmNhc2VDaGFyYWN0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5jb250YWluc051bWVyaWNDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIHN0YXR1cy5jb250YWluc051bWVyaWNDaGFyYWN0ZXIgfHwgKHN0YXR1cy5jb250YWluc051bWVyaWNDaGFyYWN0ZXIgPSBjb250YWluc051bWVyaWNDaGFyYWN0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5jb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3Rlcikge1xuICAgICAgICAgICAgc3RhdHVzLmNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyIHx8IChzdGF0dXMuY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXIgPSBjb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3Rlcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBBdXRoSW1wbCB7XG4gICAgY29uc3RydWN0b3IoYXBwLCBoZWFydGJlYXRTZXJ2aWNlUHJvdmlkZXIsIGFwcENoZWNrU2VydmljZVByb3ZpZGVyLCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgICAgIHRoaXMuaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyID0gaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyO1xuICAgICAgICB0aGlzLmFwcENoZWNrU2VydmljZVByb3ZpZGVyID0gYXBwQ2hlY2tTZXJ2aWNlUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmN1cnJlbnRVc2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbXVsYXRvckNvbmZpZyA9IG51bGw7XG4gICAgICAgIHRoaXMub3BlcmF0aW9ucyA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLmF1dGhTdGF0ZVN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24odGhpcyk7XG4gICAgICAgIHRoaXMuaWRUb2tlblN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24odGhpcyk7XG4gICAgICAgIHRoaXMuYmVmb3JlU3RhdGVRdWV1ZSA9IG5ldyBBdXRoTWlkZGxld2FyZVF1ZXVlKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZGlyZWN0VXNlciA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNQcm9hY3RpdmVSZWZyZXNoRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLkVYUEVDVEVEX1BBU1NXT1JEX1BPTElDWV9TQ0hFTUFfVkVSU0lPTiA9IDE7XG4gICAgICAgIC8vIEFueSBuZXR3b3JrIGNhbGxzIHdpbGwgc2V0IHRoaXMgdG8gdHJ1ZSBhbmQgcHJldmVudCBzdWJzZXF1ZW50IGVtdWxhdG9yXG4gICAgICAgIC8vIGluaXRpYWxpemF0aW9uXG4gICAgICAgIHRoaXMuX2NhbkluaXRFbXVsYXRvciA9IHRydWU7XG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGVsZXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXphdGlvblByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9wb3B1cFJlZGlyZWN0UmVzb2x2ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9lcnJvckZhY3RvcnkgPSBfREVGQVVMVF9BVVRIX0VSUk9SX0ZBQ1RPUlk7XG4gICAgICAgIHRoaXMuX2FnZW50UmVjYXB0Y2hhQ29uZmlnID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGVuYW50UmVjYXB0Y2hhQ29uZmlncyA9IHt9O1xuICAgICAgICB0aGlzLl9wcm9qZWN0UGFzc3dvcmRQb2xpY3kgPSBudWxsO1xuICAgICAgICB0aGlzLl90ZW5hbnRQYXNzd29yZFBvbGljaWVzID0ge307XG4gICAgICAgIC8vIFRyYWNrcyB0aGUgbGFzdCBub3RpZmllZCBVSUQgZm9yIHN0YXRlIGNoYW5nZSBsaXN0ZW5lcnMgdG8gcHJldmVudFxuICAgICAgICAvLyByZXBlYXRlZCBjYWxscyB0byB0aGUgY2FsbGJhY2tzLiBVbmRlZmluZWQgbWVhbnMgaXQncyBuZXZlciBiZWVuXG4gICAgICAgIC8vIGNhbGxlZCwgd2hlcmVhcyBudWxsIG1lYW5zIGl0J3MgYmVlbiBjYWxsZWQgd2l0aCBhIHNpZ25lZCBvdXQgdXNlclxuICAgICAgICB0aGlzLmxhc3ROb3RpZmllZFVpZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sYW5ndWFnZUNvZGUgPSBudWxsO1xuICAgICAgICB0aGlzLnRlbmFudElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHsgYXBwVmVyaWZpY2F0aW9uRGlzYWJsZWRGb3JUZXN0aW5nOiBmYWxzZSB9O1xuICAgICAgICB0aGlzLmZyYW1ld29ya3MgPSBbXTtcbiAgICAgICAgdGhpcy5uYW1lID0gYXBwLm5hbWU7XG4gICAgICAgIHRoaXMuY2xpZW50VmVyc2lvbiA9IGNvbmZpZy5zZGtDbGllbnRWZXJzaW9uO1xuICAgIH1cbiAgICBfaW5pdGlhbGl6ZVdpdGhQZXJzaXN0ZW5jZShwZXJzaXN0ZW5jZUhpZXJhcmNoeSwgcG9wdXBSZWRpcmVjdFJlc29sdmVyKSB7XG4gICAgICAgIGlmIChwb3B1cFJlZGlyZWN0UmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlciA9IF9nZXRJbnN0YW5jZShwb3B1cFJlZGlyZWN0UmVzb2x2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhdmUgdG8gY2hlY2sgZm9yIGFwcCBkZWxldGlvbiB0aHJvdWdob3V0IGluaXRpYWxpemF0aW9uIChhZnRlciBlYWNoXG4gICAgICAgIC8vIHByb21pc2UgcmVzb2x1dGlvbilcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6YXRpb25Qcm9taXNlID0gdGhpcy5xdWV1ZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBlcnNpc3RlbmNlTWFuYWdlciA9IGF3YWl0IFBlcnNpc3RlbmNlVXNlck1hbmFnZXIuY3JlYXRlKHRoaXMsIHBlcnNpc3RlbmNlSGllcmFyY2h5KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgcmVzb2x2ZXIgZWFybHkgaWYgbmVjZXNzYXJ5IChvbmx5IGFwcGxpY2FibGUgdG8gd2ViOlxuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGNhdXNlIHRoZSBpZnJhbWUgdG8gbG9hZCBpbW1lZGlhdGVseSBpbiBjZXJ0YWluIGNhc2VzKVxuICAgICAgICAgICAgaWYgKChfYSA9IHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9zaG91bGRJbml0UHJvYWN0aXZlbHkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGZhaWxzLCBkb24ndCBoYWx0IGF1dGggbG9hZGluZ1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlci5faW5pdGlhbGl6ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogSWdub3JlIHRoZSBlcnJvciAqL1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZUN1cnJlbnRVc2VyKHBvcHVwUmVkaXJlY3RSZXNvbHZlcik7XG4gICAgICAgICAgICB0aGlzLmxhc3ROb3RpZmllZFVpZCA9ICgoX2IgPSB0aGlzLmN1cnJlbnRVc2VyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudWlkKSB8fCBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbml0aWFsaXphdGlvblByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSBwZXJzaXN0ZW5jZSBpcyBjaGFuZ2VkIGluIGFub3RoZXIgd2luZG93LCB0aGUgdXNlciBtYW5hZ2VyIHdpbGwgbGV0IHVzIGtub3dcbiAgICAgKi9cbiAgICBhc3luYyBfb25TdG9yYWdlRXZlbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWxldGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMuYXNzZXJ0ZWRQZXJzaXN0ZW5jZS5nZXRDdXJyZW50VXNlcigpO1xuICAgICAgICBpZiAoIXRoaXMuY3VycmVudFVzZXIgJiYgIXVzZXIpIHtcbiAgICAgICAgICAgIC8vIE5vIGNoYW5nZSwgZG8gbm90aGluZyAod2FzIHNpZ25lZCBvdXQgYW5kIHJlbWFpbmVkIHNpZ25lZCBvdXQpLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBzYW1lIHVzZXIgaXMgdG8gYmUgc3luY2hyb25pemVkLlxuICAgICAgICBpZiAodGhpcy5jdXJyZW50VXNlciAmJiB1c2VyICYmIHRoaXMuY3VycmVudFVzZXIudWlkID09PSB1c2VyLnVpZCkge1xuICAgICAgICAgICAgLy8gRGF0YSB1cGRhdGUsIHNpbXBseSBjb3B5IGRhdGEgY2hhbmdlcy5cbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRVc2VyLl9hc3NpZ24odXNlcik7XG4gICAgICAgICAgICAvLyBJZiB0b2tlbnMgY2hhbmdlZCBmcm9tIHByZXZpb3VzIHVzZXIgdG9rZW5zLCB0aGlzIHdpbGwgdHJpZ2dlclxuICAgICAgICAgICAgLy8gbm90aWZ5QXV0aExpc3RlbmVyc18uXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmN1cnJlbnRVc2VyLmdldElkVG9rZW4oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgY3VycmVudCBBdXRoIHN0YXRlLiBFaXRoZXIgYSBuZXcgbG9naW4gb3IgbG9nb3V0LlxuICAgICAgICAvLyBTa2lwIGJsb2NraW5nIGNhbGxiYWNrcywgdGhleSBzaG91bGQgbm90IGFwcGx5IHRvIGEgY2hhbmdlIGluIGFub3RoZXIgdGFiLlxuICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVDdXJyZW50VXNlcih1c2VyLCAvKiBza2lwQmVmb3JlU3RhdGVDYWxsYmFja3MgKi8gdHJ1ZSk7XG4gICAgfVxuICAgIGFzeW5jIGluaXRpYWxpemVDdXJyZW50VXNlckZyb21JZFRva2VuKGlkVG9rZW4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZ2V0QWNjb3VudEluZm8odGhpcywgeyBpZFRva2VuIH0pO1xuICAgICAgICAgICAgY29uc3QgdXNlciA9IGF3YWl0IFVzZXJJbXBsLl9mcm9tR2V0QWNjb3VudEluZm9SZXNwb25zZSh0aGlzLCByZXNwb25zZSwgaWRUb2tlbik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIodXNlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGaXJlYmFzZVNlcnZlckFwcCBjb3VsZCBub3QgbG9naW4gdXNlciB3aXRoIHByb3ZpZGVkIGF1dGhJZFRva2VuOiAnLCBlcnIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGluaXRpYWxpemVDdXJyZW50VXNlcihwb3B1cFJlZGlyZWN0UmVzb2x2ZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoX2lzRmlyZWJhc2VTZXJ2ZXJBcHAodGhpcy5hcHApKSB7XG4gICAgICAgICAgICBjb25zdCBpZFRva2VuID0gdGhpcy5hcHAuc2V0dGluZ3MuYXV0aElkVG9rZW47XG4gICAgICAgICAgICBpZiAoaWRUb2tlbikge1xuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBhdXRoIG9wZXJhdGlvbiBpbiB0aGUgbmV4dCB0aWNrIHRvIGFsbG93IGEgbW9tZW50IGZvciB0aGUgY3VzdG9tZXIncyBhcHAgdG9cbiAgICAgICAgICAgICAgICAvLyBhdHRhY2ggYW4gZW11bGF0b3IsIGlmIGRlc2lyZWQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaW5pdGlhbGl6ZUN1cnJlbnRVc2VyRnJvbUlkVG9rZW4oaWRUb2tlbikudGhlbihyZXNvbHZlLCByZXNvbHZlKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEZpcnN0IGNoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcGVuZGluZyByZWRpcmVjdCBldmVudC5cbiAgICAgICAgY29uc3QgcHJldmlvdXNseVN0b3JlZFVzZXIgPSAoYXdhaXQgdGhpcy5hc3NlcnRlZFBlcnNpc3RlbmNlLmdldEN1cnJlbnRVc2VyKCkpO1xuICAgICAgICBsZXQgZnV0dXJlQ3VycmVudFVzZXIgPSBwcmV2aW91c2x5U3RvcmVkVXNlcjtcbiAgICAgICAgbGV0IG5lZWRzVG9jaGVja01pZGRsZXdhcmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHBvcHVwUmVkaXJlY3RSZXNvbHZlciAmJiB0aGlzLmNvbmZpZy5hdXRoRG9tYWluKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmdldE9ySW5pdFJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyKCk7XG4gICAgICAgICAgICBjb25zdCByZWRpcmVjdFVzZXJFdmVudElkID0gKF9hID0gdGhpcy5yZWRpcmVjdFVzZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fcmVkaXJlY3RFdmVudElkO1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkVXNlckV2ZW50SWQgPSBmdXR1cmVDdXJyZW50VXNlciA9PT0gbnVsbCB8fCBmdXR1cmVDdXJyZW50VXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZnV0dXJlQ3VycmVudFVzZXIuX3JlZGlyZWN0RXZlbnRJZDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMudHJ5UmVkaXJlY3RTaWduSW4ocG9wdXBSZWRpcmVjdFJlc29sdmVyKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBzdG9yZWQgdXNlciAoaS5lLiB0aGUgb2xkIFwiY3VycmVudFVzZXJcIikgaGFzIGEgcmVkaXJlY3RJZCB0aGF0XG4gICAgICAgICAgICAvLyBtYXRjaGVzIHRoZSByZWRpcmVjdCB1c2VyLCB0aGVuIHdlIHdhbnQgdG8gaW5pdGlhbGx5IHNpZ24gaW4gd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIG5ldyB1c2VyIG9iamVjdCBmcm9tIHJlc3VsdC5cbiAgICAgICAgICAgIC8vIFRPRE8oc2FtZ2hvKTogTW9yZSB0aG9yb3VnaGx5IHRlc3QgYWxsIG9mIHRoaXNcbiAgICAgICAgICAgIGlmICgoIXJlZGlyZWN0VXNlckV2ZW50SWQgfHwgcmVkaXJlY3RVc2VyRXZlbnRJZCA9PT0gc3RvcmVkVXNlckV2ZW50SWQpICYmXG4gICAgICAgICAgICAgICAgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3VsdC51c2VyKSkge1xuICAgICAgICAgICAgICAgIGZ1dHVyZUN1cnJlbnRVc2VyID0gcmVzdWx0LnVzZXI7XG4gICAgICAgICAgICAgICAgbmVlZHNUb2NoZWNrTWlkZGxld2FyZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gdXNlciBpbiBwZXJzaXN0ZW5jZSwgdGhlcmUgaXMgbm8gY3VycmVudCB1c2VyLiBTZXQgdG8gbnVsbC5cbiAgICAgICAgaWYgKCFmdXR1cmVDdXJyZW50VXNlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0bHlTZXRDdXJyZW50VXNlcihudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZ1dHVyZUN1cnJlbnRVc2VyLl9yZWRpcmVjdEV2ZW50SWQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXNuJ3QgYSByZWRpcmVjdCBsaW5rIG9wZXJhdGlvbiwgd2UgY2FuIHJlbG9hZCBhbmQgYmFpbC5cbiAgICAgICAgICAgIC8vIEZpcnN0IHRob3VnaCwgZW5zdXJlIHRoYXQgd2UgY2hlY2sgdGhlIG1pZGRsZXdhcmUgaXMgaGFwcHkuXG4gICAgICAgICAgICBpZiAobmVlZHNUb2NoZWNrTWlkZGxld2FyZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYmVmb3JlU3RhdGVRdWV1ZS5ydW5NaWRkbGV3YXJlKGZ1dHVyZUN1cnJlbnRVc2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZnV0dXJlQ3VycmVudFVzZXIgPSBwcmV2aW91c2x5U3RvcmVkVXNlcjtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Uga25vdyB0aGlzIGlzIGF2YWlsYWJsZSBzaW5jZSB0aGUgYml0IGlzIG9ubHkgc2V0IHdoZW4gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc29sdmVyIGlzIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb3B1cFJlZGlyZWN0UmVzb2x2ZXIuX292ZXJyaWRlUmVkaXJlY3RSZXN1bHQodGhpcywgKCkgPT4gUHJvbWlzZS5yZWplY3QoZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmdXR1cmVDdXJyZW50VXNlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbG9hZEFuZFNldEN1cnJlbnRVc2VyT3JDbGVhcihmdXR1cmVDdXJyZW50VXNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9hc3NlcnQodGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyLCB0aGlzLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XG4gICAgICAgIGF3YWl0IHRoaXMuZ2V0T3JJbml0UmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXIoKTtcbiAgICAgICAgLy8gSWYgdGhlIHJlZGlyZWN0IHVzZXIncyBldmVudCBJRCBtYXRjaGVzIHRoZSBjdXJyZW50IHVzZXIncyBldmVudCBJRCxcbiAgICAgICAgLy8gRE8gTk9UIHJlbG9hZCB0aGUgY3VycmVudCB1c2VyLCBvdGhlcndpc2UgdGhleSdsbCBiZSBjbGVhcmVkIGZyb20gc3RvcmFnZS5cbiAgICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIHRoZSByZWF1dGhlbnRpY2F0ZVdpdGhSZWRpcmVjdCgpIGZsb3cuXG4gICAgICAgIGlmICh0aGlzLnJlZGlyZWN0VXNlciAmJlxuICAgICAgICAgICAgdGhpcy5yZWRpcmVjdFVzZXIuX3JlZGlyZWN0RXZlbnRJZCA9PT0gZnV0dXJlQ3VycmVudFVzZXIuX3JlZGlyZWN0RXZlbnRJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0bHlTZXRDdXJyZW50VXNlcihmdXR1cmVDdXJyZW50VXNlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVsb2FkQW5kU2V0Q3VycmVudFVzZXJPckNsZWFyKGZ1dHVyZUN1cnJlbnRVc2VyKTtcbiAgICB9XG4gICAgYXN5bmMgdHJ5UmVkaXJlY3RTaWduSW4ocmVkaXJlY3RSZXNvbHZlcikge1xuICAgICAgICAvLyBUaGUgcmVkaXJlY3QgdXNlciBuZWVkcyB0byBiZSBjaGVja2VkIChhbmQgc2lnbmVkIGluIGlmIGF2YWlsYWJsZSlcbiAgICAgICAgLy8gZHVyaW5nIGF1dGggaW5pdGlhbGl6YXRpb24uIEFsbCBvZiB0aGUgbm9ybWFsIHNpZ24gaW4gYW5kIGxpbmsvcmVhdXRoXG4gICAgICAgIC8vIGZsb3dzIGNhbGwgYmFjayBpbnRvIGF1dGggYW5kIHB1c2ggdGhpbmdzIG9udG8gdGhlIHByb21pc2UgcXVldWUuIFdlXG4gICAgICAgIC8vIG5lZWQgdG8gYXdhaXQgdGhlIHJlc3VsdCBvZiB0aGUgcmVkaXJlY3Qgc2lnbiBpbiAqaW5zaWRlIHRoZSBwcm9taXNlXG4gICAgICAgIC8vIHF1ZXVlKi4gVGhpcyBwcmVzZW50cyBhIHByb2JsZW06IHdlIHJ1biBpbnRvIGRlYWRsb2NrLiBTZWU6XG4gICAgICAgIC8vICAgIOKUjD4gW0luaXRpYWxpemF0aW9uXSDilIDilIDilIDilIDilIDilJBcbiAgICAgICAgLy8gICAg4pSMPiBbPG90aGVyIHF1ZXVlIHRhc2tzPl0g4pSCXG4gICAgICAgIC8vICAgIOKUlOKUgCBbZ2V0UmVkaXJlY3RSZXN1bHRdIDzilIDilJhcbiAgICAgICAgLy8gICAgd2hlcmUgW10gYXJlIHRhc2tzIG9uIHRoZSBxdWV1ZSBhbmQgYXJyb3dzIGRlbm90ZSBhd2FpdHNcbiAgICAgICAgLy8gSW5pdGlhbGl6YXRpb24gd2lsbCBuZXZlciBjb21wbGV0ZSBiZWNhdXNlIGl0J3Mgd2FpdGluZyBvbiBzb21ldGhpbmdcbiAgICAgICAgLy8gdGhhdCdzIHdhaXRpbmcgZm9yIGluaXRpYWxpemF0aW9uIHRvIGNvbXBsZXRlIVxuICAgICAgICAvL1xuICAgICAgICAvLyBJbnN0ZWFkLCB0aGlzIG1ldGhvZCBjYWxscyBnZXRSZWRpcmVjdFJlc3VsdCgpIChzdG9yZWQgaW5cbiAgICAgICAgLy8gX2NvbXBsZXRlUmVkaXJlY3RGbikgd2l0aCBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBpbnN0cnVjdHMgYWxsIG9mXG4gICAgICAgIC8vIHRoZSB1bmRlcmx5aW5nIGF1dGggb3BlcmF0aW9ucyB0byBza2lwIGFueXRoaW5nIHRoYXQgbXV0YXRlcyBhdXRoIHN0YXRlLlxuICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdlIGtub3cgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyIGlzIHNldCBzaW5jZSByZWRpcmVjdFJlc29sdmVyXG4gICAgICAgICAgICAvLyBpcyBwYXNzZWQgaW4uIFRoZSBfY29tcGxldGVSZWRpcmVjdEZuIGV4cGVjdHMgdGhlIHVud3JhcHBlZCBleHRlcm4uXG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLl9wb3B1cFJlZGlyZWN0UmVzb2x2ZXIuX2NvbXBsZXRlUmVkaXJlY3RGbih0aGlzLCByZWRpcmVjdFJlc29sdmVyLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gU3dhbGxvdyBhbnkgZXJyb3JzIGhlcmU7IHRoZSBjb2RlIGNhbiByZXRyaWV2ZSB0aGVtIGluXG4gICAgICAgICAgICAvLyBnZXRSZWRpcmVjdFJlc3VsdCgpLlxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0UmVkaXJlY3RVc2VyKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHJlbG9hZEFuZFNldEN1cnJlbnRVc2VyT3JDbGVhcih1c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBfcmVsb2FkV2l0aG91dFNhdmluZyh1c2VyKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUuY29kZSkgIT09XG4gICAgICAgICAgICAgICAgYGF1dGgvJHtcIm5ldHdvcmstcmVxdWVzdC1mYWlsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk5FVFdPUktfUkVRVUVTVF9GQUlMRUQgKi99YCkge1xuICAgICAgICAgICAgICAgIC8vIFNvbWV0aGluZydzIHdyb25nIHdpdGggdGhlIHVzZXIncyB0b2tlbi4gTG9nIHRoZW0gb3V0IGFuZCByZW1vdmVcbiAgICAgICAgICAgICAgICAvLyB0aGVtIGZyb20gc3RvcmFnZVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0bHlTZXRDdXJyZW50VXNlcih1c2VyKTtcbiAgICB9XG4gICAgdXNlRGV2aWNlTGFuZ3VhZ2UoKSB7XG4gICAgICAgIHRoaXMubGFuZ3VhZ2VDb2RlID0gX2dldFVzZXJMYW5ndWFnZSgpO1xuICAgIH1cbiAgICBhc3luYyBfZGVsZXRlKCkge1xuICAgICAgICB0aGlzLl9kZWxldGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlQ3VycmVudFVzZXIodXNlckV4dGVybikge1xuICAgICAgICBpZiAoX2lzRmlyZWJhc2VTZXJ2ZXJBcHAodGhpcy5hcHApKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBwdWJsaWMgdXBkYXRlQ3VycmVudFVzZXIgbWV0aG9kIG5lZWRzIHRvIG1ha2UgYSBjb3B5IG9mIHRoZSB1c2VyLFxuICAgICAgICAvLyBhbmQgYWxzbyBjaGVjayB0aGF0IHRoZSBwcm9qZWN0IG1hdGNoZXNcbiAgICAgICAgY29uc3QgdXNlciA9IHVzZXJFeHRlcm5cbiAgICAgICAgICAgID8gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXJFeHRlcm4pXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgICAgICBfYXNzZXJ0KHVzZXIuYXV0aC5jb25maWcuYXBpS2V5ID09PSB0aGlzLmNvbmZpZy5hcGlLZXksIHRoaXMsIFwiaW52YWxpZC11c2VyLXRva2VuXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0FVVEggKi8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVDdXJyZW50VXNlcih1c2VyICYmIHVzZXIuX2Nsb25lKHRoaXMpKTtcbiAgICB9XG4gICAgYXN5bmMgX3VwZGF0ZUN1cnJlbnRVc2VyKHVzZXIsIHNraXBCZWZvcmVTdGF0ZUNhbGxiYWNrcyA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWxldGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgICAgIF9hc3NlcnQodGhpcy50ZW5hbnRJZCA9PT0gdXNlci50ZW5hbnRJZCwgdGhpcywgXCJ0ZW5hbnQtaWQtbWlzbWF0Y2hcIiAvKiBBdXRoRXJyb3JDb2RlLlRFTkFOVF9JRF9NSVNNQVRDSCAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFza2lwQmVmb3JlU3RhdGVDYWxsYmFja3MpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYmVmb3JlU3RhdGVRdWV1ZS5ydW5NaWRkbGV3YXJlKHVzZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZGlyZWN0bHlTZXRDdXJyZW50VXNlcih1c2VyKTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5QXV0aExpc3RlbmVycygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgc2lnbk91dCgpIHtcbiAgICAgICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKHRoaXMuYXBwKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSdW4gZmlyc3QsIHRvIGJsb2NrIF9zZXRSZWRpcmVjdFVzZXIoKSBpZiBhbnkgY2FsbGJhY2tzIGZhaWwuXG4gICAgICAgIGF3YWl0IHRoaXMuYmVmb3JlU3RhdGVRdWV1ZS5ydW5NaWRkbGV3YXJlKG51bGwpO1xuICAgICAgICAvLyBDbGVhciB0aGUgcmVkaXJlY3QgdXNlciB3aGVuIHNpZ25PdXQgaXMgY2FsbGVkXG4gICAgICAgIGlmICh0aGlzLnJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyIHx8IHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlcikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0UmVkaXJlY3RVc2VyKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgY2FsbGJhY2tzIGZyb20gYmVpbmcgY2FsbGVkIGFnYWluIGluIF91cGRhdGVDdXJyZW50VXNlciwgYXNcbiAgICAgICAgLy8gdGhleSB3ZXJlIGFscmVhZHkgY2FsbGVkIGluIHRoZSBmaXJzdCBsaW5lLlxuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlQ3VycmVudFVzZXIobnVsbCwgLyogc2tpcEJlZm9yZVN0YXRlQ2FsbGJhY2tzICovIHRydWUpO1xuICAgIH1cbiAgICBzZXRQZXJzaXN0ZW5jZShwZXJzaXN0ZW5jZSkge1xuICAgICAgICBpZiAoX2lzRmlyZWJhc2VTZXJ2ZXJBcHAodGhpcy5hcHApKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXNzZXJ0ZWRQZXJzaXN0ZW5jZS5zZXRQZXJzaXN0ZW5jZShfZ2V0SW5zdGFuY2UocGVyc2lzdGVuY2UpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRSZWNhcHRjaGFDb25maWcoKSB7XG4gICAgICAgIGlmICh0aGlzLnRlbmFudElkID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZ2VudFJlY2FwdGNoYUNvbmZpZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZW5hbnRSZWNhcHRjaGFDb25maWdzW3RoaXMudGVuYW50SWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHZhbGlkYXRlUGFzc3dvcmQocGFzc3dvcmQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9nZXRQYXNzd29yZFBvbGljeUludGVybmFsKCkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVBhc3N3b3JkUG9saWN5KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFzc3dvcmQgcG9saWN5IHdpbGwgYmUgZGVmaW5lZCBhZnRlciBmZXRjaGluZy5cbiAgICAgICAgY29uc3QgcGFzc3dvcmRQb2xpY3kgPSB0aGlzLl9nZXRQYXNzd29yZFBvbGljeUludGVybmFsKCk7XG4gICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIHBvbGljeSBzY2hlbWEgdmVyc2lvbiBpcyBzdXBwb3J0ZWQgYnkgdGhlIFNESy5cbiAgICAgICAgLy8gVE9ETzogVXBkYXRlIHRoaXMgbG9naWMgdG8gdXNlIGEgbWF4IHN1cHBvcnRlZCBwb2xpY3kgc2NoZW1hIHZlcnNpb24gb25jZSB3ZSBoYXZlIG11bHRpcGxlIHNjaGVtYSB2ZXJzaW9ucy5cbiAgICAgICAgaWYgKHBhc3N3b3JkUG9saWN5LnNjaGVtYVZlcnNpb24gIT09XG4gICAgICAgICAgICB0aGlzLkVYUEVDVEVEX1BBU1NXT1JEX1BPTElDWV9TQ0hFTUFfVkVSU0lPTikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuX2Vycm9yRmFjdG9yeS5jcmVhdGUoXCJ1bnN1cHBvcnRlZC1wYXNzd29yZC1wb2xpY3ktc2NoZW1hLXZlcnNpb25cIiAvKiBBdXRoRXJyb3JDb2RlLlVOU1VQUE9SVEVEX1BBU1NXT1JEX1BPTElDWV9TQ0hFTUFfVkVSU0lPTiAqLywge30pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFzc3dvcmRQb2xpY3kudmFsaWRhdGVQYXNzd29yZChwYXNzd29yZCk7XG4gICAgfVxuICAgIF9nZXRQYXNzd29yZFBvbGljeUludGVybmFsKCkge1xuICAgICAgICBpZiAodGhpcy50ZW5hbnRJZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2plY3RQYXNzd29yZFBvbGljeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZW5hbnRQYXNzd29yZFBvbGljaWVzW3RoaXMudGVuYW50SWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF91cGRhdGVQYXNzd29yZFBvbGljeSgpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfZ2V0UGFzc3dvcmRQb2xpY3kodGhpcyk7XG4gICAgICAgIGNvbnN0IHBhc3N3b3JkUG9saWN5ID0gbmV3IFBhc3N3b3JkUG9saWN5SW1wbChyZXNwb25zZSk7XG4gICAgICAgIGlmICh0aGlzLnRlbmFudElkID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9qZWN0UGFzc3dvcmRQb2xpY3kgPSBwYXNzd29yZFBvbGljeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RlbmFudFBhc3N3b3JkUG9saWNpZXNbdGhpcy50ZW5hbnRJZF0gPSBwYXNzd29yZFBvbGljeTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0UGVyc2lzdGVuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2VydGVkUGVyc2lzdGVuY2UucGVyc2lzdGVuY2UudHlwZTtcbiAgICB9XG4gICAgX3VwZGF0ZUVycm9yTWFwKGVycm9yTWFwKSB7XG4gICAgICAgIHRoaXMuX2Vycm9yRmFjdG9yeSA9IG5ldyBFcnJvckZhY3RvcnkoJ2F1dGgnLCAnRmlyZWJhc2UnLCBlcnJvck1hcCgpKTtcbiAgICB9XG4gICAgb25BdXRoU3RhdGVDaGFuZ2VkKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyU3RhdGVMaXN0ZW5lcih0aGlzLmF1dGhTdGF0ZVN1YnNjcmlwdGlvbiwgbmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpO1xuICAgIH1cbiAgICBiZWZvcmVBdXRoU3RhdGVDaGFuZ2VkKGNhbGxiYWNrLCBvbkFib3J0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlZm9yZVN0YXRlUXVldWUucHVzaENhbGxiYWNrKGNhbGxiYWNrLCBvbkFib3J0KTtcbiAgICB9XG4gICAgb25JZFRva2VuQ2hhbmdlZChuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlclN0YXRlTGlzdGVuZXIodGhpcy5pZFRva2VuU3Vic2NyaXB0aW9uLCBuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlZCk7XG4gICAgfVxuICAgIGF1dGhTdGF0ZVJlYWR5KCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFVzZXIpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMub25BdXRoU3RhdGVDaGFuZ2VkKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXZva2VzIHRoZSBnaXZlbiBhY2Nlc3MgdG9rZW4uIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIEFwcGxlIE9BdXRoIGFjY2VzcyB0b2tlbnMuXG4gICAgICovXG4gICAgYXN5bmMgcmV2b2tlQWNjZXNzVG9rZW4odG9rZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFVzZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB0aGlzLmN1cnJlbnRVc2VyLmdldElkVG9rZW4oKTtcbiAgICAgICAgICAgIC8vIEdlbmVyYWxpemUgdGhpcyB0byBhY2NlcHQgb3RoZXIgcHJvdmlkZXJzIG9uY2Ugc3VwcG9ydGVkLlxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICBwcm92aWRlcklkOiAnYXBwbGUuY29tJyxcbiAgICAgICAgICAgICAgICB0b2tlblR5cGU6IFwiQUNDRVNTX1RPS0VOXCIgLyogVG9rZW5UeXBlLkFDQ0VTU19UT0tFTiAqLyxcbiAgICAgICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgICAgICBpZFRva2VuXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMudGVuYW50SWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QudGVuYW50SWQgPSB0aGlzLnRlbmFudElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgcmV2b2tlVG9rZW4odGhpcywgcmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhcGlLZXk6IHRoaXMuY29uZmlnLmFwaUtleSxcbiAgICAgICAgICAgIGF1dGhEb21haW46IHRoaXMuY29uZmlnLmF1dGhEb21haW4sXG4gICAgICAgICAgICBhcHBOYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBjdXJyZW50VXNlcjogKF9hID0gdGhpcy5fY3VycmVudFVzZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0pTT04oKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBfc2V0UmVkaXJlY3RVc2VyKHVzZXIsIHBvcHVwUmVkaXJlY3RSZXNvbHZlcikge1xuICAgICAgICBjb25zdCByZWRpcmVjdE1hbmFnZXIgPSBhd2FpdCB0aGlzLmdldE9ySW5pdFJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyKHBvcHVwUmVkaXJlY3RSZXNvbHZlcik7XG4gICAgICAgIHJldHVybiB1c2VyID09PSBudWxsXG4gICAgICAgICAgICA/IHJlZGlyZWN0TWFuYWdlci5yZW1vdmVDdXJyZW50VXNlcigpXG4gICAgICAgICAgICA6IHJlZGlyZWN0TWFuYWdlci5zZXRDdXJyZW50VXNlcih1c2VyKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0T3JJbml0UmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXIocG9wdXBSZWRpcmVjdFJlc29sdmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWRpcmVjdFBlcnNpc3RlbmNlTWFuYWdlcikge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSAocG9wdXBSZWRpcmVjdFJlc29sdmVyICYmIF9nZXRJbnN0YW5jZShwb3B1cFJlZGlyZWN0UmVzb2x2ZXIpKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlcjtcbiAgICAgICAgICAgIF9hc3NlcnQocmVzb2x2ZXIsIHRoaXMsIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcbiAgICAgICAgICAgIHRoaXMucmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXIgPSBhd2FpdCBQZXJzaXN0ZW5jZVVzZXJNYW5hZ2VyLmNyZWF0ZSh0aGlzLCBbX2dldEluc3RhbmNlKHJlc29sdmVyLl9yZWRpcmVjdFBlcnNpc3RlbmNlKV0sIFwicmVkaXJlY3RVc2VyXCIgLyogS2V5TmFtZS5SRURJUkVDVF9VU0VSICovKTtcbiAgICAgICAgICAgIHRoaXMucmVkaXJlY3RVc2VyID1cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyLmdldEN1cnJlbnRVc2VyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXI7XG4gICAgfVxuICAgIGFzeW5jIF9yZWRpcmVjdFVzZXJGb3JJZChpZCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UndmUgY2xlYXJlZCBhbnkgcGVuZGluZyBwZXJzaXN0ZW5jZSBhY3Rpb25zIGlmIHdlJ3JlIG5vdCBpblxuICAgICAgICAvLyB0aGUgaW5pdGlhbGl6ZXJcbiAgICAgICAgaWYgKHRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucXVldWUoYXN5bmMgKCkgPT4geyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKChfYSA9IHRoaXMuX2N1cnJlbnRVc2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX3JlZGlyZWN0RXZlbnRJZCkgPT09IGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFVzZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgoX2IgPSB0aGlzLnJlZGlyZWN0VXNlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLl9yZWRpcmVjdEV2ZW50SWQpID09PSBpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVkaXJlY3RVc2VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyBfcGVyc2lzdFVzZXJJZkN1cnJlbnQodXNlcikge1xuICAgICAgICBpZiAodXNlciA9PT0gdGhpcy5jdXJyZW50VXNlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWUoYXN5bmMgKCkgPT4gdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKHVzZXIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogTm90aWZpZXMgbGlzdGVuZXJzIG9ubHkgaWYgdGhlIHVzZXIgaXMgY3VycmVudCAqL1xuICAgIF9ub3RpZnlMaXN0ZW5lcnNJZkN1cnJlbnQodXNlcikge1xuICAgICAgICBpZiAodXNlciA9PT0gdGhpcy5jdXJyZW50VXNlcikge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlBdXRoTGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2tleSgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29uZmlnLmF1dGhEb21haW59OiR7dGhpcy5jb25maWcuYXBpS2V5fToke3RoaXMubmFtZX1gO1xuICAgIH1cbiAgICBfc3RhcnRQcm9hY3RpdmVSZWZyZXNoKCkge1xuICAgICAgICB0aGlzLmlzUHJvYWN0aXZlUmVmcmVzaEVuYWJsZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50VXNlcikge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFVzZXIuX3N0YXJ0UHJvYWN0aXZlUmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9zdG9wUHJvYWN0aXZlUmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5pc1Byb2FjdGl2ZVJlZnJlc2hFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRVc2VyKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VXNlci5fc3RvcFByb2FjdGl2ZVJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgY3VycmVudCB1c2VyIGNhc3QgYXMgdGhlIGludGVybmFsIHR5cGUgKi9cbiAgICBnZXQgX2N1cnJlbnRVc2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VXNlcjtcbiAgICB9XG4gICAgbm90aWZ5QXV0aExpc3RlbmVycygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZFRva2VuU3Vic2NyaXB0aW9uLm5leHQodGhpcy5jdXJyZW50VXNlcik7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRVaWQgPSAoX2IgPSAoX2EgPSB0aGlzLmN1cnJlbnRVc2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudWlkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgICAgICBpZiAodGhpcy5sYXN0Tm90aWZpZWRVaWQgIT09IGN1cnJlbnRVaWQpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdE5vdGlmaWVkVWlkID0gY3VycmVudFVpZDtcbiAgICAgICAgICAgIHRoaXMuYXV0aFN0YXRlU3Vic2NyaXB0aW9uLm5leHQodGhpcy5jdXJyZW50VXNlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJTdGF0ZUxpc3RlbmVyKHN1YnNjcmlwdGlvbiwgbmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlbGV0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7IH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2IgPSB0eXBlb2YgbmV4dE9yT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gbmV4dE9yT2JzZXJ2ZXJcbiAgICAgICAgICAgIDogbmV4dE9yT2JzZXJ2ZXIubmV4dC5iaW5kKG5leHRPck9ic2VydmVyKTtcbiAgICAgICAgbGV0IGlzVW5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLl9pc0luaXRpYWxpemVkXG4gICAgICAgICAgICA/IFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICA6IHRoaXMuX2luaXRpYWxpemF0aW9uUHJvbWlzZTtcbiAgICAgICAgX2Fzc2VydChwcm9taXNlLCB0aGlzLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIC8vIFRoZSBjYWxsYmFjayBuZWVkcyB0byBiZSBjYWxsZWQgYXN5bmNocm9ub3VzbHkgcGVyIHRoZSBzcGVjLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgIHByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYih0aGlzLmN1cnJlbnRVc2VyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2YgbmV4dE9yT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gc3Vic2NyaXB0aW9uLmFkZE9ic2VydmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaXNVbnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdWJzY3JpcHRpb24uYWRkT2JzZXJ2ZXIobmV4dE9yT2JzZXJ2ZXIpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBpc1Vuc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5wcm90ZWN0ZWQgKGZyb20gcmFjZSBjb25kaXRpb25zKSBtZXRob2QgdG8gc2V0IHRoZSBjdXJyZW50IHVzZXIuIFRoaXNcbiAgICAgKiBzaG91bGQgb25seSBiZSBjYWxsZWQgZnJvbSB3aXRoaW4gYSBxdWV1ZWQgY2FsbGJhY2suIFRoaXMgaXMgbmVjZXNzYXJ5XG4gICAgICogYmVjYXVzZSB0aGUgcXVldWUgc2hvdWxkbid0IHJlbHkgb24gYW5vdGhlciBxdWV1ZWQgY2FsbGJhY2suXG4gICAgICovXG4gICAgYXN5bmMgZGlyZWN0bHlTZXRDdXJyZW50VXNlcih1c2VyKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRVc2VyICYmIHRoaXMuY3VycmVudFVzZXIgIT09IHVzZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRVc2VyLl9zdG9wUHJvYWN0aXZlUmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VyICYmIHRoaXMuaXNQcm9hY3RpdmVSZWZyZXNoRW5hYmxlZCkge1xuICAgICAgICAgICAgdXNlci5fc3RhcnRQcm9hY3RpdmVSZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50VXNlciA9IHVzZXI7XG4gICAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFzc2VydGVkUGVyc2lzdGVuY2Uuc2V0Q3VycmVudFVzZXIodXNlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFzc2VydGVkUGVyc2lzdGVuY2UucmVtb3ZlQ3VycmVudFVzZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZShhY3Rpb24pIHtcbiAgICAgICAgLy8gSW4gY2FzZSBzb21ldGhpbmcgZXJyb3JzLCB0aGUgY2FsbGJhY2sgc3RpbGwgc2hvdWxkIGJlIGNhbGxlZCBpbiBvcmRlclxuICAgICAgICAvLyB0byBrZWVwIHRoZSBwcm9taXNlIGNoYWluIGFsaXZlXG4gICAgICAgIHRoaXMub3BlcmF0aW9ucyA9IHRoaXMub3BlcmF0aW9ucy50aGVuKGFjdGlvbiwgYWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0aW9ucztcbiAgICB9XG4gICAgZ2V0IGFzc2VydGVkUGVyc2lzdGVuY2UoKSB7XG4gICAgICAgIF9hc3NlcnQodGhpcy5wZXJzaXN0ZW5jZU1hbmFnZXIsIHRoaXMsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2VNYW5hZ2VyO1xuICAgIH1cbiAgICBfbG9nRnJhbWV3b3JrKGZyYW1ld29yaykge1xuICAgICAgICBpZiAoIWZyYW1ld29yayB8fCB0aGlzLmZyYW1ld29ya3MuaW5jbHVkZXMoZnJhbWV3b3JrKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJhbWV3b3Jrcy5wdXNoKGZyYW1ld29yayk7XG4gICAgICAgIC8vIFNvcnQgYWxwaGFiZXRpY2FsbHkgc28gdGhhdCBcIkZpcmViYXNlQ29yZS13ZWIsRmlyZWJhc2VVSS13ZWJcIiBhbmRcbiAgICAgICAgLy8gXCJGaXJlYmFzZVVJLXdlYixGaXJlYmFzZUNvcmUtd2ViXCIgYXJlbid0IHZpZXdlZCBhcyBkaWZmZXJlbnQuXG4gICAgICAgIHRoaXMuZnJhbWV3b3Jrcy5zb3J0KCk7XG4gICAgICAgIHRoaXMuY2xpZW50VmVyc2lvbiA9IF9nZXRDbGllbnRWZXJzaW9uKHRoaXMuY29uZmlnLmNsaWVudFBsYXRmb3JtLCB0aGlzLl9nZXRGcmFtZXdvcmtzKCkpO1xuICAgIH1cbiAgICBfZ2V0RnJhbWV3b3JrcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhbWV3b3JrcztcbiAgICB9XG4gICAgYXN5bmMgX2dldEFkZGl0aW9uYWxIZWFkZXJzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIEFkZGl0aW9uYWwgaGVhZGVycyBvbiBldmVyeSByZXF1ZXN0XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICBbXCJYLUNsaWVudC1WZXJzaW9uXCIgLyogSHR0cEhlYWRlci5YX0NMSUVOVF9WRVJTSU9OICovXTogdGhpcy5jbGllbnRWZXJzaW9uXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmFwcC5vcHRpb25zLmFwcElkKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiWC1GaXJlYmFzZS1nbXBpZFwiIC8qIEh0dHBIZWFkZXIuWF9GSVJFQkFTRV9HTVBJRCAqL10gPSB0aGlzLmFwcC5vcHRpb25zLmFwcElkO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBoZWFydGJlYXQgc2VydmljZSBleGlzdHMsIGFkZCB0aGUgaGVhcnRiZWF0IHN0cmluZ1xuICAgICAgICBjb25zdCBoZWFydGJlYXRzSGVhZGVyID0gYXdhaXQgKChfYSA9IHRoaXMuaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyXG4gICAgICAgICAgICAuZ2V0SW1tZWRpYXRlKHtcbiAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgICAgIH0pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0SGVhcnRiZWF0c0hlYWRlcigpKTtcbiAgICAgICAgaWYgKGhlYXJ0YmVhdHNIZWFkZXIpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJYLUZpcmViYXNlLUNsaWVudFwiIC8qIEh0dHBIZWFkZXIuWF9GSVJFQkFTRV9DTElFTlQgKi9dID0gaGVhcnRiZWF0c0hlYWRlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgQXBwIENoZWNrIHNlcnZpY2UgZXhpc3RzLCBhZGQgdGhlIEFwcCBDaGVjayB0b2tlbiBpbiB0aGUgaGVhZGVyc1xuICAgICAgICBjb25zdCBhcHBDaGVja1Rva2VuID0gYXdhaXQgdGhpcy5fZ2V0QXBwQ2hlY2tUb2tlbigpO1xuICAgICAgICBpZiAoYXBwQ2hlY2tUb2tlbikge1xuICAgICAgICAgICAgaGVhZGVyc1tcIlgtRmlyZWJhc2UtQXBwQ2hlY2tcIiAvKiBIdHRwSGVhZGVyLlhfRklSRUJBU0VfQVBQX0NIRUNLICovXSA9IGFwcENoZWNrVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRBcHBDaGVja1Rva2VuKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGFwcENoZWNrVG9rZW5SZXN1bHQgPSBhd2FpdCAoKF9hID0gdGhpcy5hcHBDaGVja1NlcnZpY2VQcm92aWRlclxuICAgICAgICAgICAgLmdldEltbWVkaWF0ZSh7IG9wdGlvbmFsOiB0cnVlIH0pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0VG9rZW4oKSk7XG4gICAgICAgIGlmIChhcHBDaGVja1Rva2VuUmVzdWx0ID09PSBudWxsIHx8IGFwcENoZWNrVG9rZW5SZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFwcENoZWNrVG9rZW5SZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIENvbnRleHQ6IGFwcENoZWNrLmdldFRva2VuKCkgd2lsbCBuZXZlciB0aHJvdyBldmVuIGlmIGFuIGVycm9yIGhhcHBlbmVkLlxuICAgICAgICAgICAgLy8gSW4gdGhlIGVycm9yIGNhc2UsIGEgZHVtbXkgdG9rZW4gd2lsbCBiZSByZXR1cm5lZCBhbG9uZyB3aXRoIGFuIGVycm9yIGZpZWxkIGRlc2NyaWJpbmdcbiAgICAgICAgICAgIC8vIHRoZSBlcnJvci4gSW4gZ2VuZXJhbCwgd2Ugc2hvdWxkbid0IGNhcmUgYWJvdXQgdGhlIGVycm9yIGNvbmRpdGlvbiBhbmQganVzdCB1c2VcbiAgICAgICAgICAgIC8vIHRoZSB0b2tlbiAoYWN0dWFsIG9yIGR1bW15KSB0byBzZW5kIHJlcXVlc3RzLlxuICAgICAgICAgICAgX2xvZ1dhcm4oYEVycm9yIHdoaWxlIHJldHJpZXZpbmcgQXBwIENoZWNrIHRva2VuOiAke2FwcENoZWNrVG9rZW5SZXN1bHQuZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcENoZWNrVG9rZW5SZXN1bHQgPT09IG51bGwgfHwgYXBwQ2hlY2tUb2tlblJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXBwQ2hlY2tUb2tlblJlc3VsdC50b2tlbjtcbiAgICB9XG59XG4vKipcbiAqIE1ldGhvZCB0byBiZSB1c2VkIHRvIGNhc3QgZG93biB0byBvdXIgcHJpdmF0ZSBpbXBsZW1lbnRhdGlvbiBvZiBBdXRoLlxuICogSXQgd2lsbCBhbHNvIGhhbmRsZSB1bndyYXBwaW5nIGZyb20gdGhlIGNvbXBhdCB0eXBlIGlmIG5lY2Vzc2FyeVxuICpcbiAqIEBwYXJhbSBhdXRoIEF1dGggb2JqZWN0IHBhc3NlZCBpbiBmcm9tIGRldmVsb3BlclxuICovXG5mdW5jdGlvbiBfY2FzdEF1dGgoYXV0aCkge1xuICAgIHJldHVybiBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCk7XG59XG4vKiogSGVscGVyIGNsYXNzIHRvIHdyYXAgc3Vic2NyaWJlciBsb2dpYyAqL1xuY2xhc3MgU3Vic2NyaXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihhdXRoKSB7XG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmFkZE9ic2VydmVyID0gY3JlYXRlU3Vic2NyaWJlKG9ic2VydmVyID0+ICh0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXIpKTtcbiAgICB9XG4gICAgZ2V0IG5leHQoKSB7XG4gICAgICAgIF9hc3NlcnQodGhpcy5vYnNlcnZlciwgdGhpcy5hdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIHJldHVybiB0aGlzLm9ic2VydmVyLm5leHQuYmluZCh0aGlzLm9ic2VydmVyKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5sZXQgZXh0ZXJuYWxKU1Byb3ZpZGVyID0ge1xuICAgIGFzeW5jIGxvYWRKUygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gbG9hZCBleHRlcm5hbCBzY3JpcHRzJyk7XG4gICAgfSxcbiAgICByZWNhcHRjaGFWMlNjcmlwdDogJycsXG4gICAgcmVjYXB0Y2hhRW50ZXJwcmlzZVNjcmlwdDogJycsXG4gICAgZ2FwaVNjcmlwdDogJydcbn07XG5mdW5jdGlvbiBfbG9hZEpTKHVybCkge1xuICAgIHJldHVybiBleHRlcm5hbEpTUHJvdmlkZXIubG9hZEpTKHVybCk7XG59XG5mdW5jdGlvbiBfcmVjYXB0Y2hhRW50ZXJwcmlzZVNjcmlwdFVybCgpIHtcbiAgICByZXR1cm4gZXh0ZXJuYWxKU1Byb3ZpZGVyLnJlY2FwdGNoYUVudGVycHJpc2VTY3JpcHQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBNb2NrR3JlQ0FQVENIQVRvcExldmVsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lbnRlcnByaXNlID0gbmV3IE1vY2tHcmVDQVBUQ0hBKCk7XG4gICAgfVxuICAgIHJlYWR5KGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIGV4ZWN1dGUoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIF9zaXRlS2V5LCBfb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCd0b2tlbicpO1xuICAgIH1cbiAgICByZW5kZXIoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIF9jb250YWluZXIsIF9wYXJhbWV0ZXJzKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG5jbGFzcyBNb2NrR3JlQ0FQVENIQSB7XG4gICAgcmVhZHkoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgZXhlY3V0ZShcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgX3NpdGVLZXksIF9vcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJ3Rva2VuJyk7XG4gICAgfVxuICAgIHJlbmRlcihcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgX2NvbnRhaW5lciwgX3BhcmFtZXRlcnMpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cyAqL1xuY29uc3QgUkVDQVBUQ0hBX0VOVEVSUFJJU0VfVkVSSUZJRVJfVFlQRSA9ICdyZWNhcHRjaGEtZW50ZXJwcmlzZSc7XG5jb25zdCBGQUtFX1RPS0VOID0gJ05PX1JFQ0FQVENIQSc7XG5jbGFzcyBSZWNhcHRjaGFFbnRlcnByaXNlVmVyaWZpZXIge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGF1dGhFeHRlcm4gLSBUaGUgY29ycmVzcG9uZGluZyBGaXJlYmFzZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhdXRoRXh0ZXJuKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZGVudGlmaWVzIHRoZSB0eXBlIG9mIGFwcGxpY2F0aW9uIHZlcmlmaWVyIChlLmcuIFwicmVjYXB0Y2hhLWVudGVycHJpc2VcIikuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSBSRUNBUFRDSEFfRU5URVJQUklTRV9WRVJJRklFUl9UWVBFO1xuICAgICAgICB0aGlzLmF1dGggPSBfY2FzdEF1dGgoYXV0aEV4dGVybik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSB2ZXJpZmljYXRpb24gcHJvY2Vzcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSBmb3IgYSB0b2tlbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGUgdmFsaWRpdHkgb2YgYSByZXF1ZXN0LlxuICAgICAqL1xuICAgIGFzeW5jIHZlcmlmeShhY3Rpb24gPSAndmVyaWZ5JywgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gcmV0cmlldmVTaXRlS2V5KGF1dGgpIHtcbiAgICAgICAgICAgIGlmICghZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF1dGgudGVuYW50SWQgPT0gbnVsbCAmJiBhdXRoLl9hZ2VudFJlY2FwdGNoYUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRoLl9hZ2VudFJlY2FwdGNoYUNvbmZpZy5zaXRlS2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXV0aC50ZW5hbnRJZCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIGF1dGguX3RlbmFudFJlY2FwdGNoYUNvbmZpZ3NbYXV0aC50ZW5hbnRJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0aC5fdGVuYW50UmVjYXB0Y2hhQ29uZmlnc1thdXRoLnRlbmFudElkXS5zaXRlS2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgZ2V0UmVjYXB0Y2hhQ29uZmlnKGF1dGgsIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50VHlwZTogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqLyxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogXCJSRUNBUFRDSEFfRU5URVJQUklTRVwiIC8qIFJlY2FwdGNoYVZlcnNpb24uRU5URVJQUklTRSAqL1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnJlY2FwdGNoYUtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdyZWNhcHRjaGEgRW50ZXJwcmlzZSBzaXRlIGtleSB1bmRlZmluZWQnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25maWcgPSBuZXcgUmVjYXB0Y2hhQ29uZmlnKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdXRoLnRlbmFudElkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoLl9hZ2VudFJlY2FwdGNoYUNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGguX3RlbmFudFJlY2FwdGNoYUNvbmZpZ3NbYXV0aC50ZW5hbnRJZF0gPSBjb25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShjb25maWcuc2l0ZUtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmV0cmlldmVSZWNhcHRjaGFUb2tlbihzaXRlS2V5LCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGdyZWNhcHRjaGEgPSB3aW5kb3cuZ3JlY2FwdGNoYTtcbiAgICAgICAgICAgIGlmIChpc0VudGVycHJpc2UoZ3JlY2FwdGNoYSkpIHtcbiAgICAgICAgICAgICAgICBncmVjYXB0Y2hhLmVudGVycHJpc2UucmVhZHkoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBncmVjYXB0Y2hhLmVudGVycHJpc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC5leGVjdXRlKHNpdGVLZXksIHsgYWN0aW9uIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbih0b2tlbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKEZBS0VfVE9LRU4pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChFcnJvcignTm8gcmVDQVBUQ0hBIGVudGVycHJpc2Ugc2NyaXB0IGxvYWRlZC4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJucyBQcm9taXNlIGZvciBhIG1vY2sgdG9rZW4gd2hlbiBhcHBWZXJpZmljYXRpb25EaXNhYmxlZEZvclRlc3RpbmcgaXMgdHJ1ZS5cbiAgICAgICAgaWYgKHRoaXMuYXV0aC5zZXR0aW5ncy5hcHBWZXJpZmljYXRpb25EaXNhYmxlZEZvclRlc3RpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZWNhcHRjaGEgPSBuZXcgTW9ja0dyZUNBUFRDSEFUb3BMZXZlbCgpO1xuICAgICAgICAgICAgcmV0dXJuIG1vY2tSZWNhcHRjaGEuZXhlY3V0ZSgnc2l0ZUtleScsIHsgYWN0aW9uOiAndmVyaWZ5JyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmV0cmlldmVTaXRlS2V5KHRoaXMuYXV0aClcbiAgICAgICAgICAgICAgICAudGhlbihzaXRlS2V5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWZvcmNlUmVmcmVzaCAmJiBpc0VudGVycHJpc2Uod2luZG93LmdyZWNhcHRjaGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHJpZXZlUmVjYXB0Y2hhVG9rZW4oc2l0ZUtleSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignUmVjYXB0Y2hhVmVyaWZpZXIgaXMgb25seSBzdXBwb3J0ZWQgaW4gYnJvd3NlcicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgdXJsID0gX3JlY2FwdGNoYUVudGVycHJpc2VTY3JpcHRVcmwoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBzaXRlS2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9sb2FkSlModXJsKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cmlldmVSZWNhcHRjaGFUb2tlbihzaXRlS2V5LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGluamVjdFJlY2FwdGNoYUZpZWxkcyhhdXRoLCByZXF1ZXN0LCBhY3Rpb24sIGlzQ2FwdGNoYVJlc3AgPSBmYWxzZSwgaXNGYWtlVG9rZW4gPSBmYWxzZSkge1xuICAgIGNvbnN0IHZlcmlmaWVyID0gbmV3IFJlY2FwdGNoYUVudGVycHJpc2VWZXJpZmllcihhdXRoKTtcbiAgICBsZXQgY2FwdGNoYVJlc3BvbnNlO1xuICAgIGlmIChpc0Zha2VUb2tlbikge1xuICAgICAgICBjYXB0Y2hhUmVzcG9uc2UgPSBGQUtFX1RPS0VOO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNhcHRjaGFSZXNwb25zZSA9IGF3YWl0IHZlcmlmaWVyLnZlcmlmeShhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdGNoYVJlc3BvbnNlID0gYXdhaXQgdmVyaWZpZXIudmVyaWZ5KGFjdGlvbiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmV3UmVxdWVzdCA9IE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3QpO1xuICAgIGlmIChhY3Rpb24gPT09IFwibWZhU21zRW5yb2xsbWVudFwiIC8qIFJlY2FwdGNoYUFjdGlvbk5hbWUuTUZBX1NNU19FTlJPTExNRU5UICovIHx8XG4gICAgICAgIGFjdGlvbiA9PT0gXCJtZmFTbXNTaWduSW5cIiAvKiBSZWNhcHRjaGFBY3Rpb25OYW1lLk1GQV9TTVNfU0lHTklOICovKSB7XG4gICAgICAgIGlmICgncGhvbmVFbnJvbGxtZW50SW5mbycgaW4gbmV3UmVxdWVzdCkge1xuICAgICAgICAgICAgY29uc3QgcGhvbmVOdW1iZXIgPSBuZXdSZXF1ZXN0LnBob25lRW5yb2xsbWVudEluZm8ucGhvbmVOdW1iZXI7XG4gICAgICAgICAgICBjb25zdCByZWNhcHRjaGFUb2tlbiA9IG5ld1JlcXVlc3QucGhvbmVFbnJvbGxtZW50SW5mby5yZWNhcHRjaGFUb2tlbjtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obmV3UmVxdWVzdCwge1xuICAgICAgICAgICAgICAgICdwaG9uZUVucm9sbG1lbnRJbmZvJzoge1xuICAgICAgICAgICAgICAgICAgICBwaG9uZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgcmVjYXB0Y2hhVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGNhcHRjaGFSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgJ2NsaWVudFR5cGUnOiBcIkNMSUVOVF9UWVBFX1dFQlwiIC8qIFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCICovLFxuICAgICAgICAgICAgICAgICAgICAncmVjYXB0Y2hhVmVyc2lvbic6IFwiUkVDQVBUQ0hBX0VOVEVSUFJJU0VcIiAvKiBSZWNhcHRjaGFWZXJzaW9uLkVOVEVSUFJJU0UgKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgncGhvbmVTaWduSW5JbmZvJyBpbiBuZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICBjb25zdCByZWNhcHRjaGFUb2tlbiA9IG5ld1JlcXVlc3QucGhvbmVTaWduSW5JbmZvLnJlY2FwdGNoYVRva2VuO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdSZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgJ3Bob25lU2lnbkluSW5mbyc6IHtcbiAgICAgICAgICAgICAgICAgICAgcmVjYXB0Y2hhVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGNhcHRjaGFSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgJ2NsaWVudFR5cGUnOiBcIkNMSUVOVF9UWVBFX1dFQlwiIC8qIFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCICovLFxuICAgICAgICAgICAgICAgICAgICAncmVjYXB0Y2hhVmVyc2lvbic6IFwiUkVDQVBUQ0hBX0VOVEVSUFJJU0VcIiAvKiBSZWNhcHRjaGFWZXJzaW9uLkVOVEVSUFJJU0UgKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3UmVxdWVzdDtcbiAgICB9XG4gICAgaWYgKCFpc0NhcHRjaGFSZXNwKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24obmV3UmVxdWVzdCwgeyBjYXB0Y2hhUmVzcG9uc2UgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBPYmplY3QuYXNzaWduKG5ld1JlcXVlc3QsIHsgJ2NhcHRjaGFSZXNwJzogY2FwdGNoYVJlc3BvbnNlIH0pO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKG5ld1JlcXVlc3QsIHsgJ2NsaWVudFR5cGUnOiBcIkNMSUVOVF9UWVBFX1dFQlwiIC8qIFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCICovIH0pO1xuICAgIE9iamVjdC5hc3NpZ24obmV3UmVxdWVzdCwge1xuICAgICAgICAncmVjYXB0Y2hhVmVyc2lvbic6IFwiUkVDQVBUQ0hBX0VOVEVSUFJJU0VcIiAvKiBSZWNhcHRjaGFWZXJzaW9uLkVOVEVSUFJJU0UgKi9cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3UmVxdWVzdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlY2FwdGNoYUZsb3coYXV0aEluc3RhbmNlLCByZXF1ZXN0LCBhY3Rpb25OYW1lLCBhY3Rpb25NZXRob2QsIHJlY2FwdGNoYUF1dGhQcm92aWRlcikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKHJlY2FwdGNoYUF1dGhQcm92aWRlciA9PT0gXCJFTUFJTF9QQVNTV09SRF9QUk9WSURFUlwiIC8qIFJlY2FwdGNoYUF1dGhQcm92aWRlci5FTUFJTF9QQVNTV09SRF9QUk9WSURFUiAqLykge1xuICAgICAgICBpZiAoKF9hID0gYXV0aEluc3RhbmNlXG4gICAgICAgICAgICAuX2dldFJlY2FwdGNoYUNvbmZpZygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNQcm92aWRlckVuYWJsZWQoXCJFTUFJTF9QQVNTV09SRF9QUk9WSURFUlwiIC8qIFJlY2FwdGNoYUF1dGhQcm92aWRlci5FTUFJTF9QQVNTV09SRF9QUk9WSURFUiAqLykpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RXaXRoUmVjYXB0Y2hhID0gYXdhaXQgaW5qZWN0UmVjYXB0Y2hhRmllbGRzKGF1dGhJbnN0YW5jZSwgcmVxdWVzdCwgYWN0aW9uTmFtZSwgYWN0aW9uTmFtZSA9PT0gXCJnZXRPb2JDb2RlXCIgLyogUmVjYXB0Y2hhQWN0aW9uTmFtZS5HRVRfT09CX0NPREUgKi8pO1xuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbk1ldGhvZChhdXRoSW5zdGFuY2UsIHJlcXVlc3RXaXRoUmVjYXB0Y2hhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb25NZXRob2QoYXV0aEluc3RhbmNlLCByZXF1ZXN0KS5jYXRjaChhc3luYyAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gYGF1dGgvJHtcIm1pc3NpbmctcmVjYXB0Y2hhLXRva2VuXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1JFQ0FQVENIQV9UT0tFTiAqL31gKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAke2FjdGlvbk5hbWV9IGlzIHByb3RlY3RlZCBieSByZUNBUFRDSEEgRW50ZXJwcmlzZSBmb3IgdGhpcyBwcm9qZWN0LiBBdXRvbWF0aWNhbGx5IHRyaWdnZXJpbmcgdGhlIHJlQ0FQVENIQSBmbG93IGFuZCByZXN0YXJ0aW5nIHRoZSBmbG93LmApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0V2l0aFJlY2FwdGNoYSA9IGF3YWl0IGluamVjdFJlY2FwdGNoYUZpZWxkcyhhdXRoSW5zdGFuY2UsIHJlcXVlc3QsIGFjdGlvbk5hbWUsIGFjdGlvbk5hbWUgPT09IFwiZ2V0T29iQ29kZVwiIC8qIFJlY2FwdGNoYUFjdGlvbk5hbWUuR0VUX09PQl9DT0RFICovKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbk1ldGhvZChhdXRoSW5zdGFuY2UsIHJlcXVlc3RXaXRoUmVjYXB0Y2hhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocmVjYXB0Y2hhQXV0aFByb3ZpZGVyID09PSBcIlBIT05FX1BST1ZJREVSXCIgLyogUmVjYXB0Y2hhQXV0aFByb3ZpZGVyLlBIT05FX1BST1ZJREVSICovKSB7XG4gICAgICAgIGlmICgoX2IgPSBhdXRoSW5zdGFuY2VcbiAgICAgICAgICAgIC5fZ2V0UmVjYXB0Y2hhQ29uZmlnKCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pc1Byb3ZpZGVyRW5hYmxlZChcIlBIT05FX1BST1ZJREVSXCIgLyogUmVjYXB0Y2hhQXV0aFByb3ZpZGVyLlBIT05FX1BST1ZJREVSICovKSkge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdFdpdGhSZWNhcHRjaGEgPSBhd2FpdCBpbmplY3RSZWNhcHRjaGFGaWVsZHMoYXV0aEluc3RhbmNlLCByZXF1ZXN0LCBhY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb25NZXRob2QoYXV0aEluc3RhbmNlLCByZXF1ZXN0V2l0aFJlY2FwdGNoYSkuY2F0Y2goYXN5bmMgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gYXV0aEluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgIC5fZ2V0UmVjYXB0Y2hhQ29uZmlnKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQcm92aWRlckVuZm9yY2VtZW50U3RhdGUoXCJQSE9ORV9QUk9WSURFUlwiIC8qIFJlY2FwdGNoYUF1dGhQcm92aWRlci5QSE9ORV9QUk9WSURFUiAqLykpID09PSBcIkFVRElUXCIgLyogRW5mb3JjZW1lbnRTdGF0ZS5BVURJVCAqLykge1xuICAgICAgICAgICAgICAgICAgICAvLyBBVURJVCBtb2RlXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBgYXV0aC8ke1wibWlzc2luZy1yZWNhcHRjaGEtdG9rZW5cIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOICovfWAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPT09IGBhdXRoLyR7XCJpbnZhbGlkLWFwcC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0FQUF9DUkVERU5USUFMICovfWApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGYWlsZWQgdG8gdmVyaWZ5IHdpdGggcmVDQVBUQ0hBIEVudGVycHJpc2UuIEF1dG9tYXRpY2FsbHkgdHJpZ2dlcmluZyB0aGUgcmVDQVBUQ0hBIHYyIGZsb3cgdG8gY29tcGxldGUgdGhlICR7YWN0aW9uTmFtZX0gZmxvdy5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlQ0FQVENIQSBFbnRlcnByaXNlIHRva2VuIGlzIG1pc3Npbmcgb3IgcmVDQVBUQ0hBIEVudGVycHJpc2UgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZhaWxzLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gcmVDQVBUQ0hBIHYyIGZsb3cuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0V2l0aFJlY2FwdGNoYUZpZWxkcyA9IGF3YWl0IGluamVjdFJlY2FwdGNoYUZpZWxkcyhhdXRoSW5zdGFuY2UsIHJlcXVlc3QsIGFjdGlvbk5hbWUsIGZhbHNlLCAvLyBpc0NhcHRjaGFSZXNwXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlIC8vIGlzRmFrZVRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGNhbGwgdGhlIFBob25lQXBpQ2FsbGVyIHRvIGZldGNoIGFuZCBpbmplY3QgcmVDQVBUQ0hBIHYyIHRva2VuLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbk1ldGhvZChhdXRoSW5zdGFuY2UsIHJlcXVlc3RXaXRoUmVjYXB0Y2hhRmllbGRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFTkZPUkNFIG1vZGUgb3IgQVVESVQgbW9kZSB3aXRoIGFueSBvdGhlciBlcnJvci5cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBEbyByZUNBUFRDSEEgdjIgZmxvdy5cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RXaXRoUmVjYXB0Y2hhRmllbGRzID0gYXdhaXQgaW5qZWN0UmVjYXB0Y2hhRmllbGRzKGF1dGhJbnN0YW5jZSwgcmVxdWVzdCwgYWN0aW9uTmFtZSwgZmFsc2UsIC8vIGlzQ2FwdGNoYVJlc3BcbiAgICAgICAgICAgIHRydWUgLy8gaXNGYWtlVG9rZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgY2FsbCB0aGUgUGhvbmVBcGlDYWxsZXIgdG8gZmV0Y2ggYW5kIGluamVjdCB2MiB0b2tlbi5cbiAgICAgICAgICAgIHJldHVybiBhY3Rpb25NZXRob2QoYXV0aEluc3RhbmNlLCByZXF1ZXN0V2l0aFJlY2FwdGNoYUZpZWxkcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWNhcHRjaGFBdXRoUHJvdmlkZXIgKyAnIHByb3ZpZGVyIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gX2luaXRpYWxpemVSZWNhcHRjaGFDb25maWcoYXV0aCkge1xuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdldFJlY2FwdGNoYUNvbmZpZyhhdXRoSW50ZXJuYWwsIHtcbiAgICAgICAgY2xpZW50VHlwZTogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqLyxcbiAgICAgICAgdmVyc2lvbjogXCJSRUNBUFRDSEFfRU5URVJQUklTRVwiIC8qIFJlY2FwdGNoYVZlcnNpb24uRU5URVJQUklTRSAqL1xuICAgIH0pO1xuICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBSZWNhcHRjaGFDb25maWcocmVzcG9uc2UpO1xuICAgIGlmIChhdXRoSW50ZXJuYWwudGVuYW50SWQgPT0gbnVsbCkge1xuICAgICAgICBhdXRoSW50ZXJuYWwuX2FnZW50UmVjYXB0Y2hhQ29uZmlnID0gY29uZmlnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXV0aEludGVybmFsLl90ZW5hbnRSZWNhcHRjaGFDb25maWdzW2F1dGhJbnRlcm5hbC50ZW5hbnRJZF0gPSBjb25maWc7XG4gICAgfVxuICAgIGlmIChjb25maWcuaXNBbnlQcm92aWRlckVuYWJsZWQoKSkge1xuICAgICAgICBjb25zdCB2ZXJpZmllciA9IG5ldyBSZWNhcHRjaGFFbnRlcnByaXNlVmVyaWZpZXIoYXV0aEludGVybmFsKTtcbiAgICAgICAgdm9pZCB2ZXJpZmllci52ZXJpZnkoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIHtAbGluayBBdXRofSBpbnN0YW5jZSB3aXRoIGZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXJcbiAqIHtAbGluayBEZXBlbmRlbmNpZXN9LlxuICpcbiAqIEByZW1hcmtzXG4gKlxuICogVGhpcyBmdW5jdGlvbiBhbGxvd3MgbW9yZSBjb250cm9sIG92ZXIgdGhlIHtAbGluayBBdXRofSBpbnN0YW5jZSB0aGFuXG4gKiB7QGxpbmsgZ2V0QXV0aH0uIGBnZXRBdXRoYCB1c2VzIHBsYXRmb3JtLXNwZWNpZmljIGRlZmF1bHRzIHRvIHN1cHBseVxuICogdGhlIHtAbGluayBEZXBlbmRlbmNpZXN9LiBJbiBnZW5lcmFsLCBgZ2V0QXV0aGAgaXMgdGhlIGVhc2llc3Qgd2F5IHRvXG4gKiBpbml0aWFsaXplIEF1dGggYW5kIHdvcmtzIGZvciBtb3N0IHVzZSBjYXNlcy4gVXNlIGBpbml0aWFsaXplQXV0aGAgaWYgeW91XG4gKiBuZWVkIGNvbnRyb2wgb3ZlciB3aGljaCBwZXJzaXN0ZW5jZSBsYXllciBpcyB1c2VkLCBvciB0byBtaW5pbWl6ZSBidW5kbGVcbiAqIHNpemUgaWYgeW91J3JlIG5vdCB1c2luZyBlaXRoZXIgYHNpZ25JbldpdGhQb3B1cGAgb3IgYHNpZ25JbldpdGhSZWRpcmVjdGAuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIHlvdXIgYXBwIG9ubHkgdXNlcyBhbm9ueW1vdXMgYWNjb3VudHMgYW5kIHlvdSBvbmx5IHdhbnRcbiAqIGFjY291bnRzIHNhdmVkIGZvciB0aGUgY3VycmVudCBzZXNzaW9uLCBpbml0aWFsaXplIGBBdXRoYCB3aXRoOlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBhdXRoID0gaW5pdGlhbGl6ZUF1dGgoYXBwLCB7XG4gKiAgIHBlcnNpc3RlbmNlOiBicm93c2VyU2Vzc2lvblBlcnNpc3RlbmNlLFxuICogICBwb3B1cFJlZGlyZWN0UmVzb2x2ZXI6IHVuZGVmaW5lZCxcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpbml0aWFsaXplQXV0aChhcHAsIGRlcHMpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IF9nZXRQcm92aWRlcihhcHAsICdhdXRoJyk7XG4gICAgaWYgKHByb3ZpZGVyLmlzSW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICBjb25zdCBhdXRoID0gcHJvdmlkZXIuZ2V0SW1tZWRpYXRlKCk7XG4gICAgICAgIGNvbnN0IGluaXRpYWxPcHRpb25zID0gcHJvdmlkZXIuZ2V0T3B0aW9ucygpO1xuICAgICAgICBpZiAoZGVlcEVxdWFsKGluaXRpYWxPcHRpb25zLCBkZXBzICE9PSBudWxsICYmIGRlcHMgIT09IHZvaWQgMCA/IGRlcHMgOiB7fSkpIHtcbiAgICAgICAgICAgIHJldHVybiBhdXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX2ZhaWwoYXV0aCwgXCJhbHJlYWR5LWluaXRpYWxpemVkXCIgLyogQXV0aEVycm9yQ29kZS5BTFJFQURZX0lOSVRJQUxJWkVEICovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhdXRoID0gcHJvdmlkZXIuaW5pdGlhbGl6ZSh7IG9wdGlvbnM6IGRlcHMgfSk7XG4gICAgcmV0dXJuIGF1dGg7XG59XG5mdW5jdGlvbiBfaW5pdGlhbGl6ZUF1dGhJbnN0YW5jZShhdXRoLCBkZXBzKSB7XG4gICAgY29uc3QgcGVyc2lzdGVuY2UgPSAoZGVwcyA9PT0gbnVsbCB8fCBkZXBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZXBzLnBlcnNpc3RlbmNlKSB8fCBbXTtcbiAgICBjb25zdCBoaWVyYXJjaHkgPSAoQXJyYXkuaXNBcnJheShwZXJzaXN0ZW5jZSkgPyBwZXJzaXN0ZW5jZSA6IFtwZXJzaXN0ZW5jZV0pLm1hcChfZ2V0SW5zdGFuY2UpO1xuICAgIGlmIChkZXBzID09PSBudWxsIHx8IGRlcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlcHMuZXJyb3JNYXApIHtcbiAgICAgICAgYXV0aC5fdXBkYXRlRXJyb3JNYXAoZGVwcy5lcnJvck1hcCk7XG4gICAgfVxuICAgIC8vIFRoaXMgcHJvbWlzZSBpcyBpbnRlbmRlZCB0byBmbG9hdDsgYXV0aCBpbml0aWFsaXphdGlvbiBoYXBwZW5zIGluIHRoZVxuICAgIC8vIGJhY2tncm91bmQsIG1lYW53aGlsZSB0aGUgYXV0aCBvYmplY3QgbWF5IGJlIHVzZWQgYnkgdGhlIGFwcC5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgYXV0aC5faW5pdGlhbGl6ZVdpdGhQZXJzaXN0ZW5jZShoaWVyYXJjaHksIGRlcHMgPT09IG51bGwgfHwgZGVwcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVwcy5wb3B1cFJlZGlyZWN0UmVzb2x2ZXIpO1xufVxuXG4vKipcbiAqIENoYW5nZXMgdGhlIHtAbGluayBBdXRofSBpbnN0YW5jZSB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBGaXJlYmFzZSBBdXRoIEVtdWxhdG9yLCBpbnN0ZWFkIG9mIHByb2R1Y3Rpb25cbiAqIEZpcmViYXNlIEF1dGggc2VydmljZXMuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgbXVzdCBiZSBjYWxsZWQgc3luY2hyb25vdXNseSBpbW1lZGlhdGVseSBmb2xsb3dpbmcgdGhlIGZpcnN0IGNhbGwgdG9cbiAqIHtAbGluayBpbml0aWFsaXplQXV0aH0uICBEbyBub3QgdXNlIHdpdGggcHJvZHVjdGlvbiBjcmVkZW50aWFscyBhcyBlbXVsYXRvclxuICogdHJhZmZpYyBpcyBub3QgZW5jcnlwdGVkLlxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogY29ubmVjdEF1dGhFbXVsYXRvcihhdXRoLCAnaHR0cDovLzEyNy4wLjAuMTo5MDk5JywgeyBkaXNhYmxlV2FybmluZ3M6IHRydWUgfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCBhdCB3aGljaCB0aGUgZW11bGF0b3IgaXMgcnVubmluZyAoZWcsICdodHRwOi8vbG9jYWxob3N0OjkwOTknKS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwuIGBvcHRpb25zLmRpc2FibGVXYXJuaW5nc2AgZGVmYXVsdHMgdG8gYGZhbHNlYC4gU2V0IGl0IHRvXG4gKiBgdHJ1ZWAgdG8gZGlzYWJsZSB0aGUgd2FybmluZyBiYW5uZXIgYXR0YWNoZWQgdG8gdGhlIERPTS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNvbm5lY3RBdXRoRW11bGF0b3IoYXV0aCwgdXJsLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xuICAgIF9hc3NlcnQoYXV0aEludGVybmFsLl9jYW5Jbml0RW11bGF0b3IsIGF1dGhJbnRlcm5hbCwgXCJlbXVsYXRvci1jb25maWctZmFpbGVkXCIgLyogQXV0aEVycm9yQ29kZS5FTVVMQVRPUl9DT05GSUdfRkFJTEVEICovKTtcbiAgICBfYXNzZXJ0KC9eaHR0cHM/OlxcL1xcLy8udGVzdCh1cmwpLCBhdXRoSW50ZXJuYWwsIFwiaW52YWxpZC1lbXVsYXRvci1zY2hlbWVcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfRU1VTEFUT1JfU0NIRU1FICovKTtcbiAgICBjb25zdCBkaXNhYmxlV2FybmluZ3MgPSAhIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGlzYWJsZVdhcm5pbmdzKTtcbiAgICBjb25zdCBwcm90b2NvbCA9IGV4dHJhY3RQcm90b2NvbCh1cmwpO1xuICAgIGNvbnN0IHsgaG9zdCwgcG9ydCB9ID0gZXh0cmFjdEhvc3RBbmRQb3J0KHVybCk7XG4gICAgY29uc3QgcG9ydFN0ciA9IHBvcnQgPT09IG51bGwgPyAnJyA6IGA6JHtwb3J0fWA7XG4gICAgLy8gQWx3YXlzIHJlcGxhY2UgcGF0aCB3aXRoIFwiL1wiIChldmVuIGlmIGlucHV0IHVybCBoYWQgbm8gcGF0aCBhdCBhbGwsIG9yIGhhZCBhIGRpZmZlcmVudCBvbmUpLlxuICAgIGF1dGhJbnRlcm5hbC5jb25maWcuZW11bGF0b3IgPSB7IHVybDogYCR7cHJvdG9jb2x9Ly8ke2hvc3R9JHtwb3J0U3RyfS9gIH07XG4gICAgYXV0aEludGVybmFsLnNldHRpbmdzLmFwcFZlcmlmaWNhdGlvbkRpc2FibGVkRm9yVGVzdGluZyA9IHRydWU7XG4gICAgYXV0aEludGVybmFsLmVtdWxhdG9yQ29uZmlnID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGhvc3QsXG4gICAgICAgIHBvcnQsXG4gICAgICAgIHByb3RvY29sOiBwcm90b2NvbC5yZXBsYWNlKCc6JywgJycpLFxuICAgICAgICBvcHRpb25zOiBPYmplY3QuZnJlZXplKHsgZGlzYWJsZVdhcm5pbmdzIH0pXG4gICAgfSk7XG4gICAgaWYgKCFkaXNhYmxlV2FybmluZ3MpIHtcbiAgICAgICAgZW1pdEVtdWxhdG9yV2FybmluZygpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGV4dHJhY3RQcm90b2NvbCh1cmwpIHtcbiAgICBjb25zdCBwcm90b2NvbEVuZCA9IHVybC5pbmRleE9mKCc6Jyk7XG4gICAgcmV0dXJuIHByb3RvY29sRW5kIDwgMCA/ICcnIDogdXJsLnN1YnN0cigwLCBwcm90b2NvbEVuZCArIDEpO1xufVxuZnVuY3Rpb24gZXh0cmFjdEhvc3RBbmRQb3J0KHVybCkge1xuICAgIGNvbnN0IHByb3RvY29sID0gZXh0cmFjdFByb3RvY29sKHVybCk7XG4gICAgY29uc3QgYXV0aG9yaXR5ID0gLyhcXC9cXC8pPyhbXj8jL10rKS8uZXhlYyh1cmwuc3Vic3RyKHByb3RvY29sLmxlbmd0aCkpOyAvLyBCZXR3ZWVuIC8vIGFuZCAvLCA/IG9yICMuXG4gICAgaWYgKCFhdXRob3JpdHkpIHtcbiAgICAgICAgcmV0dXJuIHsgaG9zdDogJycsIHBvcnQ6IG51bGwgfTtcbiAgICB9XG4gICAgY29uc3QgaG9zdEFuZFBvcnQgPSBhdXRob3JpdHlbMl0uc3BsaXQoJ0AnKS5wb3AoKSB8fCAnJzsgLy8gU3RyaXAgb3V0IFwidXNlcm5hbWU6cGFzc3dvcmRAXCIuXG4gICAgY29uc3QgYnJhY2tldGVkSVB2NiA9IC9eKFxcW1teXFxdXStcXF0pKDp8JCkvLmV4ZWMoaG9zdEFuZFBvcnQpO1xuICAgIGlmIChicmFja2V0ZWRJUHY2KSB7XG4gICAgICAgIGNvbnN0IGhvc3QgPSBicmFja2V0ZWRJUHY2WzFdO1xuICAgICAgICByZXR1cm4geyBob3N0LCBwb3J0OiBwYXJzZVBvcnQoaG9zdEFuZFBvcnQuc3Vic3RyKGhvc3QubGVuZ3RoICsgMSkpIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBbaG9zdCwgcG9ydF0gPSBob3N0QW5kUG9ydC5zcGxpdCgnOicpO1xuICAgICAgICByZXR1cm4geyBob3N0LCBwb3J0OiBwYXJzZVBvcnQocG9ydCkgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZVBvcnQocG9ydFN0cikge1xuICAgIGlmICghcG9ydFN0cikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcG9ydCA9IE51bWJlcihwb3J0U3RyKTtcbiAgICBpZiAoaXNOYU4ocG9ydCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBwb3J0O1xufVxuZnVuY3Rpb24gZW1pdEVtdWxhdG9yV2FybmluZygpIHtcbiAgICBmdW5jdGlvbiBhdHRhY2hCYW5uZXIoKSB7XG4gICAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICAgICAgICBjb25zdCBzdHkgPSBlbC5zdHlsZTtcbiAgICAgICAgZWwuaW5uZXJUZXh0ID1cbiAgICAgICAgICAgICdSdW5uaW5nIGluIGVtdWxhdG9yIG1vZGUuIERvIG5vdCB1c2Ugd2l0aCBwcm9kdWN0aW9uIGNyZWRlbnRpYWxzLic7XG4gICAgICAgIHN0eS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgIHN0eS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgc3R5LmJhY2tncm91bmRDb2xvciA9ICcjZmZmZmZmJztcbiAgICAgICAgc3R5LmJvcmRlciA9ICcuMWVtIHNvbGlkICMwMDAwMDAnO1xuICAgICAgICBzdHkuY29sb3IgPSAnI2I1MDAwMCc7XG4gICAgICAgIHN0eS5ib3R0b20gPSAnMHB4JztcbiAgICAgICAgc3R5LmxlZnQgPSAnMHB4JztcbiAgICAgICAgc3R5Lm1hcmdpbiA9ICcwcHgnO1xuICAgICAgICBzdHkuekluZGV4ID0gJzEwMDAwJztcbiAgICAgICAgc3R5LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdmaXJlYmFzZS1lbXVsYXRvci13YXJuaW5nJyk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmluZm8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKCdXQVJOSU5HOiBZb3UgYXJlIHVzaW5nIHRoZSBBdXRoIEVtdWxhdG9yLCcgK1xuICAgICAgICAgICAgJyB3aGljaCBpcyBpbnRlbmRlZCBmb3IgbG9jYWwgdGVzdGluZyBvbmx5LiAgRG8gbm90IHVzZSB3aXRoJyArXG4gICAgICAgICAgICAnIHByb2R1Y3Rpb24gY3JlZGVudGlhbHMuJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgYXR0YWNoQmFubmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF0dGFjaEJhbm5lcigpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBJbnRlcmZhY2UgdGhhdCByZXByZXNlbnRzIHRoZSBjcmVkZW50aWFscyByZXR1cm5lZCBieSBhbiB7QGxpbmsgQXV0aFByb3ZpZGVyfS5cbiAqXG4gKiBAcmVtYXJrc1xuICogSW1wbGVtZW50YXRpb25zIHNwZWNpZnkgdGhlIGRldGFpbHMgYWJvdXQgZWFjaCBhdXRoIHByb3ZpZGVyJ3MgY3JlZGVudGlhbCByZXF1aXJlbWVudHMuXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBBdXRoQ3JlZGVudGlhbCB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIFRoZSBhdXRoZW50aWNhdGlvbiBwcm92aWRlciBJRCBmb3IgdGhlIGNyZWRlbnRpYWwuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEZvciBleGFtcGxlLCAnZmFjZWJvb2suY29tJywgb3IgJ2dvb2dsZS5jb20nLlxuICAgICAqL1xuICAgIHByb3ZpZGVySWQsIFxuICAgIC8qKlxuICAgICAqIFRoZSBhdXRoZW50aWNhdGlvbiBzaWduIGluIG1ldGhvZCBmb3IgdGhlIGNyZWRlbnRpYWwuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEZvciBleGFtcGxlLCB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9QQVNTV09SRCwgb3JcbiAgICAgKiB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9MSU5LLiBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBzaWduLWluIG1ldGhvZFxuICAgICAqIGlkZW50aWZpZXIgYXMgcmV0dXJuZWQgaW4ge0BsaW5rIGZldGNoU2lnbkluTWV0aG9kc0ZvckVtYWlsfS5cbiAgICAgKi9cbiAgICBzaWduSW5NZXRob2QpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlcklkID0gcHJvdmlkZXJJZDtcbiAgICAgICAgdGhpcy5zaWduSW5NZXRob2QgPSBzaWduSW5NZXRob2Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gZGVidWdGYWlsKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9nZXRJZFRva2VuUmVzcG9uc2UoX2F1dGgpIHtcbiAgICAgICAgcmV0dXJuIGRlYnVnRmFpbCgnbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfbGlua1RvSWRUb2tlbihfYXV0aCwgX2lkVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIGRlYnVnRmFpbCgnbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZ2V0UmVhdXRoZW50aWNhdGlvblJlc29sdmVyKF9hdXRoKSB7XG4gICAgICAgIHJldHVybiBkZWJ1Z0ZhaWwoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlc2V0UGFzc3dvcmQoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpyZXNldFBhc3N3b3JkXCIgLyogRW5kcG9pbnQuUkVTRVRfUEFTU1dPUkQgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5hc3luYyBmdW5jdGlvbiB1cGRhdGVFbWFpbFBhc3N3b3JkKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6dXBkYXRlXCIgLyogRW5kcG9pbnQuU0VUX0FDQ09VTlRfSU5GTyAqLywgcmVxdWVzdCk7XG59XG4vLyBVc2VkIGZvciBsaW5raW5nIGFuIGVtYWlsL3Bhc3N3b3JkIGFjY291bnQgdG8gYW4gZXhpc3RpbmcgaWRUb2tlbi4gVXNlcyB0aGUgc2FtZSByZXF1ZXN0L3Jlc3BvbnNlXG4vLyBmb3JtYXQgYXMgdXBkYXRlRW1haWxQYXNzd29yZC5cbmFzeW5jIGZ1bmN0aW9uIGxpbmtFbWFpbFBhc3N3b3JkKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6c2lnblVwXCIgLyogRW5kcG9pbnQuU0lHTl9VUCAqLywgcmVxdWVzdCk7XG59XG5hc3luYyBmdW5jdGlvbiBhcHBseUFjdGlvbkNvZGUkMShhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnVwZGF0ZVwiIC8qIEVuZHBvaW50LlNFVF9BQ0NPVU5UX0lORk8gKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoUGFzc3dvcmQoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybVNpZ25JblJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpzaWduSW5XaXRoUGFzc3dvcmRcIiAvKiBFbmRwb2ludC5TSUdOX0lOX1dJVEhfUEFTU1dPUkQgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5hc3luYyBmdW5jdGlvbiBzZW5kT29iQ29kZShhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNlbmRPb2JDb2RlXCIgLyogRW5kcG9pbnQuU0VORF9PT0JfQ09ERSAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNlbmRFbWFpbFZlcmlmaWNhdGlvbiQxKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gc2VuZE9vYkNvZGUoYXV0aCwgcmVxdWVzdCk7XG59XG5hc3luYyBmdW5jdGlvbiBzZW5kUGFzc3dvcmRSZXNldEVtYWlsJDEoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBzZW5kT29iQ29kZShhdXRoLCByZXF1ZXN0KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNlbmRTaWduSW5MaW5rVG9FbWFpbCQxKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gc2VuZE9vYkNvZGUoYXV0aCwgcmVxdWVzdCk7XG59XG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlBbmRDaGFuZ2VFbWFpbChhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHNlbmRPb2JDb2RlKGF1dGgsIHJlcXVlc3QpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2lnbkluV2l0aEVtYWlsTGluayQxKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1TaWduSW5SZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6c2lnbkluV2l0aEVtYWlsTGlua1wiIC8qIEVuZHBvaW50LlNJR05fSU5fV0lUSF9FTUFJTF9MSU5LICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuYXN5bmMgZnVuY3Rpb24gc2lnbkluV2l0aEVtYWlsTGlua0ZvckxpbmtpbmcoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybVNpZ25JblJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpzaWduSW5XaXRoRW1haWxMaW5rXCIgLyogRW5kcG9pbnQuU0lHTl9JTl9XSVRIX0VNQUlMX0xJTksgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEludGVyZmFjZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNyZWRlbnRpYWxzIHJldHVybmVkIGJ5IHtAbGluayBFbWFpbEF1dGhQcm92aWRlcn0gZm9yXG4gKiB7QGxpbmsgUHJvdmlkZXJJZH0uUEFTU1dPUkRcbiAqXG4gKiBAcmVtYXJrc1xuICogQ292ZXJzIGJvdGgge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfUEFTU1dPUkQgYW5kXG4gKiB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9MSU5LLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgRW1haWxBdXRoQ3JlZGVudGlhbCBleHRlbmRzIEF1dGhDcmVkZW50aWFsIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9lbWFpbCwgXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9wYXNzd29yZCwgc2lnbkluTWV0aG9kLCBcbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3RlbmFudElkID0gbnVsbCkge1xuICAgICAgICBzdXBlcihcInBhc3N3b3JkXCIgLyogUHJvdmlkZXJJZC5QQVNTV09SRCAqLywgc2lnbkluTWV0aG9kKTtcbiAgICAgICAgdGhpcy5fZW1haWwgPSBfZW1haWw7XG4gICAgICAgIHRoaXMuX3Bhc3N3b3JkID0gX3Bhc3N3b3JkO1xuICAgICAgICB0aGlzLl90ZW5hbnRJZCA9IF90ZW5hbnRJZDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBfZnJvbUVtYWlsQW5kUGFzc3dvcmQoZW1haWwsIHBhc3N3b3JkKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW1haWxBdXRoQ3JlZGVudGlhbChlbWFpbCwgcGFzc3dvcmQsIFwicGFzc3dvcmRcIiAvKiBTaWduSW5NZXRob2QuRU1BSUxfUEFTU1dPUkQgKi8pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIF9mcm9tRW1haWxBbmRDb2RlKGVtYWlsLCBvb2JDb2RlLCB0ZW5hbnRJZCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbWFpbEF1dGhDcmVkZW50aWFsKGVtYWlsLCBvb2JDb2RlLCBcImVtYWlsTGlua1wiIC8qIFNpZ25Jbk1ldGhvZC5FTUFJTF9MSU5LICovLCB0ZW5hbnRJZCk7XG4gICAgfVxuICAgIC8qKiB7QGluaGVyaXRkb2MgQXV0aENyZWRlbnRpYWwudG9KU09OfSAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVtYWlsOiB0aGlzLl9lbWFpbCxcbiAgICAgICAgICAgIHBhc3N3b3JkOiB0aGlzLl9wYXNzd29yZCxcbiAgICAgICAgICAgIHNpZ25Jbk1ldGhvZDogdGhpcy5zaWduSW5NZXRob2QsXG4gICAgICAgICAgICB0ZW5hbnRJZDogdGhpcy5fdGVuYW50SWRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIG1ldGhvZCB0byBkZXNlcmlhbGl6ZSBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0IGludG8gYW4ge0BsaW5rICBBdXRoQ3JlZGVudGlhbH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ganNvbiAtIEVpdGhlciBgb2JqZWN0YCBvciB0aGUgc3RyaW5naWZpZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdC4gV2hlbiBzdHJpbmcgaXNcbiAgICAgKiBwcm92aWRlZCwgYEpTT04ucGFyc2VgIHdvdWxkIGJlIGNhbGxlZCBmaXJzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIElmIHRoZSBKU09OIGlucHV0IGRvZXMgbm90IHJlcHJlc2VudCBhbiB7QGxpbmsgQXV0aENyZWRlbnRpYWx9LCBudWxsIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoanNvbikgOiBqc29uO1xuICAgICAgICBpZiAoKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iai5lbWFpbCkgJiYgKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iai5wYXNzd29yZCkpIHtcbiAgICAgICAgICAgIGlmIChvYmouc2lnbkluTWV0aG9kID09PSBcInBhc3N3b3JkXCIgLyogU2lnbkluTWV0aG9kLkVNQUlMX1BBU1NXT1JEICovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Zyb21FbWFpbEFuZFBhc3N3b3JkKG9iai5lbWFpbCwgb2JqLnBhc3N3b3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9iai5zaWduSW5NZXRob2QgPT09IFwiZW1haWxMaW5rXCIgLyogU2lnbkluTWV0aG9kLkVNQUlMX0xJTksgKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZnJvbUVtYWlsQW5kQ29kZShvYmouZW1haWwsIG9iai5wYXNzd29yZCwgb2JqLnRlbmFudElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGFzeW5jIF9nZXRJZFRva2VuUmVzcG9uc2UoYXV0aCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc2lnbkluTWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIFwicGFzc3dvcmRcIiAvKiBTaWduSW5NZXRob2QuRU1BSUxfUEFTU1dPUkQgKi86XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVtYWlsOiB0aGlzLl9lbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHRoaXMuX3Bhc3N3b3JkLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRUeXBlOiBcIkNMSUVOVF9UWVBFX1dFQlwiIC8qIFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCICovXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlUmVjYXB0Y2hhRmxvdyhhdXRoLCByZXF1ZXN0LCBcInNpZ25JbldpdGhQYXNzd29yZFwiIC8qIFJlY2FwdGNoYUFjdGlvbk5hbWUuU0lHTl9JTl9XSVRIX1BBU1NXT1JEICovLCBzaWduSW5XaXRoUGFzc3dvcmQsIFwiRU1BSUxfUEFTU1dPUkRfUFJPVklERVJcIiAvKiBSZWNhcHRjaGFBdXRoUHJvdmlkZXIuRU1BSUxfUEFTU1dPUkRfUFJPVklERVIgKi8pO1xuICAgICAgICAgICAgY2FzZSBcImVtYWlsTGlua1wiIC8qIFNpZ25Jbk1ldGhvZC5FTUFJTF9MSU5LICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBzaWduSW5XaXRoRW1haWxMaW5rJDEoYXV0aCwge1xuICAgICAgICAgICAgICAgICAgICBlbWFpbDogdGhpcy5fZW1haWwsXG4gICAgICAgICAgICAgICAgICAgIG9vYkNvZGU6IHRoaXMuX3Bhc3N3b3JkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIF9mYWlsKGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgYXN5bmMgX2xpbmtUb0lkVG9rZW4oYXV0aCwgaWRUb2tlbikge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc2lnbkluTWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIFwicGFzc3dvcmRcIiAvKiBTaWduSW5NZXRob2QuRU1BSUxfUEFTU1dPUkQgKi86XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWRUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVtYWlsOiB0aGlzLl9lbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHRoaXMuX3Bhc3N3b3JkLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRUeXBlOiBcIkNMSUVOVF9UWVBFX1dFQlwiIC8qIFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCICovXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlUmVjYXB0Y2hhRmxvdyhhdXRoLCByZXF1ZXN0LCBcInNpZ25VcFBhc3N3b3JkXCIgLyogUmVjYXB0Y2hhQWN0aW9uTmFtZS5TSUdOX1VQX1BBU1NXT1JEICovLCBsaW5rRW1haWxQYXNzd29yZCwgXCJFTUFJTF9QQVNTV09SRF9QUk9WSURFUlwiIC8qIFJlY2FwdGNoYUF1dGhQcm92aWRlci5FTUFJTF9QQVNTV09SRF9QUk9WSURFUiAqLyk7XG4gICAgICAgICAgICBjYXNlIFwiZW1haWxMaW5rXCIgLyogU2lnbkluTWV0aG9kLkVNQUlMX0xJTksgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25JbldpdGhFbWFpbExpbmtGb3JMaW5raW5nKGF1dGgsIHtcbiAgICAgICAgICAgICAgICAgICAgaWRUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgZW1haWw6IHRoaXMuX2VtYWlsLFxuICAgICAgICAgICAgICAgICAgICBvb2JDb2RlOiB0aGlzLl9wYXNzd29yZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBfZmFpbChhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9nZXRSZWF1dGhlbnRpY2F0aW9uUmVzb2x2ZXIoYXV0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SWRUb2tlblJlc3BvbnNlKGF1dGgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhJZHAoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybVNpZ25JblJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpzaWduSW5XaXRoSWRwXCIgLyogRW5kcG9pbnQuU0lHTl9JTl9XSVRIX0lEUCAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IElEUF9SRVFVRVNUX1VSSSQxID0gJ2h0dHA6Ly9sb2NhbGhvc3QnO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBPQXV0aCBjcmVkZW50aWFscyByZXR1cm5lZCBieSBhbiB7QGxpbmsgT0F1dGhQcm92aWRlcn0uXG4gKlxuICogQHJlbWFya3NcbiAqIEltcGxlbWVudGF0aW9ucyBzcGVjaWZ5IHRoZSBkZXRhaWxzIGFib3V0IGVhY2ggYXV0aCBwcm92aWRlcidzIGNyZWRlbnRpYWwgcmVxdWlyZW1lbnRzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgT0F1dGhDcmVkZW50aWFsIGV4dGVuZHMgQXV0aENyZWRlbnRpYWwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnBlbmRpbmdUb2tlbiA9IG51bGw7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgX2Zyb21QYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGNyZWQgPSBuZXcgT0F1dGhDcmVkZW50aWFsKHBhcmFtcy5wcm92aWRlcklkLCBwYXJhbXMuc2lnbkluTWV0aG9kKTtcbiAgICAgICAgaWYgKHBhcmFtcy5pZFRva2VuIHx8IHBhcmFtcy5hY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgLy8gT0F1dGggMiBhbmQgZWl0aGVyIElEIHRva2VuIG9yIGFjY2VzcyB0b2tlbi5cbiAgICAgICAgICAgIGlmIChwYXJhbXMuaWRUb2tlbikge1xuICAgICAgICAgICAgICAgIGNyZWQuaWRUb2tlbiA9IHBhcmFtcy5pZFRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtcy5hY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgICAgIGNyZWQuYWNjZXNzVG9rZW4gPSBwYXJhbXMuYWNjZXNzVG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgbm9uY2UgaWYgYXZhaWxhYmxlIGFuZCBubyBwZW5kaW5nVG9rZW4gaXMgcHJlc2VudC5cbiAgICAgICAgICAgIGlmIChwYXJhbXMubm9uY2UgJiYgIXBhcmFtcy5wZW5kaW5nVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjcmVkLm5vbmNlID0gcGFyYW1zLm5vbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtcy5wZW5kaW5nVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjcmVkLnBlbmRpbmdUb2tlbiA9IHBhcmFtcy5wZW5kaW5nVG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyYW1zLm9hdXRoVG9rZW4gJiYgcGFyYW1zLm9hdXRoVG9rZW5TZWNyZXQpIHtcbiAgICAgICAgICAgIC8vIE9BdXRoIDEgYW5kIE9BdXRoIHRva2VuIHdpdGggdG9rZW4gc2VjcmV0XG4gICAgICAgICAgICBjcmVkLmFjY2Vzc1Rva2VuID0gcGFyYW1zLm9hdXRoVG9rZW47XG4gICAgICAgICAgICBjcmVkLnNlY3JldCA9IHBhcmFtcy5vYXV0aFRva2VuU2VjcmV0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX2ZhaWwoXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVkO1xuICAgIH1cbiAgICAvKioge0Bpbmhlcml0ZG9jIEF1dGhDcmVkZW50aWFsLnRvSlNPTn0gICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWRUb2tlbjogdGhpcy5pZFRva2VuLFxuICAgICAgICAgICAgYWNjZXNzVG9rZW46IHRoaXMuYWNjZXNzVG9rZW4sXG4gICAgICAgICAgICBzZWNyZXQ6IHRoaXMuc2VjcmV0LFxuICAgICAgICAgICAgbm9uY2U6IHRoaXMubm9uY2UsXG4gICAgICAgICAgICBwZW5kaW5nVG9rZW46IHRoaXMucGVuZGluZ1Rva2VuLFxuICAgICAgICAgICAgcHJvdmlkZXJJZDogdGhpcy5wcm92aWRlcklkLFxuICAgICAgICAgICAgc2lnbkluTWV0aG9kOiB0aGlzLnNpZ25Jbk1ldGhvZFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgbWV0aG9kIHRvIGRlc2VyaWFsaXplIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhbiBvYmplY3QgaW50byBhblxuICAgICAqIHtAbGluayAgQXV0aENyZWRlbnRpYWx9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGpzb24gLSBJbnB1dCBjYW4gYmUgZWl0aGVyIE9iamVjdCBvciB0aGUgc3RyaW5naWZpZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdC5cbiAgICAgKiBXaGVuIHN0cmluZyBpcyBwcm92aWRlZCwgSlNPTi5wYXJzZSB3b3VsZCBiZSBjYWxsZWQgZmlyc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBJZiB0aGUgSlNPTiBpbnB1dCBkb2VzIG5vdCByZXByZXNlbnQgYW4ge0BsaW5rICBBdXRoQ3JlZGVudGlhbH0sIG51bGwgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgY29uc3Qgb2JqID0gdHlwZW9mIGpzb24gPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShqc29uKSA6IGpzb247XG4gICAgICAgIGNvbnN0IHsgcHJvdmlkZXJJZCwgc2lnbkluTWV0aG9kIH0gPSBvYmosIHJlc3QgPSBfX3Jlc3Qob2JqLCBbXCJwcm92aWRlcklkXCIsIFwic2lnbkluTWV0aG9kXCJdKTtcbiAgICAgICAgaWYgKCFwcm92aWRlcklkIHx8ICFzaWduSW5NZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNyZWQgPSBuZXcgT0F1dGhDcmVkZW50aWFsKHByb3ZpZGVySWQsIHNpZ25Jbk1ldGhvZCk7XG4gICAgICAgIGNyZWQuaWRUb2tlbiA9IHJlc3QuaWRUb2tlbiB8fCB1bmRlZmluZWQ7XG4gICAgICAgIGNyZWQuYWNjZXNzVG9rZW4gPSByZXN0LmFjY2Vzc1Rva2VuIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgY3JlZC5zZWNyZXQgPSByZXN0LnNlY3JldDtcbiAgICAgICAgY3JlZC5ub25jZSA9IHJlc3Qubm9uY2U7XG4gICAgICAgIGNyZWQucGVuZGluZ1Rva2VuID0gcmVzdC5wZW5kaW5nVG9rZW4gfHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIGNyZWQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZ2V0SWRUb2tlblJlc3BvbnNlKGF1dGgpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuYnVpbGRSZXF1ZXN0KCk7XG4gICAgICAgIHJldHVybiBzaWduSW5XaXRoSWRwKGF1dGgsIHJlcXVlc3QpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2xpbmtUb0lkVG9rZW4oYXV0aCwgaWRUb2tlbikge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5idWlsZFJlcXVlc3QoKTtcbiAgICAgICAgcmVxdWVzdC5pZFRva2VuID0gaWRUb2tlbjtcbiAgICAgICAgcmV0dXJuIHNpZ25JbldpdGhJZHAoYXV0aCwgcmVxdWVzdCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZ2V0UmVhdXRoZW50aWNhdGlvblJlc29sdmVyKGF1dGgpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuYnVpbGRSZXF1ZXN0KCk7XG4gICAgICAgIHJlcXVlc3QuYXV0b0NyZWF0ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gc2lnbkluV2l0aElkcChhdXRoLCByZXF1ZXN0KTtcbiAgICB9XG4gICAgYnVpbGRSZXF1ZXN0KCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgcmVxdWVzdFVyaTogSURQX1JFUVVFU1RfVVJJJDEsXG4gICAgICAgICAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nVG9rZW4pIHtcbiAgICAgICAgICAgIHJlcXVlc3QucGVuZGluZ1Rva2VuID0gdGhpcy5wZW5kaW5nVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwb3N0Qm9keSA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuaWRUb2tlbikge1xuICAgICAgICAgICAgICAgIHBvc3RCb2R5WydpZF90b2tlbiddID0gdGhpcy5pZFRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBwb3N0Qm9keVsnYWNjZXNzX3Rva2VuJ10gPSB0aGlzLmFjY2Vzc1Rva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2VjcmV0KSB7XG4gICAgICAgICAgICAgICAgcG9zdEJvZHlbJ29hdXRoX3Rva2VuX3NlY3JldCddID0gdGhpcy5zZWNyZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3N0Qm9keVsncHJvdmlkZXJJZCddID0gdGhpcy5wcm92aWRlcklkO1xuICAgICAgICAgICAgaWYgKHRoaXMubm9uY2UgJiYgIXRoaXMucGVuZGluZ1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgcG9zdEJvZHlbJ25vbmNlJ10gPSB0aGlzLm5vbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxdWVzdC5wb3N0Qm9keSA9IHF1ZXJ5c3RyaW5nKHBvc3RCb2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoUGhvbmVOdW1iZXIkMShhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25JbldpdGhQaG9uZU51bWJlclwiIC8qIEVuZHBvaW50LlNJR05fSU5fV0lUSF9QSE9ORV9OVU1CRVIgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5hc3luYyBmdW5jdGlvbiBsaW5rV2l0aFBob25lTnVtYmVyJDEoYXV0aCwgcmVxdWVzdCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX3BlcmZvcm1TaWduSW5SZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6c2lnbkluV2l0aFBob25lTnVtYmVyXCIgLyogRW5kcG9pbnQuU0lHTl9JTl9XSVRIX1BIT05FX05VTUJFUiAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcbiAgICBpZiAocmVzcG9uc2UudGVtcG9yYXJ5UHJvb2YpIHtcbiAgICAgICAgdGhyb3cgX21ha2VUYWdnZWRFcnJvcihhdXRoLCBcImFjY291bnQtZXhpc3RzLXdpdGgtZGlmZmVyZW50LWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLk5FRURfQ09ORklSTUFUSU9OICovLCByZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbn1cbmNvbnN0IFZFUklGWV9QSE9ORV9OVU1CRVJfRk9SX0VYSVNUSU5HX0VSUk9SX01BUF8gPSB7XG4gICAgW1wiVVNFUl9OT1RfRk9VTkRcIiAvKiBTZXJ2ZXJFcnJvci5VU0VSX05PVF9GT1VORCAqL106IFwidXNlci1ub3QtZm91bmRcIiAvKiBBdXRoRXJyb3JDb2RlLlVTRVJfREVMRVRFRCAqL1xufTtcbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeVBob25lTnVtYmVyRm9yRXhpc3RpbmcoYXV0aCwgcmVxdWVzdCkge1xuICAgIGNvbnN0IGFwaVJlcXVlc3QgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3QpLCB7IG9wZXJhdGlvbjogJ1JFQVVUSCcgfSk7XG4gICAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25JbldpdGhQaG9uZU51bWJlclwiIC8qIEVuZHBvaW50LlNJR05fSU5fV0lUSF9QSE9ORV9OVU1CRVIgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCBhcGlSZXF1ZXN0KSwgVkVSSUZZX1BIT05FX05VTUJFUl9GT1JfRVhJU1RJTkdfRVJST1JfTUFQXyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGNyZWRlbnRpYWxzIHJldHVybmVkIGJ5IHtAbGluayBQaG9uZUF1dGhQcm92aWRlcn0uXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBQaG9uZUF1dGhDcmVkZW50aWFsIGV4dGVuZHMgQXV0aENyZWRlbnRpYWwge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBzdXBlcihcInBob25lXCIgLyogUHJvdmlkZXJJZC5QSE9ORSAqLywgXCJwaG9uZVwiIC8qIFNpZ25Jbk1ldGhvZC5QSE9ORSAqLyk7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIF9mcm9tVmVyaWZpY2F0aW9uKHZlcmlmaWNhdGlvbklkLCB2ZXJpZmljYXRpb25Db2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGhvbmVBdXRoQ3JlZGVudGlhbCh7IHZlcmlmaWNhdGlvbklkLCB2ZXJpZmljYXRpb25Db2RlIH0pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIF9mcm9tVG9rZW5SZXNwb25zZShwaG9uZU51bWJlciwgdGVtcG9yYXJ5UHJvb2YpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQaG9uZUF1dGhDcmVkZW50aWFsKHsgcGhvbmVOdW1iZXIsIHRlbXBvcmFyeVByb29mIH0pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldElkVG9rZW5SZXNwb25zZShhdXRoKSB7XG4gICAgICAgIHJldHVybiBzaWduSW5XaXRoUGhvbmVOdW1iZXIkMShhdXRoLCB0aGlzLl9tYWtlVmVyaWZpY2F0aW9uUmVxdWVzdCgpKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9saW5rVG9JZFRva2VuKGF1dGgsIGlkVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIGxpbmtXaXRoUGhvbmVOdW1iZXIkMShhdXRoLCBPYmplY3QuYXNzaWduKHsgaWRUb2tlbiB9LCB0aGlzLl9tYWtlVmVyaWZpY2F0aW9uUmVxdWVzdCgpKSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZ2V0UmVhdXRoZW50aWNhdGlvblJlc29sdmVyKGF1dGgpIHtcbiAgICAgICAgcmV0dXJuIHZlcmlmeVBob25lTnVtYmVyRm9yRXhpc3RpbmcoYXV0aCwgdGhpcy5fbWFrZVZlcmlmaWNhdGlvblJlcXVlc3QoKSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfbWFrZVZlcmlmaWNhdGlvblJlcXVlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgdGVtcG9yYXJ5UHJvb2YsIHBob25lTnVtYmVyLCB2ZXJpZmljYXRpb25JZCwgdmVyaWZpY2F0aW9uQ29kZSB9ID0gdGhpcy5wYXJhbXM7XG4gICAgICAgIGlmICh0ZW1wb3JhcnlQcm9vZiAmJiBwaG9uZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgdGVtcG9yYXJ5UHJvb2YsIHBob25lTnVtYmVyIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlc3Npb25JbmZvOiB2ZXJpZmljYXRpb25JZCxcbiAgICAgICAgICAgIGNvZGU6IHZlcmlmaWNhdGlvbkNvZGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqIHtAaW5oZXJpdGRvYyBBdXRoQ3JlZGVudGlhbC50b0pTT059ICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgICAgICBwcm92aWRlcklkOiB0aGlzLnByb3ZpZGVySWRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLnBob25lTnVtYmVyKSB7XG4gICAgICAgICAgICBvYmoucGhvbmVOdW1iZXIgPSB0aGlzLnBhcmFtcy5waG9uZU51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXJhbXMudGVtcG9yYXJ5UHJvb2YpIHtcbiAgICAgICAgICAgIG9iai50ZW1wb3JhcnlQcm9vZiA9IHRoaXMucGFyYW1zLnRlbXBvcmFyeVByb29mO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy52ZXJpZmljYXRpb25Db2RlKSB7XG4gICAgICAgICAgICBvYmoudmVyaWZpY2F0aW9uQ29kZSA9IHRoaXMucGFyYW1zLnZlcmlmaWNhdGlvbkNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLnZlcmlmaWNhdGlvbklkKSB7XG4gICAgICAgICAgICBvYmoudmVyaWZpY2F0aW9uSWQgPSB0aGlzLnBhcmFtcy52ZXJpZmljYXRpb25JZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvKiogR2VuZXJhdGVzIGEgcGhvbmUgY3JlZGVudGlhbCBiYXNlZCBvbiBhIHBsYWluIG9iamVjdCBvciBhIEpTT04gc3RyaW5nLiAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGpzb24gPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdmVyaWZpY2F0aW9uSWQsIHZlcmlmaWNhdGlvbkNvZGUsIHBob25lTnVtYmVyLCB0ZW1wb3JhcnlQcm9vZiB9ID0ganNvbjtcbiAgICAgICAgaWYgKCF2ZXJpZmljYXRpb25Db2RlICYmXG4gICAgICAgICAgICAhdmVyaWZpY2F0aW9uSWQgJiZcbiAgICAgICAgICAgICFwaG9uZU51bWJlciAmJlxuICAgICAgICAgICAgIXRlbXBvcmFyeVByb29mKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBob25lQXV0aENyZWRlbnRpYWwoe1xuICAgICAgICAgICAgdmVyaWZpY2F0aW9uSWQsXG4gICAgICAgICAgICB2ZXJpZmljYXRpb25Db2RlLFxuICAgICAgICAgICAgcGhvbmVOdW1iZXIsXG4gICAgICAgICAgICB0ZW1wb3JhcnlQcm9vZlxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIE1hcHMgdGhlIG1vZGUgc3RyaW5nIGluIGFjdGlvbiBjb2RlIFVSTCB0byBBY3Rpb24gQ29kZSBJbmZvIG9wZXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0gbW9kZVxuICovXG5mdW5jdGlvbiBwYXJzZU1vZGUobW9kZSkge1xuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICBjYXNlICdyZWNvdmVyRW1haWwnOlxuICAgICAgICAgICAgcmV0dXJuIFwiUkVDT1ZFUl9FTUFJTFwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uUkVDT1ZFUl9FTUFJTCAqLztcbiAgICAgICAgY2FzZSAncmVzZXRQYXNzd29yZCc6XG4gICAgICAgICAgICByZXR1cm4gXCJQQVNTV09SRF9SRVNFVFwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uUEFTU1dPUkRfUkVTRVQgKi87XG4gICAgICAgIGNhc2UgJ3NpZ25Jbic6XG4gICAgICAgICAgICByZXR1cm4gXCJFTUFJTF9TSUdOSU5cIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLkVNQUlMX1NJR05JTiAqLztcbiAgICAgICAgY2FzZSAndmVyaWZ5RW1haWwnOlxuICAgICAgICAgICAgcmV0dXJuIFwiVkVSSUZZX0VNQUlMXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfRU1BSUwgKi87XG4gICAgICAgIGNhc2UgJ3ZlcmlmeUFuZENoYW5nZUVtYWlsJzpcbiAgICAgICAgICAgIHJldHVybiBcIlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfQU5EX0NIQU5HRV9FTUFJTCAqLztcbiAgICAgICAgY2FzZSAncmV2ZXJ0U2Vjb25kRmFjdG9yQWRkaXRpb24nOlxuICAgICAgICAgICAgcmV0dXJuIFwiUkVWRVJUX1NFQ09ORF9GQUNUT1JfQURESVRJT05cIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlJFVkVSVF9TRUNPTkRfRkFDVE9SX0FERElUSU9OICovO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdG8gcGFyc2UgRkRMIGxpbmtzXG4gKlxuICogQHBhcmFtIHVybFxuICovXG5mdW5jdGlvbiBwYXJzZURlZXBMaW5rKHVybCkge1xuICAgIGNvbnN0IGxpbmsgPSBxdWVyeXN0cmluZ0RlY29kZShleHRyYWN0UXVlcnlzdHJpbmcodXJsKSlbJ2xpbmsnXTtcbiAgICAvLyBEb3VibGUgbGluayBjYXNlIChhdXRvbWF0aWMgcmVkaXJlY3QpLlxuICAgIGNvbnN0IGRvdWJsZURlZXBMaW5rID0gbGlua1xuICAgICAgICA/IHF1ZXJ5c3RyaW5nRGVjb2RlKGV4dHJhY3RRdWVyeXN0cmluZyhsaW5rKSlbJ2RlZXBfbGlua19pZCddXG4gICAgICAgIDogbnVsbDtcbiAgICAvLyBpT1MgY3VzdG9tIHNjaGVtZSBsaW5rcy5cbiAgICBjb25zdCBpT1NEZWVwTGluayA9IHF1ZXJ5c3RyaW5nRGVjb2RlKGV4dHJhY3RRdWVyeXN0cmluZyh1cmwpKVsnZGVlcF9saW5rX2lkJ107XG4gICAgY29uc3QgaU9TRG91YmxlRGVlcExpbmsgPSBpT1NEZWVwTGlua1xuICAgICAgICA/IHF1ZXJ5c3RyaW5nRGVjb2RlKGV4dHJhY3RRdWVyeXN0cmluZyhpT1NEZWVwTGluaykpWydsaW5rJ11cbiAgICAgICAgOiBudWxsO1xuICAgIHJldHVybiBpT1NEb3VibGVEZWVwTGluayB8fCBpT1NEZWVwTGluayB8fCBkb3VibGVEZWVwTGluayB8fCBsaW5rIHx8IHVybDtcbn1cbi8qKlxuICogQSB1dGlsaXR5IGNsYXNzIHRvIHBhcnNlIGVtYWlsIGFjdGlvbiBVUkxzIHN1Y2ggYXMgcGFzc3dvcmQgcmVzZXQsIGVtYWlsIHZlcmlmaWNhdGlvbixcbiAqIGVtYWlsIGxpbmsgc2lnbiBpbiwgZXRjLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgQWN0aW9uQ29kZVVSTCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFjdGlvbkxpbmsgLSBUaGUgbGluayBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgdGhlIFVSTC5cbiAgICAgKiBAcmV0dXJucyBUaGUge0BsaW5rIEFjdGlvbkNvZGVVUkx9IG9iamVjdCwgb3IgbnVsbCBpZiB0aGUgbGluayBpcyBpbnZhbGlkLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWN0aW9uTGluaykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gcXVlcnlzdHJpbmdEZWNvZGUoZXh0cmFjdFF1ZXJ5c3RyaW5nKGFjdGlvbkxpbmspKTtcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gKF9hID0gc2VhcmNoUGFyYW1zW1wiYXBpS2V5XCIgLyogUXVlcnlGaWVsZC5BUElfS0VZICovXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICAgICAgY29uc3QgY29kZSA9IChfYiA9IHNlYXJjaFBhcmFtc1tcIm9vYkNvZGVcIiAvKiBRdWVyeUZpZWxkLkNPREUgKi9dKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBwYXJzZU1vZGUoKF9jID0gc2VhcmNoUGFyYW1zW1wibW9kZVwiIC8qIFF1ZXJ5RmllbGQuTU9ERSAqL10pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGwpO1xuICAgICAgICAvLyBWYWxpZGF0ZSBBUEkga2V5LCBjb2RlIGFuZCBtb2RlLlxuICAgICAgICBfYXNzZXJ0KGFwaUtleSAmJiBjb2RlICYmIG9wZXJhdGlvbiwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xuICAgICAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcbiAgICAgICAgdGhpcy5vcGVyYXRpb24gPSBvcGVyYXRpb247XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMuY29udGludWVVcmwgPSAoX2QgPSBzZWFyY2hQYXJhbXNbXCJjb250aW51ZVVybFwiIC8qIFF1ZXJ5RmllbGQuQ09OVElOVUVfVVJMICovXSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogbnVsbDtcbiAgICAgICAgdGhpcy5sYW5ndWFnZUNvZGUgPSAoX2UgPSBzZWFyY2hQYXJhbXNbXCJsYW5ndWFnZUNvZGVcIiAvKiBRdWVyeUZpZWxkLkxBTkdVQUdFX0NPREUgKi9dKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBudWxsO1xuICAgICAgICB0aGlzLnRlbmFudElkID0gKF9mID0gc2VhcmNoUGFyYW1zW1widGVuYW50SWRcIiAvKiBRdWVyeUZpZWxkLlRFTkFOVF9JRCAqL10pICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgZW1haWwgYWN0aW9uIGxpbmsgc3RyaW5nIGFuZCByZXR1cm5zIGFuIHtAbGluayBBY3Rpb25Db2RlVVJMfSBpZiB0aGUgbGluayBpcyB2YWxpZCxcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJucyBudWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxpbmsgIC0gVGhlIGVtYWlsIGFjdGlvbiBsaW5rIHN0cmluZy5cbiAgICAgKiBAcmV0dXJucyBUaGUge0BsaW5rIEFjdGlvbkNvZGVVUkx9IG9iamVjdCwgb3IgbnVsbCBpZiB0aGUgbGluayBpcyBpbnZhbGlkLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZUxpbmsobGluaykge1xuICAgICAgICBjb25zdCBhY3Rpb25MaW5rID0gcGFyc2VEZWVwTGluayhsaW5rKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aW9uQ29kZVVSTChhY3Rpb25MaW5rKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBQYXJzZXMgdGhlIGVtYWlsIGFjdGlvbiBsaW5rIHN0cmluZyBhbmQgcmV0dXJucyBhbiB7QGxpbmsgQWN0aW9uQ29kZVVSTH0gaWZcbiAqIHRoZSBsaW5rIGlzIHZhbGlkLCBvdGhlcndpc2UgcmV0dXJucyBudWxsLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcGFyc2VBY3Rpb25Db2RlVVJMKGxpbmspIHtcbiAgICByZXR1cm4gQWN0aW9uQ29kZVVSTC5wYXJzZUxpbmsobGluayk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIHtAbGluayBFbWFpbEF1dGhDcmVkZW50aWFsfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEVtYWlsQXV0aFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFByb3ZpZGVySWR9LlBBU1NXT1JELCBldmVuIGZvciBlbWFpbCBsaW5rLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm92aWRlcklkID0gRW1haWxBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgYW4ge0BsaW5rIEF1dGhDcmVkZW50aWFsfSB1c2luZyBhbiBlbWFpbCBhbmQgcGFzc3dvcmQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiBjb25zdCBhdXRoQ3JlZGVudGlhbCA9IEVtYWlsQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWwoZW1haWwsIHBhc3N3b3JkKTtcbiAgICAgKiBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IHNpZ25JbldpdGhDcmVkZW50aWFsKGF1dGgsIGF1dGhDcmVkZW50aWFsKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgc2lnbkluV2l0aEVtYWlsQW5kUGFzc3dvcmQoYXV0aCwgZW1haWwsIHBhc3N3b3JkKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbWFpbCAtIEVtYWlsIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIHBhc3N3b3JkIC0gVXNlciBhY2NvdW50IHBhc3N3b3JkLlxuICAgICAqIEByZXR1cm5zIFRoZSBhdXRoIHByb3ZpZGVyIGNyZWRlbnRpYWwuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWwoZW1haWwsIHBhc3N3b3JkKSB7XG4gICAgICAgIHJldHVybiBFbWFpbEF1dGhDcmVkZW50aWFsLl9mcm9tRW1haWxBbmRQYXNzd29yZChlbWFpbCwgcGFzc3dvcmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGFuIHtAbGluayBBdXRoQ3JlZGVudGlhbH0gdXNpbmcgYW4gZW1haWwgYW5kIGFuIGVtYWlsIGxpbmsgYWZ0ZXIgYSBzaWduIGluIHdpdGhcbiAgICAgKiBlbWFpbCBsaW5rIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIGNvbnN0IGF1dGhDcmVkZW50aWFsID0gRW1haWxBdXRoUHJvdmlkZXIuY3JlZGVudGlhbFdpdGhMaW5rKGF1dGgsIGVtYWlsLCBlbWFpbExpbmspO1xuICAgICAqIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgc2lnbkluV2l0aENyZWRlbnRpYWwoYXV0aCwgYXV0aENyZWRlbnRpYWwpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqYXZhc2NyaXB0XG4gICAgICogYXdhaXQgc2VuZFNpZ25JbkxpbmtUb0VtYWlsKGF1dGgsIGVtYWlsKTtcbiAgICAgKiAvLyBPYnRhaW4gZW1haWxMaW5rIGZyb20gdXNlci5cbiAgICAgKiBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IHNpZ25JbldpdGhFbWFpbExpbmsoYXV0aCwgZW1haWwsIGVtYWlsTGluayk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UgdXNlZCB0byB2ZXJpZnkgdGhlIGxpbmsuXG4gICAgICogQHBhcmFtIGVtYWlsIC0gRW1haWwgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gZW1haWxMaW5rIC0gU2lnbi1pbiBlbWFpbCBsaW5rLlxuICAgICAqIEByZXR1cm5zIC0gVGhlIGF1dGggcHJvdmlkZXIgY3JlZGVudGlhbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlZGVudGlhbFdpdGhMaW5rKGVtYWlsLCBlbWFpbExpbmspIHtcbiAgICAgICAgY29uc3QgYWN0aW9uQ29kZVVybCA9IEFjdGlvbkNvZGVVUkwucGFyc2VMaW5rKGVtYWlsTGluayk7XG4gICAgICAgIF9hc3NlcnQoYWN0aW9uQ29kZVVybCwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xuICAgICAgICByZXR1cm4gRW1haWxBdXRoQ3JlZGVudGlhbC5fZnJvbUVtYWlsQW5kQ29kZShlbWFpbCwgYWN0aW9uQ29kZVVybC5jb2RlLCBhY3Rpb25Db2RlVXJsLnRlbmFudElkKTtcbiAgICB9XG59XG4vKipcbiAqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFByb3ZpZGVySWR9LlBBU1NXT1JELCBldmVuIGZvciBlbWFpbCBsaW5rLlxuICovXG5FbWFpbEF1dGhQcm92aWRlci5QUk9WSURFUl9JRCA9IFwicGFzc3dvcmRcIiAvKiBQcm92aWRlcklkLlBBU1NXT1JEICovO1xuLyoqXG4gKiBBbHdheXMgc2V0IHRvIHtAbGluayBTaWduSW5NZXRob2R9LkVNQUlMX1BBU1NXT1JELlxuICovXG5FbWFpbEF1dGhQcm92aWRlci5FTUFJTF9QQVNTV09SRF9TSUdOX0lOX01FVEhPRCA9IFwicGFzc3dvcmRcIiAvKiBTaWduSW5NZXRob2QuRU1BSUxfUEFTU1dPUkQgKi87XG4vKipcbiAqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfTElOSy5cbiAqL1xuRW1haWxBdXRoUHJvdmlkZXIuRU1BSUxfTElOS19TSUdOX0lOX01FVEhPRCA9IFwiZW1haWxMaW5rXCIgLyogU2lnbkluTWV0aG9kLkVNQUlMX0xJTksgKi87XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBhbGwgRmVkZXJhdGVkIHByb3ZpZGVycyAoT0F1dGggKGluY2x1ZGluZyBPSURDKSwgU0FNTCkuXG4gKlxuICogVGhpcyBjbGFzcyBpcyBub3QgbWVhbnQgdG8gYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgRmVkZXJhdGVkQXV0aFByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgZ2VuZXJpYyBPQXV0aCBwcm92aWRlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvdmlkZXJJZCAtIFByb3ZpZGVyIGZvciB3aGljaCBjcmVkZW50aWFscyBzaG91bGQgYmUgZ2VuZXJhdGVkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVySWQpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlcklkID0gcHJvdmlkZXJJZDtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLmRlZmF1bHRMYW5ndWFnZUNvZGUgPSBudWxsO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuY3VzdG9tUGFyYW1ldGVycyA9IHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGxhbmd1YWdlIGdvZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2VDb2RlIC0gbGFuZ3VhZ2UgY29kZVxuICAgICAqL1xuICAgIHNldERlZmF1bHRMYW5ndWFnZShsYW5ndWFnZUNvZGUpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0TGFuZ3VhZ2VDb2RlID0gbGFuZ3VhZ2VDb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBPQXV0aCBjdXN0b20gcGFyYW1ldGVycyB0byBwYXNzIGluIGFuIE9BdXRoIHJlcXVlc3QgZm9yIHBvcHVwIGFuZCByZWRpcmVjdCBzaWduLWluXG4gICAgICogb3BlcmF0aW9ucy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogRm9yIGEgZGV0YWlsZWQgbGlzdCwgY2hlY2sgdGhlIHJlc2VydmVkIHJlcXVpcmVkIE9BdXRoIDIuMCBwYXJhbWV0ZXJzIHN1Y2ggYXMgYGNsaWVudF9pZGAsXG4gICAgICogYHJlZGlyZWN0X3VyaWAsIGBzY29wZWAsIGByZXNwb25zZV90eXBlYCwgYW5kIGBzdGF0ZWAgYXJlIG5vdCBhbGxvd2VkIGFuZCB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY3VzdG9tT0F1dGhQYXJhbWV0ZXJzIC0gVGhlIGN1c3RvbSBPQXV0aCBwYXJhbWV0ZXJzIHRvIHBhc3MgaW4gdGhlIE9BdXRoIHJlcXVlc3QuXG4gICAgICovXG4gICAgc2V0Q3VzdG9tUGFyYW1ldGVycyhjdXN0b21PQXV0aFBhcmFtZXRlcnMpIHtcbiAgICAgICAgdGhpcy5jdXN0b21QYXJhbWV0ZXJzID0gY3VzdG9tT0F1dGhQYXJhbWV0ZXJzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGN1cnJlbnQgbGlzdCBvZiB7QGxpbmsgQ3VzdG9tUGFyYW1ldGVyc30uXG4gICAgICovXG4gICAgZ2V0Q3VzdG9tUGFyYW1ldGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tUGFyYW1ldGVycztcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENvbW1vbiBjb2RlIHRvIGFsbCBPQXV0aCBwcm92aWRlcnMuIFRoaXMgaXMgc2VwYXJhdGUgZnJvbSB0aGVcbiAqIHtAbGluayBPQXV0aFByb3ZpZGVyfSBzbyB0aGF0IGNoaWxkIHByb3ZpZGVycyAobGlrZVxuICoge0BsaW5rIEdvb2dsZUF1dGhQcm92aWRlcn0pIGRvbid0IGluaGVyaXQgdGhlIGBjcmVkZW50aWFsYCBpbnN0YW5jZSBtZXRob2QuXG4gKiBJbnN0ZWFkLCB0aGV5IHJlbHkgb24gYSBzdGF0aWMgYGNyZWRlbnRpYWxgIG1ldGhvZC5cbiAqL1xuY2xhc3MgQmFzZU9BdXRoUHJvdmlkZXIgZXh0ZW5kcyBGZWRlcmF0ZWRBdXRoUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuc2NvcGVzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBPQXV0aCBzY29wZSB0byB0aGUgY3JlZGVudGlhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY29wZSAtIFByb3ZpZGVyIE9BdXRoIHNjb3BlIHRvIGFkZC5cbiAgICAgKi9cbiAgICBhZGRTY29wZShzY29wZSkge1xuICAgICAgICAvLyBJZiBub3QgYWxyZWFkeSBhZGRlZCwgYWRkIHNjb3BlIHRvIGxpc3QuXG4gICAgICAgIGlmICghdGhpcy5zY29wZXMuaW5jbHVkZXMoc2NvcGUpKSB7XG4gICAgICAgICAgICB0aGlzLnNjb3Blcy5wdXNoKHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGN1cnJlbnQgbGlzdCBvZiBPQXV0aCBzY29wZXMuXG4gICAgICovXG4gICAgZ2V0U2NvcGVzKCkge1xuICAgICAgICByZXR1cm4gWy4uLnRoaXMuc2NvcGVzXTtcbiAgICB9XG59XG4vKipcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGdlbmVyaWMge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSByZWRpcmVjdC5cbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IE9BdXRoUHJvdmlkZXIoJ2dvb2dsZS5jb20nKTtcbiAqIC8vIFN0YXJ0IGEgc2lnbiBpbiBwcm9jZXNzIGZvciBhbiB1bmF1dGhlbnRpY2F0ZWQgdXNlci5cbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdwcm9maWxlJyk7XG4gKiBwcm92aWRlci5hZGRTY29wZSgnZW1haWwnKTtcbiAqIGF3YWl0IHNpZ25JbldpdGhSZWRpcmVjdChhdXRoLCBwcm92aWRlcik7XG4gKiAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIGZ1bGwgcGFnZSByZWRpcmVjdCBhd2F5IGZyb20geW91ciBhcHBcbiAqXG4gKiAvLyBBZnRlciByZXR1cm5pbmcgZnJvbSB0aGUgcmVkaXJlY3Qgd2hlbiB5b3VyIGFwcCBpbml0aWFsaXplcyB5b3UgY2FuIG9idGFpbiB0aGUgcmVzdWx0XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRSZWRpcmVjdFJlc3VsdChhdXRoKTtcbiAqIGlmIChyZXN1bHQpIHtcbiAqICAgLy8gVGhpcyBpcyB0aGUgc2lnbmVkLWluIHVzZXJcbiAqICAgY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xuICogICAvLyBUaGlzIGdpdmVzIHlvdSBhIE9BdXRoIEFjY2VzcyBUb2tlbiBmb3IgdGhlIHByb3ZpZGVyLlxuICogICBjb25zdCBjcmVkZW50aWFsID0gcHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQoYXV0aCwgcmVzdWx0KTtcbiAqICAgY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xuICogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSBwb3B1cC5cbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IE9BdXRoUHJvdmlkZXIoJ2dvb2dsZS5jb20nKTtcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdwcm9maWxlJyk7XG4gKiBwcm92aWRlci5hZGRTY29wZSgnZW1haWwnKTtcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNpZ25JbldpdGhQb3B1cChhdXRoLCBwcm92aWRlcik7XG4gKlxuICogLy8gVGhlIHNpZ25lZC1pbiB1c2VyIGluZm8uXG4gKiBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XG4gKiAvLyBUaGlzIGdpdmVzIHlvdSBhIE9BdXRoIEFjY2VzcyBUb2tlbiBmb3IgdGhlIHByb3ZpZGVyLlxuICogY29uc3QgY3JlZGVudGlhbCA9IHByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KGF1dGgsIHJlc3VsdCk7XG4gKiBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XG4gKiBgYGBcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgT0F1dGhQcm92aWRlciBleHRlbmRzIEJhc2VPQXV0aFByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSBKU09OIHN0cmluZyBvciBhIHBsYWluIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ganNvbiAtIEEgcGxhaW4gb2JqZWN0IG9yIGEgSlNPTiBzdHJpbmdcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21KU09OKGpzb24pIHtcbiAgICAgICAgY29uc3Qgb2JqID0gdHlwZW9mIGpzb24gPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShqc29uKSA6IGpzb247XG4gICAgICAgIF9hc3NlcnQoJ3Byb3ZpZGVySWQnIGluIG9iaiAmJiAnc2lnbkluTWV0aG9kJyBpbiBvYmosIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcbiAgICAgICAgcmV0dXJuIE9BdXRoQ3JlZGVudGlhbC5fZnJvbVBhcmFtcyhvYmopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIGdlbmVyaWMgT0F1dGggcHJvdmlkZXIncyBhY2Nlc3MgdG9rZW4gb3IgSUQgdG9rZW4uXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSByYXcgbm9uY2UgaXMgcmVxdWlyZWQgd2hlbiBhbiBJRCB0b2tlbiB3aXRoIGEgbm9uY2UgZmllbGQgaXMgcHJvdmlkZWQuIFRoZSBTSEEtMjU2IGhhc2ggb2ZcbiAgICAgKiB0aGUgcmF3IG5vbmNlIG11c3QgbWF0Y2ggdGhlIG5vbmNlIGZpZWxkIGluIHRoZSBJRCB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIC8vIGBnb29nbGVVc2VyYCBmcm9tIHRoZSBvbnN1Y2Nlc3MgR29vZ2xlIFNpZ24gSW4gY2FsbGJhY2suXG4gICAgICogLy8gSW5pdGlhbGl6ZSBhIGdlbmVyYXRlIE9BdXRoIHByb3ZpZGVyIHdpdGggYSBgZ29vZ2xlLmNvbWAgcHJvdmlkZXJJZC5cbiAgICAgKiBjb25zdCBwcm92aWRlciA9IG5ldyBPQXV0aFByb3ZpZGVyKCdnb29nbGUuY29tJyk7XG4gICAgICogY29uc3QgY3JlZGVudGlhbCA9IHByb3ZpZGVyLmNyZWRlbnRpYWwoe1xuICAgICAqICAgaWRUb2tlbjogZ29vZ2xlVXNlci5nZXRBdXRoUmVzcG9uc2UoKS5pZF90b2tlbixcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoQ3JlZGVudGlhbChjcmVkZW50aWFsKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBFaXRoZXIgdGhlIG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIElEIHRva2VuLCBhY2Nlc3MgdG9rZW4gYW5kIHJhdyBub25jZVxuICAgICAqIG9yIHRoZSBJRCB0b2tlbiBzdHJpbmcuXG4gICAgICovXG4gICAgY3JlZGVudGlhbChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWRlbnRpYWwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCB7IG5vbmNlOiBwYXJhbXMucmF3Tm9uY2UgfSkpO1xuICAgIH1cbiAgICAvKiogQW4gaW50ZXJuYWwgY3JlZGVudGlhbCBtZXRob2QgdGhhdCBhY2NlcHRzIG1vcmUgcGVybWlzc2l2ZSBvcHRpb25zICovXG4gICAgX2NyZWRlbnRpYWwocGFyYW1zKSB7XG4gICAgICAgIF9hc3NlcnQocGFyYW1zLmlkVG9rZW4gfHwgcGFyYW1zLmFjY2Vzc1Rva2VuLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XG4gICAgICAgIC8vIEZvciBPQXV0aENyZWRlbnRpYWwsIHNpZ24gaW4gbWV0aG9kIGlzIHNhbWUgYXMgcHJvdmlkZXJJZC5cbiAgICAgICAgcmV0dXJuIE9BdXRoQ3JlZGVudGlhbC5fZnJvbVBhcmFtcyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHsgcHJvdmlkZXJJZDogdGhpcy5wcm92aWRlcklkLCBzaWduSW5NZXRob2Q6IHRoaXMucHJvdmlkZXJJZCB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIFVzZXJDcmVkZW50aWFsfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tUmVzdWx0KHVzZXJDcmVkZW50aWFsKSB7XG4gICAgICAgIHJldHVybiBPQXV0aFByb3ZpZGVyLm9hdXRoQ3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QodXNlckNyZWRlbnRpYWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBBdXRoRXJyb3J9IHdoaWNoIHdhc1xuICAgICAqIHRocm93biBkdXJpbmcgYSBzaWduLWluLCBsaW5rLCBvciByZWF1dGhlbnRpY2F0ZSBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbUVycm9yKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBPQXV0aFByb3ZpZGVyLm9hdXRoQ3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoKGVycm9yLmN1c3RvbURhdGEgfHwge30pKTtcbiAgICB9XG4gICAgc3RhdGljIG9hdXRoQ3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoeyBfdG9rZW5SZXNwb25zZTogdG9rZW5SZXNwb25zZSB9KSB7XG4gICAgICAgIGlmICghdG9rZW5SZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBvYXV0aElkVG9rZW4sIG9hdXRoQWNjZXNzVG9rZW4sIG9hdXRoVG9rZW5TZWNyZXQsIHBlbmRpbmdUb2tlbiwgbm9uY2UsIHByb3ZpZGVySWQgfSA9IHRva2VuUmVzcG9uc2U7XG4gICAgICAgIGlmICghb2F1dGhBY2Nlc3NUb2tlbiAmJlxuICAgICAgICAgICAgIW9hdXRoVG9rZW5TZWNyZXQgJiZcbiAgICAgICAgICAgICFvYXV0aElkVG9rZW4gJiZcbiAgICAgICAgICAgICFwZW5kaW5nVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJvdmlkZXJJZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgT0F1dGhQcm92aWRlcihwcm92aWRlcklkKS5fY3JlZGVudGlhbCh7XG4gICAgICAgICAgICAgICAgaWRUb2tlbjogb2F1dGhJZFRva2VuLFxuICAgICAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiBvYXV0aEFjY2Vzc1Rva2VuLFxuICAgICAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgICAgICAgIHBlbmRpbmdUb2tlblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQcm92aWRlciBmb3IgZ2VuZXJhdGluZyBhbiB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmb3Ige0BsaW5rIFByb3ZpZGVySWR9LkZBQ0VCT09LLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcmVkaXJlY3QuXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBGYWNlYm9va0F1dGhQcm92aWRlcigpO1xuICogLy8gU3RhcnQgYSBzaWduIGluIHByb2Nlc3MgZm9yIGFuIHVuYXV0aGVudGljYXRlZCB1c2VyLlxuICogcHJvdmlkZXIuYWRkU2NvcGUoJ3VzZXJfYmlydGhkYXknKTtcbiAqIGF3YWl0IHNpZ25JbldpdGhSZWRpcmVjdChhdXRoLCBwcm92aWRlcik7XG4gKiAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIGZ1bGwgcGFnZSByZWRpcmVjdCBhd2F5IGZyb20geW91ciBhcHBcbiAqXG4gKiAvLyBBZnRlciByZXR1cm5pbmcgZnJvbSB0aGUgcmVkaXJlY3Qgd2hlbiB5b3VyIGFwcCBpbml0aWFsaXplcyB5b3UgY2FuIG9idGFpbiB0aGUgcmVzdWx0XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRSZWRpcmVjdFJlc3VsdChhdXRoKTtcbiAqIGlmIChyZXN1bHQpIHtcbiAqICAgLy8gVGhpcyBpcyB0aGUgc2lnbmVkLWluIHVzZXJcbiAqICAgY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xuICogICAvLyBUaGlzIGdpdmVzIHlvdSBhIEZhY2Vib29rIEFjY2VzcyBUb2tlbi5cbiAqICAgY29uc3QgY3JlZGVudGlhbCA9IEZhY2Vib29rQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KHJlc3VsdCk7XG4gKiAgIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcG9wdXAuXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBGYWNlYm9va0F1dGhQcm92aWRlcigpO1xuICogcHJvdmlkZXIuYWRkU2NvcGUoJ3VzZXJfYmlydGhkYXknKTtcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNpZ25JbldpdGhQb3B1cChhdXRoLCBwcm92aWRlcik7XG4gKlxuICogLy8gVGhlIHNpZ25lZC1pbiB1c2VyIGluZm8uXG4gKiBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XG4gKiAvLyBUaGlzIGdpdmVzIHlvdSBhIEZhY2Vib29rIEFjY2VzcyBUb2tlbi5cbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBGYWNlYm9va0F1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xuICogY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBGYWNlYm9va0F1dGhQcm92aWRlciBleHRlbmRzIEJhc2VPQXV0aFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJmYWNlYm9vay5jb21cIiAvKiBQcm92aWRlcklkLkZBQ0VCT09LICovKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNyZWRlbnRpYWwgZm9yIEZhY2Vib29rLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqYXZhc2NyaXB0XG4gICAgICogLy8gYGV2ZW50YCBmcm9tIHRoZSBGYWNlYm9vayBhdXRoLmF1dGhSZXNwb25zZUNoYW5nZSBjYWxsYmFjay5cbiAgICAgKiBjb25zdCBjcmVkZW50aWFsID0gRmFjZWJvb2tBdXRoUHJvdmlkZXIuY3JlZGVudGlhbChldmVudC5hdXRoUmVzcG9uc2UuYWNjZXNzVG9rZW4pO1xuICAgICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNpZ25JbldpdGhDcmVkZW50aWFsKGNyZWRlbnRpYWwpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGFjY2Vzc1Rva2VuIC0gRmFjZWJvb2sgYWNjZXNzIHRva2VuLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsKGFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIHJldHVybiBPQXV0aENyZWRlbnRpYWwuX2Zyb21QYXJhbXMoe1xuICAgICAgICAgICAgcHJvdmlkZXJJZDogRmFjZWJvb2tBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQsXG4gICAgICAgICAgICBzaWduSW5NZXRob2Q6IEZhY2Vib29rQXV0aFByb3ZpZGVyLkZBQ0VCT09LX1NJR05fSU5fTUVUSE9ELFxuICAgICAgICAgICAgYWNjZXNzVG9rZW5cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIFVzZXJDcmVkZW50aWFsfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tUmVzdWx0KHVzZXJDcmVkZW50aWFsKSB7XG4gICAgICAgIHJldHVybiBGYWNlYm9va0F1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh1c2VyQ3JlZGVudGlhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIEF1dGhFcnJvcn0gd2hpY2ggd2FzXG4gICAgICogdGhyb3duIGR1cmluZyBhIHNpZ24taW4sIGxpbmssIG9yIHJlYXV0aGVudGljYXRlIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIEZhY2Vib29rQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KChlcnJvci5jdXN0b21EYXRhIHx8IHt9KSk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh7IF90b2tlblJlc3BvbnNlOiB0b2tlblJlc3BvbnNlIH0pIHtcbiAgICAgICAgaWYgKCF0b2tlblJlc3BvbnNlIHx8ICEoJ29hdXRoQWNjZXNzVG9rZW4nIGluIHRva2VuUmVzcG9uc2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRva2VuUmVzcG9uc2Uub2F1dGhBY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBGYWNlYm9va0F1dGhQcm92aWRlci5jcmVkZW50aWFsKHRva2VuUmVzcG9uc2Uub2F1dGhBY2Nlc3NUb2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKiBBbHdheXMgc2V0IHRvIHtAbGluayBTaWduSW5NZXRob2R9LkZBQ0VCT09LLiAqL1xuRmFjZWJvb2tBdXRoUHJvdmlkZXIuRkFDRUJPT0tfU0lHTl9JTl9NRVRIT0QgPSBcImZhY2Vib29rLmNvbVwiIC8qIFNpZ25Jbk1ldGhvZC5GQUNFQk9PSyAqLztcbi8qKiBBbHdheXMgc2V0IHRvIHtAbGluayBQcm92aWRlcklkfS5GQUNFQk9PSy4gKi9cbkZhY2Vib29rQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lEID0gXCJmYWNlYm9vay5jb21cIiAvKiBQcm92aWRlcklkLkZBQ0VCT09LICovO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQcm92aWRlciBmb3IgZ2VuZXJhdGluZyBhbiB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmb3Ige0BsaW5rIFByb3ZpZGVySWR9LkdPT0dMRS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHJlZGlyZWN0LlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgR29vZ2xlQXV0aFByb3ZpZGVyKCk7XG4gKiAvLyBTdGFydCBhIHNpZ24gaW4gcHJvY2VzcyBmb3IgYW4gdW5hdXRoZW50aWNhdGVkIHVzZXIuXG4gKiBwcm92aWRlci5hZGRTY29wZSgncHJvZmlsZScpO1xuICogcHJvdmlkZXIuYWRkU2NvcGUoJ2VtYWlsJyk7XG4gKiBhd2FpdCBzaWduSW5XaXRoUmVkaXJlY3QoYXV0aCwgcHJvdmlkZXIpO1xuICogLy8gVGhpcyB3aWxsIHRyaWdnZXIgYSBmdWxsIHBhZ2UgcmVkaXJlY3QgYXdheSBmcm9tIHlvdXIgYXBwXG4gKlxuICogLy8gQWZ0ZXIgcmV0dXJuaW5nIGZyb20gdGhlIHJlZGlyZWN0IHdoZW4geW91ciBhcHAgaW5pdGlhbGl6ZXMgeW91IGNhbiBvYnRhaW4gdGhlIHJlc3VsdFxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0UmVkaXJlY3RSZXN1bHQoYXV0aCk7XG4gKiBpZiAocmVzdWx0KSB7XG4gKiAgIC8vIFRoaXMgaXMgdGhlIHNpZ25lZC1pbiB1c2VyXG4gKiAgIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcbiAqICAgLy8gVGhpcyBnaXZlcyB5b3UgYSBHb29nbGUgQWNjZXNzIFRva2VuLlxuICogICBjb25zdCBjcmVkZW50aWFsID0gR29vZ2xlQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KHJlc3VsdCk7XG4gKiAgIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcG9wdXAuXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBHb29nbGVBdXRoUHJvdmlkZXIoKTtcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdwcm9maWxlJyk7XG4gKiBwcm92aWRlci5hZGRTY29wZSgnZW1haWwnKTtcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNpZ25JbldpdGhQb3B1cChhdXRoLCBwcm92aWRlcik7XG4gKlxuICogLy8gVGhlIHNpZ25lZC1pbiB1c2VyIGluZm8uXG4gKiBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XG4gKiAvLyBUaGlzIGdpdmVzIHlvdSBhIEdvb2dsZSBBY2Nlc3MgVG9rZW4uXG4gKiBjb25zdCBjcmVkZW50aWFsID0gR29vZ2xlQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KHJlc3VsdCk7XG4gKiBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEdvb2dsZUF1dGhQcm92aWRlciBleHRlbmRzIEJhc2VPQXV0aFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJnb29nbGUuY29tXCIgLyogUHJvdmlkZXJJZC5HT09HTEUgKi8pO1xuICAgICAgICB0aGlzLmFkZFNjb3BlKCdwcm9maWxlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjcmVkZW50aWFsIGZvciBHb29nbGUuIEF0IGxlYXN0IG9uZSBvZiBJRCB0b2tlbiBhbmQgYWNjZXNzIHRva2VuIGlzIHJlcXVpcmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqYXZhc2NyaXB0XG4gICAgICogLy8gXFxgZ29vZ2xlVXNlclxcYCBmcm9tIHRoZSBvbnN1Y2Nlc3MgR29vZ2xlIFNpZ24gSW4gY2FsbGJhY2suXG4gICAgICogY29uc3QgY3JlZGVudGlhbCA9IEdvb2dsZUF1dGhQcm92aWRlci5jcmVkZW50aWFsKGdvb2dsZVVzZXIuZ2V0QXV0aFJlc3BvbnNlKCkuaWRfdG9rZW4pO1xuICAgICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNpZ25JbldpdGhDcmVkZW50aWFsKGNyZWRlbnRpYWwpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGlkVG9rZW4gLSBHb29nbGUgSUQgdG9rZW4uXG4gICAgICogQHBhcmFtIGFjY2Vzc1Rva2VuIC0gR29vZ2xlIGFjY2VzcyB0b2tlbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlZGVudGlhbChpZFRva2VuLCBhY2Nlc3NUb2tlbikge1xuICAgICAgICByZXR1cm4gT0F1dGhDcmVkZW50aWFsLl9mcm9tUGFyYW1zKHtcbiAgICAgICAgICAgIHByb3ZpZGVySWQ6IEdvb2dsZUF1dGhQcm92aWRlci5QUk9WSURFUl9JRCxcbiAgICAgICAgICAgIHNpZ25Jbk1ldGhvZDogR29vZ2xlQXV0aFByb3ZpZGVyLkdPT0dMRV9TSUdOX0lOX01FVEhPRCxcbiAgICAgICAgICAgIGlkVG9rZW4sXG4gICAgICAgICAgICBhY2Nlc3NUb2tlblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgVXNlckNyZWRlbnRpYWx9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21SZXN1bHQodXNlckNyZWRlbnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIEdvb2dsZUF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh1c2VyQ3JlZGVudGlhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIEF1dGhFcnJvcn0gd2hpY2ggd2FzXG4gICAgICogdGhyb3duIGR1cmluZyBhIHNpZ24taW4sIGxpbmssIG9yIHJlYXV0aGVudGljYXRlIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIEdvb2dsZUF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCgoZXJyb3IuY3VzdG9tRGF0YSB8fCB7fSkpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoeyBfdG9rZW5SZXNwb25zZTogdG9rZW5SZXNwb25zZSB9KSB7XG4gICAgICAgIGlmICghdG9rZW5SZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBvYXV0aElkVG9rZW4sIG9hdXRoQWNjZXNzVG9rZW4gfSA9IHRva2VuUmVzcG9uc2U7XG4gICAgICAgIGlmICghb2F1dGhJZFRva2VuICYmICFvYXV0aEFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIGFuIG9hdXRoIDEgY3JlZGVudGlhbCBvciBhIHBob25lIGNyZWRlbnRpYWxcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gR29vZ2xlQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWwob2F1dGhJZFRva2VuLCBvYXV0aEFjY2Vzc1Rva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFNpZ25Jbk1ldGhvZH0uR09PR0xFLiAqL1xuR29vZ2xlQXV0aFByb3ZpZGVyLkdPT0dMRV9TSUdOX0lOX01FVEhPRCA9IFwiZ29vZ2xlLmNvbVwiIC8qIFNpZ25Jbk1ldGhvZC5HT09HTEUgKi87XG4vKiogQWx3YXlzIHNldCB0byB7QGxpbmsgUHJvdmlkZXJJZH0uR09PR0xFLiAqL1xuR29vZ2xlQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lEID0gXCJnb29nbGUuY29tXCIgLyogUHJvdmlkZXJJZC5HT09HTEUgKi87XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGFuIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZvciB7QGxpbmsgUHJvdmlkZXJJZH0uR0lUSFVCLlxuICpcbiAqIEByZW1hcmtzXG4gKiBHaXRIdWIgcmVxdWlyZXMgYW4gT0F1dGggMi4wIHJlZGlyZWN0LCBzbyB5b3UgY2FuIGVpdGhlciBoYW5kbGUgdGhlIHJlZGlyZWN0IGRpcmVjdGx5LCBvciB1c2VcbiAqIHRoZSB7QGxpbmsgc2lnbkluV2l0aFBvcHVwfSBoYW5kbGVyOlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcmVkaXJlY3QuXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBHaXRodWJBdXRoUHJvdmlkZXIoKTtcbiAqIC8vIFN0YXJ0IGEgc2lnbiBpbiBwcm9jZXNzIGZvciBhbiB1bmF1dGhlbnRpY2F0ZWQgdXNlci5cbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdyZXBvJyk7XG4gKiBhd2FpdCBzaWduSW5XaXRoUmVkaXJlY3QoYXV0aCwgcHJvdmlkZXIpO1xuICogLy8gVGhpcyB3aWxsIHRyaWdnZXIgYSBmdWxsIHBhZ2UgcmVkaXJlY3QgYXdheSBmcm9tIHlvdXIgYXBwXG4gKlxuICogLy8gQWZ0ZXIgcmV0dXJuaW5nIGZyb20gdGhlIHJlZGlyZWN0IHdoZW4geW91ciBhcHAgaW5pdGlhbGl6ZXMgeW91IGNhbiBvYnRhaW4gdGhlIHJlc3VsdFxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0UmVkaXJlY3RSZXN1bHQoYXV0aCk7XG4gKiBpZiAocmVzdWx0KSB7XG4gKiAgIC8vIFRoaXMgaXMgdGhlIHNpZ25lZC1pbiB1c2VyXG4gKiAgIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcbiAqICAgLy8gVGhpcyBnaXZlcyB5b3UgYSBHaXRIdWIgQWNjZXNzIFRva2VuLlxuICogICBjb25zdCBjcmVkZW50aWFsID0gR2l0aHViQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KHJlc3VsdCk7XG4gKiAgIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcG9wdXAuXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBHaXRodWJBdXRoUHJvdmlkZXIoKTtcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdyZXBvJyk7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoUG9wdXAoYXV0aCwgcHJvdmlkZXIpO1xuICpcbiAqIC8vIFRoZSBzaWduZWQtaW4gdXNlciBpbmZvLlxuICogY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xuICogLy8gVGhpcyBnaXZlcyB5b3UgYSBHaXRIdWIgQWNjZXNzIFRva2VuLlxuICogY29uc3QgY3JlZGVudGlhbCA9IEdpdGh1YkF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xuICogY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xuICogYGBgXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEdpdGh1YkF1dGhQcm92aWRlciBleHRlbmRzIEJhc2VPQXV0aFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJnaXRodWIuY29tXCIgLyogUHJvdmlkZXJJZC5HSVRIVUIgKi8pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY3JlZGVudGlhbCBmb3IgR2l0SHViLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFjY2Vzc1Rva2VuIC0gR2l0SHViIGFjY2VzcyB0b2tlbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlZGVudGlhbChhY2Nlc3NUb2tlbikge1xuICAgICAgICByZXR1cm4gT0F1dGhDcmVkZW50aWFsLl9mcm9tUGFyYW1zKHtcbiAgICAgICAgICAgIHByb3ZpZGVySWQ6IEdpdGh1YkF1dGhQcm92aWRlci5QUk9WSURFUl9JRCxcbiAgICAgICAgICAgIHNpZ25Jbk1ldGhvZDogR2l0aHViQXV0aFByb3ZpZGVyLkdJVEhVQl9TSUdOX0lOX01FVEhPRCxcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBVc2VyQ3JlZGVudGlhbH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbVJlc3VsdCh1c2VyQ3JlZGVudGlhbCkge1xuICAgICAgICByZXR1cm4gR2l0aHViQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHVzZXJDcmVkZW50aWFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgQXV0aEVycm9yfSB3aGljaCB3YXNcbiAgICAgKiB0aHJvd24gZHVyaW5nIGEgc2lnbi1pbiwgbGluaywgb3IgcmVhdXRoZW50aWNhdGUgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21FcnJvcihlcnJvcikge1xuICAgICAgICByZXR1cm4gR2l0aHViQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KChlcnJvci5jdXN0b21EYXRhIHx8IHt9KSk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh7IF90b2tlblJlc3BvbnNlOiB0b2tlblJlc3BvbnNlIH0pIHtcbiAgICAgICAgaWYgKCF0b2tlblJlc3BvbnNlIHx8ICEoJ29hdXRoQWNjZXNzVG9rZW4nIGluIHRva2VuUmVzcG9uc2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRva2VuUmVzcG9uc2Uub2F1dGhBY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBHaXRodWJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbCh0b2tlblJlc3BvbnNlLm9hdXRoQWNjZXNzVG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiogQWx3YXlzIHNldCB0byB7QGxpbmsgU2lnbkluTWV0aG9kfS5HSVRIVUIuICovXG5HaXRodWJBdXRoUHJvdmlkZXIuR0lUSFVCX1NJR05fSU5fTUVUSE9EID0gXCJnaXRodWIuY29tXCIgLyogU2lnbkluTWV0aG9kLkdJVEhVQiAqLztcbi8qKiBBbHdheXMgc2V0IHRvIHtAbGluayBQcm92aWRlcklkfS5HSVRIVUIuICovXG5HaXRodWJBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQgPSBcImdpdGh1Yi5jb21cIiAvKiBQcm92aWRlcklkLkdJVEhVQiAqLztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IElEUF9SRVFVRVNUX1VSSSA9ICdodHRwOi8vbG9jYWxob3N0Jztcbi8qKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBTQU1MQXV0aENyZWRlbnRpYWwgZXh0ZW5kcyBBdXRoQ3JlZGVudGlhbCB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVySWQsIHBlbmRpbmdUb2tlbikge1xuICAgICAgICBzdXBlcihwcm92aWRlcklkLCBwcm92aWRlcklkKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nVG9rZW4gPSBwZW5kaW5nVG9rZW47XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZ2V0SWRUb2tlblJlc3BvbnNlKGF1dGgpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuYnVpbGRSZXF1ZXN0KCk7XG4gICAgICAgIHJldHVybiBzaWduSW5XaXRoSWRwKGF1dGgsIHJlcXVlc3QpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2xpbmtUb0lkVG9rZW4oYXV0aCwgaWRUb2tlbikge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5idWlsZFJlcXVlc3QoKTtcbiAgICAgICAgcmVxdWVzdC5pZFRva2VuID0gaWRUb2tlbjtcbiAgICAgICAgcmV0dXJuIHNpZ25JbldpdGhJZHAoYXV0aCwgcmVxdWVzdCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZ2V0UmVhdXRoZW50aWNhdGlvblJlc29sdmVyKGF1dGgpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuYnVpbGRSZXF1ZXN0KCk7XG4gICAgICAgIHJlcXVlc3QuYXV0b0NyZWF0ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gc2lnbkluV2l0aElkcChhdXRoLCByZXF1ZXN0KTtcbiAgICB9XG4gICAgLyoqIHtAaW5oZXJpdGRvYyBBdXRoQ3JlZGVudGlhbC50b0pTT059ICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNpZ25Jbk1ldGhvZDogdGhpcy5zaWduSW5NZXRob2QsXG4gICAgICAgICAgICBwcm92aWRlcklkOiB0aGlzLnByb3ZpZGVySWQsXG4gICAgICAgICAgICBwZW5kaW5nVG9rZW46IHRoaXMucGVuZGluZ1Rva2VuXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBtZXRob2QgdG8gZGVzZXJpYWxpemUgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9iamVjdCBpbnRvIGFuXG4gICAgICoge0BsaW5rICBBdXRoQ3JlZGVudGlhbH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ganNvbiAtIElucHV0IGNhbiBiZSBlaXRoZXIgT2JqZWN0IG9yIHRoZSBzdHJpbmdpZmllZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0LlxuICAgICAqIFdoZW4gc3RyaW5nIGlzIHByb3ZpZGVkLCBKU09OLnBhcnNlIHdvdWxkIGJlIGNhbGxlZCBmaXJzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIElmIHRoZSBKU09OIGlucHV0IGRvZXMgbm90IHJlcHJlc2VudCBhbiB7QGxpbmsgIEF1dGhDcmVkZW50aWFsfSwgbnVsbCBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBjb25zdCBvYmogPSB0eXBlb2YganNvbiA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbjtcbiAgICAgICAgY29uc3QgeyBwcm92aWRlcklkLCBzaWduSW5NZXRob2QsIHBlbmRpbmdUb2tlbiB9ID0gb2JqO1xuICAgICAgICBpZiAoIXByb3ZpZGVySWQgfHxcbiAgICAgICAgICAgICFzaWduSW5NZXRob2QgfHxcbiAgICAgICAgICAgICFwZW5kaW5nVG9rZW4gfHxcbiAgICAgICAgICAgIHByb3ZpZGVySWQgIT09IHNpZ25Jbk1ldGhvZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTQU1MQXV0aENyZWRlbnRpYWwocHJvdmlkZXJJZCwgcGVuZGluZ1Rva2VuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIHN0YXRpYyBtZXRob2QgdG8gYXZvaWQgZXhwb3NpbmcgdGhlIGNvbnN0cnVjdG9yIHRvIGVuZCB1c2Vycy5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBfY3JlYXRlKHByb3ZpZGVySWQsIHBlbmRpbmdUb2tlbikge1xuICAgICAgICByZXR1cm4gbmV3IFNBTUxBdXRoQ3JlZGVudGlhbChwcm92aWRlcklkLCBwZW5kaW5nVG9rZW4pO1xuICAgIH1cbiAgICBidWlsZFJlcXVlc3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXF1ZXN0VXJpOiBJRFBfUkVRVUVTVF9VUkksXG4gICAgICAgICAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZSxcbiAgICAgICAgICAgIHBlbmRpbmdUb2tlbjogdGhpcy5wZW5kaW5nVG9rZW5cbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBTQU1MX1BST1ZJREVSX1BSRUZJWCA9ICdzYW1sLic7XG4vKipcbiAqIEFuIHtAbGluayBBdXRoUHJvdmlkZXJ9IGZvciBTQU1MLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgU0FNTEF1dGhQcm92aWRlciBleHRlbmRzIEZlZGVyYXRlZEF1dGhQcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IuIFRoZSBwcm92aWRlcklkIG11c3Qgc3RhcnQgd2l0aCBcInNhbWwuXCJcbiAgICAgKiBAcGFyYW0gcHJvdmlkZXJJZCAtIFNBTUwgcHJvdmlkZXIgSUQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXJJZCkge1xuICAgICAgICBfYXNzZXJ0KHByb3ZpZGVySWQuc3RhcnRzV2l0aChTQU1MX1BST1ZJREVSX1BSRUZJWCksIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcbiAgICAgICAgc3VwZXIocHJvdmlkZXJJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhbiB7QGxpbmsgQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgVXNlckNyZWRlbnRpYWx9IGFmdGVyIGFcbiAgICAgKiBzdWNjZXNzZnVsIFNBTUwgZmxvdyBjb21wbGV0ZXMuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIHRvIGdldCBhbiB7QGxpbmsgQXV0aENyZWRlbnRpYWx9LCB5b3UgY291bGQgd3JpdGUgdGhlXG4gICAgICogZm9sbG93aW5nIGNvZGU6XG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgc2lnbkluV2l0aFBvcHVwKGF1dGgsIHNhbWxQcm92aWRlcik7XG4gICAgICogY29uc3QgY3JlZGVudGlhbCA9IFNBTUxBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQodXNlckNyZWRlbnRpYWwpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21SZXN1bHQodXNlckNyZWRlbnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIFNBTUxBdXRoUHJvdmlkZXIuc2FtbENyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHVzZXJDcmVkZW50aWFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgQXV0aEVycm9yfSB3aGljaCB3YXNcbiAgICAgKiB0aHJvd24gZHVyaW5nIGEgc2lnbi1pbiwgbGluaywgb3IgcmVhdXRoZW50aWNhdGUgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21FcnJvcihlcnJvcikge1xuICAgICAgICByZXR1cm4gU0FNTEF1dGhQcm92aWRlci5zYW1sQ3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoKGVycm9yLmN1c3RvbURhdGEgfHwge30pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiB7QGxpbmsgQXV0aENyZWRlbnRpYWx9IGZyb20gYSBKU09OIHN0cmluZyBvciBhIHBsYWluIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ganNvbiAtIEEgcGxhaW4gb2JqZWN0IG9yIGEgSlNPTiBzdHJpbmdcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21KU09OKGpzb24pIHtcbiAgICAgICAgY29uc3QgY3JlZGVudGlhbCA9IFNBTUxBdXRoQ3JlZGVudGlhbC5mcm9tSlNPTihqc29uKTtcbiAgICAgICAgX2Fzc2VydChjcmVkZW50aWFsLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XG4gICAgICAgIHJldHVybiBjcmVkZW50aWFsO1xuICAgIH1cbiAgICBzdGF0aWMgc2FtbENyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHsgX3Rva2VuUmVzcG9uc2U6IHRva2VuUmVzcG9uc2UgfSkge1xuICAgICAgICBpZiAoIXRva2VuUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcGVuZGluZ1Rva2VuLCBwcm92aWRlcklkIH0gPSB0b2tlblJlc3BvbnNlO1xuICAgICAgICBpZiAoIXBlbmRpbmdUb2tlbiB8fCAhcHJvdmlkZXJJZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBTQU1MQXV0aENyZWRlbnRpYWwuX2NyZWF0ZShwcm92aWRlcklkLCBwZW5kaW5nVG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUHJvdmlkZXIgZm9yIGdlbmVyYXRpbmcgYW4ge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZm9yIHtAbGluayBQcm92aWRlcklkfS5UV0lUVEVSLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcmVkaXJlY3QuXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBUd2l0dGVyQXV0aFByb3ZpZGVyKCk7XG4gKiAvLyBTdGFydCBhIHNpZ24gaW4gcHJvY2VzcyBmb3IgYW4gdW5hdXRoZW50aWNhdGVkIHVzZXIuXG4gKiBhd2FpdCBzaWduSW5XaXRoUmVkaXJlY3QoYXV0aCwgcHJvdmlkZXIpO1xuICogLy8gVGhpcyB3aWxsIHRyaWdnZXIgYSBmdWxsIHBhZ2UgcmVkaXJlY3QgYXdheSBmcm9tIHlvdXIgYXBwXG4gKlxuICogLy8gQWZ0ZXIgcmV0dXJuaW5nIGZyb20gdGhlIHJlZGlyZWN0IHdoZW4geW91ciBhcHAgaW5pdGlhbGl6ZXMgeW91IGNhbiBvYnRhaW4gdGhlIHJlc3VsdFxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0UmVkaXJlY3RSZXN1bHQoYXV0aCk7XG4gKiBpZiAocmVzdWx0KSB7XG4gKiAgIC8vIFRoaXMgaXMgdGhlIHNpZ25lZC1pbiB1c2VyXG4gKiAgIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcbiAqICAgLy8gVGhpcyBnaXZlcyB5b3UgYSBUd2l0dGVyIEFjY2VzcyBUb2tlbiBhbmQgU2VjcmV0LlxuICogICBjb25zdCBjcmVkZW50aWFsID0gVHdpdHRlckF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xuICogICBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XG4gKiAgIGNvbnN0IHNlY3JldCA9IGNyZWRlbnRpYWwuc2VjcmV0O1xuICogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSBwb3B1cC5cbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IFR3aXR0ZXJBdXRoUHJvdmlkZXIoKTtcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNpZ25JbldpdGhQb3B1cChhdXRoLCBwcm92aWRlcik7XG4gKlxuICogLy8gVGhlIHNpZ25lZC1pbiB1c2VyIGluZm8uXG4gKiBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XG4gKiAvLyBUaGlzIGdpdmVzIHlvdSBhIFR3aXR0ZXIgQWNjZXNzIFRva2VuIGFuZCBTZWNyZXQuXG4gKiBjb25zdCBjcmVkZW50aWFsID0gVHdpdHRlckF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xuICogY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xuICogY29uc3Qgc2VjcmV0ID0gY3JlZGVudGlhbC5zZWNyZXQ7XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFR3aXR0ZXJBdXRoUHJvdmlkZXIgZXh0ZW5kcyBCYXNlT0F1dGhQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwidHdpdHRlci5jb21cIiAvKiBQcm92aWRlcklkLlRXSVRURVIgKi8pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY3JlZGVudGlhbCBmb3IgVHdpdHRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b2tlbiAtIFR3aXR0ZXIgYWNjZXNzIHRva2VuLlxuICAgICAqIEBwYXJhbSBzZWNyZXQgLSBUd2l0dGVyIHNlY3JldC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlZGVudGlhbCh0b2tlbiwgc2VjcmV0KSB7XG4gICAgICAgIHJldHVybiBPQXV0aENyZWRlbnRpYWwuX2Zyb21QYXJhbXMoe1xuICAgICAgICAgICAgcHJvdmlkZXJJZDogVHdpdHRlckF1dGhQcm92aWRlci5QUk9WSURFUl9JRCxcbiAgICAgICAgICAgIHNpZ25Jbk1ldGhvZDogVHdpdHRlckF1dGhQcm92aWRlci5UV0lUVEVSX1NJR05fSU5fTUVUSE9ELFxuICAgICAgICAgICAgb2F1dGhUb2tlbjogdG9rZW4sXG4gICAgICAgICAgICBvYXV0aFRva2VuU2VjcmV0OiBzZWNyZXRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIFVzZXJDcmVkZW50aWFsfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tUmVzdWx0KHVzZXJDcmVkZW50aWFsKSB7XG4gICAgICAgIHJldHVybiBUd2l0dGVyQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHVzZXJDcmVkZW50aWFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgQXV0aEVycm9yfSB3aGljaCB3YXNcbiAgICAgKiB0aHJvd24gZHVyaW5nIGEgc2lnbi1pbiwgbGluaywgb3IgcmVhdXRoZW50aWNhdGUgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21FcnJvcihlcnJvcikge1xuICAgICAgICByZXR1cm4gVHdpdHRlckF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCgoZXJyb3IuY3VzdG9tRGF0YSB8fCB7fSkpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoeyBfdG9rZW5SZXNwb25zZTogdG9rZW5SZXNwb25zZSB9KSB7XG4gICAgICAgIGlmICghdG9rZW5SZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBvYXV0aEFjY2Vzc1Rva2VuLCBvYXV0aFRva2VuU2VjcmV0IH0gPSB0b2tlblJlc3BvbnNlO1xuICAgICAgICBpZiAoIW9hdXRoQWNjZXNzVG9rZW4gfHwgIW9hdXRoVG9rZW5TZWNyZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gVHdpdHRlckF1dGhQcm92aWRlci5jcmVkZW50aWFsKG9hdXRoQWNjZXNzVG9rZW4sIG9hdXRoVG9rZW5TZWNyZXQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiogQWx3YXlzIHNldCB0byB7QGxpbmsgU2lnbkluTWV0aG9kfS5UV0lUVEVSLiAqL1xuVHdpdHRlckF1dGhQcm92aWRlci5UV0lUVEVSX1NJR05fSU5fTUVUSE9EID0gXCJ0d2l0dGVyLmNvbVwiIC8qIFNpZ25Jbk1ldGhvZC5UV0lUVEVSICovO1xuLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFByb3ZpZGVySWR9LlRXSVRURVIuICovXG5Ud2l0dGVyQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lEID0gXCJ0d2l0dGVyLmNvbVwiIC8qIFByb3ZpZGVySWQuVFdJVFRFUiAqLztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNpZ25VcChhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25VcFwiIC8qIEVuZHBvaW50LlNJR05fVVAgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBVc2VyQ3JlZGVudGlhbEltcGwge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICB0aGlzLnVzZXIgPSBwYXJhbXMudXNlcjtcbiAgICAgICAgdGhpcy5wcm92aWRlcklkID0gcGFyYW1zLnByb3ZpZGVySWQ7XG4gICAgICAgIHRoaXMuX3Rva2VuUmVzcG9uc2UgPSBwYXJhbXMuX3Rva2VuUmVzcG9uc2U7XG4gICAgICAgIHRoaXMub3BlcmF0aW9uVHlwZSA9IHBhcmFtcy5vcGVyYXRpb25UeXBlO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgX2Zyb21JZFRva2VuUmVzcG9uc2UoYXV0aCwgb3BlcmF0aW9uVHlwZSwgaWRUb2tlblJlc3BvbnNlLCBpc0Fub255bW91cyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBVc2VySW1wbC5fZnJvbUlkVG9rZW5SZXNwb25zZShhdXRoLCBpZFRva2VuUmVzcG9uc2UsIGlzQW5vbnltb3VzKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJJZCA9IHByb3ZpZGVySWRGb3JSZXNwb25zZShpZFRva2VuUmVzcG9uc2UpO1xuICAgICAgICBjb25zdCB1c2VyQ3JlZCA9IG5ldyBVc2VyQ3JlZGVudGlhbEltcGwoe1xuICAgICAgICAgICAgdXNlcixcbiAgICAgICAgICAgIHByb3ZpZGVySWQsXG4gICAgICAgICAgICBfdG9rZW5SZXNwb25zZTogaWRUb2tlblJlc3BvbnNlLFxuICAgICAgICAgICAgb3BlcmF0aW9uVHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVzZXJDcmVkO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgX2Zvck9wZXJhdGlvbih1c2VyLCBvcGVyYXRpb25UeXBlLCByZXNwb25zZSkge1xuICAgICAgICBhd2FpdCB1c2VyLl91cGRhdGVUb2tlbnNJZk5lY2Vzc2FyeShyZXNwb25zZSwgLyogcmVsb2FkICovIHRydWUpO1xuICAgICAgICBjb25zdCBwcm92aWRlcklkID0gcHJvdmlkZXJJZEZvclJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVc2VyQ3JlZGVudGlhbEltcGwoe1xuICAgICAgICAgICAgdXNlcixcbiAgICAgICAgICAgIHByb3ZpZGVySWQsXG4gICAgICAgICAgICBfdG9rZW5SZXNwb25zZTogcmVzcG9uc2UsXG4gICAgICAgICAgICBvcGVyYXRpb25UeXBlXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByb3ZpZGVySWRGb3JSZXNwb25zZShyZXNwb25zZSkge1xuICAgIGlmIChyZXNwb25zZS5wcm92aWRlcklkKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5wcm92aWRlcklkO1xuICAgIH1cbiAgICBpZiAoJ3Bob25lTnVtYmVyJyBpbiByZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gXCJwaG9uZVwiIC8qIFByb3ZpZGVySWQuUEhPTkUgKi87XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBc3luY2hyb25vdXNseSBzaWducyBpbiBhcyBhbiBhbm9ueW1vdXMgdXNlci5cbiAqXG4gKiBAcmVtYXJrc1xuICogSWYgdGhlcmUgaXMgYWxyZWFkeSBhbiBhbm9ueW1vdXMgdXNlciBzaWduZWQgaW4sIHRoYXQgdXNlciB3aWxsIGJlIHJldHVybmVkOyBvdGhlcndpc2UsIGFcbiAqIG5ldyBhbm9ueW1vdXMgdXNlciBpZGVudGl0eSB3aWxsIGJlIGNyZWF0ZWQgYW5kIHJldHVybmVkLlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkge0BsaW5rIEF1dGh9IGluc3RhbmNlcyBjcmVhdGVkIHdpdGggYVxuICoge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VTZXJ2ZXJBcHB9LlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbkFub255bW91c2x5KGF1dGgpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKGF1dGguYXBwKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IoYXV0aCkpO1xuICAgIH1cbiAgICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XG4gICAgYXdhaXQgYXV0aEludGVybmFsLl9pbml0aWFsaXphdGlvblByb21pc2U7XG4gICAgaWYgKChfYSA9IGF1dGhJbnRlcm5hbC5jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzQW5vbnltb3VzKSB7XG4gICAgICAgIC8vIElmIGFuIGFub255bW91cyB1c2VyIGlzIGFscmVhZHkgc2lnbmVkIGluLCBubyBuZWVkIHRvIHNpZ24gdGhlbSBpbiBhZ2Fpbi5cbiAgICAgICAgcmV0dXJuIG5ldyBVc2VyQ3JlZGVudGlhbEltcGwoe1xuICAgICAgICAgICAgdXNlcjogYXV0aEludGVybmFsLmN1cnJlbnRVc2VyLFxuICAgICAgICAgICAgcHJvdmlkZXJJZDogbnVsbCxcbiAgICAgICAgICAgIG9wZXJhdGlvblR5cGU6IFwic2lnbkluXCIgLyogT3BlcmF0aW9uVHlwZS5TSUdOX0lOICovXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNpZ25VcChhdXRoSW50ZXJuYWwsIHtcbiAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IFVzZXJDcmVkZW50aWFsSW1wbC5fZnJvbUlkVG9rZW5SZXNwb25zZShhdXRoSW50ZXJuYWwsIFwic2lnbkluXCIgLyogT3BlcmF0aW9uVHlwZS5TSUdOX0lOICovLCByZXNwb25zZSwgdHJ1ZSk7XG4gICAgYXdhaXQgYXV0aEludGVybmFsLl91cGRhdGVDdXJyZW50VXNlcih1c2VyQ3JlZGVudGlhbC51c2VyKTtcbiAgICByZXR1cm4gdXNlckNyZWRlbnRpYWw7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBNdWx0aUZhY3RvckVycm9yIGV4dGVuZHMgRmlyZWJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoYXV0aCwgZXJyb3IsIG9wZXJhdGlvblR5cGUsIHVzZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdXBlcihlcnJvci5jb2RlLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25UeXBlID0gb3BlcmF0aW9uVHlwZTtcbiAgICAgICAgdGhpcy51c2VyID0gdXNlcjtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0LXdpa2kvYmxvYi9tYXN0ZXIvQnJlYWtpbmctQ2hhbmdlcy5tZCNleHRlbmRpbmctYnVpbHQtaW5zLWxpa2UtZXJyb3ItYXJyYXktYW5kLW1hcC1tYXktbm8tbG9uZ2VyLXdvcmtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIE11bHRpRmFjdG9yRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgdGhpcy5jdXN0b21EYXRhID0ge1xuICAgICAgICAgICAgYXBwTmFtZTogYXV0aC5uYW1lLFxuICAgICAgICAgICAgdGVuYW50SWQ6IChfYSA9IGF1dGgudGVuYW50SWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9zZXJ2ZXJSZXNwb25zZTogZXJyb3IuY3VzdG9tRGF0YS5fc2VydmVyUmVzcG9uc2UsXG4gICAgICAgICAgICBvcGVyYXRpb25UeXBlXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBfZnJvbUVycm9yQW5kT3BlcmF0aW9uKGF1dGgsIGVycm9yLCBvcGVyYXRpb25UeXBlLCB1c2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgTXVsdGlGYWN0b3JFcnJvcihhdXRoLCBlcnJvciwgb3BlcmF0aW9uVHlwZSwgdXNlcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX3Byb2Nlc3NDcmVkZW50aWFsU2F2aW5nTWZhQ29udGV4dElmTmVjZXNzYXJ5KGF1dGgsIG9wZXJhdGlvblR5cGUsIGNyZWRlbnRpYWwsIHVzZXIpIHtcbiAgICBjb25zdCBpZFRva2VuUHJvdmlkZXIgPSBvcGVyYXRpb25UeXBlID09PSBcInJlYXV0aGVudGljYXRlXCIgLyogT3BlcmF0aW9uVHlwZS5SRUFVVEhFTlRJQ0FURSAqL1xuICAgICAgICA/IGNyZWRlbnRpYWwuX2dldFJlYXV0aGVudGljYXRpb25SZXNvbHZlcihhdXRoKVxuICAgICAgICA6IGNyZWRlbnRpYWwuX2dldElkVG9rZW5SZXNwb25zZShhdXRoKTtcbiAgICByZXR1cm4gaWRUb2tlblByb3ZpZGVyLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IGBhdXRoLyR7XCJtdWx0aS1mYWN0b3ItYXV0aC1yZXF1aXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuTUZBX1JFUVVJUkVEICovfWApIHtcbiAgICAgICAgICAgIHRocm93IE11bHRpRmFjdG9yRXJyb3IuX2Zyb21FcnJvckFuZE9wZXJhdGlvbihhdXRoLCBlcnJvciwgb3BlcmF0aW9uVHlwZSwgdXNlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRha2VzIGEgc2V0IG9mIFVzZXJJbmZvIHByb3ZpZGVyIGRhdGEgYW5kIGNvbnZlcnRzIGl0IHRvIGEgc2V0IG9mIG5hbWVzXG4gKi9cbmZ1bmN0aW9uIHByb3ZpZGVyRGF0YUFzTmFtZXMocHJvdmlkZXJEYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBTZXQocHJvdmlkZXJEYXRhXG4gICAgICAgIC5tYXAoKHsgcHJvdmlkZXJJZCB9KSA9PiBwcm92aWRlcklkKVxuICAgICAgICAuZmlsdGVyKHBpZCA9PiAhIXBpZCkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBVbmxpbmtzIGEgcHJvdmlkZXIgZnJvbSBhIHVzZXIgYWNjb3VudC5cbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICogQHBhcmFtIHByb3ZpZGVySWQgLSBUaGUgcHJvdmlkZXIgdG8gdW5saW5rLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdW5saW5rKHVzZXIsIHByb3ZpZGVySWQpIHtcbiAgICBjb25zdCB1c2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcik7XG4gICAgYXdhaXQgX2Fzc2VydExpbmtlZFN0YXR1cyh0cnVlLCB1c2VySW50ZXJuYWwsIHByb3ZpZGVySWQpO1xuICAgIGNvbnN0IHsgcHJvdmlkZXJVc2VySW5mbyB9ID0gYXdhaXQgZGVsZXRlTGlua2VkQWNjb3VudHModXNlckludGVybmFsLmF1dGgsIHtcbiAgICAgICAgaWRUb2tlbjogYXdhaXQgdXNlckludGVybmFsLmdldElkVG9rZW4oKSxcbiAgICAgICAgZGVsZXRlUHJvdmlkZXI6IFtwcm92aWRlcklkXVxuICAgIH0pO1xuICAgIGNvbnN0IHByb3ZpZGVyc0xlZnQgPSBwcm92aWRlckRhdGFBc05hbWVzKHByb3ZpZGVyVXNlckluZm8gfHwgW10pO1xuICAgIHVzZXJJbnRlcm5hbC5wcm92aWRlckRhdGEgPSB1c2VySW50ZXJuYWwucHJvdmlkZXJEYXRhLmZpbHRlcihwZCA9PiBwcm92aWRlcnNMZWZ0LmhhcyhwZC5wcm92aWRlcklkKSk7XG4gICAgaWYgKCFwcm92aWRlcnNMZWZ0LmhhcyhcInBob25lXCIgLyogUHJvdmlkZXJJZC5QSE9ORSAqLykpIHtcbiAgICAgICAgdXNlckludGVybmFsLnBob25lTnVtYmVyID0gbnVsbDtcbiAgICB9XG4gICAgYXdhaXQgdXNlckludGVybmFsLmF1dGguX3BlcnNpc3RVc2VySWZDdXJyZW50KHVzZXJJbnRlcm5hbCk7XG4gICAgcmV0dXJuIHVzZXJJbnRlcm5hbDtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9saW5rKHVzZXIsIGNyZWRlbnRpYWwsIGJ5cGFzc0F1dGhTdGF0ZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZCh1c2VyLCBjcmVkZW50aWFsLl9saW5rVG9JZFRva2VuKHVzZXIuYXV0aCwgYXdhaXQgdXNlci5nZXRJZFRva2VuKCkpLCBieXBhc3NBdXRoU3RhdGUpO1xuICAgIHJldHVybiBVc2VyQ3JlZGVudGlhbEltcGwuX2Zvck9wZXJhdGlvbih1c2VyLCBcImxpbmtcIiAvKiBPcGVyYXRpb25UeXBlLkxJTksgKi8sIHJlc3BvbnNlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9hc3NlcnRMaW5rZWRTdGF0dXMoZXhwZWN0ZWQsIHVzZXIsIHByb3ZpZGVyKSB7XG4gICAgYXdhaXQgX3JlbG9hZFdpdGhvdXRTYXZpbmcodXNlcik7XG4gICAgY29uc3QgcHJvdmlkZXJJZHMgPSBwcm92aWRlckRhdGFBc05hbWVzKHVzZXIucHJvdmlkZXJEYXRhKTtcbiAgICBjb25zdCBjb2RlID0gZXhwZWN0ZWQgPT09IGZhbHNlXG4gICAgICAgID8gXCJwcm92aWRlci1hbHJlYWR5LWxpbmtlZFwiIC8qIEF1dGhFcnJvckNvZGUuUFJPVklERVJfQUxSRUFEWV9MSU5LRUQgKi9cbiAgICAgICAgOiBcIm5vLXN1Y2gtcHJvdmlkZXJcIiAvKiBBdXRoRXJyb3JDb2RlLk5PX1NVQ0hfUFJPVklERVIgKi87XG4gICAgX2Fzc2VydChwcm92aWRlcklkcy5oYXMocHJvdmlkZXIpID09PSBleHBlY3RlZCwgdXNlci5hdXRoLCBjb2RlKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9yZWF1dGhlbnRpY2F0ZSh1c2VyLCBjcmVkZW50aWFsLCBieXBhc3NBdXRoU3RhdGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHsgYXV0aCB9ID0gdXNlcjtcbiAgICBpZiAoX2lzRmlyZWJhc2VTZXJ2ZXJBcHAoYXV0aC5hcHApKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChfc2VydmVyQXBwQ3VycmVudFVzZXJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvcihhdXRoKSk7XG4gICAgfVxuICAgIGNvbnN0IG9wZXJhdGlvblR5cGUgPSBcInJlYXV0aGVudGljYXRlXCIgLyogT3BlcmF0aW9uVHlwZS5SRUFVVEhFTlRJQ0FURSAqLztcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9sb2dvdXRJZkludmFsaWRhdGVkKHVzZXIsIF9wcm9jZXNzQ3JlZGVudGlhbFNhdmluZ01mYUNvbnRleHRJZk5lY2Vzc2FyeShhdXRoLCBvcGVyYXRpb25UeXBlLCBjcmVkZW50aWFsLCB1c2VyKSwgYnlwYXNzQXV0aFN0YXRlKTtcbiAgICAgICAgX2Fzc2VydChyZXNwb25zZS5pZFRva2VuLCBhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IF9wYXJzZVRva2VuKHJlc3BvbnNlLmlkVG9rZW4pO1xuICAgICAgICBfYXNzZXJ0KHBhcnNlZCwgYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICBjb25zdCB7IHN1YjogbG9jYWxJZCB9ID0gcGFyc2VkO1xuICAgICAgICBfYXNzZXJ0KHVzZXIudWlkID09PSBsb2NhbElkLCBhdXRoLCBcInVzZXItbWlzbWF0Y2hcIiAvKiBBdXRoRXJyb3JDb2RlLlVTRVJfTUlTTUFUQ0ggKi8pO1xuICAgICAgICByZXR1cm4gVXNlckNyZWRlbnRpYWxJbXBsLl9mb3JPcGVyYXRpb24odXNlciwgb3BlcmF0aW9uVHlwZSwgcmVzcG9uc2UpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBDb252ZXJ0IHVzZXIgZGVsZXRlZCBlcnJvciBpbnRvIHVzZXIgbWlzbWF0Y2hcbiAgICAgICAgaWYgKChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUuY29kZSkgPT09IGBhdXRoLyR7XCJ1c2VyLW5vdC1mb3VuZFwiIC8qIEF1dGhFcnJvckNvZGUuVVNFUl9ERUxFVEVEICovfWApIHtcbiAgICAgICAgICAgIF9mYWlsKGF1dGgsIFwidXNlci1taXNtYXRjaFwiIC8qIEF1dGhFcnJvckNvZGUuVVNFUl9NSVNNQVRDSCAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBfc2lnbkluV2l0aENyZWRlbnRpYWwoYXV0aCwgY3JlZGVudGlhbCwgYnlwYXNzQXV0aFN0YXRlID0gZmFsc2UpIHtcbiAgICBpZiAoX2lzRmlyZWJhc2VTZXJ2ZXJBcHAoYXV0aC5hcHApKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChfc2VydmVyQXBwQ3VycmVudFVzZXJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvcihhdXRoKSk7XG4gICAgfVxuICAgIGNvbnN0IG9wZXJhdGlvblR5cGUgPSBcInNpZ25JblwiIC8qIE9wZXJhdGlvblR5cGUuU0lHTl9JTiAqLztcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9wcm9jZXNzQ3JlZGVudGlhbFNhdmluZ01mYUNvbnRleHRJZk5lY2Vzc2FyeShhdXRoLCBvcGVyYXRpb25UeXBlLCBjcmVkZW50aWFsKTtcbiAgICBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IFVzZXJDcmVkZW50aWFsSW1wbC5fZnJvbUlkVG9rZW5SZXNwb25zZShhdXRoLCBvcGVyYXRpb25UeXBlLCByZXNwb25zZSk7XG4gICAgaWYgKCFieXBhc3NBdXRoU3RhdGUpIHtcbiAgICAgICAgYXdhaXQgYXV0aC5fdXBkYXRlQ3VycmVudFVzZXIodXNlckNyZWRlbnRpYWwudXNlcik7XG4gICAgfVxuICAgIHJldHVybiB1c2VyQ3JlZGVudGlhbDtcbn1cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgc2lnbnMgaW4gd2l0aCB0aGUgZ2l2ZW4gY3JlZGVudGlhbHMuXG4gKlxuICogQHJlbWFya3NcbiAqIEFuIHtAbGluayBBdXRoUHJvdmlkZXJ9IGNhbiBiZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjcmVkZW50aWFsLlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkge0BsaW5rIEF1dGh9IGluc3RhbmNlcyBjcmVhdGVkIHdpdGggYVxuICoge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VTZXJ2ZXJBcHB9LlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBjcmVkZW50aWFsIC0gVGhlIGF1dGggY3JlZGVudGlhbC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhDcmVkZW50aWFsKGF1dGgsIGNyZWRlbnRpYWwpIHtcbiAgICByZXR1cm4gX3NpZ25JbldpdGhDcmVkZW50aWFsKF9jYXN0QXV0aChhdXRoKSwgY3JlZGVudGlhbCk7XG59XG4vKipcbiAqIExpbmtzIHRoZSB1c2VyIGFjY291bnQgd2l0aCB0aGUgZ2l2ZW4gY3JlZGVudGlhbHMuXG4gKlxuICogQHJlbWFya3NcbiAqIEFuIHtAbGluayBBdXRoUHJvdmlkZXJ9IGNhbiBiZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjcmVkZW50aWFsLlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gY3JlZGVudGlhbCAtIFRoZSBhdXRoIGNyZWRlbnRpYWwuXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBsaW5rV2l0aENyZWRlbnRpYWwodXNlciwgY3JlZGVudGlhbCkge1xuICAgIGNvbnN0IHVzZXJJbnRlcm5hbCA9IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKTtcbiAgICBhd2FpdCBfYXNzZXJ0TGlua2VkU3RhdHVzKGZhbHNlLCB1c2VySW50ZXJuYWwsIGNyZWRlbnRpYWwucHJvdmlkZXJJZCk7XG4gICAgcmV0dXJuIF9saW5rKHVzZXJJbnRlcm5hbCwgY3JlZGVudGlhbCk7XG59XG4vKipcbiAqIFJlLWF1dGhlbnRpY2F0ZXMgYSB1c2VyIHVzaW5nIGEgZnJlc2ggY3JlZGVudGlhbC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVXNlIGJlZm9yZSBvcGVyYXRpb25zIHN1Y2ggYXMge0BsaW5rIHVwZGF0ZVBhc3N3b3JkfSB0aGF0IHJlcXVpcmUgdG9rZW5zIGZyb20gcmVjZW50IHNpZ24taW5cbiAqIGF0dGVtcHRzLiBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCB0byByZWNvdmVyIGZyb20gYSBgQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOYCBlcnJvclxuICogb3IgYSBgVE9LRU5fRVhQSVJFRGAgZXJyb3IuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBvbiBhbnkge0BsaW5rIFVzZXJ9IHNpZ25lZCBpbiBieSB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzXG4gKiBjcmVhdGVkIHdpdGggYSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZVNlcnZlckFwcH0uXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqIEBwYXJhbSBjcmVkZW50aWFsIC0gVGhlIGF1dGggY3JlZGVudGlhbC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlYXV0aGVudGljYXRlV2l0aENyZWRlbnRpYWwodXNlciwgY3JlZGVudGlhbCkge1xuICAgIHJldHVybiBfcmVhdXRoZW50aWNhdGUoZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpLCBjcmVkZW50aWFsKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhDdXN0b21Ub2tlbiQxKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1TaWduSW5SZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6c2lnbkluV2l0aEN1c3RvbVRva2VuXCIgLyogRW5kcG9pbnQuU0lHTl9JTl9XSVRIX0NVU1RPTV9UT0tFTiAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgc2lnbnMgaW4gdXNpbmcgYSBjdXN0b20gdG9rZW4uXG4gKlxuICogQHJlbWFya3NcbiAqIEN1c3RvbSB0b2tlbnMgYXJlIHVzZWQgdG8gaW50ZWdyYXRlIEZpcmViYXNlIEF1dGggd2l0aCBleGlzdGluZyBhdXRoIHN5c3RlbXMsIGFuZCBtdXN0XG4gKiBiZSBnZW5lcmF0ZWQgYnkgYW4gYXV0aCBiYWNrZW5kIHVzaW5nIHRoZVxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL3JlZmVyZW5jZS9hZG1pbi9ub2RlL2FkbWluLmF1dGguQXV0aCNjcmVhdGVjdXN0b210b2tlbiB8IGNyZWF0ZUN1c3RvbVRva2VufVxuICogbWV0aG9kIGluIHRoZSB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvYXV0aC9hZG1pbiB8IEFkbWluIFNES30gLlxuICpcbiAqIEZhaWxzIHdpdGggYW4gZXJyb3IgaWYgdGhlIHRva2VuIGlzIGludmFsaWQsIGV4cGlyZWQsIG9yIG5vdCBhY2NlcHRlZCBieSB0aGUgRmlyZWJhc2UgQXV0aCBzZXJ2aWNlLlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkge0BsaW5rIEF1dGh9IGluc3RhbmNlcyBjcmVhdGVkIHdpdGggYVxuICoge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VTZXJ2ZXJBcHB9LlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBjdXN0b21Ub2tlbiAtIFRoZSBjdXN0b20gdG9rZW4gdG8gc2lnbiBpbiB3aXRoLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2lnbkluV2l0aEN1c3RvbVRva2VuKGF1dGgsIGN1c3RvbVRva2VuKSB7XG4gICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKGF1dGguYXBwKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IoYXV0aCkpO1xuICAgIH1cbiAgICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzaWduSW5XaXRoQ3VzdG9tVG9rZW4kMShhdXRoSW50ZXJuYWwsIHtcbiAgICAgICAgdG9rZW46IGN1c3RvbVRva2VuLFxuICAgICAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IGNyZWQgPSBhd2FpdCBVc2VyQ3JlZGVudGlhbEltcGwuX2Zyb21JZFRva2VuUmVzcG9uc2UoYXV0aEludGVybmFsLCBcInNpZ25JblwiIC8qIE9wZXJhdGlvblR5cGUuU0lHTl9JTiAqLywgcmVzcG9uc2UpO1xuICAgIGF3YWl0IGF1dGhJbnRlcm5hbC5fdXBkYXRlQ3VycmVudFVzZXIoY3JlZC51c2VyKTtcbiAgICByZXR1cm4gY3JlZDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIE11bHRpRmFjdG9ySW5mb0ltcGwge1xuICAgIGNvbnN0cnVjdG9yKGZhY3RvcklkLCByZXNwb25zZSkge1xuICAgICAgICB0aGlzLmZhY3RvcklkID0gZmFjdG9ySWQ7XG4gICAgICAgIHRoaXMudWlkID0gcmVzcG9uc2UubWZhRW5yb2xsbWVudElkO1xuICAgICAgICB0aGlzLmVucm9sbG1lbnRUaW1lID0gbmV3IERhdGUocmVzcG9uc2UuZW5yb2xsZWRBdCkudG9VVENTdHJpbmcoKTtcbiAgICAgICAgdGhpcy5kaXNwbGF5TmFtZSA9IHJlc3BvbnNlLmRpc3BsYXlOYW1lO1xuICAgIH1cbiAgICBzdGF0aWMgX2Zyb21TZXJ2ZXJSZXNwb25zZShhdXRoLCBlbnJvbGxtZW50KSB7XG4gICAgICAgIGlmICgncGhvbmVJbmZvJyBpbiBlbnJvbGxtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gUGhvbmVNdWx0aUZhY3RvckluZm9JbXBsLl9mcm9tU2VydmVyUmVzcG9uc2UoYXV0aCwgZW5yb2xsbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ3RvdHBJbmZvJyBpbiBlbnJvbGxtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gVG90cE11bHRpRmFjdG9ySW5mb0ltcGwuX2Zyb21TZXJ2ZXJSZXNwb25zZShhdXRoLCBlbnJvbGxtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2ZhaWwoYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgIH1cbn1cbmNsYXNzIFBob25lTXVsdGlGYWN0b3JJbmZvSW1wbCBleHRlbmRzIE11bHRpRmFjdG9ySW5mb0ltcGwge1xuICAgIGNvbnN0cnVjdG9yKHJlc3BvbnNlKSB7XG4gICAgICAgIHN1cGVyKFwicGhvbmVcIiAvKiBGYWN0b3JJZC5QSE9ORSAqLywgcmVzcG9uc2UpO1xuICAgICAgICB0aGlzLnBob25lTnVtYmVyID0gcmVzcG9uc2UucGhvbmVJbmZvO1xuICAgIH1cbiAgICBzdGF0aWMgX2Zyb21TZXJ2ZXJSZXNwb25zZShfYXV0aCwgZW5yb2xsbWVudCkge1xuICAgICAgICByZXR1cm4gbmV3IFBob25lTXVsdGlGYWN0b3JJbmZvSW1wbChlbnJvbGxtZW50KTtcbiAgICB9XG59XG5jbGFzcyBUb3RwTXVsdGlGYWN0b3JJbmZvSW1wbCBleHRlbmRzIE11bHRpRmFjdG9ySW5mb0ltcGwge1xuICAgIGNvbnN0cnVjdG9yKHJlc3BvbnNlKSB7XG4gICAgICAgIHN1cGVyKFwidG90cFwiIC8qIEZhY3RvcklkLlRPVFAgKi8sIHJlc3BvbnNlKTtcbiAgICB9XG4gICAgc3RhdGljIF9mcm9tU2VydmVyUmVzcG9uc2UoX2F1dGgsIGVucm9sbG1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUb3RwTXVsdGlGYWN0b3JJbmZvSW1wbChlbnJvbGxtZW50KTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBfc2V0QWN0aW9uQ29kZVNldHRpbmdzT25SZXF1ZXN0KGF1dGgsIHJlcXVlc3QsIGFjdGlvbkNvZGVTZXR0aW5ncykge1xuICAgIHZhciBfYTtcbiAgICBfYXNzZXJ0KCgoX2EgPSBhY3Rpb25Db2RlU2V0dGluZ3MudXJsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSA+IDAsIGF1dGgsIFwiaW52YWxpZC1jb250aW51ZS11cmlcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ09OVElOVUVfVVJJICovKTtcbiAgICBfYXNzZXJ0KHR5cGVvZiBhY3Rpb25Db2RlU2V0dGluZ3MuZHluYW1pY0xpbmtEb21haW4gPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgIGFjdGlvbkNvZGVTZXR0aW5ncy5keW5hbWljTGlua0RvbWFpbi5sZW5ndGggPiAwLCBhdXRoLCBcImludmFsaWQtZHluYW1pYy1saW5rLWRvbWFpblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9EWU5BTUlDX0xJTktfRE9NQUlOICovKTtcbiAgICByZXF1ZXN0LmNvbnRpbnVlVXJsID0gYWN0aW9uQ29kZVNldHRpbmdzLnVybDtcbiAgICByZXF1ZXN0LmR5bmFtaWNMaW5rRG9tYWluID0gYWN0aW9uQ29kZVNldHRpbmdzLmR5bmFtaWNMaW5rRG9tYWluO1xuICAgIHJlcXVlc3QuY2FuSGFuZGxlQ29kZUluQXBwID0gYWN0aW9uQ29kZVNldHRpbmdzLmhhbmRsZUNvZGVJbkFwcDtcbiAgICBpZiAoYWN0aW9uQ29kZVNldHRpbmdzLmlPUykge1xuICAgICAgICBfYXNzZXJ0KGFjdGlvbkNvZGVTZXR0aW5ncy5pT1MuYnVuZGxlSWQubGVuZ3RoID4gMCwgYXV0aCwgXCJtaXNzaW5nLWlvcy1idW5kbGUtaWRcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfSU9TX0JVTkRMRV9JRCAqLyk7XG4gICAgICAgIHJlcXVlc3QuaU9TQnVuZGxlSWQgPSBhY3Rpb25Db2RlU2V0dGluZ3MuaU9TLmJ1bmRsZUlkO1xuICAgIH1cbiAgICBpZiAoYWN0aW9uQ29kZVNldHRpbmdzLmFuZHJvaWQpIHtcbiAgICAgICAgX2Fzc2VydChhY3Rpb25Db2RlU2V0dGluZ3MuYW5kcm9pZC5wYWNrYWdlTmFtZS5sZW5ndGggPiAwLCBhdXRoLCBcIm1pc3NpbmctYW5kcm9pZC1wa2ctbmFtZVwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19BTkRST0lEX1BBQ0tBR0VfTkFNRSAqLyk7XG4gICAgICAgIHJlcXVlc3QuYW5kcm9pZEluc3RhbGxBcHAgPSBhY3Rpb25Db2RlU2V0dGluZ3MuYW5kcm9pZC5pbnN0YWxsQXBwO1xuICAgICAgICByZXF1ZXN0LmFuZHJvaWRNaW5pbXVtVmVyc2lvbkNvZGUgPVxuICAgICAgICAgICAgYWN0aW9uQ29kZVNldHRpbmdzLmFuZHJvaWQubWluaW11bVZlcnNpb247XG4gICAgICAgIHJlcXVlc3QuYW5kcm9pZFBhY2thZ2VOYW1lID0gYWN0aW9uQ29kZVNldHRpbmdzLmFuZHJvaWQucGFja2FnZU5hbWU7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBVcGRhdGVzIHRoZSBwYXNzd29yZCBwb2xpY3kgY2FjaGVkIGluIHRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UgaWYgYSBwb2xpY3kgaXMgYWxyZWFkeVxuICogY2FjaGVkIGZvciB0aGUgcHJvamVjdCBvciB0ZW5hbnQuXG4gKlxuICogQHJlbWFya3NcbiAqIFdlIG9ubHkgZmV0Y2ggdGhlIHBhc3N3b3JkIHBvbGljeSBpZiB0aGUgcGFzc3dvcmQgZGlkIG5vdCBtZWV0IHBvbGljeSByZXF1aXJlbWVudHMgYW5kXG4gKiB0aGVyZSBpcyBhbiBleGlzdGluZyBwb2xpY3kgY2FjaGVkLiBBIGRldmVsb3BlciBtdXN0IGNhbGwgdmFsaWRhdGVQYXNzd29yZCBhdCBsZWFzdFxuICogb25jZSBmb3IgdGhlIGNhY2hlIHRvIGJlIGF1dG9tYXRpY2FsbHkgdXBkYXRlZC5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVjYWNoZVBhc3N3b3JkUG9saWN5KGF1dGgpIHtcbiAgICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XG4gICAgaWYgKGF1dGhJbnRlcm5hbC5fZ2V0UGFzc3dvcmRQb2xpY3lJbnRlcm5hbCgpKSB7XG4gICAgICAgIGF3YWl0IGF1dGhJbnRlcm5hbC5fdXBkYXRlUGFzc3dvcmRQb2xpY3koKTtcbiAgICB9XG59XG4vKipcbiAqIFNlbmRzIGEgcGFzc3dvcmQgcmVzZXQgZW1haWwgdG8gdGhlIGdpdmVuIGVtYWlsIGFkZHJlc3MuIFRoaXMgbWV0aG9kIGRvZXMgbm90IHRocm93IGFuIGVycm9yIHdoZW5cbiAqIHRoZXJlJ3Mgbm8gdXNlciBhY2NvdW50IHdpdGggdGhlIGdpdmVuIGVtYWlsIGFkZHJlc3MgYW5kXG4gKiB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2lkZW50aXR5LXBsYXRmb3JtL2RvY3MvYWRtaW4vZW1haWwtZW51bWVyYXRpb24tcHJvdGVjdGlvbiB8IEVtYWlsIEVudW1lcmF0aW9uIFByb3RlY3Rpb259XG4gKiBpcyBlbmFibGVkLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUbyBjb21wbGV0ZSB0aGUgcGFzc3dvcmQgcmVzZXQsIGNhbGwge0BsaW5rIGNvbmZpcm1QYXNzd29yZFJlc2V0fSB3aXRoIHRoZSBjb2RlIHN1cHBsaWVkIGluXG4gKiB0aGUgZW1haWwgc2VudCB0byB0aGUgdXNlciwgYWxvbmcgd2l0aCB0aGUgbmV3IHBhc3N3b3JkIHNwZWNpZmllZCBieSB0aGUgdXNlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgYWN0aW9uQ29kZVNldHRpbmdzID0ge1xuICogICB1cmw6ICdodHRwczovL3d3dy5leGFtcGxlLmNvbS8/ZW1haWw9dXNlckBleGFtcGxlLmNvbScsXG4gKiAgIGlPUzoge1xuICogICAgICBidW5kbGVJZDogJ2NvbS5leGFtcGxlLmlvcydcbiAqICAgfSxcbiAqICAgYW5kcm9pZDoge1xuICogICAgIHBhY2thZ2VOYW1lOiAnY29tLmV4YW1wbGUuYW5kcm9pZCcsXG4gKiAgICAgaW5zdGFsbEFwcDogdHJ1ZSxcbiAqICAgICBtaW5pbXVtVmVyc2lvbjogJzEyJ1xuICogICB9LFxuICogICBoYW5kbGVDb2RlSW5BcHA6IHRydWVcbiAqIH07XG4gKiBhd2FpdCBzZW5kUGFzc3dvcmRSZXNldEVtYWlsKGF1dGgsICd1c2VyQGV4YW1wbGUuY29tJywgYWN0aW9uQ29kZVNldHRpbmdzKTtcbiAqIC8vIE9idGFpbiBjb2RlIGZyb20gdXNlci5cbiAqIGF3YWl0IGNvbmZpcm1QYXNzd29yZFJlc2V0KCd1c2VyQGV4YW1wbGUuY29tJywgY29kZSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gZW1haWwgLSBUaGUgdXNlcidzIGVtYWlsIGFkZHJlc3MuXG4gKiBAcGFyYW0gYWN0aW9uQ29kZVNldHRpbmdzIC0gVGhlIHtAbGluayBBY3Rpb25Db2RlU2V0dGluZ3N9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2VuZFBhc3N3b3JkUmVzZXRFbWFpbChhdXRoLCBlbWFpbCwgYWN0aW9uQ29kZVNldHRpbmdzKSB7XG4gICAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIHJlcXVlc3RUeXBlOiBcIlBBU1NXT1JEX1JFU0VUXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5QQVNTV09SRF9SRVNFVCAqLyxcbiAgICAgICAgZW1haWwsXG4gICAgICAgIGNsaWVudFR5cGU6IFwiQ0xJRU5UX1RZUEVfV0VCXCIgLyogUmVjYXB0Y2hhQ2xpZW50VHlwZS5XRUIgKi9cbiAgICB9O1xuICAgIGlmIChhY3Rpb25Db2RlU2V0dGluZ3MpIHtcbiAgICAgICAgX3NldEFjdGlvbkNvZGVTZXR0aW5nc09uUmVxdWVzdChhdXRoSW50ZXJuYWwsIHJlcXVlc3QsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XG4gICAgfVxuICAgIGF3YWl0IGhhbmRsZVJlY2FwdGNoYUZsb3coYXV0aEludGVybmFsLCByZXF1ZXN0LCBcImdldE9vYkNvZGVcIiAvKiBSZWNhcHRjaGFBY3Rpb25OYW1lLkdFVF9PT0JfQ09ERSAqLywgc2VuZFBhc3N3b3JkUmVzZXRFbWFpbCQxLCBcIkVNQUlMX1BBU1NXT1JEX1BST1ZJREVSXCIgLyogUmVjYXB0Y2hhQXV0aFByb3ZpZGVyLkVNQUlMX1BBU1NXT1JEX1BST1ZJREVSICovKTtcbn1cbi8qKlxuICogQ29tcGxldGVzIHRoZSBwYXNzd29yZCByZXNldCBwcm9jZXNzLCBnaXZlbiBhIGNvbmZpcm1hdGlvbiBjb2RlIGFuZCBuZXcgcGFzc3dvcmQuXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIG9vYkNvZGUgLSBBIGNvbmZpcm1hdGlvbiBjb2RlIHNlbnQgdG8gdGhlIHVzZXIuXG4gKiBAcGFyYW0gbmV3UGFzc3dvcmQgLSBUaGUgbmV3IHBhc3N3b3JkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY29uZmlybVBhc3N3b3JkUmVzZXQoYXV0aCwgb29iQ29kZSwgbmV3UGFzc3dvcmQpIHtcbiAgICBhd2FpdCByZXNldFBhc3N3b3JkKGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKSwge1xuICAgICAgICBvb2JDb2RlLFxuICAgICAgICBuZXdQYXNzd29yZFxuICAgIH0pXG4gICAgICAgIC5jYXRjaChhc3luYyAoZXJyb3IpID0+IHtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09XG4gICAgICAgICAgICBgYXV0aC8ke1wicGFzc3dvcmQtZG9lcy1ub3QtbWVldC1yZXF1aXJlbWVudHNcIiAvKiBBdXRoRXJyb3JDb2RlLlBBU1NXT1JEX0RPRVNfTk9UX01FRVRfUkVRVUlSRU1FTlRTICovfWApIHtcbiAgICAgICAgICAgIHZvaWQgcmVjYWNoZVBhc3N3b3JkUG9saWN5KGF1dGgpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICAgIC8vIERvIG5vdCByZXR1cm4gdGhlIGVtYWlsLlxufVxuLyoqXG4gKiBBcHBsaWVzIGEgdmVyaWZpY2F0aW9uIGNvZGUgc2VudCB0byB0aGUgdXNlciBieSBlbWFpbCBvciBvdGhlciBvdXQtb2YtYmFuZCBtZWNoYW5pc20uXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIG9vYkNvZGUgLSBBIHZlcmlmaWNhdGlvbiBjb2RlIHNlbnQgdG8gdGhlIHVzZXIuXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBhcHBseUFjdGlvbkNvZGUoYXV0aCwgb29iQ29kZSkge1xuICAgIGF3YWl0IGFwcGx5QWN0aW9uQ29kZSQxKGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKSwgeyBvb2JDb2RlIH0pO1xufVxuLyoqXG4gKiBDaGVja3MgYSB2ZXJpZmljYXRpb24gY29kZSBzZW50IHRvIHRoZSB1c2VyIGJ5IGVtYWlsIG9yIG90aGVyIG91dC1vZi1iYW5kIG1lY2hhbmlzbS5cbiAqXG4gKiBAcmV0dXJucyBtZXRhZGF0YSBhYm91dCB0aGUgY29kZS5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gb29iQ29kZSAtIEEgdmVyaWZpY2F0aW9uIGNvZGUgc2VudCB0byB0aGUgdXNlci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrQWN0aW9uQ29kZShhdXRoLCBvb2JDb2RlKSB7XG4gICAgY29uc3QgYXV0aE1vZHVsYXIgPSBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNldFBhc3N3b3JkKGF1dGhNb2R1bGFyLCB7IG9vYkNvZGUgfSk7XG4gICAgLy8gRW1haWwgY291bGQgYmUgZW1wdHkgb25seSBpZiB0aGUgcmVxdWVzdCB0eXBlIGlzIEVNQUlMX1NJR05JTiBvclxuICAgIC8vIFZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMLlxuICAgIC8vIE5ldyBlbWFpbCBzaG91bGQgbm90IGJlIGVtcHR5IGlmIHRoZSByZXF1ZXN0IHR5cGUgaXNcbiAgICAvLyBWRVJJRllfQU5EX0NIQU5HRV9FTUFJTC5cbiAgICAvLyBNdWx0aS1mYWN0b3IgaW5mbyBjb3VsZCBub3QgYmUgZW1wdHkgaWYgdGhlIHJlcXVlc3QgdHlwZSBpc1xuICAgIC8vIFJFVkVSVF9TRUNPTkRfRkFDVE9SX0FERElUSU9OLlxuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHJlc3BvbnNlLnJlcXVlc3RUeXBlO1xuICAgIF9hc3NlcnQob3BlcmF0aW9uLCBhdXRoTW9kdWxhciwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgIHN3aXRjaCAob3BlcmF0aW9uKSB7XG4gICAgICAgIGNhc2UgXCJFTUFJTF9TSUdOSU5cIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLkVNQUlMX1NJR05JTiAqLzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiVkVSSUZZX0FORF9DSEFOR0VfRU1BSUxcIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMICovOlxuICAgICAgICAgICAgX2Fzc2VydChyZXNwb25zZS5uZXdFbWFpbCwgYXV0aE1vZHVsYXIsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUkVWRVJUX1NFQ09ORF9GQUNUT1JfQURESVRJT05cIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlJFVkVSVF9TRUNPTkRfRkFDVE9SX0FERElUSU9OICovOlxuICAgICAgICAgICAgX2Fzc2VydChyZXNwb25zZS5tZmFJbmZvLCBhdXRoTW9kdWxhciwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIF9hc3NlcnQocmVzcG9uc2UuZW1haWwsIGF1dGhNb2R1bGFyLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgfVxuICAgIC8vIFRoZSBtdWx0aS1mYWN0b3IgaW5mbyBmb3IgcmV2ZXJ0IHNlY29uZCBmYWN0b3IgYWRkaXRpb25cbiAgICBsZXQgbXVsdGlGYWN0b3JJbmZvID0gbnVsbDtcbiAgICBpZiAocmVzcG9uc2UubWZhSW5mbykge1xuICAgICAgICBtdWx0aUZhY3RvckluZm8gPSBNdWx0aUZhY3RvckluZm9JbXBsLl9mcm9tU2VydmVyUmVzcG9uc2UoX2Nhc3RBdXRoKGF1dGhNb2R1bGFyKSwgcmVzcG9uc2UubWZhSW5mbyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGVtYWlsOiAocmVzcG9uc2UucmVxdWVzdFR5cGUgPT09IFwiVkVSSUZZX0FORF9DSEFOR0VfRU1BSUxcIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMICovXG4gICAgICAgICAgICAgICAgPyByZXNwb25zZS5uZXdFbWFpbFxuICAgICAgICAgICAgICAgIDogcmVzcG9uc2UuZW1haWwpIHx8IG51bGwsXG4gICAgICAgICAgICBwcmV2aW91c0VtYWlsOiAocmVzcG9uc2UucmVxdWVzdFR5cGUgPT09IFwiVkVSSUZZX0FORF9DSEFOR0VfRU1BSUxcIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMICovXG4gICAgICAgICAgICAgICAgPyByZXNwb25zZS5lbWFpbFxuICAgICAgICAgICAgICAgIDogcmVzcG9uc2UubmV3RW1haWwpIHx8IG51bGwsXG4gICAgICAgICAgICBtdWx0aUZhY3RvckluZm9cbiAgICAgICAgfSxcbiAgICAgICAgb3BlcmF0aW9uXG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2tzIGEgcGFzc3dvcmQgcmVzZXQgY29kZSBzZW50IHRvIHRoZSB1c2VyIGJ5IGVtYWlsIG9yIG90aGVyIG91dC1vZi1iYW5kIG1lY2hhbmlzbS5cbiAqXG4gKiBAcmV0dXJucyB0aGUgdXNlcidzIGVtYWlsIGFkZHJlc3MgaWYgdmFsaWQuXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIGNvZGUgLSBBIHZlcmlmaWNhdGlvbiBjb2RlIHNlbnQgdG8gdGhlIHVzZXIuXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlQYXNzd29yZFJlc2V0Q29kZShhdXRoLCBjb2RlKSB7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBjaGVja0FjdGlvbkNvZGUoZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLCBjb2RlKTtcbiAgICAvLyBFbWFpbCBzaG91bGQgYWx3YXlzIGJlIHByZXNlbnQgc2luY2UgYSBjb2RlIHdhcyBzZW50IHRvIGl0XG4gICAgcmV0dXJuIGRhdGEuZW1haWw7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdXNlciBhY2NvdW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGVtYWlsIGFkZHJlc3MgYW5kIHBhc3N3b3JkLlxuICpcbiAqIEByZW1hcmtzXG4gKiBPbiBzdWNjZXNzZnVsIGNyZWF0aW9uIG9mIHRoZSB1c2VyIGFjY291bnQsIHRoaXMgdXNlciB3aWxsIGFsc28gYmUgc2lnbmVkIGluIHRvIHlvdXIgYXBwbGljYXRpb24uXG4gKlxuICogVXNlciBhY2NvdW50IGNyZWF0aW9uIGNhbiBmYWlsIGlmIHRoZSBhY2NvdW50IGFscmVhZHkgZXhpc3RzIG9yIHRoZSBwYXNzd29yZCBpcyBpbnZhbGlkLlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgb24ge0BsaW5rIEF1dGh9IGluc3RhbmNlcyBjcmVhdGVkIHdpdGggYVxuICoge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VTZXJ2ZXJBcHB9LlxuICpcbiAqIE5vdGU6IFRoZSBlbWFpbCBhZGRyZXNzIGFjdHMgYXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHVzZXIgYW5kIGVuYWJsZXMgYW4gZW1haWwtYmFzZWRcbiAqIHBhc3N3b3JkIHJlc2V0LiBUaGlzIGZ1bmN0aW9uIHdpbGwgY3JlYXRlIGEgbmV3IHVzZXIgYWNjb3VudCBhbmQgc2V0IHRoZSBpbml0aWFsIHVzZXIgcGFzc3dvcmQuXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIGVtYWlsIC0gVGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIHBhc3N3b3JkIC0gVGhlIHVzZXIncyBjaG9zZW4gcGFzc3dvcmQuXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVVc2VyV2l0aEVtYWlsQW5kUGFzc3dvcmQoYXV0aCwgZW1haWwsIHBhc3N3b3JkKSB7XG4gICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKGF1dGguYXBwKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IoYXV0aCkpO1xuICAgIH1cbiAgICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWUsXG4gICAgICAgIGVtYWlsLFxuICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgY2xpZW50VHlwZTogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqL1xuICAgIH07XG4gICAgY29uc3Qgc2lnblVwUmVzcG9uc2UgPSBoYW5kbGVSZWNhcHRjaGFGbG93KGF1dGhJbnRlcm5hbCwgcmVxdWVzdCwgXCJzaWduVXBQYXNzd29yZFwiIC8qIFJlY2FwdGNoYUFjdGlvbk5hbWUuU0lHTl9VUF9QQVNTV09SRCAqLywgc2lnblVwLCBcIkVNQUlMX1BBU1NXT1JEX1BST1ZJREVSXCIgLyogUmVjYXB0Y2hhQXV0aFByb3ZpZGVyLkVNQUlMX1BBU1NXT1JEX1BST1ZJREVSICovKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNpZ25VcFJlc3BvbnNlLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IGBhdXRoLyR7XCJwYXNzd29yZC1kb2VzLW5vdC1tZWV0LXJlcXVpcmVtZW50c1wiIC8qIEF1dGhFcnJvckNvZGUuUEFTU1dPUkRfRE9FU19OT1RfTUVFVF9SRVFVSVJFTUVOVFMgKi99YCkge1xuICAgICAgICAgICAgdm9pZCByZWNhY2hlUGFzc3dvcmRQb2xpY3koYXV0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG4gICAgY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBVc2VyQ3JlZGVudGlhbEltcGwuX2Zyb21JZFRva2VuUmVzcG9uc2UoYXV0aEludGVybmFsLCBcInNpZ25JblwiIC8qIE9wZXJhdGlvblR5cGUuU0lHTl9JTiAqLywgcmVzcG9uc2UpO1xuICAgIGF3YWl0IGF1dGhJbnRlcm5hbC5fdXBkYXRlQ3VycmVudFVzZXIodXNlckNyZWRlbnRpYWwudXNlcik7XG4gICAgcmV0dXJuIHVzZXJDcmVkZW50aWFsO1xufVxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBzaWducyBpbiB1c2luZyBhbiBlbWFpbCBhbmQgcGFzc3dvcmQuXG4gKlxuICogQHJlbWFya3NcbiAqIEZhaWxzIHdpdGggYW4gZXJyb3IgaWYgdGhlIGVtYWlsIGFkZHJlc3MgYW5kIHBhc3N3b3JkIGRvIG5vdCBtYXRjaC4gV2hlblxuICoge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9pZGVudGl0eS1wbGF0Zm9ybS9kb2NzL2FkbWluL2VtYWlsLWVudW1lcmF0aW9uLXByb3RlY3Rpb24gfCBFbWFpbCBFbnVtZXJhdGlvbiBQcm90ZWN0aW9ufVxuICogaXMgZW5hYmxlZCwgdGhpcyBtZXRob2QgZmFpbHMgd2l0aCBcImF1dGgvaW52YWxpZC1jcmVkZW50aWFsXCIgaW4gY2FzZSBvZiBhbiBpbnZhbGlkXG4gKiBlbWFpbC9wYXNzd29yZC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIG9uIHtAbGluayBBdXRofSBpbnN0YW5jZXMgY3JlYXRlZCB3aXRoIGFcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cbiAqXG4gKiBOb3RlOiBUaGUgdXNlcidzIHBhc3N3b3JkIGlzIE5PVCB0aGUgcGFzc3dvcmQgdXNlZCB0byBhY2Nlc3MgdGhlIHVzZXIncyBlbWFpbCBhY2NvdW50LiBUaGVcbiAqIGVtYWlsIGFkZHJlc3Mgc2VydmVzIGFzIGEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB1c2VyLCBhbmQgdGhlIHBhc3N3b3JkIGlzIHVzZWQgdG8gYWNjZXNzXG4gKiB0aGUgdXNlcidzIGFjY291bnQgaW4geW91ciBGaXJlYmFzZSBwcm9qZWN0LiBTZWUgYWxzbzoge0BsaW5rIGNyZWF0ZVVzZXJXaXRoRW1haWxBbmRQYXNzd29yZH0uXG4gKlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBlbWFpbCAtIFRoZSB1c2VycyBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIHBhc3N3b3JkIC0gVGhlIHVzZXJzIHBhc3N3b3JkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc2lnbkluV2l0aEVtYWlsQW5kUGFzc3dvcmQoYXV0aCwgZW1haWwsIHBhc3N3b3JkKSB7XG4gICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKGF1dGguYXBwKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IoYXV0aCkpO1xuICAgIH1cbiAgICByZXR1cm4gc2lnbkluV2l0aENyZWRlbnRpYWwoZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLCBFbWFpbEF1dGhQcm92aWRlci5jcmVkZW50aWFsKGVtYWlsLCBwYXNzd29yZCkpLmNhdGNoKGFzeW5jIChlcnJvcikgPT4ge1xuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gYGF1dGgvJHtcInBhc3N3b3JkLWRvZXMtbm90LW1lZXQtcmVxdWlyZW1lbnRzXCIgLyogQXV0aEVycm9yQ29kZS5QQVNTV09SRF9ET0VTX05PVF9NRUVUX1JFUVVJUkVNRU5UUyAqL31gKSB7XG4gICAgICAgICAgICB2b2lkIHJlY2FjaGVQYXNzd29yZFBvbGljeShhdXRoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogU2VuZHMgYSBzaWduLWluIGVtYWlsIGxpbmsgdG8gdGhlIHVzZXIgd2l0aCB0aGUgc3BlY2lmaWVkIGVtYWlsLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgc2lnbi1pbiBvcGVyYXRpb24gaGFzIHRvIGFsd2F5cyBiZSBjb21wbGV0ZWQgaW4gdGhlIGFwcCB1bmxpa2Ugb3RoZXIgb3V0IG9mIGJhbmQgZW1haWxcbiAqIGFjdGlvbnMgKHBhc3N3b3JkIHJlc2V0IGFuZCBlbWFpbCB2ZXJpZmljYXRpb25zKS4gVGhpcyBpcyBiZWNhdXNlLCBhdCB0aGUgZW5kIG9mIHRoZSBmbG93LFxuICogdGhlIHVzZXIgaXMgZXhwZWN0ZWQgdG8gYmUgc2lnbmVkIGluIGFuZCB0aGVpciBBdXRoIHN0YXRlIHBlcnNpc3RlZCB3aXRoaW4gdGhlIGFwcC5cbiAqXG4gKiBUbyBjb21wbGV0ZSBzaWduIGluIHdpdGggdGhlIGVtYWlsIGxpbmssIGNhbGwge0BsaW5rIHNpZ25JbldpdGhFbWFpbExpbmt9IHdpdGggdGhlIGVtYWlsXG4gKiBhZGRyZXNzIGFuZCB0aGUgZW1haWwgbGluayBzdXBwbGllZCBpbiB0aGUgZW1haWwgc2VudCB0byB0aGUgdXNlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgYWN0aW9uQ29kZVNldHRpbmdzID0ge1xuICogICB1cmw6ICdodHRwczovL3d3dy5leGFtcGxlLmNvbS8/ZW1haWw9dXNlckBleGFtcGxlLmNvbScsXG4gKiAgIGlPUzoge1xuICogICAgICBidW5kbGVJZDogJ2NvbS5leGFtcGxlLmlvcydcbiAqICAgfSxcbiAqICAgYW5kcm9pZDoge1xuICogICAgIHBhY2thZ2VOYW1lOiAnY29tLmV4YW1wbGUuYW5kcm9pZCcsXG4gKiAgICAgaW5zdGFsbEFwcDogdHJ1ZSxcbiAqICAgICBtaW5pbXVtVmVyc2lvbjogJzEyJ1xuICogICB9LFxuICogICBoYW5kbGVDb2RlSW5BcHA6IHRydWVcbiAqIH07XG4gKiBhd2FpdCBzZW5kU2lnbkluTGlua1RvRW1haWwoYXV0aCwgJ3VzZXJAZXhhbXBsZS5jb20nLCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xuICogLy8gT2J0YWluIGVtYWlsTGluayBmcm9tIHRoZSB1c2VyLlxuICogaWYoaXNTaWduSW5XaXRoRW1haWxMaW5rKGF1dGgsIGVtYWlsTGluaykpIHtcbiAqICAgYXdhaXQgc2lnbkluV2l0aEVtYWlsTGluayhhdXRoLCAndXNlckBleGFtcGxlLmNvbScsIGVtYWlsTGluayk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aEludGVybmFsIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBlbWFpbCAtIFRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cbiAqIEBwYXJhbSBhY3Rpb25Db2RlU2V0dGluZ3MgLSBUaGUge0BsaW5rIEFjdGlvbkNvZGVTZXR0aW5nc30uXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBzZW5kU2lnbkluTGlua1RvRW1haWwoYXV0aCwgZW1haWwsIGFjdGlvbkNvZGVTZXR0aW5ncykge1xuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICByZXF1ZXN0VHlwZTogXCJFTUFJTF9TSUdOSU5cIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLkVNQUlMX1NJR05JTiAqLyxcbiAgICAgICAgZW1haWwsXG4gICAgICAgIGNsaWVudFR5cGU6IFwiQ0xJRU5UX1RZUEVfV0VCXCIgLyogUmVjYXB0Y2hhQ2xpZW50VHlwZS5XRUIgKi9cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHNldEFjdGlvbkNvZGVTZXR0aW5ncyhyZXF1ZXN0LCBhY3Rpb25Db2RlU2V0dGluZ3MpIHtcbiAgICAgICAgX2Fzc2VydChhY3Rpb25Db2RlU2V0dGluZ3MuaGFuZGxlQ29kZUluQXBwLCBhdXRoSW50ZXJuYWwsIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcbiAgICAgICAgaWYgKGFjdGlvbkNvZGVTZXR0aW5ncykge1xuICAgICAgICAgICAgX3NldEFjdGlvbkNvZGVTZXR0aW5nc09uUmVxdWVzdChhdXRoSW50ZXJuYWwsIHJlcXVlc3QsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0QWN0aW9uQ29kZVNldHRpbmdzKHJlcXVlc3QsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XG4gICAgYXdhaXQgaGFuZGxlUmVjYXB0Y2hhRmxvdyhhdXRoSW50ZXJuYWwsIHJlcXVlc3QsIFwiZ2V0T29iQ29kZVwiIC8qIFJlY2FwdGNoYUFjdGlvbk5hbWUuR0VUX09PQl9DT0RFICovLCBzZW5kU2lnbkluTGlua1RvRW1haWwkMSwgXCJFTUFJTF9QQVNTV09SRF9QUk9WSURFUlwiIC8qIFJlY2FwdGNoYUF1dGhQcm92aWRlci5FTUFJTF9QQVNTV09SRF9QUk9WSURFUiAqLyk7XG59XG4vKipcbiAqIENoZWNrcyBpZiBhbiBpbmNvbWluZyBsaW5rIGlzIGEgc2lnbi1pbiB3aXRoIGVtYWlsIGxpbmsgc3VpdGFibGUgZm9yIHtAbGluayBzaWduSW5XaXRoRW1haWxMaW5rfS5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gZW1haWxMaW5rIC0gVGhlIGxpbmsgc2VudCB0byB0aGUgdXNlcidzIGVtYWlsIGFkZHJlc3MuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpc1NpZ25JbldpdGhFbWFpbExpbmsoYXV0aCwgZW1haWxMaW5rKSB7XG4gICAgY29uc3QgYWN0aW9uQ29kZVVybCA9IEFjdGlvbkNvZGVVUkwucGFyc2VMaW5rKGVtYWlsTGluayk7XG4gICAgcmV0dXJuIChhY3Rpb25Db2RlVXJsID09PSBudWxsIHx8IGFjdGlvbkNvZGVVcmwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGlvbkNvZGVVcmwub3BlcmF0aW9uKSA9PT0gXCJFTUFJTF9TSUdOSU5cIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLkVNQUlMX1NJR05JTiAqLztcbn1cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgc2lnbnMgaW4gdXNpbmcgYW4gZW1haWwgYW5kIHNpZ24taW4gZW1haWwgbGluay5cbiAqXG4gKiBAcmVtYXJrc1xuICogSWYgbm8gbGluayBpcyBwYXNzZWQsIHRoZSBsaW5rIGlzIGluZmVycmVkIGZyb20gdGhlIGN1cnJlbnQgVVJMLlxuICpcbiAqIEZhaWxzIHdpdGggYW4gZXJyb3IgaWYgdGhlIGVtYWlsIGFkZHJlc3MgaXMgaW52YWxpZCBvciBPVFAgaW4gZW1haWwgbGluayBleHBpcmVzLlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkge0BsaW5rIEF1dGh9IGluc3RhbmNlcyBjcmVhdGVkIHdpdGggYVxuICoge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VTZXJ2ZXJBcHB9LlxuICpcbiAqIE5vdGU6IENvbmZpcm0gdGhlIGxpbmsgaXMgYSBzaWduLWluIGVtYWlsIGxpbmsgYmVmb3JlIGNhbGxpbmcgdGhpcyBtZXRob2QgZmlyZWJhc2UuYXV0aC5BdXRoLmlzU2lnbkluV2l0aEVtYWlsTGluay5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgYWN0aW9uQ29kZVNldHRpbmdzID0ge1xuICogICB1cmw6ICdodHRwczovL3d3dy5leGFtcGxlLmNvbS8/ZW1haWw9dXNlckBleGFtcGxlLmNvbScsXG4gKiAgIGlPUzoge1xuICogICAgICBidW5kbGVJZDogJ2NvbS5leGFtcGxlLmlvcydcbiAqICAgfSxcbiAqICAgYW5kcm9pZDoge1xuICogICAgIHBhY2thZ2VOYW1lOiAnY29tLmV4YW1wbGUuYW5kcm9pZCcsXG4gKiAgICAgaW5zdGFsbEFwcDogdHJ1ZSxcbiAqICAgICBtaW5pbXVtVmVyc2lvbjogJzEyJ1xuICogICB9LFxuICogICBoYW5kbGVDb2RlSW5BcHA6IHRydWVcbiAqIH07XG4gKiBhd2FpdCBzZW5kU2lnbkluTGlua1RvRW1haWwoYXV0aCwgJ3VzZXJAZXhhbXBsZS5jb20nLCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xuICogLy8gT2J0YWluIGVtYWlsTGluayBmcm9tIHRoZSB1c2VyLlxuICogaWYoaXNTaWduSW5XaXRoRW1haWxMaW5rKGF1dGgsIGVtYWlsTGluaykpIHtcbiAqICAgYXdhaXQgc2lnbkluV2l0aEVtYWlsTGluayhhdXRoLCAndXNlckBleGFtcGxlLmNvbScsIGVtYWlsTGluayk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIGVtYWlsIC0gVGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIGVtYWlsTGluayAtIFRoZSBsaW5rIHNlbnQgdG8gdGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2lnbkluV2l0aEVtYWlsTGluayhhdXRoLCBlbWFpbCwgZW1haWxMaW5rKSB7XG4gICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKGF1dGguYXBwKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IoYXV0aCkpO1xuICAgIH1cbiAgICBjb25zdCBhdXRoTW9kdWxhciA9IGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKTtcbiAgICBjb25zdCBjcmVkZW50aWFsID0gRW1haWxBdXRoUHJvdmlkZXIuY3JlZGVudGlhbFdpdGhMaW5rKGVtYWlsLCBlbWFpbExpbmsgfHwgX2dldEN1cnJlbnRVcmwoKSk7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHRlbmFudCBJRCBpbiB0aGUgZW1haWwgbGluayBtYXRjaGVzIHRoZSB0ZW5hbnQgSUQgb24gQXV0aFxuICAgIC8vIGluc3RhbmNlLlxuICAgIF9hc3NlcnQoY3JlZGVudGlhbC5fdGVuYW50SWQgPT09IChhdXRoTW9kdWxhci50ZW5hbnRJZCB8fCBudWxsKSwgYXV0aE1vZHVsYXIsIFwidGVuYW50LWlkLW1pc21hdGNoXCIgLyogQXV0aEVycm9yQ29kZS5URU5BTlRfSURfTUlTTUFUQ0ggKi8pO1xuICAgIHJldHVybiBzaWduSW5XaXRoQ3JlZGVudGlhbChhdXRoTW9kdWxhciwgY3JlZGVudGlhbCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVBdXRoVXJpKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6Y3JlYXRlQXV0aFVyaVwiIC8qIEVuZHBvaW50LkNSRUFURV9BVVRIX1VSSSAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBvZiBwb3NzaWJsZSBzaWduIGluIG1ldGhvZHMgZm9yIHRoZSBnaXZlbiBlbWFpbCBhZGRyZXNzLiBUaGlzIG1ldGhvZCByZXR1cm5zIGFuXG4gKiBlbXB0eSBsaXN0IHdoZW5cbiAqIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vaWRlbnRpdHktcGxhdGZvcm0vZG9jcy9hZG1pbi9lbWFpbC1lbnVtZXJhdGlvbi1wcm90ZWN0aW9uIHwgRW1haWwgRW51bWVyYXRpb24gUHJvdGVjdGlvbn1cbiAqIGlzIGVuYWJsZWQsIGlycmVzcGVjdGl2ZSBvZiB0aGUgbnVtYmVyIG9mIGF1dGhlbnRpY2F0aW9uIG1ldGhvZHMgYXZhaWxhYmxlIGZvciB0aGUgZ2l2ZW4gZW1haWwuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgaXMgdXNlZnVsIHRvIGRpZmZlcmVudGlhdGUgbWV0aG9kcyBvZiBzaWduLWluIGZvciB0aGUgc2FtZSBwcm92aWRlciwgZWcuXG4gKiB7QGxpbmsgRW1haWxBdXRoUHJvdmlkZXJ9IHdoaWNoIGhhcyAyIG1ldGhvZHMgb2Ygc2lnbi1pbixcbiAqIHtAbGluayBTaWduSW5NZXRob2R9LkVNQUlMX1BBU1NXT1JEIGFuZFxuICoge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfTElOSy5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gZW1haWwgLSBUaGUgdXNlcidzIGVtYWlsIGFkZHJlc3MuXG4gKlxuICogRGVwcmVjYXRlZC4gTWlncmF0aW5nIG9mZiBvZiB0aGlzIG1ldGhvZCBpcyByZWNvbW1lbmRlZCBhcyBhIHNlY3VyaXR5IGJlc3QtcHJhY3RpY2UuXG4gKiBMZWFybiBtb3JlIGluIHRoZSBJZGVudGl0eSBQbGF0Zm9ybSBkb2N1bWVudGF0aW9uIGZvclxuICoge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9pZGVudGl0eS1wbGF0Zm9ybS9kb2NzL2FkbWluL2VtYWlsLWVudW1lcmF0aW9uLXByb3RlY3Rpb24gfCBFbWFpbCBFbnVtZXJhdGlvbiBQcm90ZWN0aW9ufS5cbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hTaWduSW5NZXRob2RzRm9yRW1haWwoYXV0aCwgZW1haWwpIHtcbiAgICAvLyBjcmVhdGVBdXRoVXJpIHJldHVybnMgYW4gZXJyb3IgaWYgY29udGludWUgVVJJIGlzIG5vdCBodHRwIG9yIGh0dHBzLlxuICAgIC8vIEZvciBlbnZpcm9ubWVudHMgbGlrZSBDb3Jkb3ZhLCBDaHJvbWUgZXh0ZW5zaW9ucywgbmF0aXZlIGZyYW1ld29ya3MsIGZpbGVcbiAgICAvLyBzeXN0ZW1zLCBldGMsIHVzZSBodHRwOi8vbG9jYWxob3N0IGFzIGNvbnRpbnVlIFVSTC5cbiAgICBjb25zdCBjb250aW51ZVVyaSA9IF9pc0h0dHBPckh0dHBzKCkgPyBfZ2V0Q3VycmVudFVybCgpIDogJ2h0dHA6Ly9sb2NhbGhvc3QnO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIGlkZW50aWZpZXI6IGVtYWlsLFxuICAgICAgICBjb250aW51ZVVyaVxuICAgIH07XG4gICAgY29uc3QgeyBzaWduaW5NZXRob2RzIH0gPSBhd2FpdCBjcmVhdGVBdXRoVXJpKGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKSwgcmVxdWVzdCk7XG4gICAgcmV0dXJuIHNpZ25pbk1ldGhvZHMgfHwgW107XG59XG4vKipcbiAqIFNlbmRzIGEgdmVyaWZpY2F0aW9uIGVtYWlsIHRvIGEgdXNlci5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIHZlcmlmaWNhdGlvbiBwcm9jZXNzIGlzIGNvbXBsZXRlZCBieSBjYWxsaW5nIHtAbGluayBhcHBseUFjdGlvbkNvZGV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBhY3Rpb25Db2RlU2V0dGluZ3MgPSB7XG4gKiAgIHVybDogJ2h0dHBzOi8vd3d3LmV4YW1wbGUuY29tLz9lbWFpbD11c2VyQGV4YW1wbGUuY29tJyxcbiAqICAgaU9TOiB7XG4gKiAgICAgIGJ1bmRsZUlkOiAnY29tLmV4YW1wbGUuaW9zJ1xuICogICB9LFxuICogICBhbmRyb2lkOiB7XG4gKiAgICAgcGFja2FnZU5hbWU6ICdjb20uZXhhbXBsZS5hbmRyb2lkJyxcbiAqICAgICBpbnN0YWxsQXBwOiB0cnVlLFxuICogICAgIG1pbmltdW1WZXJzaW9uOiAnMTInXG4gKiAgIH0sXG4gKiAgIGhhbmRsZUNvZGVJbkFwcDogdHJ1ZVxuICogfTtcbiAqIGF3YWl0IHNlbmRFbWFpbFZlcmlmaWNhdGlvbih1c2VyLCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xuICogLy8gT2J0YWluIGNvZGUgZnJvbSB0aGUgdXNlci5cbiAqIGF3YWl0IGFwcGx5QWN0aW9uQ29kZShhdXRoLCBjb2RlKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gYWN0aW9uQ29kZVNldHRpbmdzIC0gVGhlIHtAbGluayBBY3Rpb25Db2RlU2V0dGluZ3N9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2VuZEVtYWlsVmVyaWZpY2F0aW9uKHVzZXIsIGFjdGlvbkNvZGVTZXR0aW5ncykge1xuICAgIGNvbnN0IHVzZXJJbnRlcm5hbCA9IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKTtcbiAgICBjb25zdCBpZFRva2VuID0gYXdhaXQgdXNlci5nZXRJZFRva2VuKCk7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgcmVxdWVzdFR5cGU6IFwiVkVSSUZZX0VNQUlMXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfRU1BSUwgKi8sXG4gICAgICAgIGlkVG9rZW5cbiAgICB9O1xuICAgIGlmIChhY3Rpb25Db2RlU2V0dGluZ3MpIHtcbiAgICAgICAgX3NldEFjdGlvbkNvZGVTZXR0aW5nc09uUmVxdWVzdCh1c2VySW50ZXJuYWwuYXV0aCwgcmVxdWVzdCwgYWN0aW9uQ29kZVNldHRpbmdzKTtcbiAgICB9XG4gICAgY29uc3QgeyBlbWFpbCB9ID0gYXdhaXQgc2VuZEVtYWlsVmVyaWZpY2F0aW9uJDEodXNlckludGVybmFsLmF1dGgsIHJlcXVlc3QpO1xuICAgIGlmIChlbWFpbCAhPT0gdXNlci5lbWFpbCkge1xuICAgICAgICBhd2FpdCB1c2VyLnJlbG9hZCgpO1xuICAgIH1cbn1cbi8qKlxuICogU2VuZHMgYSB2ZXJpZmljYXRpb24gZW1haWwgdG8gYSBuZXcgZW1haWwgYWRkcmVzcy5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIHVzZXIncyBlbWFpbCB3aWxsIGJlIHVwZGF0ZWQgdG8gdGhlIG5ldyBvbmUgYWZ0ZXIgYmVpbmcgdmVyaWZpZWQuXG4gKlxuICogSWYgeW91IGhhdmUgYSBjdXN0b20gZW1haWwgYWN0aW9uIGhhbmRsZXIsIHlvdSBjYW4gY29tcGxldGUgdGhlIHZlcmlmaWNhdGlvbiBwcm9jZXNzIGJ5IGNhbGxpbmdcbiAqIHtAbGluayBhcHBseUFjdGlvbkNvZGV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBhY3Rpb25Db2RlU2V0dGluZ3MgPSB7XG4gKiAgIHVybDogJ2h0dHBzOi8vd3d3LmV4YW1wbGUuY29tLz9lbWFpbD11c2VyQGV4YW1wbGUuY29tJyxcbiAqICAgaU9TOiB7XG4gKiAgICAgIGJ1bmRsZUlkOiAnY29tLmV4YW1wbGUuaW9zJ1xuICogICB9LFxuICogICBhbmRyb2lkOiB7XG4gKiAgICAgcGFja2FnZU5hbWU6ICdjb20uZXhhbXBsZS5hbmRyb2lkJyxcbiAqICAgICBpbnN0YWxsQXBwOiB0cnVlLFxuICogICAgIG1pbmltdW1WZXJzaW9uOiAnMTInXG4gKiAgIH0sXG4gKiAgIGhhbmRsZUNvZGVJbkFwcDogdHJ1ZVxuICogfTtcbiAqIGF3YWl0IHZlcmlmeUJlZm9yZVVwZGF0ZUVtYWlsKHVzZXIsICduZXdlbWFpbEBleGFtcGxlLmNvbScsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XG4gKiAvLyBPYnRhaW4gY29kZSBmcm9tIHRoZSB1c2VyLlxuICogYXdhaXQgYXBwbHlBY3Rpb25Db2RlKGF1dGgsIGNvZGUpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqIEBwYXJhbSBuZXdFbWFpbCAtIFRoZSBuZXcgZW1haWwgYWRkcmVzcyB0byBiZSB2ZXJpZmllZCBiZWZvcmUgdXBkYXRlLlxuICogQHBhcmFtIGFjdGlvbkNvZGVTZXR0aW5ncyAtIFRoZSB7QGxpbmsgQWN0aW9uQ29kZVNldHRpbmdzfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeUJlZm9yZVVwZGF0ZUVtYWlsKHVzZXIsIG5ld0VtYWlsLCBhY3Rpb25Db2RlU2V0dGluZ3MpIHtcbiAgICBjb25zdCB1c2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcik7XG4gICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIHJlcXVlc3RUeXBlOiBcIlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfQU5EX0NIQU5HRV9FTUFJTCAqLyxcbiAgICAgICAgaWRUb2tlbixcbiAgICAgICAgbmV3RW1haWxcbiAgICB9O1xuICAgIGlmIChhY3Rpb25Db2RlU2V0dGluZ3MpIHtcbiAgICAgICAgX3NldEFjdGlvbkNvZGVTZXR0aW5nc09uUmVxdWVzdCh1c2VySW50ZXJuYWwuYXV0aCwgcmVxdWVzdCwgYWN0aW9uQ29kZVNldHRpbmdzKTtcbiAgICB9XG4gICAgY29uc3QgeyBlbWFpbCB9ID0gYXdhaXQgdmVyaWZ5QW5kQ2hhbmdlRW1haWwodXNlckludGVybmFsLmF1dGgsIHJlcXVlc3QpO1xuICAgIGlmIChlbWFpbCAhPT0gdXNlci5lbWFpbCkge1xuICAgICAgICAvLyBJZiB0aGUgbG9jYWwgY29weSBvZiB0aGUgZW1haWwgb24gdXNlciBpcyBvdXRkYXRlZCwgcmVsb2FkIHRoZVxuICAgICAgICAvLyB1c2VyLlxuICAgICAgICBhd2FpdCB1c2VyLnJlbG9hZCgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVByb2ZpbGUkMShhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnVwZGF0ZVwiIC8qIEVuZHBvaW50LlNFVF9BQ0NPVU5UX0lORk8gKi8sIHJlcXVlc3QpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBVcGRhdGVzIGEgdXNlcidzIHByb2ZpbGUgZGF0YS5cbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICogQHBhcmFtIHByb2ZpbGUgLSBUaGUgcHJvZmlsZSdzIGBkaXNwbGF5TmFtZWAgYW5kIGBwaG90b1VSTGAgdG8gdXBkYXRlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdXBkYXRlUHJvZmlsZSh1c2VyLCB7IGRpc3BsYXlOYW1lLCBwaG90b1VSTDogcGhvdG9VcmwgfSkge1xuICAgIGlmIChkaXNwbGF5TmFtZSA9PT0gdW5kZWZpbmVkICYmIHBob3RvVXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB1c2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcik7XG4gICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHVzZXJJbnRlcm5hbC5nZXRJZFRva2VuKCk7XG4gICAgY29uc3QgcHJvZmlsZVJlcXVlc3QgPSB7XG4gICAgICAgIGlkVG9rZW4sXG4gICAgICAgIGRpc3BsYXlOYW1lLFxuICAgICAgICBwaG90b1VybCxcbiAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWVcbiAgICB9O1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodXNlckludGVybmFsLCB1cGRhdGVQcm9maWxlJDEodXNlckludGVybmFsLmF1dGgsIHByb2ZpbGVSZXF1ZXN0KSk7XG4gICAgdXNlckludGVybmFsLmRpc3BsYXlOYW1lID0gcmVzcG9uc2UuZGlzcGxheU5hbWUgfHwgbnVsbDtcbiAgICB1c2VySW50ZXJuYWwucGhvdG9VUkwgPSByZXNwb25zZS5waG90b1VybCB8fCBudWxsO1xuICAgIC8vIFVwZGF0ZSB0aGUgcGFzc3dvcmQgcHJvdmlkZXIgYXMgd2VsbFxuICAgIGNvbnN0IHBhc3N3b3JkUHJvdmlkZXIgPSB1c2VySW50ZXJuYWwucHJvdmlkZXJEYXRhLmZpbmQoKHsgcHJvdmlkZXJJZCB9KSA9PiBwcm92aWRlcklkID09PSBcInBhc3N3b3JkXCIgLyogUHJvdmlkZXJJZC5QQVNTV09SRCAqLyk7XG4gICAgaWYgKHBhc3N3b3JkUHJvdmlkZXIpIHtcbiAgICAgICAgcGFzc3dvcmRQcm92aWRlci5kaXNwbGF5TmFtZSA9IHVzZXJJbnRlcm5hbC5kaXNwbGF5TmFtZTtcbiAgICAgICAgcGFzc3dvcmRQcm92aWRlci5waG90b1VSTCA9IHVzZXJJbnRlcm5hbC5waG90b1VSTDtcbiAgICB9XG4gICAgYXdhaXQgdXNlckludGVybmFsLl91cGRhdGVUb2tlbnNJZk5lY2Vzc2FyeShyZXNwb25zZSk7XG59XG4vKipcbiAqIFVwZGF0ZXMgdGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxuICpcbiAqIEByZW1hcmtzXG4gKiBBbiBlbWFpbCB3aWxsIGJlIHNlbnQgdG8gdGhlIG9yaWdpbmFsIGVtYWlsIGFkZHJlc3MgKGlmIGl0IHdhcyBzZXQpIHRoYXQgYWxsb3dzIHRvIHJldm9rZSB0aGVcbiAqIGVtYWlsIGFkZHJlc3MgY2hhbmdlLCBpbiBvcmRlciB0byBwcm90ZWN0IHRoZW0gZnJvbSBhY2NvdW50IGhpamFja2luZy5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIG9uIGFueSB7QGxpbmsgVXNlcn0gc2lnbmVkIGluIGJ5IHtAbGluayBBdXRofSBpbnN0YW5jZXNcbiAqIGNyZWF0ZWQgd2l0aCBhIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cbiAqXG4gKiBJbXBvcnRhbnQ6IHRoaXMgaXMgYSBzZWN1cml0eSBzZW5zaXRpdmUgb3BlcmF0aW9uIHRoYXQgcmVxdWlyZXMgdGhlIHVzZXIgdG8gaGF2ZSByZWNlbnRseSBzaWduZWRcbiAqIGluLiBJZiB0aGlzIHJlcXVpcmVtZW50IGlzbid0IG1ldCwgYXNrIHRoZSB1c2VyIHRvIGF1dGhlbnRpY2F0ZSBhZ2FpbiBhbmQgdGhlbiBjYWxsXG4gKiB7QGxpbmsgcmVhdXRoZW50aWNhdGVXaXRoQ3JlZGVudGlhbH0uXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqIEBwYXJhbSBuZXdFbWFpbCAtIFRoZSBuZXcgZW1haWwgYWRkcmVzcy5cbiAqXG4gKiBUaHJvd3MgXCJhdXRoL29wZXJhdGlvbi1ub3QtYWxsb3dlZFwiIGVycm9yIHdoZW5cbiAqIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vaWRlbnRpdHktcGxhdGZvcm0vZG9jcy9hZG1pbi9lbWFpbC1lbnVtZXJhdGlvbi1wcm90ZWN0aW9uIHwgRW1haWwgRW51bWVyYXRpb24gUHJvdGVjdGlvbn1cbiAqIGlzIGVuYWJsZWQuXG4gKiBEZXByZWNhdGVkIC0gVXNlIHtAbGluayB2ZXJpZnlCZWZvcmVVcGRhdGVFbWFpbH0gaW5zdGVhZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUVtYWlsKHVzZXIsIG5ld0VtYWlsKSB7XG4gICAgY29uc3QgdXNlckludGVybmFsID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xuICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcCh1c2VySW50ZXJuYWwuYXV0aC5hcHApKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChfc2VydmVyQXBwQ3VycmVudFVzZXJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvcih1c2VySW50ZXJuYWwuYXV0aCkpO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlRW1haWxPclBhc3N3b3JkKHVzZXJJbnRlcm5hbCwgbmV3RW1haWwsIG51bGwpO1xufVxuLyoqXG4gKiBVcGRhdGVzIHRoZSB1c2VyJ3MgcGFzc3dvcmQuXG4gKlxuICogQHJlbWFya3NcbiAqIEltcG9ydGFudDogdGhpcyBpcyBhIHNlY3VyaXR5IHNlbnNpdGl2ZSBvcGVyYXRpb24gdGhhdCByZXF1aXJlcyB0aGUgdXNlciB0byBoYXZlIHJlY2VudGx5IHNpZ25lZFxuICogaW4uIElmIHRoaXMgcmVxdWlyZW1lbnQgaXNuJ3QgbWV0LCBhc2sgdGhlIHVzZXIgdG8gYXV0aGVudGljYXRlIGFnYWluIGFuZCB0aGVuIGNhbGxcbiAqIHtAbGluayByZWF1dGhlbnRpY2F0ZVdpdGhDcmVkZW50aWFsfS5cbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICogQHBhcmFtIG5ld1Bhc3N3b3JkIC0gVGhlIG5ldyBwYXNzd29yZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVBhc3N3b3JkKHVzZXIsIG5ld1Bhc3N3b3JkKSB7XG4gICAgcmV0dXJuIHVwZGF0ZUVtYWlsT3JQYXNzd29yZChnZXRNb2R1bGFySW5zdGFuY2UodXNlciksIG51bGwsIG5ld1Bhc3N3b3JkKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUVtYWlsT3JQYXNzd29yZCh1c2VyLCBlbWFpbCwgcGFzc3dvcmQpIHtcbiAgICBjb25zdCB7IGF1dGggfSA9IHVzZXI7XG4gICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIGlkVG9rZW4sXG4gICAgICAgIHJldHVyblNlY3VyZVRva2VuOiB0cnVlXG4gICAgfTtcbiAgICBpZiAoZW1haWwpIHtcbiAgICAgICAgcmVxdWVzdC5lbWFpbCA9IGVtYWlsO1xuICAgIH1cbiAgICBpZiAocGFzc3dvcmQpIHtcbiAgICAgICAgcmVxdWVzdC5wYXNzd29yZCA9IHBhc3N3b3JkO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9sb2dvdXRJZkludmFsaWRhdGVkKHVzZXIsIHVwZGF0ZUVtYWlsUGFzc3dvcmQoYXV0aCwgcmVxdWVzdCkpO1xuICAgIGF3YWl0IHVzZXIuX3VwZGF0ZVRva2Vuc0lmTmVjZXNzYXJ5KHJlc3BvbnNlLCAvKiByZWxvYWQgKi8gdHJ1ZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFBhcnNlIHRoZSBgQWRkaXRpb25hbFVzZXJJbmZvYCBmcm9tIHRoZSBJRCB0b2tlbiByZXNwb25zZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIF9mcm9tSWRUb2tlblJlc3BvbnNlKGlkVG9rZW5SZXNwb25zZSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKCFpZFRva2VuUmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgcHJvdmlkZXJJZCB9ID0gaWRUb2tlblJlc3BvbnNlO1xuICAgIGNvbnN0IHByb2ZpbGUgPSBpZFRva2VuUmVzcG9uc2UucmF3VXNlckluZm9cbiAgICAgICAgPyBKU09OLnBhcnNlKGlkVG9rZW5SZXNwb25zZS5yYXdVc2VySW5mbylcbiAgICAgICAgOiB7fTtcbiAgICBjb25zdCBpc05ld1VzZXIgPSBpZFRva2VuUmVzcG9uc2UuaXNOZXdVc2VyIHx8XG4gICAgICAgIGlkVG9rZW5SZXNwb25zZS5raW5kID09PSBcImlkZW50aXR5dG9vbGtpdCNTaWdudXBOZXdVc2VyUmVzcG9uc2VcIiAvKiBJZFRva2VuUmVzcG9uc2VLaW5kLlNpZ251cE5ld1VzZXIgKi87XG4gICAgaWYgKCFwcm92aWRlcklkICYmIChpZFRva2VuUmVzcG9uc2UgPT09IG51bGwgfHwgaWRUb2tlblJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpZFRva2VuUmVzcG9uc2UuaWRUb2tlbikpIHtcbiAgICAgICAgY29uc3Qgc2lnbkluUHJvdmlkZXIgPSAoX2IgPSAoX2EgPSBfcGFyc2VUb2tlbihpZFRva2VuUmVzcG9uc2UuaWRUb2tlbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maXJlYmFzZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWydzaWduX2luX3Byb3ZpZGVyJ107XG4gICAgICAgIGlmIChzaWduSW5Qcm92aWRlcikge1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRQcm92aWRlcklkID0gc2lnbkluUHJvdmlkZXIgIT09IFwiYW5vbnltb3VzXCIgLyogUHJvdmlkZXJJZC5BTk9OWU1PVVMgKi8gJiZcbiAgICAgICAgICAgICAgICBzaWduSW5Qcm92aWRlciAhPT0gXCJjdXN0b21cIiAvKiBQcm92aWRlcklkLkNVU1RPTSAqL1xuICAgICAgICAgICAgICAgID8gc2lnbkluUHJvdmlkZXJcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAvLyBVc2VzIGdlbmVyaWMgY2xhc3MgaW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBsZWdhY3kgU0RLLlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljQWRkaXRpb25hbFVzZXJJbmZvKGlzTmV3VXNlciwgZmlsdGVyZWRQcm92aWRlcklkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXByb3ZpZGVySWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN3aXRjaCAocHJvdmlkZXJJZCkge1xuICAgICAgICBjYXNlIFwiZmFjZWJvb2suY29tXCIgLyogUHJvdmlkZXJJZC5GQUNFQk9PSyAqLzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmFjZWJvb2tBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBwcm9maWxlKTtcbiAgICAgICAgY2FzZSBcImdpdGh1Yi5jb21cIiAvKiBQcm92aWRlcklkLkdJVEhVQiAqLzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgR2l0aHViQWRkaXRpb25hbFVzZXJJbmZvKGlzTmV3VXNlciwgcHJvZmlsZSk7XG4gICAgICAgIGNhc2UgXCJnb29nbGUuY29tXCIgLyogUHJvdmlkZXJJZC5HT09HTEUgKi86XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdvb2dsZUFkZGl0aW9uYWxVc2VySW5mbyhpc05ld1VzZXIsIHByb2ZpbGUpO1xuICAgICAgICBjYXNlIFwidHdpdHRlci5jb21cIiAvKiBQcm92aWRlcklkLlRXSVRURVIgKi86XG4gICAgICAgICAgICByZXR1cm4gbmV3IFR3aXR0ZXJBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBwcm9maWxlLCBpZFRva2VuUmVzcG9uc2Uuc2NyZWVuTmFtZSB8fCBudWxsKTtcbiAgICAgICAgY2FzZSBcImN1c3RvbVwiIC8qIFByb3ZpZGVySWQuQ1VTVE9NICovOlxuICAgICAgICBjYXNlIFwiYW5vbnltb3VzXCIgLyogUHJvdmlkZXJJZC5BTk9OWU1PVVMgKi86XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBudWxsKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgR2VuZXJpY0FkZGl0aW9uYWxVc2VySW5mbyhpc05ld1VzZXIsIHByb3ZpZGVySWQsIHByb2ZpbGUpO1xuICAgIH1cbn1cbmNsYXNzIEdlbmVyaWNBZGRpdGlvbmFsVXNlckluZm8ge1xuICAgIGNvbnN0cnVjdG9yKGlzTmV3VXNlciwgcHJvdmlkZXJJZCwgcHJvZmlsZSA9IHt9KSB7XG4gICAgICAgIHRoaXMuaXNOZXdVc2VyID0gaXNOZXdVc2VyO1xuICAgICAgICB0aGlzLnByb3ZpZGVySWQgPSBwcm92aWRlcklkO1xuICAgICAgICB0aGlzLnByb2ZpbGUgPSBwcm9maWxlO1xuICAgIH1cbn1cbmNsYXNzIEZlZGVyYXRlZEFkZGl0aW9uYWxVc2VySW5mb1dpdGhVc2VybmFtZSBleHRlbmRzIEdlbmVyaWNBZGRpdGlvbmFsVXNlckluZm8ge1xuICAgIGNvbnN0cnVjdG9yKGlzTmV3VXNlciwgcHJvdmlkZXJJZCwgcHJvZmlsZSwgdXNlcm5hbWUpIHtcbiAgICAgICAgc3VwZXIoaXNOZXdVc2VyLCBwcm92aWRlcklkLCBwcm9maWxlKTtcbiAgICAgICAgdGhpcy51c2VybmFtZSA9IHVzZXJuYW1lO1xuICAgIH1cbn1cbmNsYXNzIEZhY2Vib29rQWRkaXRpb25hbFVzZXJJbmZvIGV4dGVuZHMgR2VuZXJpY0FkZGl0aW9uYWxVc2VySW5mbyB7XG4gICAgY29uc3RydWN0b3IoaXNOZXdVc2VyLCBwcm9maWxlKSB7XG4gICAgICAgIHN1cGVyKGlzTmV3VXNlciwgXCJmYWNlYm9vay5jb21cIiAvKiBQcm92aWRlcklkLkZBQ0VCT09LICovLCBwcm9maWxlKTtcbiAgICB9XG59XG5jbGFzcyBHaXRodWJBZGRpdGlvbmFsVXNlckluZm8gZXh0ZW5kcyBGZWRlcmF0ZWRBZGRpdGlvbmFsVXNlckluZm9XaXRoVXNlcm5hbWUge1xuICAgIGNvbnN0cnVjdG9yKGlzTmV3VXNlciwgcHJvZmlsZSkge1xuICAgICAgICBzdXBlcihpc05ld1VzZXIsIFwiZ2l0aHViLmNvbVwiIC8qIFByb3ZpZGVySWQuR0lUSFVCICovLCBwcm9maWxlLCB0eXBlb2YgKHByb2ZpbGUgPT09IG51bGwgfHwgcHJvZmlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvZmlsZS5sb2dpbikgPT09ICdzdHJpbmcnID8gcHJvZmlsZSA9PT0gbnVsbCB8fCBwcm9maWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9maWxlLmxvZ2luIDogbnVsbCk7XG4gICAgfVxufVxuY2xhc3MgR29vZ2xlQWRkaXRpb25hbFVzZXJJbmZvIGV4dGVuZHMgR2VuZXJpY0FkZGl0aW9uYWxVc2VySW5mbyB7XG4gICAgY29uc3RydWN0b3IoaXNOZXdVc2VyLCBwcm9maWxlKSB7XG4gICAgICAgIHN1cGVyKGlzTmV3VXNlciwgXCJnb29nbGUuY29tXCIgLyogUHJvdmlkZXJJZC5HT09HTEUgKi8sIHByb2ZpbGUpO1xuICAgIH1cbn1cbmNsYXNzIFR3aXR0ZXJBZGRpdGlvbmFsVXNlckluZm8gZXh0ZW5kcyBGZWRlcmF0ZWRBZGRpdGlvbmFsVXNlckluZm9XaXRoVXNlcm5hbWUge1xuICAgIGNvbnN0cnVjdG9yKGlzTmV3VXNlciwgcHJvZmlsZSwgc2NyZWVuTmFtZSkge1xuICAgICAgICBzdXBlcihpc05ld1VzZXIsIFwidHdpdHRlci5jb21cIiAvKiBQcm92aWRlcklkLlRXSVRURVIgKi8sIHByb2ZpbGUsIHNjcmVlbk5hbWUpO1xuICAgIH1cbn1cbi8qKlxuICogRXh0cmFjdHMgcHJvdmlkZXIgc3BlY2lmaWMge0BsaW5rIEFkZGl0aW9uYWxVc2VySW5mb30gZm9yIHRoZSBnaXZlbiBjcmVkZW50aWFsLlxuICpcbiAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBnZXRBZGRpdGlvbmFsVXNlckluZm8odXNlckNyZWRlbnRpYWwpIHtcbiAgICBjb25zdCB7IHVzZXIsIF90b2tlblJlc3BvbnNlIH0gPSB1c2VyQ3JlZGVudGlhbDtcbiAgICBpZiAodXNlci5pc0Fub255bW91cyAmJiAhX3Rva2VuUmVzcG9uc2UpIHtcbiAgICAgICAgLy8gSGFuZGxlIHRoZSBzcGVjaWFsIGNhc2Ugd2hlcmUgc2lnbkluQW5vbnltb3VzbHkoKSBnZXRzIGNhbGxlZCB0d2ljZS5cbiAgICAgICAgLy8gTm8gbmV0d29yayBjYWxsIGlzIG1hZGUgc28gdGhlcmUncyBub3RoaW5nIHRvIGFjdHVhbGx5IGZpbGwgdGhpcyBpblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvdmlkZXJJZDogbnVsbCxcbiAgICAgICAgICAgIGlzTmV3VXNlcjogZmFsc2UsXG4gICAgICAgICAgICBwcm9maWxlOiBudWxsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfZnJvbUlkVG9rZW5SZXNwb25zZShfdG9rZW5SZXNwb25zZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBOb24tb3B0aW9uYWwgYXV0aCBtZXRob2RzLlxuLyoqXG4gKiBDaGFuZ2VzIHRoZSB0eXBlIG9mIHBlcnNpc3RlbmNlIG9uIHRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UgZm9yIHRoZSBjdXJyZW50bHkgc2F2ZWRcbiAqIGBBdXRoYCBzZXNzaW9uIGFuZCBhcHBsaWVzIHRoaXMgdHlwZSBvZiBwZXJzaXN0ZW5jZSBmb3IgZnV0dXJlIHNpZ24taW4gcmVxdWVzdHMsIGluY2x1ZGluZ1xuICogc2lnbi1pbiB3aXRoIHJlZGlyZWN0IHJlcXVlc3RzLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIG1ha2VzIGl0IGVhc3kgZm9yIGEgdXNlciBzaWduaW5nIGluIHRvIHNwZWNpZnkgd2hldGhlciB0aGVpciBzZXNzaW9uIHNob3VsZCBiZVxuICogcmVtZW1iZXJlZCBvciBub3QuIEl0IGFsc28gbWFrZXMgaXQgZWFzaWVyIHRvIG5ldmVyIHBlcnNpc3QgdGhlIGBBdXRoYCBzdGF0ZSBmb3IgYXBwbGljYXRpb25zXG4gKiB0aGF0IGFyZSBzaGFyZWQgYnkgb3RoZXIgdXNlcnMgb3IgaGF2ZSBzZW5zaXRpdmUgZGF0YS5cbiAqXG4gKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB3b3JrIGluIGEgTm9kZS5qcyBlbnZpcm9ubWVudCBvciB3aXRoIHtAbGluayBBdXRofSBpbnN0YW5jZXMgY3JlYXRlZCB3aXRoIGFcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogc2V0UGVyc2lzdGVuY2UoYXV0aCwgYnJvd3NlclNlc3Npb25QZXJzaXN0ZW5jZSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gcGVyc2lzdGVuY2UgLSBUaGUge0BsaW5rIFBlcnNpc3RlbmNlfSB0byB1c2UuXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIG9uY2UgdGhlIHBlcnNpc3RlbmNlIGNoYW5nZSBoYXMgY29tcGxldGVkXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBzZXRQZXJzaXN0ZW5jZShhdXRoLCBwZXJzaXN0ZW5jZSkge1xuICAgIHJldHVybiBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCkuc2V0UGVyc2lzdGVuY2UocGVyc2lzdGVuY2UpO1xufVxuLyoqXG4gKiBMb2FkcyB0aGUgcmVDQVBUQ0hBIGNvbmZpZ3VyYXRpb24gaW50byB0aGUgYEF1dGhgIGluc3RhbmNlLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIHdpbGwgbG9hZCB0aGUgcmVDQVBUQ0hBIGNvbmZpZywgd2hpY2ggaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHJlQ0FQVENIQVxuICogdmVyaWZpY2F0aW9uIGZsb3cgc2hvdWxkIGJlIHRyaWdnZXJlZCBmb3IgZWFjaCBhdXRoIHByb3ZpZGVyLCBpbnRvIHRoZVxuICogY3VycmVudCBBdXRoIHNlc3Npb24uXG4gKlxuICogSWYgaW5pdGlhbGl6ZVJlY2FwdGNoYUNvbmZpZygpIGlzIG5vdCBpbnZva2VkLCB0aGUgYXV0aCBmbG93IHdpbGwgYWx3YXlzIHN0YXJ0XG4gKiB3aXRob3V0IHJlQ0FQVENIQSB2ZXJpZmljYXRpb24uIElmIHRoZSBwcm92aWRlciBpcyBjb25maWd1cmVkIHRvIHJlcXVpcmUgcmVDQVBUQ0hBXG4gKiB2ZXJpZmljYXRpb24sIHRoZSBTREsgd2lsbCB0cmFuc3BhcmVudGx5IGxvYWQgdGhlIHJlQ0FQVENIQSBjb25maWcgYW5kIHJlc3RhcnQgdGhlXG4gKiBhdXRoIGZsb3dzLlxuICpcbiAqIFRodXMsIGJ5IGNhbGxpbmcgdGhpcyBvcHRpb25hbCBtZXRob2QsIHlvdSB3aWxsIHJlZHVjZSB0aGUgbGF0ZW5jeSBvZiBmdXR1cmUgYXV0aCBmbG93cy5cbiAqIExvYWRpbmcgdGhlIHJlQ0FQVENIQSBjb25maWcgZWFybHkgd2lsbCBhbHNvIGVuaGFuY2UgdGhlIHNpZ25hbCBjb2xsZWN0ZWQgYnkgcmVDQVBUQ0hBLlxuICpcbiAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHdvcmsgaW4gYSBOb2RlLmpzIGVudmlyb25tZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBpbml0aWFsaXplUmVjYXB0Y2hhQ29uZmlnKGF1dGgpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZVJlY2FwdGNoYUNvbmZpZyhhdXRoKSB7XG4gICAgcmV0dXJuIF9pbml0aWFsaXplUmVjYXB0Y2hhQ29uZmlnKGF1dGgpO1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIHBhc3N3b3JkIGFnYWluc3QgdGhlIHBhc3N3b3JkIHBvbGljeSBjb25maWd1cmVkIGZvciB0aGUgcHJvamVjdCBvciB0ZW5hbnQuXG4gKlxuICogQHJlbWFya3NcbiAqIElmIG5vIHRlbmFudCBJRCBpcyBzZXQgb24gdGhlIGBBdXRoYCBpbnN0YW5jZSwgdGhlbiB0aGlzIG1ldGhvZCB3aWxsIHVzZSB0aGUgcGFzc3dvcmRcbiAqIHBvbGljeSBjb25maWd1cmVkIGZvciB0aGUgcHJvamVjdC4gT3RoZXJ3aXNlLCB0aGlzIG1ldGhvZCB3aWxsIHVzZSB0aGUgcG9saWN5IGNvbmZpZ3VyZWRcbiAqIGZvciB0aGUgdGVuYW50LiBJZiBhIHBhc3N3b3JkIHBvbGljeSBoYXMgbm90IGJlZW4gY29uZmlndXJlZCwgdGhlbiB0aGUgZGVmYXVsdCBwb2xpY3lcbiAqIGNvbmZpZ3VyZWQgZm9yIGFsbCBwcm9qZWN0cyB3aWxsIGJlIHVzZWQuXG4gKlxuICogSWYgYW4gYXV0aCBmbG93IGZhaWxzIGJlY2F1c2UgYSBzdWJtaXR0ZWQgcGFzc3dvcmQgZG9lcyBub3QgbWVldCB0aGUgcGFzc3dvcmQgcG9saWN5XG4gKiByZXF1aXJlbWVudHMgYW5kIHRoaXMgbWV0aG9kIGhhcyBwcmV2aW91c2x5IGJlZW4gY2FsbGVkLCB0aGVuIHRoaXMgbWV0aG9kIHdpbGwgdXNlIHRoZVxuICogbW9zdCByZWNlbnQgcG9saWN5IGF2YWlsYWJsZSB3aGVuIGNhbGxlZCBhZ2Fpbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogdmFsaWRhdGVQYXNzd29yZChhdXRoLCAnc29tZS1wYXNzd29yZCcpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGggVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBwYXNzd29yZCBUaGUgcGFzc3dvcmQgdG8gdmFsaWRhdGUuXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZVBhc3N3b3JkKGF1dGgsIHBhc3N3b3JkKSB7XG4gICAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xuICAgIHJldHVybiBhdXRoSW50ZXJuYWwudmFsaWRhdGVQYXNzd29yZChwYXNzd29yZCk7XG59XG4vKipcbiAqIEFkZHMgYW4gb2JzZXJ2ZXIgZm9yIGNoYW5nZXMgdG8gdGhlIHNpZ25lZC1pbiB1c2VyJ3MgSUQgdG9rZW4uXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgaW5jbHVkZXMgc2lnbi1pbiwgc2lnbi1vdXQsIGFuZCB0b2tlbiByZWZyZXNoIGV2ZW50cy5cbiAqIFRoaXMgd2lsbCBub3QgYmUgdHJpZ2dlcmVkIGF1dG9tYXRpY2FsbHkgdXBvbiBJRCB0b2tlbiBleHBpcmF0aW9uLiBVc2Uge0BsaW5rIFVzZXIuZ2V0SWRUb2tlbn0gdG8gcmVmcmVzaCB0aGUgSUQgdG9rZW4uXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIG5leHRPck9ic2VydmVyIC0gY2FsbGJhY2sgdHJpZ2dlcmVkIG9uIGNoYW5nZS5cbiAqIEBwYXJhbSBlcnJvciAtIERlcHJlY2F0ZWQuIFRoaXMgY2FsbGJhY2sgaXMgbmV2ZXIgdHJpZ2dlcmVkLiBFcnJvcnNcbiAqIG9uIHNpZ25pbmcgaW4vb3V0IGNhbiBiZSBjYXVnaHQgaW4gcHJvbWlzZXMgcmV0dXJuZWQgZnJvbVxuICogc2lnbi1pbi9zaWduLW91dCBmdW5jdGlvbnMuXG4gKiBAcGFyYW0gY29tcGxldGVkIC0gRGVwcmVjYXRlZC4gVGhpcyBjYWxsYmFjayBpcyBuZXZlciB0cmlnZ2VyZWQuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBvbklkVG9rZW5DaGFuZ2VkKGF1dGgsIG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKSB7XG4gICAgcmV0dXJuIGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKS5vbklkVG9rZW5DaGFuZ2VkKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKTtcbn1cbi8qKlxuICogQWRkcyBhIGJsb2NraW5nIGNhbGxiYWNrIHRoYXQgcnVucyBiZWZvcmUgYW4gYXV0aCBzdGF0ZSBjaGFuZ2VcbiAqIHNldHMgYSBuZXcgdXNlci5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gY2FsbGJhY2sgLSBjYWxsYmFjayB0cmlnZ2VyZWQgYmVmb3JlIG5ldyB1c2VyIHZhbHVlIGlzIHNldC5cbiAqICAgSWYgdGhpcyB0aHJvd3MsIGl0IGJsb2NrcyB0aGUgdXNlciBmcm9tIGJlaW5nIHNldC5cbiAqIEBwYXJhbSBvbkFib3J0IC0gY2FsbGJhY2sgdHJpZ2dlcmVkIGlmIGEgbGF0ZXIgYGJlZm9yZUF1dGhTdGF0ZUNoYW5nZWQoKWBcbiAqICAgY2FsbGJhY2sgdGhyb3dzLCBhbGxvd2luZyB5b3UgdG8gdW5kbyBhbnkgc2lkZSBlZmZlY3RzLlxuICovXG5mdW5jdGlvbiBiZWZvcmVBdXRoU3RhdGVDaGFuZ2VkKGF1dGgsIGNhbGxiYWNrLCBvbkFib3J0KSB7XG4gICAgcmV0dXJuIGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKS5iZWZvcmVBdXRoU3RhdGVDaGFuZ2VkKGNhbGxiYWNrLCBvbkFib3J0KTtcbn1cbi8qKlxuICogQWRkcyBhbiBvYnNlcnZlciBmb3IgY2hhbmdlcyB0byB0aGUgdXNlcidzIHNpZ24taW4gc3RhdGUuXG4gKlxuICogQHJlbWFya3NcbiAqIFRvIGtlZXAgdGhlIG9sZCBiZWhhdmlvciwgc2VlIHtAbGluayBvbklkVG9rZW5DaGFuZ2VkfS5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gbmV4dE9yT2JzZXJ2ZXIgLSBjYWxsYmFjayB0cmlnZ2VyZWQgb24gY2hhbmdlLlxuICogQHBhcmFtIGVycm9yIC0gRGVwcmVjYXRlZC4gVGhpcyBjYWxsYmFjayBpcyBuZXZlciB0cmlnZ2VyZWQuIEVycm9yc1xuICogb24gc2lnbmluZyBpbi9vdXQgY2FuIGJlIGNhdWdodCBpbiBwcm9taXNlcyByZXR1cm5lZCBmcm9tXG4gKiBzaWduLWluL3NpZ24tb3V0IGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSBjb21wbGV0ZWQgLSBEZXByZWNhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5ldmVyIHRyaWdnZXJlZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIG9uQXV0aFN0YXRlQ2hhbmdlZChhdXRoLCBuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlZCkge1xuICAgIHJldHVybiBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCkub25BdXRoU3RhdGVDaGFuZ2VkKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKTtcbn1cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCBsYW5ndWFnZSB0byB0aGUgZGVmYXVsdCBkZXZpY2UvYnJvd3NlciBwcmVmZXJlbmNlLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZURldmljZUxhbmd1YWdlKGF1dGgpIHtcbiAgICBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCkudXNlRGV2aWNlTGFuZ3VhZ2UoKTtcbn1cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgc2V0cyB0aGUgcHJvdmlkZWQgdXNlciBhcyB7QGxpbmsgQXV0aC5jdXJyZW50VXNlcn0gb24gdGhlXG4gKiB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKlxuICogQHJlbWFya3NcbiAqIEEgbmV3IGluc3RhbmNlIGNvcHkgb2YgdGhlIHVzZXIgcHJvdmlkZWQgd2lsbCBiZSBtYWRlIGFuZCBzZXQgYXMgY3VycmVudFVzZXIuXG4gKlxuICogVGhpcyB3aWxsIHRyaWdnZXIge0BsaW5rIG9uQXV0aFN0YXRlQ2hhbmdlZH0gYW5kIHtAbGluayBvbklkVG9rZW5DaGFuZ2VkfSBsaXN0ZW5lcnNcbiAqIGxpa2Ugb3RoZXIgc2lnbiBpbiBtZXRob2RzLlxuICpcbiAqIFRoZSBvcGVyYXRpb24gZmFpbHMgd2l0aCBhbiBlcnJvciBpZiB0aGUgdXNlciB0byBiZSB1cGRhdGVkIGJlbG9uZ3MgdG8gYSBkaWZmZXJlbnQgRmlyZWJhc2VcbiAqIHByb2plY3QuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzIGNyZWF0ZWQgd2l0aCBhXG4gKiB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZVNlcnZlckFwcH0uXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIHVzZXIgLSBUaGUgbmV3IHtAbGluayBVc2VyfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUN1cnJlbnRVc2VyKGF1dGgsIHVzZXIpIHtcbiAgICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLnVwZGF0ZUN1cnJlbnRVc2VyKHVzZXIpO1xufVxuLyoqXG4gKiBTaWducyBvdXQgdGhlIGN1cnJlbnQgdXNlci5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzIGNyZWF0ZWQgd2l0aCBhXG4gKiB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZVNlcnZlckFwcH0uXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc2lnbk91dChhdXRoKSB7XG4gICAgcmV0dXJuIGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKS5zaWduT3V0KCk7XG59XG4vKipcbiAqIFJldm9rZXMgdGhlIGdpdmVuIGFjY2VzcyB0b2tlbi4gQ3VycmVudGx5IG9ubHkgc3VwcG9ydHMgQXBwbGUgT0F1dGggYWNjZXNzIHRva2Vucy5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gdG9rZW4gLSBUaGUgQXBwbGUgT0F1dGggYWNjZXNzIHRva2VuLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcmV2b2tlQWNjZXNzVG9rZW4oYXV0aCwgdG9rZW4pIHtcbiAgICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XG4gICAgcmV0dXJuIGF1dGhJbnRlcm5hbC5yZXZva2VBY2Nlc3NUb2tlbih0b2tlbik7XG59XG4vKipcbiAqIERlbGV0ZXMgYW5kIHNpZ25zIG91dCB0aGUgdXNlci5cbiAqXG4gKiBAcmVtYXJrc1xuICogSW1wb3J0YW50OiB0aGlzIGlzIGEgc2VjdXJpdHktc2Vuc2l0aXZlIG9wZXJhdGlvbiB0aGF0IHJlcXVpcmVzIHRoZSB1c2VyIHRvIGhhdmUgcmVjZW50bHlcbiAqIHNpZ25lZCBpbi4gSWYgdGhpcyByZXF1aXJlbWVudCBpc24ndCBtZXQsIGFzayB0aGUgdXNlciB0byBhdXRoZW50aWNhdGUgYWdhaW4gYW5kIHRoZW4gY2FsbFxuICoge0BsaW5rIHJlYXV0aGVudGljYXRlV2l0aENyZWRlbnRpYWx9LlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBkZWxldGVVc2VyKHVzZXIpIHtcbiAgICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpLmRlbGV0ZSgpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgTXVsdGlGYWN0b3JTZXNzaW9uSW1wbCB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgY3JlZGVudGlhbCwgdXNlcikge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWwgPSBjcmVkZW50aWFsO1xuICAgICAgICB0aGlzLnVzZXIgPSB1c2VyO1xuICAgIH1cbiAgICBzdGF0aWMgX2Zyb21JZHRva2VuKGlkVG9rZW4sIHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNdWx0aUZhY3RvclNlc3Npb25JbXBsKFwiZW5yb2xsXCIgLyogTXVsdGlGYWN0b3JTZXNzaW9uVHlwZS5FTlJPTEwgKi8sIGlkVG9rZW4sIHVzZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgX2Zyb21NZmFQZW5kaW5nQ3JlZGVudGlhbChtZmFQZW5kaW5nQ3JlZGVudGlhbCkge1xuICAgICAgICByZXR1cm4gbmV3IE11bHRpRmFjdG9yU2Vzc2lvbkltcGwoXCJzaWduaW5cIiAvKiBNdWx0aUZhY3RvclNlc3Npb25UeXBlLlNJR05fSU4gKi8sIG1mYVBlbmRpbmdDcmVkZW50aWFsKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLnR5cGUgPT09IFwiZW5yb2xsXCIgLyogTXVsdGlGYWN0b3JTZXNzaW9uVHlwZS5FTlJPTEwgKi9cbiAgICAgICAgICAgID8gJ2lkVG9rZW4nXG4gICAgICAgICAgICA6ICdwZW5kaW5nQ3JlZGVudGlhbCc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtdWx0aUZhY3RvclNlc3Npb246IHtcbiAgICAgICAgICAgICAgICBba2V5XTogdGhpcy5jcmVkZW50aWFsXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSlNPTihvYmopIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iai5tdWx0aUZhY3RvclNlc3Npb24pIHtcbiAgICAgICAgICAgIGlmICgoX2EgPSBvYmoubXVsdGlGYWN0b3JTZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGVuZGluZ0NyZWRlbnRpYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTXVsdGlGYWN0b3JTZXNzaW9uSW1wbC5fZnJvbU1mYVBlbmRpbmdDcmVkZW50aWFsKG9iai5tdWx0aUZhY3RvclNlc3Npb24ucGVuZGluZ0NyZWRlbnRpYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKF9iID0gb2JqLm11bHRpRmFjdG9yU2Vzc2lvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlkVG9rZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTXVsdGlGYWN0b3JTZXNzaW9uSW1wbC5fZnJvbUlkdG9rZW4ob2JqLm11bHRpRmFjdG9yU2Vzc2lvbi5pZFRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBNdWx0aUZhY3RvclJlc29sdmVySW1wbCB7XG4gICAgY29uc3RydWN0b3Ioc2Vzc2lvbiwgaGludHMsIHNpZ25JblJlc29sdmVyKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIHRoaXMuaGludHMgPSBoaW50cztcbiAgICAgICAgdGhpcy5zaWduSW5SZXNvbHZlciA9IHNpZ25JblJlc29sdmVyO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIF9mcm9tRXJyb3IoYXV0aEV4dGVybiwgZXJyb3IpIHtcbiAgICAgICAgY29uc3QgYXV0aCA9IF9jYXN0QXV0aChhdXRoRXh0ZXJuKTtcbiAgICAgICAgY29uc3Qgc2VydmVyUmVzcG9uc2UgPSBlcnJvci5jdXN0b21EYXRhLl9zZXJ2ZXJSZXNwb25zZTtcbiAgICAgICAgY29uc3QgaGludHMgPSAoc2VydmVyUmVzcG9uc2UubWZhSW5mbyB8fCBbXSkubWFwKGVucm9sbG1lbnQgPT4gTXVsdGlGYWN0b3JJbmZvSW1wbC5fZnJvbVNlcnZlclJlc3BvbnNlKGF1dGgsIGVucm9sbG1lbnQpKTtcbiAgICAgICAgX2Fzc2VydChzZXJ2ZXJSZXNwb25zZS5tZmFQZW5kaW5nQ3JlZGVudGlhbCwgYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICBjb25zdCBzZXNzaW9uID0gTXVsdGlGYWN0b3JTZXNzaW9uSW1wbC5fZnJvbU1mYVBlbmRpbmdDcmVkZW50aWFsKHNlcnZlclJlc3BvbnNlLm1mYVBlbmRpbmdDcmVkZW50aWFsKTtcbiAgICAgICAgcmV0dXJuIG5ldyBNdWx0aUZhY3RvclJlc29sdmVySW1wbChzZXNzaW9uLCBoaW50cywgYXN5bmMgKGFzc2VydGlvbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWZhUmVzcG9uc2UgPSBhd2FpdCBhc3NlcnRpb24uX3Byb2Nlc3MoYXV0aCwgc2Vzc2lvbik7XG4gICAgICAgICAgICAvLyBDbGVhciBvdXQgdGhlIHVubmVlZGVkIGZpZWxkcyBmcm9tIHRoZSBvbGQgbG9naW4gcmVzcG9uc2VcbiAgICAgICAgICAgIGRlbGV0ZSBzZXJ2ZXJSZXNwb25zZS5tZmFJbmZvO1xuICAgICAgICAgICAgZGVsZXRlIHNlcnZlclJlc3BvbnNlLm1mYVBlbmRpbmdDcmVkZW50aWFsO1xuICAgICAgICAgICAgLy8gVXNlIGluIHRoZSBuZXcgdG9rZW4gJiByZWZyZXNoIHRva2VuIGluIHRoZSBvbGQgcmVzcG9uc2VcbiAgICAgICAgICAgIGNvbnN0IGlkVG9rZW5SZXNwb25zZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VydmVyUmVzcG9uc2UpLCB7IGlkVG9rZW46IG1mYVJlc3BvbnNlLmlkVG9rZW4sIHJlZnJlc2hUb2tlbjogbWZhUmVzcG9uc2UucmVmcmVzaFRva2VuIH0pO1xuICAgICAgICAgICAgLy8gVE9ETzogd2Ugc2hvdWxkIGNvbGxhcHNlIHRoaXMgc3dpdGNoIHN0YXRlbWVudCBpbnRvIFVzZXJDcmVkZW50aWFsSW1wbC5fZm9yT3BlcmF0aW9uIGFuZCBoYXZlIGl0IHN1cHBvcnQgdGhlIFNJR05fSU4gY2FzZVxuICAgICAgICAgICAgc3dpdGNoIChlcnJvci5vcGVyYXRpb25UeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNpZ25JblwiIC8qIE9wZXJhdGlvblR5cGUuU0lHTl9JTiAqLzpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBVc2VyQ3JlZGVudGlhbEltcGwuX2Zyb21JZFRva2VuUmVzcG9uc2UoYXV0aCwgZXJyb3Iub3BlcmF0aW9uVHlwZSwgaWRUb2tlblJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgYXV0aC5fdXBkYXRlQ3VycmVudFVzZXIodXNlckNyZWRlbnRpYWwudXNlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1c2VyQ3JlZGVudGlhbDtcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVhdXRoZW50aWNhdGVcIiAvKiBPcGVyYXRpb25UeXBlLlJFQVVUSEVOVElDQVRFICovOlxuICAgICAgICAgICAgICAgICAgICBfYXNzZXJ0KGVycm9yLnVzZXIsIGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFVzZXJDcmVkZW50aWFsSW1wbC5fZm9yT3BlcmF0aW9uKGVycm9yLnVzZXIsIGVycm9yLm9wZXJhdGlvblR5cGUsIGlkVG9rZW5SZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgX2ZhaWwoYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZVNpZ25Jbihhc3NlcnRpb25FeHRlcm4pIHtcbiAgICAgICAgY29uc3QgYXNzZXJ0aW9uID0gYXNzZXJ0aW9uRXh0ZXJuO1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduSW5SZXNvbHZlcihhc3NlcnRpb24pO1xuICAgIH1cbn1cbi8qKlxuICogUHJvdmlkZXMgYSB7QGxpbmsgTXVsdGlGYWN0b3JSZXNvbHZlcn0gc3VpdGFibGUgZm9yIGNvbXBsZXRpb24gb2YgYVxuICogbXVsdGktZmFjdG9yIGZsb3cuXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIGVycm9yIC0gVGhlIHtAbGluayBNdWx0aUZhY3RvckVycm9yfSByYWlzZWQgZHVyaW5nIGEgc2lnbi1pbiwgb3JcbiAqIHJlYXV0aGVudGljYXRpb24gb3BlcmF0aW9uLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZ2V0TXVsdGlGYWN0b3JSZXNvbHZlcihhdXRoLCBlcnJvcikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBhdXRoTW9kdWxhciA9IGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKTtcbiAgICBjb25zdCBlcnJvckludGVybmFsID0gZXJyb3I7XG4gICAgX2Fzc2VydChlcnJvci5jdXN0b21EYXRhLm9wZXJhdGlvblR5cGUsIGF1dGhNb2R1bGFyLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XG4gICAgX2Fzc2VydCgoX2EgPSBlcnJvckludGVybmFsLmN1c3RvbURhdGEuX3NlcnZlclJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWZhUGVuZGluZ0NyZWRlbnRpYWwsIGF1dGhNb2R1bGFyLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XG4gICAgcmV0dXJuIE11bHRpRmFjdG9yUmVzb2x2ZXJJbXBsLl9mcm9tRXJyb3IoYXV0aE1vZHVsYXIsIGVycm9ySW50ZXJuYWwpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gc3RhcnRFbnJvbGxUb3RwTWZhKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjIvYWNjb3VudHMvbWZhRW5yb2xsbWVudDpzdGFydFwiIC8qIEVuZHBvaW50LlNUQVJUX01GQV9FTlJPTExNRU5UICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuZnVuY3Rpb24gZmluYWxpemVFbnJvbGxUb3RwTWZhKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjIvYWNjb3VudHMvbWZhRW5yb2xsbWVudDpmaW5hbGl6ZVwiIC8qIEVuZHBvaW50LkZJTkFMSVpFX01GQV9FTlJPTExNRU5UICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuZnVuY3Rpb24gd2l0aGRyYXdNZmEoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92Mi9hY2NvdW50cy9tZmFFbnJvbGxtZW50OndpdGhkcmF3XCIgLyogRW5kcG9pbnQuV0lUSERSQVdfTUZBICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuXG5jbGFzcyBNdWx0aUZhY3RvclVzZXJJbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcih1c2VyKSB7XG4gICAgICAgIHRoaXMudXNlciA9IHVzZXI7XG4gICAgICAgIHRoaXMuZW5yb2xsZWRGYWN0b3JzID0gW107XG4gICAgICAgIHVzZXIuX29uUmVsb2FkKHVzZXJJbmZvID0+IHtcbiAgICAgICAgICAgIGlmICh1c2VySW5mby5tZmFJbmZvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnJvbGxlZEZhY3RvcnMgPSB1c2VySW5mby5tZmFJbmZvLm1hcChlbnJvbGxtZW50ID0+IE11bHRpRmFjdG9ySW5mb0ltcGwuX2Zyb21TZXJ2ZXJSZXNwb25zZSh1c2VyLmF1dGgsIGVucm9sbG1lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBfZnJvbVVzZXIodXNlcikge1xuICAgICAgICByZXR1cm4gbmV3IE11bHRpRmFjdG9yVXNlckltcGwodXNlcik7XG4gICAgfVxuICAgIGFzeW5jIGdldFNlc3Npb24oKSB7XG4gICAgICAgIHJldHVybiBNdWx0aUZhY3RvclNlc3Npb25JbXBsLl9mcm9tSWR0b2tlbihhd2FpdCB0aGlzLnVzZXIuZ2V0SWRUb2tlbigpLCB0aGlzLnVzZXIpO1xuICAgIH1cbiAgICBhc3luYyBlbnJvbGwoYXNzZXJ0aW9uRXh0ZXJuLCBkaXNwbGF5TmFtZSkge1xuICAgICAgICBjb25zdCBhc3NlcnRpb24gPSBhc3NlcnRpb25FeHRlcm47XG4gICAgICAgIGNvbnN0IHNlc3Npb24gPSAoYXdhaXQgdGhpcy5nZXRTZXNzaW9uKCkpO1xuICAgICAgICBjb25zdCBmaW5hbGl6ZU1mYVJlc3BvbnNlID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodGhpcy51c2VyLCBhc3NlcnRpb24uX3Byb2Nlc3ModGhpcy51c2VyLmF1dGgsIHNlc3Npb24sIGRpc3BsYXlOYW1lKSk7XG4gICAgICAgIC8vIE5ldyB0b2tlbnMgd2lsbCBiZSBpc3N1ZWQgYWZ0ZXIgZW5yb2xsbWVudCBvZiB0aGUgbmV3IHNlY29uZCBmYWN0b3JzLlxuICAgICAgICAvLyBUaGV5IG5lZWQgdG8gYmUgdXBkYXRlZCBvbiB0aGUgdXNlci5cbiAgICAgICAgYXdhaXQgdGhpcy51c2VyLl91cGRhdGVUb2tlbnNJZk5lY2Vzc2FyeShmaW5hbGl6ZU1mYVJlc3BvbnNlKTtcbiAgICAgICAgLy8gVGhlIHVzZXIgbmVlZHMgdG8gYmUgcmVsb2FkZWQgdG8gZ2V0IHRoZSBuZXcgbXVsdGktZmFjdG9yIGluZm9ybWF0aW9uXG4gICAgICAgIC8vIGZyb20gc2VydmVyLiBVU0VSX1JFTE9BREVEIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkIGFuZCBgZW5yb2xsZWRGYWN0b3JzYFxuICAgICAgICAvLyB3aWxsIGJlIHVwZGF0ZWQuXG4gICAgICAgIHJldHVybiB0aGlzLnVzZXIucmVsb2FkKCk7XG4gICAgfVxuICAgIGFzeW5jIHVuZW5yb2xsKGluZm9PclVpZCkge1xuICAgICAgICBjb25zdCBtZmFFbnJvbGxtZW50SWQgPSB0eXBlb2YgaW5mb09yVWlkID09PSAnc3RyaW5nJyA/IGluZm9PclVpZCA6IGluZm9PclVpZC51aWQ7XG4gICAgICAgIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB0aGlzLnVzZXIuZ2V0SWRUb2tlbigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaWRUb2tlblJlc3BvbnNlID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodGhpcy51c2VyLCB3aXRoZHJhd01mYSh0aGlzLnVzZXIuYXV0aCwge1xuICAgICAgICAgICAgICAgIGlkVG9rZW4sXG4gICAgICAgICAgICAgICAgbWZhRW5yb2xsbWVudElkXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlY29uZCBmYWN0b3IgZnJvbSB0aGUgdXNlcidzIGxpc3QuXG4gICAgICAgICAgICB0aGlzLmVucm9sbGVkRmFjdG9ycyA9IHRoaXMuZW5yb2xsZWRGYWN0b3JzLmZpbHRlcigoeyB1aWQgfSkgPT4gdWlkICE9PSBtZmFFbnJvbGxtZW50SWQpO1xuICAgICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGJhY2tlbmQgZGVjaWRlZCB0byByZXZva2UgdGhlIHVzZXIncyBzZXNzaW9uLFxuICAgICAgICAgICAgLy8gdGhlIHRva2VuUmVzcG9uc2UgbWF5IGJlIGVtcHR5LiBJZiB0aGUgdG9rZW5zIHdlcmUgbm90IHVwZGF0ZWQgKGFuZCB0aGV5XG4gICAgICAgICAgICAvLyBhcmUgbm93IGludmFsaWQpLCByZWxvYWRpbmcgdGhlIHVzZXIgd2lsbCBkaXNjb3ZlciB0aGlzIGFuZCBpbnZhbGlkYXRlXG4gICAgICAgICAgICAvLyB0aGUgdXNlcidzIHN0YXRlIGFjY29yZGluZ2x5LlxuICAgICAgICAgICAgYXdhaXQgdGhpcy51c2VyLl91cGRhdGVUb2tlbnNJZk5lY2Vzc2FyeShpZFRva2VuUmVzcG9uc2UpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy51c2VyLnJlbG9hZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgbXVsdGlGYWN0b3JVc2VyQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBUaGUge0BsaW5rIE11bHRpRmFjdG9yVXNlcn0gY29ycmVzcG9uZGluZyB0byB0aGUgdXNlci5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBpcyB1c2VkIHRvIGFjY2VzcyBhbGwgbXVsdGktZmFjdG9yIHByb3BlcnRpZXMgYW5kIG9wZXJhdGlvbnMgcmVsYXRlZCB0byB0aGUgdXNlci5cbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gbXVsdGlGYWN0b3IodXNlcikge1xuICAgIGNvbnN0IHVzZXJNb2R1bGFyID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xuICAgIGlmICghbXVsdGlGYWN0b3JVc2VyQ2FjaGUuaGFzKHVzZXJNb2R1bGFyKSkge1xuICAgICAgICBtdWx0aUZhY3RvclVzZXJDYWNoZS5zZXQodXNlck1vZHVsYXIsIE11bHRpRmFjdG9yVXNlckltcGwuX2Zyb21Vc2VyKHVzZXJNb2R1bGFyKSk7XG4gICAgfVxuICAgIHJldHVybiBtdWx0aUZhY3RvclVzZXJDYWNoZS5nZXQodXNlck1vZHVsYXIpO1xufVxuXG52YXIgbmFtZSA9IFwiQGZpcmViYXNlL2F1dGhcIjtcbnZhciB2ZXJzaW9uID0gXCIxLjguMVwiO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgQXV0aEludGVyb3Age1xuICAgIGNvbnN0cnVjdG9yKGF1dGgpIHtcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICAgICAgdGhpcy5pbnRlcm5hbExpc3RlbmVycyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgZ2V0VWlkKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuYXNzZXJ0QXV0aENvbmZpZ3VyZWQoKTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLmF1dGguY3VycmVudFVzZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51aWQpIHx8IG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGdldFRva2VuKGZvcmNlUmVmcmVzaCkge1xuICAgICAgICB0aGlzLmFzc2VydEF1dGhDb25maWd1cmVkKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuYXV0aC5faW5pdGlhbGl6YXRpb25Qcm9taXNlO1xuICAgICAgICBpZiAoIXRoaXMuYXV0aC5jdXJyZW50VXNlcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW4gPSBhd2FpdCB0aGlzLmF1dGguY3VycmVudFVzZXIuZ2V0SWRUb2tlbihmb3JjZVJlZnJlc2gpO1xuICAgICAgICByZXR1cm4geyBhY2Nlc3NUb2tlbiB9O1xuICAgIH1cbiAgICBhZGRBdXRoVG9rZW5MaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmFzc2VydEF1dGhDb25maWd1cmVkKCk7XG4gICAgICAgIGlmICh0aGlzLmludGVybmFsTGlzdGVuZXJzLmhhcyhsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMuYXV0aC5vbklkVG9rZW5DaGFuZ2VkKHVzZXIgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXIoKHVzZXIgPT09IG51bGwgfHwgdXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlci5zdHNUb2tlbk1hbmFnZXIuYWNjZXNzVG9rZW4pIHx8IG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbExpc3RlbmVycy5zZXQobGlzdGVuZXIsIHVuc3Vic2NyaWJlKTtcbiAgICAgICAgdGhpcy51cGRhdGVQcm9hY3RpdmVSZWZyZXNoKCk7XG4gICAgfVxuICAgIHJlbW92ZUF1dGhUb2tlbkxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0QXV0aENvbmZpZ3VyZWQoKTtcbiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSB0aGlzLmludGVybmFsTGlzdGVuZXJzLmdldChsaXN0ZW5lcik7XG4gICAgICAgIGlmICghdW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVybmFsTGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMudXBkYXRlUHJvYWN0aXZlUmVmcmVzaCgpO1xuICAgIH1cbiAgICBhc3NlcnRBdXRoQ29uZmlndXJlZCgpIHtcbiAgICAgICAgX2Fzc2VydCh0aGlzLmF1dGguX2luaXRpYWxpemF0aW9uUHJvbWlzZSwgXCJkZXBlbmRlbnQtc2RrLWluaXRpYWxpemVkLWJlZm9yZS1hdXRoXCIgLyogQXV0aEVycm9yQ29kZS5ERVBFTkRFTlRfU0RLX0lOSVRfQkVGT1JFX0FVVEggKi8pO1xuICAgIH1cbiAgICB1cGRhdGVQcm9hY3RpdmVSZWZyZXNoKCkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcm5hbExpc3RlbmVycy5zaXplID4gMCkge1xuICAgICAgICAgICAgdGhpcy5hdXRoLl9zdGFydFByb2FjdGl2ZVJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXV0aC5fc3RvcFByb2FjdGl2ZVJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGdldFZlcnNpb25Gb3JQbGF0Zm9ybShjbGllbnRQbGF0Zm9ybSkge1xuICAgIHN3aXRjaCAoY2xpZW50UGxhdGZvcm0pIHtcbiAgICAgICAgY2FzZSBcIk5vZGVcIiAvKiBDbGllbnRQbGF0Zm9ybS5OT0RFICovOlxuICAgICAgICAgICAgcmV0dXJuICdub2RlJztcbiAgICAgICAgY2FzZSBcIlJlYWN0TmF0aXZlXCIgLyogQ2xpZW50UGxhdGZvcm0uUkVBQ1RfTkFUSVZFICovOlxuICAgICAgICAgICAgcmV0dXJuICdybic7XG4gICAgICAgIGNhc2UgXCJXb3JrZXJcIiAvKiBDbGllbnRQbGF0Zm9ybS5XT1JLRVIgKi86XG4gICAgICAgICAgICByZXR1cm4gJ3dlYndvcmtlcic7XG4gICAgICAgIGNhc2UgXCJDb3Jkb3ZhXCIgLyogQ2xpZW50UGxhdGZvcm0uQ09SRE9WQSAqLzpcbiAgICAgICAgICAgIHJldHVybiAnY29yZG92YSc7XG4gICAgICAgIGNhc2UgXCJXZWJFeHRlbnNpb25cIiAvKiBDbGllbnRQbGF0Zm9ybS5XRUJfRVhURU5TSU9OICovOlxuICAgICAgICAgICAgcmV0dXJuICd3ZWItZXh0ZW5zaW9uJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJBdXRoKGNsaWVudFBsYXRmb3JtKSB7XG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoXCJhdXRoXCIgLyogX0NvbXBvbmVudE5hbWUuQVVUSCAqLywgKGNvbnRhaW5lciwgeyBvcHRpb25zOiBkZXBzIH0pID0+IHtcbiAgICAgICAgY29uc3QgYXBwID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcbiAgICAgICAgY29uc3QgaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdoZWFydGJlYXQnKTtcbiAgICAgICAgY29uc3QgYXBwQ2hlY2tTZXJ2aWNlUHJvdmlkZXIgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2FwcC1jaGVjay1pbnRlcm5hbCcpO1xuICAgICAgICBjb25zdCB7IGFwaUtleSwgYXV0aERvbWFpbiB9ID0gYXBwLm9wdGlvbnM7XG4gICAgICAgIF9hc3NlcnQoYXBpS2V5ICYmICFhcGlLZXkuaW5jbHVkZXMoJzonKSwgXCJpbnZhbGlkLWFwaS1rZXlcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQVBJX0tFWSAqLywgeyBhcHBOYW1lOiBhcHAubmFtZSB9KTtcbiAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgYXBpS2V5LFxuICAgICAgICAgICAgYXV0aERvbWFpbixcbiAgICAgICAgICAgIGNsaWVudFBsYXRmb3JtLFxuICAgICAgICAgICAgYXBpSG9zdDogXCJpZGVudGl0eXRvb2xraXQuZ29vZ2xlYXBpcy5jb21cIiAvKiBEZWZhdWx0Q29uZmlnLkFQSV9IT1NUICovLFxuICAgICAgICAgICAgdG9rZW5BcGlIb3N0OiBcInNlY3VyZXRva2VuLmdvb2dsZWFwaXMuY29tXCIgLyogRGVmYXVsdENvbmZpZy5UT0tFTl9BUElfSE9TVCAqLyxcbiAgICAgICAgICAgIGFwaVNjaGVtZTogXCJodHRwc1wiIC8qIERlZmF1bHRDb25maWcuQVBJX1NDSEVNRSAqLyxcbiAgICAgICAgICAgIHNka0NsaWVudFZlcnNpb246IF9nZXRDbGllbnRWZXJzaW9uKGNsaWVudFBsYXRmb3JtKVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhdXRoSW5zdGFuY2UgPSBuZXcgQXV0aEltcGwoYXBwLCBoZWFydGJlYXRTZXJ2aWNlUHJvdmlkZXIsIGFwcENoZWNrU2VydmljZVByb3ZpZGVyLCBjb25maWcpO1xuICAgICAgICBfaW5pdGlhbGl6ZUF1dGhJbnN0YW5jZShhdXRoSW5zdGFuY2UsIGRlcHMpO1xuICAgICAgICByZXR1cm4gYXV0aEluc3RhbmNlO1xuICAgIH0sIFwiUFVCTElDXCIgLyogQ29tcG9uZW50VHlwZS5QVUJMSUMgKi8pXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdXRoIGNhbiBvbmx5IGJlIGluaXRpYWxpemVkIGJ5IGV4cGxpY2l0bHkgY2FsbGluZyBnZXRBdXRoKCkgb3IgaW5pdGlhbGl6ZUF1dGgoKVxuICAgICAgICAgKiBGb3Igd2h5IHdlIGRvIHRoaXMsIFNlZSBnby9maXJlYmFzZS1uZXh0LWF1dGgtaW5pdFxuICAgICAgICAgKi9cbiAgICAgICAgLnNldEluc3RhbnRpYXRpb25Nb2RlKFwiRVhQTElDSVRcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5FWFBMSUNJVCAqLylcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJlY2F1c2UgYWxsIGZpcmViYXNlIHByb2R1Y3RzIHRoYXQgZGVwZW5kIG9uIGF1dGggZGVwZW5kIG9uIGF1dGgtaW50ZXJuYWwgZGlyZWN0bHksXG4gICAgICAgICAqIHdlIG5lZWQgdG8gaW5pdGlhbGl6ZSBhdXRoLWludGVybmFsIGFmdGVyIGF1dGggaXMgaW5pdGlhbGl6ZWQgdG8gbWFrZSBpdCBhdmFpbGFibGUgdG8gb3RoZXIgZmlyZWJhc2UgcHJvZHVjdHMuXG4gICAgICAgICAqL1xuICAgICAgICAuc2V0SW5zdGFuY2VDcmVhdGVkQ2FsbGJhY2soKGNvbnRhaW5lciwgX2luc3RhbmNlSWRlbnRpZmllciwgX2luc3RhbmNlKSA9PiB7XG4gICAgICAgIGNvbnN0IGF1dGhJbnRlcm5hbFByb3ZpZGVyID0gY29udGFpbmVyLmdldFByb3ZpZGVyKFwiYXV0aC1pbnRlcm5hbFwiIC8qIF9Db21wb25lbnROYW1lLkFVVEhfSU5URVJOQUwgKi8pO1xuICAgICAgICBhdXRoSW50ZXJuYWxQcm92aWRlci5pbml0aWFsaXplKCk7XG4gICAgfSkpO1xuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KFwiYXV0aC1pbnRlcm5hbFwiIC8qIF9Db21wb25lbnROYW1lLkFVVEhfSU5URVJOQUwgKi8sIGNvbnRhaW5lciA9PiB7XG4gICAgICAgIGNvbnN0IGF1dGggPSBfY2FzdEF1dGgoY29udGFpbmVyLmdldFByb3ZpZGVyKFwiYXV0aFwiIC8qIF9Db21wb25lbnROYW1lLkFVVEggKi8pLmdldEltbWVkaWF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIChhdXRoID0+IG5ldyBBdXRoSW50ZXJvcChhdXRoKSkoYXV0aCk7XG4gICAgfSwgXCJQUklWQVRFXCIgLyogQ29tcG9uZW50VHlwZS5QUklWQVRFICovKS5zZXRJbnN0YW50aWF0aW9uTW9kZShcIkVYUExJQ0lUXCIgLyogSW5zdGFudGlhdGlvbk1vZGUuRVhQTElDSVQgKi8pKTtcbiAgICByZWdpc3RlclZlcnNpb24obmFtZSwgdmVyc2lvbiwgZ2V0VmVyc2lvbkZvclBsYXRmb3JtKGNsaWVudFBsYXRmb3JtKSk7XG4gICAgLy8gQlVJTERfVEFSR0VUIHdpbGwgYmUgcmVwbGFjZWQgYnkgdmFsdWVzIGxpa2UgZXNtMjAxNywgY2pzMjAxNywgZXRjIGR1cmluZyB0aGUgY29tcGlsYXRpb25cbiAgICByZWdpc3RlclZlcnNpb24obmFtZSwgdmVyc2lvbiwgJ2VzbTIwMTcnKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8vIEluaXRpYWxpemUgdGhlIGZldGNoIHBvbHlmaWxsLCB0aGUgdHlwZXMgYXJlIHNsaWdodGx5IG9mZiBzbyBqdXN0IGNhc3QgYW5kIGhvcGUgZm9yIHRoZSBiZXN0XG5GZXRjaFByb3ZpZGVyLmluaXRpYWxpemUoZmV0Y2gsIEhlYWRlcnMsIFJlc3BvbnNlKTtcbi8vIEZpcnN0LCB3ZSBzZXQgdXAgdGhlIHZhcmlvdXMgcGxhdGZvcm0tc3BlY2lmaWMgZmVhdHVyZXMgZm9yIE5vZGUgKHJlZ2lzdGVyXG4vLyB0aGUgdmVyc2lvbiBhbmQgZGVjbGFyZSB0aGUgTm9kZSBnZXRBdXRoIGZ1bmN0aW9uKVxuZnVuY3Rpb24gZ2V0QXV0aChhcHAgPSBnZXRBcHAoKSkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gX2dldFByb3ZpZGVyKGFwcCwgJ2F1dGgnKTtcbiAgICBpZiAocHJvdmlkZXIuaXNJbml0aWFsaXplZCgpKSB7XG4gICAgICAgIHJldHVybiBwcm92aWRlci5nZXRJbW1lZGlhdGUoKTtcbiAgICB9XG4gICAgY29uc3QgYXV0aCA9IGluaXRpYWxpemVBdXRoKGFwcCk7XG4gICAgY29uc3QgYXV0aEVtdWxhdG9ySG9zdCA9IGdldERlZmF1bHRFbXVsYXRvckhvc3QoJ2F1dGgnKTtcbiAgICBpZiAoYXV0aEVtdWxhdG9ySG9zdCkge1xuICAgICAgICBjb25uZWN0QXV0aEVtdWxhdG9yKGF1dGgsIGBodHRwOi8vJHthdXRoRW11bGF0b3JIb3N0fWApO1xuICAgIH1cbiAgICByZXR1cm4gYXV0aDtcbn1cbnJlZ2lzdGVyQXV0aChcIk5vZGVcIiAvKiBDbGllbnRQbGF0Zm9ybS5OT0RFICovKTtcbi8vIFRoZSByZXN0IG9mIHRoaXMgZmlsZSBjb250YWlucyBuby1vcHMgYW5kIGVycm9ycyBmb3IgYnJvd3Nlci1zcGVjaWZpY1xuLy8gbWV0aG9kcy4gV2Uga2VlcCB0aGUgYnJvd3NlciBhbmQgTm9kZSBlbnRyeSBwb2ludHMgdGhlIHNhbWUsIGJ1dCBmZWF0dXJlc1xuLy8gdGhhdCBvbmx5IHdvcmsgaW4gYnJvd3NlcnMgYXJlIHNldCB0byBlaXRoZXIgZG8gbm90aGluZyAoc2V0UGVyc2lzdGVuY2UpIG9yXG4vLyB0byByZWplY3Qgd2l0aCBhbiBhdXRoL29wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnQgZXJyb3IuXG4vLyBUaGUgYmVsb3cgZXhwb3J0cyBhcmUgcHVsbGVkIGludG8gdGhlIG1haW4gZW50cnkgcG9pbnQgYnkgYSByb2xsdXAgYWxpYXNcbi8vIHBsdWdpbiAob3ZlcndyaXRpbmcgdGhlIGRlZmF1bHQgYnJvd3NlciBpbXBvcnRzKS5cbi8qKiBhdXRoL29wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnQgKi9cbmNvbnN0IE5PVF9BVkFJTEFCTEVfRVJST1IgPSBfY3JlYXRlRXJyb3IoXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIgLyogQXV0aEVycm9yQ29kZS5PUEVSQVRJT05fTk9UX1NVUFBPUlRFRCAqLyk7XG4vKiogUmVqZWN0IHdpdGggYXV0aC9vcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50ICovXG5hc3luYyBmdW5jdGlvbiBmYWlsKCkge1xuICAgIHRocm93IE5PVF9BVkFJTEFCTEVfRVJST1I7XG59XG4vKipcbiAqIEEgY2xhc3Mgd2hpY2ggd2lsbCB0aHJvdyB3aXRoXG4gKiBhdXRoL29wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnQgaWYgaW5zdGFudGlhdGVkXG4gKi9cbmNsYXNzIEZhaWxDbGFzcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRocm93IE5PVF9BVkFJTEFCTEVfRVJST1I7XG4gICAgfVxufVxuY29uc3QgYnJvd3NlckxvY2FsUGVyc2lzdGVuY2UgPSBpbk1lbW9yeVBlcnNpc3RlbmNlO1xuY29uc3QgYnJvd3NlclNlc3Npb25QZXJzaXN0ZW5jZSA9IGluTWVtb3J5UGVyc2lzdGVuY2U7XG5jb25zdCBpbmRleGVkREJMb2NhbFBlcnNpc3RlbmNlID0gaW5NZW1vcnlQZXJzaXN0ZW5jZTtcbmNvbnN0IGJyb3dzZXJQb3B1cFJlZGlyZWN0UmVzb2x2ZXIgPSBOT1RfQVZBSUxBQkxFX0VSUk9SO1xuY29uc3QgUGhvbmVBdXRoUHJvdmlkZXIgPSBGYWlsQ2xhc3M7XG5jb25zdCBzaWduSW5XaXRoUGhvbmVOdW1iZXIgPSBmYWlsO1xuY29uc3QgbGlua1dpdGhQaG9uZU51bWJlciA9IGZhaWw7XG5jb25zdCByZWF1dGhlbnRpY2F0ZVdpdGhQaG9uZU51bWJlciA9IGZhaWw7XG5jb25zdCB1cGRhdGVQaG9uZU51bWJlciA9IGZhaWw7XG5jb25zdCBzaWduSW5XaXRoUG9wdXAgPSBmYWlsO1xuY29uc3QgbGlua1dpdGhQb3B1cCA9IGZhaWw7XG5jb25zdCByZWF1dGhlbnRpY2F0ZVdpdGhQb3B1cCA9IGZhaWw7XG5jb25zdCBzaWduSW5XaXRoUmVkaXJlY3QgPSBmYWlsO1xuY29uc3QgbGlua1dpdGhSZWRpcmVjdCA9IGZhaWw7XG5jb25zdCByZWF1dGhlbnRpY2F0ZVdpdGhSZWRpcmVjdCA9IGZhaWw7XG5jb25zdCBnZXRSZWRpcmVjdFJlc3VsdCA9IGZhaWw7XG5jb25zdCBSZWNhcHRjaGFWZXJpZmllciA9IEZhaWxDbGFzcztcbmNsYXNzIFBob25lTXVsdGlGYWN0b3JHZW5lcmF0b3Ige1xuICAgIHN0YXRpYyBhc3NlcnRpb24oKSB7XG4gICAgICAgIHRocm93IE5PVF9BVkFJTEFCTEVfRVJST1I7XG4gICAgfVxufVxuLy8gU2V0IHBlcnNpc3RlbmNlIHNob3VsZCBuby1vcCBpbnN0ZWFkIG9mIGZhaWwuIENoYW5naW5nIHRoZSBwcm90b3R5cGUgd2lsbFxuLy8gbWFrZSBzdXJlIGJvdGggc2V0UGVyc2lzdGVuY2UoYXV0aCwgcGVyc2lzdGVuY2UpIGFuZFxuLy8gYXV0aC5zZXRQZXJzaXN0ZW5jZShwZXJzaXN0ZW5jZSkgYXJlIGNvdmVyZWQuXG5BdXRoSW1wbC5wcm90b3R5cGUuc2V0UGVyc2lzdGVuY2UgPSBhc3luYyAoKSA9PiB7IH07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBmaW5hbGl6ZVNpZ25JblRvdHBNZmEoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92Mi9hY2NvdW50cy9tZmFTaWduSW46ZmluYWxpemVcIiAvKiBFbmRwb2ludC5GSU5BTElaRV9NRkFfU0lHTl9JTiAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcbn1cblxuY2xhc3MgTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3JJZCkge1xuICAgICAgICB0aGlzLmZhY3RvcklkID0gZmFjdG9ySWQ7XG4gICAgfVxuICAgIF9wcm9jZXNzKGF1dGgsIHNlc3Npb24sIGRpc3BsYXlOYW1lKSB7XG4gICAgICAgIHN3aXRjaCAoc2Vzc2lvbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZW5yb2xsXCIgLyogTXVsdGlGYWN0b3JTZXNzaW9uVHlwZS5FTlJPTEwgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplRW5yb2xsKGF1dGgsIHNlc3Npb24uY3JlZGVudGlhbCwgZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcInNpZ25pblwiIC8qIE11bHRpRmFjdG9yU2Vzc2lvblR5cGUuU0lHTl9JTiAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVTaWduSW4oYXV0aCwgc2Vzc2lvbi5jcmVkZW50aWFsKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlYnVnRmFpbCgndW5leHBlY3RlZCBNdWx0aUZhY3RvclNlc3Npb25UeXBlJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogUHJvdmlkZXIgZm9yIGdlbmVyYXRpbmcgYSB7QGxpbmsgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9ufS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFRvdHBNdWx0aUZhY3RvckdlbmVyYXRvciB7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSB7QGxpbmsgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9ufSB0byBjb25maXJtIG93bmVyc2hpcCBvZlxuICAgICAqIHRoZSBUT1RQICh0aW1lLWJhc2VkIG9uZS10aW1lIHBhc3N3b3JkKSBzZWNvbmQgZmFjdG9yLlxuICAgICAqIFRoaXMgYXNzZXJ0aW9uIGlzIHVzZWQgdG8gY29tcGxldGUgZW5yb2xsbWVudCBpbiBUT1RQIHNlY29uZCBmYWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2VjcmV0IEEge0BsaW5rIFRvdHBTZWNyZXR9IGNvbnRhaW5pbmcgdGhlIHNoYXJlZCBzZWNyZXQga2V5IGFuZCBvdGhlciBUT1RQIHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIG9uZVRpbWVQYXNzd29yZCBPbmUtdGltZSBwYXNzd29yZCBmcm9tIFRPVFAgQXBwLlxuICAgICAqIEByZXR1cm5zIEEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0gd2hpY2ggY2FuIGJlIHVzZWQgd2l0aFxuICAgICAqIHtAbGluayBNdWx0aUZhY3RvclVzZXIuZW5yb2xsfS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXNzZXJ0aW9uRm9yRW5yb2xsbWVudChzZWNyZXQsIG9uZVRpbWVQYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbC5fZnJvbVNlY3JldChzZWNyZXQsIG9uZVRpbWVQYXNzd29yZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0gdG8gY29uZmlybSBvd25lcnNoaXAgb2YgdGhlIFRPVFAgc2Vjb25kIGZhY3Rvci5cbiAgICAgKiBUaGlzIGFzc2VydGlvbiBpcyB1c2VkIHRvIGNvbXBsZXRlIHNpZ25JbiB3aXRoIFRPVFAgYXMgdGhlIHNlY29uZCBmYWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW5yb2xsbWVudElkIGlkZW50aWZpZXMgdGhlIGVucm9sbGVkIFRPVFAgc2Vjb25kIGZhY3Rvci5cbiAgICAgKiBAcGFyYW0gb25lVGltZVBhc3N3b3JkIE9uZS10aW1lIHBhc3N3b3JkIGZyb20gVE9UUCBBcHAuXG4gICAgICogQHJldHVybnMgQSB7QGxpbmsgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9ufSB3aGljaCBjYW4gYmUgdXNlZCB3aXRoXG4gICAgICoge0BsaW5rIE11bHRpRmFjdG9yUmVzb2x2ZXIucmVzb2x2ZVNpZ25Jbn0uXG4gICAgICovXG4gICAgc3RhdGljIGFzc2VydGlvbkZvclNpZ25JbihlbnJvbGxtZW50SWQsIG9uZVRpbWVQYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbC5fZnJvbUVucm9sbG1lbnRJZChlbnJvbGxtZW50SWQsIG9uZVRpbWVQYXNzd29yZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRvIHtAbGluayBUb3RwU2VjcmV0fSB3aGljaCBjb250YWlucyB0aGUgVE9UUCBzaGFyZWQgc2VjcmV0IGtleSBhbmQgb3RoZXIgcGFyYW1ldGVycy5cbiAgICAgKiBDcmVhdGVzIGEgVE9UUCBzZWNyZXQgYXMgcGFydCBvZiBlbnJvbGxpbmcgYSBUT1RQIHNlY29uZCBmYWN0b3IuXG4gICAgICogVXNlZCBmb3IgZ2VuZXJhdGluZyBhIFFSIGNvZGUgVVJMIG9yIGlucHV0dGluZyBpbnRvIGEgVE9UUCBhcHAuXG4gICAgICogVGhpcyBtZXRob2QgdXNlcyB0aGUgYXV0aCBpbnN0YW5jZSBjb3JyZXNwb25kaW5nIHRvIHRoZSB1c2VyIGluIHRoZSBtdWx0aUZhY3RvclNlc3Npb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2Vzc2lvbiBUaGUge0BsaW5rIE11bHRpRmFjdG9yU2Vzc2lvbn0gdGhhdCB0aGUgdXNlciBpcyBwYXJ0IG9mLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0byB7QGxpbmsgVG90cFNlY3JldH0uXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGdlbmVyYXRlU2VjcmV0KHNlc3Npb24pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZmFTZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgX2Fzc2VydCh0eXBlb2YgKChfYSA9IG1mYVNlc3Npb24udXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF1dGgpICE9PSAndW5kZWZpbmVkJywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHN0YXJ0RW5yb2xsVG90cE1mYShtZmFTZXNzaW9uLnVzZXIuYXV0aCwge1xuICAgICAgICAgICAgaWRUb2tlbjogbWZhU2Vzc2lvbi5jcmVkZW50aWFsLFxuICAgICAgICAgICAgdG90cEVucm9sbG1lbnRJbmZvOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFRvdHBTZWNyZXQuX2Zyb21TdGFydFRvdHBNZmFFbnJvbGxtZW50UmVzcG9uc2UocmVzcG9uc2UsIG1mYVNlc3Npb24udXNlci5hdXRoKTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBpZGVudGlmaWVyIG9mIHRoZSBUT1RQIHNlY29uZCBmYWN0b3I6IGB0b3RwYC5cbiAqL1xuVG90cE11bHRpRmFjdG9yR2VuZXJhdG9yLkZBQ1RPUl9JRCA9IFwidG90cFwiIC8qIEZhY3RvcklkLlRPVFAgKi87XG5jbGFzcyBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsIGV4dGVuZHMgTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihvdHAsIGVucm9sbG1lbnRJZCwgc2VjcmV0KSB7XG4gICAgICAgIHN1cGVyKFwidG90cFwiIC8qIEZhY3RvcklkLlRPVFAgKi8pO1xuICAgICAgICB0aGlzLm90cCA9IG90cDtcbiAgICAgICAgdGhpcy5lbnJvbGxtZW50SWQgPSBlbnJvbGxtZW50SWQ7XG4gICAgICAgIHRoaXMuc2VjcmV0ID0gc2VjcmV0O1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIF9mcm9tU2VjcmV0KHNlY3JldCwgb3RwKSB7XG4gICAgICAgIHJldHVybiBuZXcgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbChvdHAsIHVuZGVmaW5lZCwgc2VjcmV0KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBfZnJvbUVucm9sbG1lbnRJZChlbnJvbGxtZW50SWQsIG90cCkge1xuICAgICAgICByZXR1cm4gbmV3IFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbkltcGwob3RwLCBlbnJvbGxtZW50SWQpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgYXN5bmMgX2ZpbmFsaXplRW5yb2xsKGF1dGgsIGlkVG9rZW4sIGRpc3BsYXlOYW1lKSB7XG4gICAgICAgIF9hc3NlcnQodHlwZW9mIHRoaXMuc2VjcmV0ICE9PSAndW5kZWZpbmVkJywgYXV0aCwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xuICAgICAgICByZXR1cm4gZmluYWxpemVFbnJvbGxUb3RwTWZhKGF1dGgsIHtcbiAgICAgICAgICAgIGlkVG9rZW4sXG4gICAgICAgICAgICBkaXNwbGF5TmFtZSxcbiAgICAgICAgICAgIHRvdHBWZXJpZmljYXRpb25JbmZvOiB0aGlzLnNlY3JldC5fbWFrZVRvdHBWZXJpZmljYXRpb25JbmZvKHRoaXMub3RwKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGFzeW5jIF9maW5hbGl6ZVNpZ25JbihhdXRoLCBtZmFQZW5kaW5nQ3JlZGVudGlhbCkge1xuICAgICAgICBfYXNzZXJ0KHRoaXMuZW5yb2xsbWVudElkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vdHAgIT09IHVuZGVmaW5lZCwgYXV0aCwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xuICAgICAgICBjb25zdCB0b3RwVmVyaWZpY2F0aW9uSW5mbyA9IHsgdmVyaWZpY2F0aW9uQ29kZTogdGhpcy5vdHAgfTtcbiAgICAgICAgcmV0dXJuIGZpbmFsaXplU2lnbkluVG90cE1mYShhdXRoLCB7XG4gICAgICAgICAgICBtZmFQZW5kaW5nQ3JlZGVudGlhbCxcbiAgICAgICAgICAgIG1mYUVucm9sbG1lbnRJZDogdGhpcy5lbnJvbGxtZW50SWQsXG4gICAgICAgICAgICB0b3RwVmVyaWZpY2F0aW9uSW5mb1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0uXG4gKlxuICogU3RvcmVzIHRoZSBzaGFyZWQgc2VjcmV0IGtleSBhbmQgb3RoZXIgcGFyYW1ldGVycyB0byBnZW5lcmF0ZSB0aW1lLWJhc2VkIE9UUHMuXG4gKiBJbXBsZW1lbnRzIG1ldGhvZHMgdG8gcmV0cmlldmUgdGhlIHNoYXJlZCBzZWNyZXQga2V5IGFuZCBnZW5lcmF0ZSBhIFFSIGNvZGUgVVJMLlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBUb3RwU2VjcmV0IHtcbiAgICAvLyBUaGUgcHVibGljIG1lbWJlcnMgYXJlIGRlY2xhcmVkIG91dHNpZGUgdGhlIGNvbnN0cnVjdG9yIHNvIHRoZSBkb2NzIGNhbiBiZSBnZW5lcmF0ZWQuXG4gICAgY29uc3RydWN0b3Ioc2VjcmV0S2V5LCBoYXNoaW5nQWxnb3JpdGhtLCBjb2RlTGVuZ3RoLCBjb2RlSW50ZXJ2YWxTZWNvbmRzLCBlbnJvbGxtZW50Q29tcGxldGlvbkRlYWRsaW5lLCBzZXNzaW9uSW5mbywgYXV0aCkge1xuICAgICAgICB0aGlzLnNlc3Npb25JbmZvID0gc2Vzc2lvbkluZm87XG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgICAgIHRoaXMuc2VjcmV0S2V5ID0gc2VjcmV0S2V5O1xuICAgICAgICB0aGlzLmhhc2hpbmdBbGdvcml0aG0gPSBoYXNoaW5nQWxnb3JpdGhtO1xuICAgICAgICB0aGlzLmNvZGVMZW5ndGggPSBjb2RlTGVuZ3RoO1xuICAgICAgICB0aGlzLmNvZGVJbnRlcnZhbFNlY29uZHMgPSBjb2RlSW50ZXJ2YWxTZWNvbmRzO1xuICAgICAgICB0aGlzLmVucm9sbG1lbnRDb21wbGV0aW9uRGVhZGxpbmUgPSBlbnJvbGxtZW50Q29tcGxldGlvbkRlYWRsaW5lO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIF9mcm9tU3RhcnRUb3RwTWZhRW5yb2xsbWVudFJlc3BvbnNlKHJlc3BvbnNlLCBhdXRoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVG90cFNlY3JldChyZXNwb25zZS50b3RwU2Vzc2lvbkluZm8uc2hhcmVkU2VjcmV0S2V5LCByZXNwb25zZS50b3RwU2Vzc2lvbkluZm8uaGFzaGluZ0FsZ29yaXRobSwgcmVzcG9uc2UudG90cFNlc3Npb25JbmZvLnZlcmlmaWNhdGlvbkNvZGVMZW5ndGgsIHJlc3BvbnNlLnRvdHBTZXNzaW9uSW5mby5wZXJpb2RTZWMsIG5ldyBEYXRlKHJlc3BvbnNlLnRvdHBTZXNzaW9uSW5mby5maW5hbGl6ZUVucm9sbG1lbnRUaW1lKS50b1VUQ1N0cmluZygpLCByZXNwb25zZS50b3RwU2Vzc2lvbkluZm8uc2Vzc2lvbkluZm8sIGF1dGgpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX21ha2VUb3RwVmVyaWZpY2F0aW9uSW5mbyhvdHApIHtcbiAgICAgICAgcmV0dXJuIHsgc2Vzc2lvbkluZm86IHRoaXMuc2Vzc2lvbkluZm8sIHZlcmlmaWNhdGlvbkNvZGU6IG90cCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgUVIgY29kZSBVUkwgYXMgZGVzY3JpYmVkIGluXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9nb29nbGUtYXV0aGVudGljYXRvci93aWtpL0tleS1VcmktRm9ybWF0XG4gICAgICogVGhpcyBjYW4gYmUgZGlzcGxheWVkIHRvIHRoZSB1c2VyIGFzIGEgUVIgY29kZSB0byBiZSBzY2FubmVkIGludG8gYSBUT1RQIGFwcCBsaWtlIEdvb2dsZSBBdXRoZW50aWNhdG9yLlxuICAgICAqIElmIHRoZSBvcHRpb25hbCBwYXJhbWV0ZXJzIGFyZSB1bnNwZWNpZmllZCwgYW4gYWNjb3VudE5hbWUgb2YgPHVzZXJFbWFpbD4gYW5kIGlzc3VlciBvZiA8ZmlyZWJhc2VBcHBOYW1lPiBhcmUgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY2NvdW50TmFtZSB0aGUgbmFtZSBvZiB0aGUgYWNjb3VudC9hcHAgYWxvbmcgd2l0aCBhIHVzZXIgaWRlbnRpZmllci5cbiAgICAgKiBAcGFyYW0gaXNzdWVyIGlzc3VlciBvZiB0aGUgVE9UUCAobGlrZWx5IHRoZSBhcHAgbmFtZSkuXG4gICAgICogQHJldHVybnMgQSBRUiBjb2RlIFVSTCBzdHJpbmcuXG4gICAgICovXG4gICAgZ2VuZXJhdGVRckNvZGVVcmwoYWNjb3VudE5hbWUsIGlzc3Vlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCB1c2VEZWZhdWx0cyA9IGZhbHNlO1xuICAgICAgICBpZiAoX2lzRW1wdHlTdHJpbmcoYWNjb3VudE5hbWUpIHx8IF9pc0VtcHR5U3RyaW5nKGlzc3VlcikpIHtcbiAgICAgICAgICAgIHVzZURlZmF1bHRzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlRGVmYXVsdHMpIHtcbiAgICAgICAgICAgIGlmIChfaXNFbXB0eVN0cmluZyhhY2NvdW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50TmFtZSA9ICgoX2EgPSB0aGlzLmF1dGguY3VycmVudFVzZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbWFpbCkgfHwgJ3Vua25vd251c2VyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfaXNFbXB0eVN0cmluZyhpc3N1ZXIpKSB7XG4gICAgICAgICAgICAgICAgaXNzdWVyID0gdGhpcy5hdXRoLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBvdHBhdXRoOi8vdG90cC8ke2lzc3Vlcn06JHthY2NvdW50TmFtZX0/c2VjcmV0PSR7dGhpcy5zZWNyZXRLZXl9Jmlzc3Vlcj0ke2lzc3Vlcn0mYWxnb3JpdGhtPSR7dGhpcy5oYXNoaW5nQWxnb3JpdGhtfSZkaWdpdHM9JHt0aGlzLmNvZGVMZW5ndGh9YDtcbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBfaXNFbXB0eVN0cmluZyhpbnB1dCkge1xuICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnIHx8IChpbnB1dCA9PT0gbnVsbCB8fCBpbnB1dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5wdXQubGVuZ3RoKSA9PT0gMDtcbn1cblxuZXhwb3J0IHsgVHdpdHRlckF1dGhQcm92aWRlciBhcyAkLCBBY3Rpb25Db2RlT3BlcmF0aW9uIGFzIEEsIHVwZGF0ZUN1cnJlbnRVc2VyIGFzIEIsIHNpZ25PdXQgYXMgQywgcmV2b2tlQWNjZXNzVG9rZW4gYXMgRCwgZGVsZXRlVXNlciBhcyBFLCBGYWN0b3JJZCBhcyBGLCBkZWJ1Z0Vycm9yTWFwIGFzIEcsIHByb2RFcnJvck1hcCBhcyBILCBBVVRIX0VSUk9SX0NPREVTX01BUF9ET19OT1RfVVNFX0lOVEVSTkFMTFkgYXMgSSwgaW5pdGlhbGl6ZUF1dGggYXMgSiwgY29ubmVjdEF1dGhFbXVsYXRvciBhcyBLLCBBdXRoQ3JlZGVudGlhbCBhcyBMLCBFbWFpbEF1dGhDcmVkZW50aWFsIGFzIE0sIE9BdXRoQ3JlZGVudGlhbCBhcyBOLCBPcGVyYXRpb25UeXBlIGFzIE8sIFBob25lQXV0aFByb3ZpZGVyIGFzIFAsIFBob25lQXV0aENyZWRlbnRpYWwgYXMgUSwgUmVjYXB0Y2hhVmVyaWZpZXIgYXMgUiwgU2lnbkluTWV0aG9kIGFzIFMsIFRvdHBNdWx0aUZhY3RvckdlbmVyYXRvciBhcyBULCBpbk1lbW9yeVBlcnNpc3RlbmNlIGFzIFUsIEVtYWlsQXV0aFByb3ZpZGVyIGFzIFYsIEZhY2Vib29rQXV0aFByb3ZpZGVyIGFzIFcsIEdvb2dsZUF1dGhQcm92aWRlciBhcyBYLCBHaXRodWJBdXRoUHJvdmlkZXIgYXMgWSwgT0F1dGhQcm92aWRlciBhcyBaLCBTQU1MQXV0aFByb3ZpZGVyIGFzIF8sIGJyb3dzZXJTZXNzaW9uUGVyc2lzdGVuY2UgYXMgYSwgc2lnbkluQW5vbnltb3VzbHkgYXMgYTAsIHNpZ25JbldpdGhDcmVkZW50aWFsIGFzIGExLCBsaW5rV2l0aENyZWRlbnRpYWwgYXMgYTIsIHJlYXV0aGVudGljYXRlV2l0aENyZWRlbnRpYWwgYXMgYTMsIHNpZ25JbldpdGhDdXN0b21Ub2tlbiBhcyBhNCwgc2VuZFBhc3N3b3JkUmVzZXRFbWFpbCBhcyBhNSwgY29uZmlybVBhc3N3b3JkUmVzZXQgYXMgYTYsIGFwcGx5QWN0aW9uQ29kZSBhcyBhNywgY2hlY2tBY3Rpb25Db2RlIGFzIGE4LCB2ZXJpZnlQYXNzd29yZFJlc2V0Q29kZSBhcyBhOSwgX2ZhaWwgYXMgYUEsIGRlYnVnQXNzZXJ0IGFzIGFCLCBfcGVyc2lzdGVuY2VLZXlOYW1lIGFzIGFDLCBfc2VydmVyQXBwQ3VycmVudFVzZXJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvciBhcyBhRCwgX2Nhc3RBdXRoIGFzIGFFLCBGZWRlcmF0ZWRBdXRoUHJvdmlkZXIgYXMgYUYsIEJhc2VPQXV0aFByb3ZpZGVyIGFzIGFHLCBfZW11bGF0b3JVcmwgYXMgYUgsIF9wZXJmb3JtQXBpUmVxdWVzdCBhcyBhSSwgX2lzSU9TIGFzIGFKLCBfaXNBbmRyb2lkIGFzIGFLLCBfaXNJT1M3T3I4IGFzIGFMLCBfY3JlYXRlRXJyb3IgYXMgYU0sIF9pc01vYmlsZUJyb3dzZXIgYXMgYU4sIF9pc0lFMTAgYXMgYU8sIFVzZXJJbXBsIGFzIGFQLCBBdXRoSW1wbCBhcyBhUSwgX2dldENsaWVudFZlcnNpb24gYXMgYVIsIEZldGNoUHJvdmlkZXIgYXMgYVMsIFNBTUxBdXRoQ3JlZGVudGlhbCBhcyBhVCwgY3JlYXRlVXNlcldpdGhFbWFpbEFuZFBhc3N3b3JkIGFzIGFhLCBzaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZCBhcyBhYiwgc2VuZFNpZ25JbkxpbmtUb0VtYWlsIGFzIGFjLCBpc1NpZ25JbldpdGhFbWFpbExpbmsgYXMgYWQsIHNpZ25JbldpdGhFbWFpbExpbmsgYXMgYWUsIGZldGNoU2lnbkluTWV0aG9kc0ZvckVtYWlsIGFzIGFmLCBzZW5kRW1haWxWZXJpZmljYXRpb24gYXMgYWcsIHZlcmlmeUJlZm9yZVVwZGF0ZUVtYWlsIGFzIGFoLCBBY3Rpb25Db2RlVVJMIGFzIGFpLCBwYXJzZUFjdGlvbkNvZGVVUkwgYXMgYWosIHVwZGF0ZVByb2ZpbGUgYXMgYWssIHVwZGF0ZUVtYWlsIGFzIGFsLCB1cGRhdGVQYXNzd29yZCBhcyBhbSwgZ2V0SWRUb2tlbiBhcyBhbiwgZ2V0SWRUb2tlblJlc3VsdCBhcyBhbywgdW5saW5rIGFzIGFwLCBnZXRBZGRpdGlvbmFsVXNlckluZm8gYXMgYXEsIHJlbG9hZCBhcyBhciwgZ2V0TXVsdGlGYWN0b3JSZXNvbHZlciBhcyBhcywgbXVsdGlGYWN0b3IgYXMgYXQsIF9nZXRJbnN0YW5jZSBhcyBhdSwgX2Fzc2VydCBhcyBhdiwgX3NpZ25JbldpdGhDcmVkZW50aWFsIGFzIGF3LCBfcmVhdXRoZW50aWNhdGUgYXMgYXgsIF9saW5rIGFzIGF5LCBzaWduSW5XaXRoSWRwIGFzIGF6LCBicm93c2VyTG9jYWxQZXJzaXN0ZW5jZSBhcyBiLCBzaWduSW5XaXRoUG9wdXAgYXMgYywgbGlua1dpdGhQb3B1cCBhcyBkLCByZWF1dGhlbnRpY2F0ZVdpdGhQb3B1cCBhcyBlLCBzaWduSW5XaXRoUmVkaXJlY3QgYXMgZiwgbGlua1dpdGhSZWRpcmVjdCBhcyBnLCByZWF1dGhlbnRpY2F0ZVdpdGhSZWRpcmVjdCBhcyBoLCBpbmRleGVkREJMb2NhbFBlcnNpc3RlbmNlIGFzIGksIGdldFJlZGlyZWN0UmVzdWx0IGFzIGosIGJyb3dzZXJQb3B1cFJlZGlyZWN0UmVzb2x2ZXIgYXMgaywgbGlua1dpdGhQaG9uZU51bWJlciBhcyBsLCBQaG9uZU11bHRpRmFjdG9yR2VuZXJhdG9yIGFzIG0sIFRvdHBTZWNyZXQgYXMgbiwgZ2V0QXV0aCBhcyBvLCBQcm92aWRlcklkIGFzIHAsIHNldFBlcnNpc3RlbmNlIGFzIHEsIHJlYXV0aGVudGljYXRlV2l0aFBob25lTnVtYmVyIGFzIHIsIHNpZ25JbldpdGhQaG9uZU51bWJlciBhcyBzLCBpbml0aWFsaXplUmVjYXB0Y2hhQ29uZmlnIGFzIHQsIHVwZGF0ZVBob25lTnVtYmVyIGFzIHUsIHZhbGlkYXRlUGFzc3dvcmQgYXMgdiwgb25JZFRva2VuQ2hhbmdlZCBhcyB3LCBiZWZvcmVBdXRoU3RhdGVDaGFuZ2VkIGFzIHgsIG9uQXV0aFN0YXRlQ2hhbmdlZCBhcyB5LCB1c2VEZXZpY2VMYW5ndWFnZSBhcyB6IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b3RwLTNkZjJmNWY5LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/auth/dist/node-esm/totp-3df2f5f9.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js":
/*!********************************************************************!*\
  !*** ./node_modules/@firebase/component/dist/esm/index.esm2017.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Component: () => (/* binding */ Component),\n/* harmony export */   ComponentContainer: () => (/* binding */ ComponentContainer),\n/* harmony export */   Provider: () => (/* binding */ Provider)\n/* harmony export */ });\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n\n\n/**\n * Component for service name T, e.g. `auth`, `auth-internal`\n */\nclass Component {\n    /**\n     *\n     * @param name The public service name, e.g. app, auth, firestore, database\n     * @param instanceFactory Service factory responsible for creating the public interface\n     * @param type whether the service provided by the component is public or private\n     */\n    constructor(name, instanceFactory, type) {\n        this.name = name;\n        this.instanceFactory = instanceFactory;\n        this.type = type;\n        this.multipleInstances = false;\n        /**\n         * Properties to be added to the service namespace\n         */\n        this.serviceProps = {};\n        this.instantiationMode = \"LAZY\" /* InstantiationMode.LAZY */;\n        this.onInstanceCreated = null;\n    }\n    setInstantiationMode(mode) {\n        this.instantiationMode = mode;\n        return this;\n    }\n    setMultipleInstances(multipleInstances) {\n        this.multipleInstances = multipleInstances;\n        return this;\n    }\n    setServiceProps(props) {\n        this.serviceProps = props;\n        return this;\n    }\n    setInstanceCreatedCallback(callback) {\n        this.onInstanceCreated = callback;\n        return this;\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\n * NameServiceMapping[T] is an alias for the type of the instance\n */\nclass Provider {\n    constructor(name, container) {\n        this.name = name;\n        this.container = container;\n        this.component = null;\n        this.instances = new Map();\n        this.instancesDeferred = new Map();\n        this.instancesOptions = new Map();\n        this.onInitCallbacks = new Map();\n    }\n    /**\n     * @param identifier A provider can provide multiple instances of a service\n     * if this.component.multipleInstances is true.\n     */\n    get(identifier) {\n        // if multipleInstances is not supported, use the default name\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n        if (!this.instancesDeferred.has(normalizedIdentifier)) {\n            const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n            this.instancesDeferred.set(normalizedIdentifier, deferred);\n            if (this.isInitialized(normalizedIdentifier) ||\n                this.shouldAutoInitialize()) {\n                // initialize the service if it can be auto-initialized\n                try {\n                    const instance = this.getOrInitializeService({\n                        instanceIdentifier: normalizedIdentifier\n                    });\n                    if (instance) {\n                        deferred.resolve(instance);\n                    }\n                }\n                catch (e) {\n                    // when the instance factory throws an exception during get(), it should not cause\n                    // a fatal error. We just return the unresolved promise in this case.\n                }\n            }\n        }\n        return this.instancesDeferred.get(normalizedIdentifier).promise;\n    }\n    getImmediate(options) {\n        var _a;\n        // if multipleInstances is not supported, use the default name\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\n        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\n        if (this.isInitialized(normalizedIdentifier) ||\n            this.shouldAutoInitialize()) {\n            try {\n                return this.getOrInitializeService({\n                    instanceIdentifier: normalizedIdentifier\n                });\n            }\n            catch (e) {\n                if (optional) {\n                    return null;\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        else {\n            // In case a component is not initialized and should/cannot be auto-initialized at the moment, return null if the optional flag is set, or throw\n            if (optional) {\n                return null;\n            }\n            else {\n                throw Error(`Service ${this.name} is not available`);\n            }\n        }\n    }\n    getComponent() {\n        return this.component;\n    }\n    setComponent(component) {\n        if (component.name !== this.name) {\n            throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);\n        }\n        if (this.component) {\n            throw Error(`Component for ${this.name} has already been provided`);\n        }\n        this.component = component;\n        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\n        if (!this.shouldAutoInitialize()) {\n            return;\n        }\n        // if the service is eager, initialize the default instance\n        if (isComponentEager(component)) {\n            try {\n                this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });\n            }\n            catch (e) {\n                // when the instance factory for an eager Component throws an exception during the eager\n                // initialization, it should not cause a fatal error.\n                // TODO: Investigate if we need to make it configurable, because some component may want to cause\n                // a fatal error in this case?\n            }\n        }\n        // Create service instances for the pending promises and resolve them\n        // NOTE: if this.multipleInstances is false, only the default instance will be created\n        // and all promises with resolve with it regardless of the identifier.\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\n            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n            try {\n                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\n                const instance = this.getOrInitializeService({\n                    instanceIdentifier: normalizedIdentifier\n                });\n                instanceDeferred.resolve(instance);\n            }\n            catch (e) {\n                // when the instance factory throws an exception, it should not cause\n                // a fatal error. We just leave the promise unresolved.\n            }\n        }\n    }\n    clearInstance(identifier = DEFAULT_ENTRY_NAME) {\n        this.instancesDeferred.delete(identifier);\n        this.instancesOptions.delete(identifier);\n        this.instances.delete(identifier);\n    }\n    // app.delete() will call this method on every provider to delete the services\n    // TODO: should we mark the provider as deleted?\n    async delete() {\n        const services = Array.from(this.instances.values());\n        await Promise.all([\n            ...services\n                .filter(service => 'INTERNAL' in service) // legacy services\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                .map(service => service.INTERNAL.delete()),\n            ...services\n                .filter(service => '_delete' in service) // modularized services\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                .map(service => service._delete())\n        ]);\n    }\n    isComponentSet() {\n        return this.component != null;\n    }\n    isInitialized(identifier = DEFAULT_ENTRY_NAME) {\n        return this.instances.has(identifier);\n    }\n    getOptions(identifier = DEFAULT_ENTRY_NAME) {\n        return this.instancesOptions.get(identifier) || {};\n    }\n    initialize(opts = {}) {\n        const { options = {} } = opts;\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\n        if (this.isInitialized(normalizedIdentifier)) {\n            throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);\n        }\n        if (!this.isComponentSet()) {\n            throw Error(`Component ${this.name} has not been registered yet`);\n        }\n        const instance = this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier,\n            options\n        });\n        // resolve any pending promise waiting for the service instance\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\n            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n            if (normalizedIdentifier === normalizedDeferredIdentifier) {\n                instanceDeferred.resolve(instance);\n            }\n        }\n        return instance;\n    }\n    /**\n     *\n     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\n     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\n     *\n     * @param identifier An optional instance identifier\n     * @returns a function to unregister the callback\n     */\n    onInit(callback, identifier) {\n        var _a;\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\n        existingCallbacks.add(callback);\n        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\n        const existingInstance = this.instances.get(normalizedIdentifier);\n        if (existingInstance) {\n            callback(existingInstance, normalizedIdentifier);\n        }\n        return () => {\n            existingCallbacks.delete(callback);\n        };\n    }\n    /**\n     * Invoke onInit callbacks synchronously\n     * @param instance the service instance`\n     */\n    invokeOnInitCallbacks(instance, identifier) {\n        const callbacks = this.onInitCallbacks.get(identifier);\n        if (!callbacks) {\n            return;\n        }\n        for (const callback of callbacks) {\n            try {\n                callback(instance, identifier);\n            }\n            catch (_a) {\n                // ignore errors in the onInit callback\n            }\n        }\n    }\n    getOrInitializeService({ instanceIdentifier, options = {} }) {\n        let instance = this.instances.get(instanceIdentifier);\n        if (!instance && this.component) {\n            instance = this.component.instanceFactory(this.container, {\n                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\n                options\n            });\n            this.instances.set(instanceIdentifier, instance);\n            this.instancesOptions.set(instanceIdentifier, options);\n            /**\n             * Invoke onInit listeners.\n             * Note this.component.onInstanceCreated is different, which is used by the component creator,\n             * while onInit listeners are registered by consumers of the provider.\n             */\n            this.invokeOnInitCallbacks(instance, instanceIdentifier);\n            /**\n             * Order is important\n             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\n             * makes `isInitialized()` return true.\n             */\n            if (this.component.onInstanceCreated) {\n                try {\n                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\n                }\n                catch (_a) {\n                    // ignore errors in the onInstanceCreatedCallback\n                }\n            }\n        }\n        return instance || null;\n    }\n    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {\n        if (this.component) {\n            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\n        }\n        else {\n            return identifier; // assume multiple instances are supported before the component is provided.\n        }\n    }\n    shouldAutoInitialize() {\n        return (!!this.component &&\n            this.component.instantiationMode !== \"EXPLICIT\" /* InstantiationMode.EXPLICIT */);\n    }\n}\n// undefined should be passed to the service factory for the default instance\nfunction normalizeIdentifierForFactory(identifier) {\n    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\n}\nfunction isComponentEager(component) {\n    return component.instantiationMode === \"EAGER\" /* InstantiationMode.EAGER */;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\n */\nclass ComponentContainer {\n    constructor(name) {\n        this.name = name;\n        this.providers = new Map();\n    }\n    /**\n     *\n     * @param component Component being added\n     * @param overwrite When a component with the same name has already been registered,\n     * if overwrite is true: overwrite the existing component with the new component and create a new\n     * provider with the new component. It can be useful in tests where you want to use different mocks\n     * for different tests.\n     * if overwrite is false: throw an exception\n     */\n    addComponent(component) {\n        const provider = this.getProvider(component.name);\n        if (provider.isComponentSet()) {\n            throw new Error(`Component ${component.name} has already been registered with ${this.name}`);\n        }\n        provider.setComponent(component);\n    }\n    addOrOverwriteComponent(component) {\n        const provider = this.getProvider(component.name);\n        if (provider.isComponentSet()) {\n            // delete the existing provider from the container, so we can register the new component\n            this.providers.delete(component.name);\n        }\n        this.addComponent(component);\n    }\n    /**\n     * getProvider provides a type safe interface where it can only be called with a field name\n     * present in NameServiceMapping interface.\n     *\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\n     * themselves.\n     */\n    getProvider(name) {\n        if (this.providers.has(name)) {\n            return this.providers.get(name);\n        }\n        // create a Provider for a service that hasn't registered with Firebase\n        const provider = new Provider(name, this);\n        this.providers.set(name, provider);\n        return provider;\n    }\n    getProviders() {\n        return Array.from(this.providers.values());\n    }\n}\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2NvbXBvbmVudC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0RBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQixlQUFlLFVBQVU7QUFDMUY7QUFDQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3Q0FBd0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0EsMkJBQTJCLFVBQVUsR0FBRyxxQkFBcUI7QUFDN0Q7QUFDQTtBQUNBLHFDQUFxQyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtDQUFrQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnQkFBZ0IsbUNBQW1DLFVBQVU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1EO0FBQ25EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvY29tcG9uZW50L2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanM/OGFlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEZWZlcnJlZCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuLyoqXG4gKiBDb21wb25lbnQgZm9yIHNlcnZpY2UgbmFtZSBULCBlLmcuIGBhdXRoYCwgYGF1dGgtaW50ZXJuYWxgXG4gKi9cbmNsYXNzIENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgcHVibGljIHNlcnZpY2UgbmFtZSwgZS5nLiBhcHAsIGF1dGgsIGZpcmVzdG9yZSwgZGF0YWJhc2VcbiAgICAgKiBAcGFyYW0gaW5zdGFuY2VGYWN0b3J5IFNlcnZpY2UgZmFjdG9yeSByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhlIHB1YmxpYyBpbnRlcmZhY2VcbiAgICAgKiBAcGFyYW0gdHlwZSB3aGV0aGVyIHRoZSBzZXJ2aWNlIHByb3ZpZGVkIGJ5IHRoZSBjb21wb25lbnQgaXMgcHVibGljIG9yIHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBpbnN0YW5jZUZhY3RvcnksIHR5cGUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZUZhY3RvcnkgPSBpbnN0YW5jZUZhY3Rvcnk7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMubXVsdGlwbGVJbnN0YW5jZXMgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgdG8gYmUgYWRkZWQgdG8gdGhlIHNlcnZpY2UgbmFtZXNwYWNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlcnZpY2VQcm9wcyA9IHt9O1xuICAgICAgICB0aGlzLmluc3RhbnRpYXRpb25Nb2RlID0gXCJMQVpZXCIgLyogSW5zdGFudGlhdGlvbk1vZGUuTEFaWSAqLztcbiAgICAgICAgdGhpcy5vbkluc3RhbmNlQ3JlYXRlZCA9IG51bGw7XG4gICAgfVxuICAgIHNldEluc3RhbnRpYXRpb25Nb2RlKG1vZGUpIHtcbiAgICAgICAgdGhpcy5pbnN0YW50aWF0aW9uTW9kZSA9IG1vZGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRNdWx0aXBsZUluc3RhbmNlcyhtdWx0aXBsZUluc3RhbmNlcykge1xuICAgICAgICB0aGlzLm11bHRpcGxlSW5zdGFuY2VzID0gbXVsdGlwbGVJbnN0YW5jZXM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRTZXJ2aWNlUHJvcHMocHJvcHMpIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlUHJvcHMgPSBwcm9wcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldEluc3RhbmNlQ3JlYXRlZENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMub25JbnN0YW5jZUNyZWF0ZWQgPSBjYWxsYmFjaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgREVGQVVMVF9FTlRSWV9OQU1FID0gJ1tERUZBVUxUXSc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFByb3ZpZGVyIGZvciBpbnN0YW5jZSBmb3Igc2VydmljZSBuYW1lIFQsIGUuZy4gJ2F1dGgnLCAnYXV0aC1pbnRlcm5hbCdcbiAqIE5hbWVTZXJ2aWNlTWFwcGluZ1tUXSBpcyBhbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgdGhlIGluc3RhbmNlXG4gKi9cbmNsYXNzIFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnN0YW5jZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VzT3B0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5vbkluaXRDYWxsYmFja3MgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBpZGVudGlmaWVyIEEgcHJvdmlkZXIgY2FuIHByb3ZpZGUgbXVsdGlwbGUgaW5zdGFuY2VzIG9mIGEgc2VydmljZVxuICAgICAqIGlmIHRoaXMuY29tcG9uZW50Lm11bHRpcGxlSW5zdGFuY2VzIGlzIHRydWUuXG4gICAgICovXG4gICAgZ2V0KGlkZW50aWZpZXIpIHtcbiAgICAgICAgLy8gaWYgbXVsdGlwbGVJbnN0YW5jZXMgaXMgbm90IHN1cHBvcnRlZCwgdXNlIHRoZSBkZWZhdWx0IG5hbWVcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKCF0aGlzLmluc3RhbmNlc0RlZmVycmVkLmhhcyhub3JtYWxpemVkSWRlbnRpZmllcikpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlc0RlZmVycmVkLnNldChub3JtYWxpemVkSWRlbnRpZmllciwgZGVmZXJyZWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZChub3JtYWxpemVkSWRlbnRpZmllcikgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBzZXJ2aWNlIGlmIGl0IGNhbiBiZSBhdXRvLWluaXRpYWxpemVkXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmdldE9ySW5pdGlhbGl6ZVNlcnZpY2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVkSWRlbnRpZmllclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBpbnN0YW5jZSBmYWN0b3J5IHRocm93cyBhbiBleGNlcHRpb24gZHVyaW5nIGdldCgpLCBpdCBzaG91bGQgbm90IGNhdXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgZmF0YWwgZXJyb3IuIFdlIGp1c3QgcmV0dXJuIHRoZSB1bnJlc29sdmVkIHByb21pc2UgaW4gdGhpcyBjYXNlLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5nZXQobm9ybWFsaXplZElkZW50aWZpZXIpLnByb21pc2U7XG4gICAgfVxuICAgIGdldEltbWVkaWF0ZShvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gaWYgbXVsdGlwbGVJbnN0YW5jZXMgaXMgbm90IHN1cHBvcnRlZCwgdXNlIHRoZSBkZWZhdWx0IG5hbWVcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaWRlbnRpZmllcik7XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9wdGlvbmFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZChub3JtYWxpemVkSWRlbnRpZmllcikgfHxcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkQXV0b0luaXRpYWxpemUoKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVkSWRlbnRpZmllclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEluIGNhc2UgYSBjb21wb25lbnQgaXMgbm90IGluaXRpYWxpemVkIGFuZCBzaG91bGQvY2Fubm90IGJlIGF1dG8taW5pdGlhbGl6ZWQgYXQgdGhlIG1vbWVudCwgcmV0dXJuIG51bGwgaWYgdGhlIG9wdGlvbmFsIGZsYWcgaXMgc2V0LCBvciB0aHJvd1xuICAgICAgICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgU2VydmljZSAke3RoaXMubmFtZX0gaXMgbm90IGF2YWlsYWJsZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldENvbXBvbmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50O1xuICAgIH1cbiAgICBzZXRDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgICAgIGlmIChjb21wb25lbnQubmFtZSAhPT0gdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgTWlzbWF0Y2hpbmcgQ29tcG9uZW50ICR7Y29tcG9uZW50Lm5hbWV9IGZvciBQcm92aWRlciAke3RoaXMubmFtZX0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgQ29tcG9uZW50IGZvciAke3RoaXMubmFtZX0gaGFzIGFscmVhZHkgYmVlbiBwcm92aWRlZGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICAvLyByZXR1cm4gZWFybHkgd2l0aG91dCBhdHRlbXB0aW5nIHRvIGluaXRpYWxpemUgdGhlIGNvbXBvbmVudCBpZiB0aGUgY29tcG9uZW50IHJlcXVpcmVzIGV4cGxpY2l0IGluaXRpYWxpemF0aW9uIChjYWxsaW5nIGBQcm92aWRlci5pbml0aWFsaXplKClgKVxuICAgICAgICBpZiAoIXRoaXMuc2hvdWxkQXV0b0luaXRpYWxpemUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBzZXJ2aWNlIGlzIGVhZ2VyLCBpbml0aWFsaXplIHRoZSBkZWZhdWx0IGluc3RhbmNlXG4gICAgICAgIGlmIChpc0NvbXBvbmVudEVhZ2VyKGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHsgaW5zdGFuY2VJZGVudGlmaWVyOiBERUZBVUxUX0VOVFJZX05BTUUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGluc3RhbmNlIGZhY3RvcnkgZm9yIGFuIGVhZ2VyIENvbXBvbmVudCB0aHJvd3MgYW4gZXhjZXB0aW9uIGR1cmluZyB0aGUgZWFnZXJcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXphdGlvbiwgaXQgc2hvdWxkIG5vdCBjYXVzZSBhIGZhdGFsIGVycm9yLlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IEludmVzdGlnYXRlIGlmIHdlIG5lZWQgdG8gbWFrZSBpdCBjb25maWd1cmFibGUsIGJlY2F1c2Ugc29tZSBjb21wb25lbnQgbWF5IHdhbnQgdG8gY2F1c2VcbiAgICAgICAgICAgICAgICAvLyBhIGZhdGFsIGVycm9yIGluIHRoaXMgY2FzZT9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgc2VydmljZSBpbnN0YW5jZXMgZm9yIHRoZSBwZW5kaW5nIHByb21pc2VzIGFuZCByZXNvbHZlIHRoZW1cbiAgICAgICAgLy8gTk9URTogaWYgdGhpcy5tdWx0aXBsZUluc3RhbmNlcyBpcyBmYWxzZSwgb25seSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWRcbiAgICAgICAgLy8gYW5kIGFsbCBwcm9taXNlcyB3aXRoIHJlc29sdmUgd2l0aCBpdCByZWdhcmRsZXNzIG9mIHRoZSBpZGVudGlmaWVyLlxuICAgICAgICBmb3IgKGNvbnN0IFtpbnN0YW5jZUlkZW50aWZpZXIsIGluc3RhbmNlRGVmZXJyZWRdIG9mIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZW50cmllcygpKSB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGluc3RhbmNlSWRlbnRpZmllcik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIGBnZXRPckluaXRpYWxpemVTZXJ2aWNlKClgIHNob3VsZCBhbHdheXMgcmV0dXJuIGEgdmFsaWQgaW5zdGFuY2Ugc2luY2UgYSBjb21wb25lbnQgaXMgZ3VhcmFudGVlZC4gdXNlICEgdG8gbWFrZSB0eXBlc2NyaXB0IGhhcHB5LlxuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVkSWRlbnRpZmllclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlRGVmZXJyZWQucmVzb2x2ZShpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGluc3RhbmNlIGZhY3RvcnkgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgaXQgc2hvdWxkIG5vdCBjYXVzZVxuICAgICAgICAgICAgICAgIC8vIGEgZmF0YWwgZXJyb3IuIFdlIGp1c3QgbGVhdmUgdGhlIHByb21pc2UgdW5yZXNvbHZlZC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhckluc3RhbmNlKGlkZW50aWZpZXIgPSBERUZBVUxUX0VOVFJZX05BTUUpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5kZWxldGUoaWRlbnRpZmllcik7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VzT3B0aW9ucy5kZWxldGUoaWRlbnRpZmllcik7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VzLmRlbGV0ZShpZGVudGlmaWVyKTtcbiAgICB9XG4gICAgLy8gYXBwLmRlbGV0ZSgpIHdpbGwgY2FsbCB0aGlzIG1ldGhvZCBvbiBldmVyeSBwcm92aWRlciB0byBkZWxldGUgdGhlIHNlcnZpY2VzXG4gICAgLy8gVE9ETzogc2hvdWxkIHdlIG1hcmsgdGhlIHByb3ZpZGVyIGFzIGRlbGV0ZWQ/XG4gICAgYXN5bmMgZGVsZXRlKCkge1xuICAgICAgICBjb25zdCBzZXJ2aWNlcyA9IEFycmF5LmZyb20odGhpcy5pbnN0YW5jZXMudmFsdWVzKCkpO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAuLi5zZXJ2aWNlc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoc2VydmljZSA9PiAnSU5URVJOQUwnIGluIHNlcnZpY2UpIC8vIGxlZ2FjeSBzZXJ2aWNlc1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgLm1hcChzZXJ2aWNlID0+IHNlcnZpY2UuSU5URVJOQUwuZGVsZXRlKCkpLFxuICAgICAgICAgICAgLi4uc2VydmljZXNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKHNlcnZpY2UgPT4gJ19kZWxldGUnIGluIHNlcnZpY2UpIC8vIG1vZHVsYXJpemVkIHNlcnZpY2VzXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAubWFwKHNlcnZpY2UgPT4gc2VydmljZS5fZGVsZXRlKCkpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBpc0NvbXBvbmVudFNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50ICE9IG51bGw7XG4gICAgfVxuICAgIGlzSW5pdGlhbGl6ZWQoaWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZXMuaGFzKGlkZW50aWZpZXIpO1xuICAgIH1cbiAgICBnZXRPcHRpb25zKGlkZW50aWZpZXIgPSBERUZBVUxUX0VOVFJZX05BTUUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VzT3B0aW9ucy5nZXQoaWRlbnRpZmllcikgfHwge307XG4gICAgfVxuICAgIGluaXRpYWxpemUob3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyA9IHt9IH0gPSBvcHRzO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKG9wdHMuaW5zdGFuY2VJZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZChub3JtYWxpemVkSWRlbnRpZmllcikpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGAke3RoaXMubmFtZX0oJHtub3JtYWxpemVkSWRlbnRpZmllcn0pIGhhcyBhbHJlYWR5IGJlZW4gaW5pdGlhbGl6ZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNDb21wb25lbnRTZXQoKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYENvbXBvbmVudCAke3RoaXMubmFtZX0gaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQgeWV0YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmdldE9ySW5pdGlhbGl6ZVNlcnZpY2Uoe1xuICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVkSWRlbnRpZmllcixcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHJlc29sdmUgYW55IHBlbmRpbmcgcHJvbWlzZSB3YWl0aW5nIGZvciB0aGUgc2VydmljZSBpbnN0YW5jZVxuICAgICAgICBmb3IgKGNvbnN0IFtpbnN0YW5jZUlkZW50aWZpZXIsIGluc3RhbmNlRGVmZXJyZWRdIG9mIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZW50cmllcygpKSB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkRGVmZXJyZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaW5zdGFuY2VJZGVudGlmaWVyKTtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkSWRlbnRpZmllciA9PT0gbm9ybWFsaXplZERlZmVycmVkSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlRGVmZXJyZWQucmVzb2x2ZShpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWQgIGFmdGVyIHRoZSBwcm92aWRlciBoYXMgYmVlbiBpbml0aWFsaXplZCBieSBjYWxsaW5nIHByb3ZpZGVyLmluaXRpYWxpemUoKS5cbiAgICAgKiBUaGUgZnVuY3Rpb24gaXMgaW52b2tlZCBTWU5DSFJPTk9VU0xZLCBzbyBpdCBzaG91bGQgbm90IGV4ZWN1dGUgYW55IGxvbmdydW5uaW5nIHRhc2tzIGluIG9yZGVyIHRvIG5vdCBibG9jayB0aGUgcHJvZ3JhbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZGVudGlmaWVyIEFuIG9wdGlvbmFsIGluc3RhbmNlIGlkZW50aWZpZXJcbiAgICAgKiBAcmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVucmVnaXN0ZXIgdGhlIGNhbGxiYWNrXG4gICAgICovXG4gICAgb25Jbml0KGNhbGxiYWNrLCBpZGVudGlmaWVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdDYWxsYmFja3MgPSAoX2EgPSB0aGlzLm9uSW5pdENhbGxiYWNrcy5nZXQobm9ybWFsaXplZElkZW50aWZpZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgU2V0KCk7XG4gICAgICAgIGV4aXN0aW5nQ2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgICAgIHRoaXMub25Jbml0Q2FsbGJhY2tzLnNldChub3JtYWxpemVkSWRlbnRpZmllciwgZXhpc3RpbmdDYWxsYmFja3MpO1xuICAgICAgICBjb25zdCBleGlzdGluZ0luc3RhbmNlID0gdGhpcy5pbnN0YW5jZXMuZ2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGV4aXN0aW5nSW5zdGFuY2UsIG5vcm1hbGl6ZWRJZGVudGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgZXhpc3RpbmdDYWxsYmFja3MuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlIG9uSW5pdCBjYWxsYmFja3Mgc3luY2hyb25vdXNseVxuICAgICAqIEBwYXJhbSBpbnN0YW5jZSB0aGUgc2VydmljZSBpbnN0YW5jZWBcbiAgICAgKi9cbiAgICBpbnZva2VPbkluaXRDYWxsYmFja3MoaW5zdGFuY2UsIGlkZW50aWZpZXIpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5vbkluaXRDYWxsYmFja3MuZ2V0KGlkZW50aWZpZXIpO1xuICAgICAgICBpZiAoIWNhbGxiYWNrcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGluc3RhbmNlLCBpZGVudGlmaWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBlcnJvcnMgaW4gdGhlIG9uSW5pdCBjYWxsYmFja1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldE9ySW5pdGlhbGl6ZVNlcnZpY2UoeyBpbnN0YW5jZUlkZW50aWZpZXIsIG9wdGlvbnMgPSB7fSB9KSB7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2VzLmdldChpbnN0YW5jZUlkZW50aWZpZXIpO1xuICAgICAgICBpZiAoIWluc3RhbmNlICYmIHRoaXMuY29tcG9uZW50KSB7XG4gICAgICAgICAgICBpbnN0YW5jZSA9IHRoaXMuY29tcG9uZW50Lmluc3RhbmNlRmFjdG9yeSh0aGlzLmNvbnRhaW5lciwge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplSWRlbnRpZmllckZvckZhY3RvcnkoaW5zdGFuY2VJZGVudGlmaWVyKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VzLnNldChpbnN0YW5jZUlkZW50aWZpZXIsIGluc3RhbmNlKTtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VzT3B0aW9ucy5zZXQoaW5zdGFuY2VJZGVudGlmaWVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW52b2tlIG9uSW5pdCBsaXN0ZW5lcnMuXG4gICAgICAgICAgICAgKiBOb3RlIHRoaXMuY29tcG9uZW50Lm9uSW5zdGFuY2VDcmVhdGVkIGlzIGRpZmZlcmVudCwgd2hpY2ggaXMgdXNlZCBieSB0aGUgY29tcG9uZW50IGNyZWF0b3IsXG4gICAgICAgICAgICAgKiB3aGlsZSBvbkluaXQgbGlzdGVuZXJzIGFyZSByZWdpc3RlcmVkIGJ5IGNvbnN1bWVycyBvZiB0aGUgcHJvdmlkZXIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaW52b2tlT25Jbml0Q2FsbGJhY2tzKGluc3RhbmNlLCBpbnN0YW5jZUlkZW50aWZpZXIpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPcmRlciBpcyBpbXBvcnRhbnRcbiAgICAgICAgICAgICAqIG9uSW5zdGFuY2VDcmVhdGVkKCkgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciB0aGlzLmluc3RhbmNlcy5zZXQoaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZSk7IHdoaWNoXG4gICAgICAgICAgICAgKiBtYWtlcyBgaXNJbml0aWFsaXplZCgpYCByZXR1cm4gdHJ1ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50Lm9uSW5zdGFuY2VDcmVhdGVkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnQub25JbnN0YW5jZUNyZWF0ZWQodGhpcy5jb250YWluZXIsIGluc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIGVycm9ycyBpbiB0aGUgb25JbnN0YW5jZUNyZWF0ZWRDYWxsYmFja1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdGFuY2UgfHwgbnVsbDtcbiAgICB9XG4gICAgbm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGlkZW50aWZpZXIgPSBERUZBVUxUX0VOVFJZX05BTUUpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQubXVsdGlwbGVJbnN0YW5jZXMgPyBpZGVudGlmaWVyIDogREVGQVVMVF9FTlRSWV9OQU1FO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlkZW50aWZpZXI7IC8vIGFzc3VtZSBtdWx0aXBsZSBpbnN0YW5jZXMgYXJlIHN1cHBvcnRlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBwcm92aWRlZC5cbiAgICAgICAgfVxuICAgIH1cbiAgICBzaG91bGRBdXRvSW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuICghIXRoaXMuY29tcG9uZW50ICYmXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5pbnN0YW50aWF0aW9uTW9kZSAhPT0gXCJFWFBMSUNJVFwiIC8qIEluc3RhbnRpYXRpb25Nb2RlLkVYUExJQ0lUICovKTtcbiAgICB9XG59XG4vLyB1bmRlZmluZWQgc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgc2VydmljZSBmYWN0b3J5IGZvciB0aGUgZGVmYXVsdCBpbnN0YW5jZVxuZnVuY3Rpb24gbm9ybWFsaXplSWRlbnRpZmllckZvckZhY3RvcnkoaWRlbnRpZmllcikge1xuICAgIHJldHVybiBpZGVudGlmaWVyID09PSBERUZBVUxUX0VOVFJZX05BTUUgPyB1bmRlZmluZWQgOiBpZGVudGlmaWVyO1xufVxuZnVuY3Rpb24gaXNDb21wb25lbnRFYWdlcihjb21wb25lbnQpIHtcbiAgICByZXR1cm4gY29tcG9uZW50Lmluc3RhbnRpYXRpb25Nb2RlID09PSBcIkVBR0VSXCIgLyogSW5zdGFudGlhdGlvbk1vZGUuRUFHRVIgKi87XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENvbXBvbmVudENvbnRhaW5lciB0aGF0IHByb3ZpZGVzIFByb3ZpZGVycyBmb3Igc2VydmljZSBuYW1lIFQsIGUuZy4gYGF1dGhgLCBgYXV0aC1pbnRlcm5hbGBcbiAqL1xuY2xhc3MgQ29tcG9uZW50Q29udGFpbmVyIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb21wb25lbnQgQ29tcG9uZW50IGJlaW5nIGFkZGVkXG4gICAgICogQHBhcmFtIG92ZXJ3cml0ZSBXaGVuIGEgY29tcG9uZW50IHdpdGggdGhlIHNhbWUgbmFtZSBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQsXG4gICAgICogaWYgb3ZlcndyaXRlIGlzIHRydWU6IG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgY29tcG9uZW50IHdpdGggdGhlIG5ldyBjb21wb25lbnQgYW5kIGNyZWF0ZSBhIG5ld1xuICAgICAqIHByb3ZpZGVyIHdpdGggdGhlIG5ldyBjb21wb25lbnQuIEl0IGNhbiBiZSB1c2VmdWwgaW4gdGVzdHMgd2hlcmUgeW91IHdhbnQgdG8gdXNlIGRpZmZlcmVudCBtb2Nrc1xuICAgICAqIGZvciBkaWZmZXJlbnQgdGVzdHMuXG4gICAgICogaWYgb3ZlcndyaXRlIGlzIGZhbHNlOiB0aHJvdyBhbiBleGNlcHRpb25cbiAgICAgKi9cbiAgICBhZGRDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihjb21wb25lbnQubmFtZSk7XG4gICAgICAgIGlmIChwcm92aWRlci5pc0NvbXBvbmVudFNldCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbXBvbmVudCAke2NvbXBvbmVudC5uYW1lfSBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgd2l0aCAke3RoaXMubmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBwcm92aWRlci5zZXRDb21wb25lbnQoY29tcG9uZW50KTtcbiAgICB9XG4gICAgYWRkT3JPdmVyd3JpdGVDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihjb21wb25lbnQubmFtZSk7XG4gICAgICAgIGlmIChwcm92aWRlci5pc0NvbXBvbmVudFNldCgpKSB7XG4gICAgICAgICAgICAvLyBkZWxldGUgdGhlIGV4aXN0aW5nIHByb3ZpZGVyIGZyb20gdGhlIGNvbnRhaW5lciwgc28gd2UgY2FuIHJlZ2lzdGVyIHRoZSBuZXcgY29tcG9uZW50XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycy5kZWxldGUoY29tcG9uZW50Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldFByb3ZpZGVyIHByb3ZpZGVzIGEgdHlwZSBzYWZlIGludGVyZmFjZSB3aGVyZSBpdCBjYW4gb25seSBiZSBjYWxsZWQgd2l0aCBhIGZpZWxkIG5hbWVcbiAgICAgKiBwcmVzZW50IGluIE5hbWVTZXJ2aWNlTWFwcGluZyBpbnRlcmZhY2UuXG4gICAgICpcbiAgICAgKiBGaXJlYmFzZSBTREtzIHByb3ZpZGluZyBzZXJ2aWNlcyBzaG91bGQgZXh0ZW5kIE5hbWVTZXJ2aWNlTWFwcGluZyBpbnRlcmZhY2UgdG8gcmVnaXN0ZXJcbiAgICAgKiB0aGVtc2VsdmVzLlxuICAgICAqL1xuICAgIGdldFByb3ZpZGVyKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvdmlkZXJzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXJzLmdldChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGUgYSBQcm92aWRlciBmb3IgYSBzZXJ2aWNlIHRoYXQgaGFzbid0IHJlZ2lzdGVyZWQgd2l0aCBGaXJlYmFzZVxuICAgICAgICBjb25zdCBwcm92aWRlciA9IG5ldyBQcm92aWRlcihuYW1lLCB0aGlzKTtcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5hbWUsIHByb3ZpZGVyKTtcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyO1xuICAgIH1cbiAgICBnZXRQcm92aWRlcnMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucHJvdmlkZXJzLnZhbHVlcygpKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IENvbXBvbmVudCwgQ29tcG9uZW50Q29udGFpbmVyLCBQcm92aWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/installations/dist/esm/index.esm2017.js":
/*!************************************************************************!*\
  !*** ./node_modules/@firebase/installations/dist/esm/index.esm2017.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deleteInstallations: () => (/* binding */ deleteInstallations),\n/* harmony export */   getId: () => (/* binding */ getId),\n/* harmony export */   getInstallations: () => (/* binding */ getInstallations),\n/* harmony export */   getToken: () => (/* binding */ getToken),\n/* harmony export */   onIdChange: () => (/* binding */ onIdChange)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! idb */ \"(ssr)/./node_modules/idb/build/index.js\");\n\n\n\n\n\nconst name = \"@firebase/installations\";\nconst version = \"0.6.11\";\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst PENDING_TIMEOUT_MS = 10000;\nconst PACKAGE_VERSION = `w:${version}`;\nconst INTERNAL_AUTH_VERSION = 'FIS_v2';\nconst INSTALLATIONS_API_URL = 'https://firebaseinstallations.googleapis.com/v1';\nconst TOKEN_EXPIRATION_BUFFER = 60 * 60 * 1000; // One hour\nconst SERVICE = 'installations';\nconst SERVICE_NAME = 'Installations';\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst ERROR_DESCRIPTION_MAP = {\n    [\"missing-app-config-values\" /* ErrorCode.MISSING_APP_CONFIG_VALUES */]: 'Missing App configuration value: \"{$valueName}\"',\n    [\"not-registered\" /* ErrorCode.NOT_REGISTERED */]: 'Firebase Installation is not registered.',\n    [\"installation-not-found\" /* ErrorCode.INSTALLATION_NOT_FOUND */]: 'Firebase Installation not found.',\n    [\"request-failed\" /* ErrorCode.REQUEST_FAILED */]: '{$requestName} request failed with error \"{$serverCode} {$serverStatus}: {$serverMessage}\"',\n    [\"app-offline\" /* ErrorCode.APP_OFFLINE */]: 'Could not process request. Application offline.',\n    [\"delete-pending-registration\" /* ErrorCode.DELETE_PENDING_REGISTRATION */]: \"Can't delete installation while there is a pending registration request.\"\n};\nconst ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.ErrorFactory(SERVICE, SERVICE_NAME, ERROR_DESCRIPTION_MAP);\n/** Returns true if error is a FirebaseError that is based on an error from the server. */\nfunction isServerError(error) {\n    return (error instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError &&\n        error.code.includes(\"request-failed\" /* ErrorCode.REQUEST_FAILED */));\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction getInstallationsEndpoint({ projectId }) {\n    return `${INSTALLATIONS_API_URL}/projects/${projectId}/installations`;\n}\nfunction extractAuthTokenInfoFromResponse(response) {\n    return {\n        token: response.token,\n        requestStatus: 2 /* RequestStatus.COMPLETED */,\n        expiresIn: getExpiresInFromResponseExpiresIn(response.expiresIn),\n        creationTime: Date.now()\n    };\n}\nasync function getErrorFromResponse(requestName, response) {\n    const responseJson = await response.json();\n    const errorData = responseJson.error;\n    return ERROR_FACTORY.create(\"request-failed\" /* ErrorCode.REQUEST_FAILED */, {\n        requestName,\n        serverCode: errorData.code,\n        serverMessage: errorData.message,\n        serverStatus: errorData.status\n    });\n}\nfunction getHeaders({ apiKey }) {\n    return new Headers({\n        'Content-Type': 'application/json',\n        Accept: 'application/json',\n        'x-goog-api-key': apiKey\n    });\n}\nfunction getHeadersWithAuth(appConfig, { refreshToken }) {\n    const headers = getHeaders(appConfig);\n    headers.append('Authorization', getAuthorizationHeader(refreshToken));\n    return headers;\n}\n/**\n * Calls the passed in fetch wrapper and returns the response.\n * If the returned response has a status of 5xx, re-runs the function once and\n * returns the response.\n */\nasync function retryIfServerError(fn) {\n    const result = await fn();\n    if (result.status >= 500 && result.status < 600) {\n        // Internal Server Error. Retry request.\n        return fn();\n    }\n    return result;\n}\nfunction getExpiresInFromResponseExpiresIn(responseExpiresIn) {\n    // This works because the server will never respond with fractions of a second.\n    return Number(responseExpiresIn.replace('s', '000'));\n}\nfunction getAuthorizationHeader(refreshToken) {\n    return `${INTERNAL_AUTH_VERSION} ${refreshToken}`;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function createInstallationRequest({ appConfig, heartbeatServiceProvider }, { fid }) {\n    const endpoint = getInstallationsEndpoint(appConfig);\n    const headers = getHeaders(appConfig);\n    // If heartbeat service exists, add the heartbeat string to the header.\n    const heartbeatService = heartbeatServiceProvider.getImmediate({\n        optional: true\n    });\n    if (heartbeatService) {\n        const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();\n        if (heartbeatsHeader) {\n            headers.append('x-firebase-client', heartbeatsHeader);\n        }\n    }\n    const body = {\n        fid,\n        authVersion: INTERNAL_AUTH_VERSION,\n        appId: appConfig.appId,\n        sdkVersion: PACKAGE_VERSION\n    };\n    const request = {\n        method: 'POST',\n        headers,\n        body: JSON.stringify(body)\n    };\n    const response = await retryIfServerError(() => fetch(endpoint, request));\n    if (response.ok) {\n        const responseValue = await response.json();\n        const registeredInstallationEntry = {\n            fid: responseValue.fid || fid,\n            registrationStatus: 2 /* RequestStatus.COMPLETED */,\n            refreshToken: responseValue.refreshToken,\n            authToken: extractAuthTokenInfoFromResponse(responseValue.authToken)\n        };\n        return registeredInstallationEntry;\n    }\n    else {\n        throw await getErrorFromResponse('Create Installation', response);\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Returns a promise that resolves after given time passes. */\nfunction sleep(ms) {\n    return new Promise(resolve => {\n        setTimeout(resolve, ms);\n    });\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction bufferToBase64UrlSafe(array) {\n    const b64 = btoa(String.fromCharCode(...array));\n    return b64.replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst VALID_FID_PATTERN = /^[cdef][\\w-]{21}$/;\nconst INVALID_FID = '';\n/**\n * Generates a new FID using random values from Web Crypto API.\n * Returns an empty string if FID generation fails for any reason.\n */\nfunction generateFid() {\n    try {\n        // A valid FID has exactly 22 base64 characters, which is 132 bits, or 16.5\n        // bytes. our implementation generates a 17 byte array instead.\n        const fidByteArray = new Uint8Array(17);\n        const crypto = self.crypto || self.msCrypto;\n        crypto.getRandomValues(fidByteArray);\n        // Replace the first 4 random bits with the constant FID header of 0b0111.\n        fidByteArray[0] = 0b01110000 + (fidByteArray[0] % 0b00010000);\n        const fid = encode(fidByteArray);\n        return VALID_FID_PATTERN.test(fid) ? fid : INVALID_FID;\n    }\n    catch (_a) {\n        // FID generation errored\n        return INVALID_FID;\n    }\n}\n/** Converts a FID Uint8Array to a base64 string representation. */\nfunction encode(fidByteArray) {\n    const b64String = bufferToBase64UrlSafe(fidByteArray);\n    // Remove the 23rd character that was added because of the extra 4 bits at the\n    // end of our 17 byte array, and the '=' padding.\n    return b64String.substr(0, 22);\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Returns a string key that can be used to identify the app. */\nfunction getKey(appConfig) {\n    return `${appConfig.appName}!${appConfig.appId}`;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst fidChangeCallbacks = new Map();\n/**\n * Calls the onIdChange callbacks with the new FID value, and broadcasts the\n * change to other tabs.\n */\nfunction fidChanged(appConfig, fid) {\n    const key = getKey(appConfig);\n    callFidChangeCallbacks(key, fid);\n    broadcastFidChange(key, fid);\n}\nfunction addCallback(appConfig, callback) {\n    // Open the broadcast channel if it's not already open,\n    // to be able to listen to change events from other tabs.\n    getBroadcastChannel();\n    const key = getKey(appConfig);\n    let callbackSet = fidChangeCallbacks.get(key);\n    if (!callbackSet) {\n        callbackSet = new Set();\n        fidChangeCallbacks.set(key, callbackSet);\n    }\n    callbackSet.add(callback);\n}\nfunction removeCallback(appConfig, callback) {\n    const key = getKey(appConfig);\n    const callbackSet = fidChangeCallbacks.get(key);\n    if (!callbackSet) {\n        return;\n    }\n    callbackSet.delete(callback);\n    if (callbackSet.size === 0) {\n        fidChangeCallbacks.delete(key);\n    }\n    // Close broadcast channel if there are no more callbacks.\n    closeBroadcastChannel();\n}\nfunction callFidChangeCallbacks(key, fid) {\n    const callbacks = fidChangeCallbacks.get(key);\n    if (!callbacks) {\n        return;\n    }\n    for (const callback of callbacks) {\n        callback(fid);\n    }\n}\nfunction broadcastFidChange(key, fid) {\n    const channel = getBroadcastChannel();\n    if (channel) {\n        channel.postMessage({ key, fid });\n    }\n    closeBroadcastChannel();\n}\nlet broadcastChannel = null;\n/** Opens and returns a BroadcastChannel if it is supported by the browser. */\nfunction getBroadcastChannel() {\n    if (!broadcastChannel && 'BroadcastChannel' in self) {\n        broadcastChannel = new BroadcastChannel('[Firebase] FID Change');\n        broadcastChannel.onmessage = e => {\n            callFidChangeCallbacks(e.data.key, e.data.fid);\n        };\n    }\n    return broadcastChannel;\n}\nfunction closeBroadcastChannel() {\n    if (fidChangeCallbacks.size === 0 && broadcastChannel) {\n        broadcastChannel.close();\n        broadcastChannel = null;\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DATABASE_NAME = 'firebase-installations-database';\nconst DATABASE_VERSION = 1;\nconst OBJECT_STORE_NAME = 'firebase-installations-store';\nlet dbPromise = null;\nfunction getDbPromise() {\n    if (!dbPromise) {\n        dbPromise = (0,idb__WEBPACK_IMPORTED_MODULE_3__.openDB)(DATABASE_NAME, DATABASE_VERSION, {\n            upgrade: (db, oldVersion) => {\n                // We don't use 'break' in this switch statement, the fall-through\n                // behavior is what we want, because if there are multiple versions between\n                // the old version and the current version, we want ALL the migrations\n                // that correspond to those versions to run, not only the last one.\n                // eslint-disable-next-line default-case\n                switch (oldVersion) {\n                    case 0:\n                        db.createObjectStore(OBJECT_STORE_NAME);\n                }\n            }\n        });\n    }\n    return dbPromise;\n}\n/** Assigns or overwrites the record for the given key with the given value. */\nasync function set(appConfig, value) {\n    const key = getKey(appConfig);\n    const db = await getDbPromise();\n    const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n    const objectStore = tx.objectStore(OBJECT_STORE_NAME);\n    const oldValue = (await objectStore.get(key));\n    await objectStore.put(value, key);\n    await tx.done;\n    if (!oldValue || oldValue.fid !== value.fid) {\n        fidChanged(appConfig, value.fid);\n    }\n    return value;\n}\n/** Removes record(s) from the objectStore that match the given key. */\nasync function remove(appConfig) {\n    const key = getKey(appConfig);\n    const db = await getDbPromise();\n    const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n    await tx.objectStore(OBJECT_STORE_NAME).delete(key);\n    await tx.done;\n}\n/**\n * Atomically updates a record with the result of updateFn, which gets\n * called with the current value. If newValue is undefined, the record is\n * deleted instead.\n * @return Updated value\n */\nasync function update(appConfig, updateFn) {\n    const key = getKey(appConfig);\n    const db = await getDbPromise();\n    const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\n    const store = tx.objectStore(OBJECT_STORE_NAME);\n    const oldValue = (await store.get(key));\n    const newValue = updateFn(oldValue);\n    if (newValue === undefined) {\n        await store.delete(key);\n    }\n    else {\n        await store.put(newValue, key);\n    }\n    await tx.done;\n    if (newValue && (!oldValue || oldValue.fid !== newValue.fid)) {\n        fidChanged(appConfig, newValue.fid);\n    }\n    return newValue;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Updates and returns the InstallationEntry from the database.\n * Also triggers a registration request if it is necessary and possible.\n */\nasync function getInstallationEntry(installations) {\n    let registrationPromise;\n    const installationEntry = await update(installations.appConfig, oldEntry => {\n        const installationEntry = updateOrCreateInstallationEntry(oldEntry);\n        const entryWithPromise = triggerRegistrationIfNecessary(installations, installationEntry);\n        registrationPromise = entryWithPromise.registrationPromise;\n        return entryWithPromise.installationEntry;\n    });\n    if (installationEntry.fid === INVALID_FID) {\n        // FID generation failed. Waiting for the FID from the server.\n        return { installationEntry: await registrationPromise };\n    }\n    return {\n        installationEntry,\n        registrationPromise\n    };\n}\n/**\n * Creates a new Installation Entry if one does not exist.\n * Also clears timed out pending requests.\n */\nfunction updateOrCreateInstallationEntry(oldEntry) {\n    const entry = oldEntry || {\n        fid: generateFid(),\n        registrationStatus: 0 /* RequestStatus.NOT_STARTED */\n    };\n    return clearTimedOutRequest(entry);\n}\n/**\n * If the Firebase Installation is not registered yet, this will trigger the\n * registration and return an InProgressInstallationEntry.\n *\n * If registrationPromise does not exist, the installationEntry is guaranteed\n * to be registered.\n */\nfunction triggerRegistrationIfNecessary(installations, installationEntry) {\n    if (installationEntry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */) {\n        if (!navigator.onLine) {\n            // Registration required but app is offline.\n            const registrationPromiseWithError = Promise.reject(ERROR_FACTORY.create(\"app-offline\" /* ErrorCode.APP_OFFLINE */));\n            return {\n                installationEntry,\n                registrationPromise: registrationPromiseWithError\n            };\n        }\n        // Try registering. Change status to IN_PROGRESS.\n        const inProgressEntry = {\n            fid: installationEntry.fid,\n            registrationStatus: 1 /* RequestStatus.IN_PROGRESS */,\n            registrationTime: Date.now()\n        };\n        const registrationPromise = registerInstallation(installations, inProgressEntry);\n        return { installationEntry: inProgressEntry, registrationPromise };\n    }\n    else if (installationEntry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */) {\n        return {\n            installationEntry,\n            registrationPromise: waitUntilFidRegistration(installations)\n        };\n    }\n    else {\n        return { installationEntry };\n    }\n}\n/** This will be executed only once for each new Firebase Installation. */\nasync function registerInstallation(installations, installationEntry) {\n    try {\n        const registeredInstallationEntry = await createInstallationRequest(installations, installationEntry);\n        return set(installations.appConfig, registeredInstallationEntry);\n    }\n    catch (e) {\n        if (isServerError(e) && e.customData.serverCode === 409) {\n            // Server returned a \"FID cannot be used\" error.\n            // Generate a new ID next time.\n            await remove(installations.appConfig);\n        }\n        else {\n            // Registration failed. Set FID as not registered.\n            await set(installations.appConfig, {\n                fid: installationEntry.fid,\n                registrationStatus: 0 /* RequestStatus.NOT_STARTED */\n            });\n        }\n        throw e;\n    }\n}\n/** Call if FID registration is pending in another request. */\nasync function waitUntilFidRegistration(installations) {\n    // Unfortunately, there is no way of reliably observing when a value in\n    // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\n    // so we need to poll.\n    let entry = await updateInstallationRequest(installations.appConfig);\n    while (entry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */) {\n        // createInstallation request still in progress.\n        await sleep(100);\n        entry = await updateInstallationRequest(installations.appConfig);\n    }\n    if (entry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */) {\n        // The request timed out or failed in a different call. Try again.\n        const { installationEntry, registrationPromise } = await getInstallationEntry(installations);\n        if (registrationPromise) {\n            return registrationPromise;\n        }\n        else {\n            // if there is no registrationPromise, entry is registered.\n            return installationEntry;\n        }\n    }\n    return entry;\n}\n/**\n * Called only if there is a CreateInstallation request in progress.\n *\n * Updates the InstallationEntry in the DB based on the status of the\n * CreateInstallation request.\n *\n * Returns the updated InstallationEntry.\n */\nfunction updateInstallationRequest(appConfig) {\n    return update(appConfig, oldEntry => {\n        if (!oldEntry) {\n            throw ERROR_FACTORY.create(\"installation-not-found\" /* ErrorCode.INSTALLATION_NOT_FOUND */);\n        }\n        return clearTimedOutRequest(oldEntry);\n    });\n}\nfunction clearTimedOutRequest(entry) {\n    if (hasInstallationRequestTimedOut(entry)) {\n        return {\n            fid: entry.fid,\n            registrationStatus: 0 /* RequestStatus.NOT_STARTED */\n        };\n    }\n    return entry;\n}\nfunction hasInstallationRequestTimedOut(installationEntry) {\n    return (installationEntry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */ &&\n        installationEntry.registrationTime + PENDING_TIMEOUT_MS < Date.now());\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function generateAuthTokenRequest({ appConfig, heartbeatServiceProvider }, installationEntry) {\n    const endpoint = getGenerateAuthTokenEndpoint(appConfig, installationEntry);\n    const headers = getHeadersWithAuth(appConfig, installationEntry);\n    // If heartbeat service exists, add the heartbeat string to the header.\n    const heartbeatService = heartbeatServiceProvider.getImmediate({\n        optional: true\n    });\n    if (heartbeatService) {\n        const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();\n        if (heartbeatsHeader) {\n            headers.append('x-firebase-client', heartbeatsHeader);\n        }\n    }\n    const body = {\n        installation: {\n            sdkVersion: PACKAGE_VERSION,\n            appId: appConfig.appId\n        }\n    };\n    const request = {\n        method: 'POST',\n        headers,\n        body: JSON.stringify(body)\n    };\n    const response = await retryIfServerError(() => fetch(endpoint, request));\n    if (response.ok) {\n        const responseValue = await response.json();\n        const completedAuthToken = extractAuthTokenInfoFromResponse(responseValue);\n        return completedAuthToken;\n    }\n    else {\n        throw await getErrorFromResponse('Generate Auth Token', response);\n    }\n}\nfunction getGenerateAuthTokenEndpoint(appConfig, { fid }) {\n    return `${getInstallationsEndpoint(appConfig)}/${fid}/authTokens:generate`;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns a valid authentication token for the installation. Generates a new\n * token if one doesn't exist, is expired or about to expire.\n *\n * Should only be called if the Firebase Installation is registered.\n */\nasync function refreshAuthToken(installations, forceRefresh = false) {\n    let tokenPromise;\n    const entry = await update(installations.appConfig, oldEntry => {\n        if (!isEntryRegistered(oldEntry)) {\n            throw ERROR_FACTORY.create(\"not-registered\" /* ErrorCode.NOT_REGISTERED */);\n        }\n        const oldAuthToken = oldEntry.authToken;\n        if (!forceRefresh && isAuthTokenValid(oldAuthToken)) {\n            // There is a valid token in the DB.\n            return oldEntry;\n        }\n        else if (oldAuthToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */) {\n            // There already is a token request in progress.\n            tokenPromise = waitUntilAuthTokenRequest(installations, forceRefresh);\n            return oldEntry;\n        }\n        else {\n            // No token or token expired.\n            if (!navigator.onLine) {\n                throw ERROR_FACTORY.create(\"app-offline\" /* ErrorCode.APP_OFFLINE */);\n            }\n            const inProgressEntry = makeAuthTokenRequestInProgressEntry(oldEntry);\n            tokenPromise = fetchAuthTokenFromServer(installations, inProgressEntry);\n            return inProgressEntry;\n        }\n    });\n    const authToken = tokenPromise\n        ? await tokenPromise\n        : entry.authToken;\n    return authToken;\n}\n/**\n * Call only if FID is registered and Auth Token request is in progress.\n *\n * Waits until the current pending request finishes. If the request times out,\n * tries once in this thread as well.\n */\nasync function waitUntilAuthTokenRequest(installations, forceRefresh) {\n    // Unfortunately, there is no way of reliably observing when a value in\n    // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\n    // so we need to poll.\n    let entry = await updateAuthTokenRequest(installations.appConfig);\n    while (entry.authToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */) {\n        // generateAuthToken still in progress.\n        await sleep(100);\n        entry = await updateAuthTokenRequest(installations.appConfig);\n    }\n    const authToken = entry.authToken;\n    if (authToken.requestStatus === 0 /* RequestStatus.NOT_STARTED */) {\n        // The request timed out or failed in a different call. Try again.\n        return refreshAuthToken(installations, forceRefresh);\n    }\n    else {\n        return authToken;\n    }\n}\n/**\n * Called only if there is a GenerateAuthToken request in progress.\n *\n * Updates the InstallationEntry in the DB based on the status of the\n * GenerateAuthToken request.\n *\n * Returns the updated InstallationEntry.\n */\nfunction updateAuthTokenRequest(appConfig) {\n    return update(appConfig, oldEntry => {\n        if (!isEntryRegistered(oldEntry)) {\n            throw ERROR_FACTORY.create(\"not-registered\" /* ErrorCode.NOT_REGISTERED */);\n        }\n        const oldAuthToken = oldEntry.authToken;\n        if (hasAuthTokenRequestTimedOut(oldAuthToken)) {\n            return Object.assign(Object.assign({}, oldEntry), { authToken: { requestStatus: 0 /* RequestStatus.NOT_STARTED */ } });\n        }\n        return oldEntry;\n    });\n}\nasync function fetchAuthTokenFromServer(installations, installationEntry) {\n    try {\n        const authToken = await generateAuthTokenRequest(installations, installationEntry);\n        const updatedInstallationEntry = Object.assign(Object.assign({}, installationEntry), { authToken });\n        await set(installations.appConfig, updatedInstallationEntry);\n        return authToken;\n    }\n    catch (e) {\n        if (isServerError(e) &&\n            (e.customData.serverCode === 401 || e.customData.serverCode === 404)) {\n            // Server returned a \"FID not found\" or a \"Invalid authentication\" error.\n            // Generate a new ID next time.\n            await remove(installations.appConfig);\n        }\n        else {\n            const updatedInstallationEntry = Object.assign(Object.assign({}, installationEntry), { authToken: { requestStatus: 0 /* RequestStatus.NOT_STARTED */ } });\n            await set(installations.appConfig, updatedInstallationEntry);\n        }\n        throw e;\n    }\n}\nfunction isEntryRegistered(installationEntry) {\n    return (installationEntry !== undefined &&\n        installationEntry.registrationStatus === 2 /* RequestStatus.COMPLETED */);\n}\nfunction isAuthTokenValid(authToken) {\n    return (authToken.requestStatus === 2 /* RequestStatus.COMPLETED */ &&\n        !isAuthTokenExpired(authToken));\n}\nfunction isAuthTokenExpired(authToken) {\n    const now = Date.now();\n    return (now < authToken.creationTime ||\n        authToken.creationTime + authToken.expiresIn < now + TOKEN_EXPIRATION_BUFFER);\n}\n/** Returns an updated InstallationEntry with an InProgressAuthToken. */\nfunction makeAuthTokenRequestInProgressEntry(oldEntry) {\n    const inProgressAuthToken = {\n        requestStatus: 1 /* RequestStatus.IN_PROGRESS */,\n        requestTime: Date.now()\n    };\n    return Object.assign(Object.assign({}, oldEntry), { authToken: inProgressAuthToken });\n}\nfunction hasAuthTokenRequestTimedOut(authToken) {\n    return (authToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */ &&\n        authToken.requestTime + PENDING_TIMEOUT_MS < Date.now());\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Creates a Firebase Installation if there isn't one for the app and\n * returns the Installation ID.\n * @param installations - The `Installations` instance.\n *\n * @public\n */\nasync function getId(installations) {\n    const installationsImpl = installations;\n    const { installationEntry, registrationPromise } = await getInstallationEntry(installationsImpl);\n    if (registrationPromise) {\n        registrationPromise.catch(console.error);\n    }\n    else {\n        // If the installation is already registered, update the authentication\n        // token if needed.\n        refreshAuthToken(installationsImpl).catch(console.error);\n    }\n    return installationEntry.fid;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns a Firebase Installations auth token, identifying the current\n * Firebase Installation.\n * @param installations - The `Installations` instance.\n * @param forceRefresh - Force refresh regardless of token expiration.\n *\n * @public\n */\nasync function getToken(installations, forceRefresh = false) {\n    const installationsImpl = installations;\n    await completeInstallationRegistration(installationsImpl);\n    // At this point we either have a Registered Installation in the DB, or we've\n    // already thrown an error.\n    const authToken = await refreshAuthToken(installationsImpl, forceRefresh);\n    return authToken.token;\n}\nasync function completeInstallationRegistration(installations) {\n    const { registrationPromise } = await getInstallationEntry(installations);\n    if (registrationPromise) {\n        // A createInstallation request is in progress. Wait until it finishes.\n        await registrationPromise;\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function deleteInstallationRequest(appConfig, installationEntry) {\n    const endpoint = getDeleteEndpoint(appConfig, installationEntry);\n    const headers = getHeadersWithAuth(appConfig, installationEntry);\n    const request = {\n        method: 'DELETE',\n        headers\n    };\n    const response = await retryIfServerError(() => fetch(endpoint, request));\n    if (!response.ok) {\n        throw await getErrorFromResponse('Delete Installation', response);\n    }\n}\nfunction getDeleteEndpoint(appConfig, { fid }) {\n    return `${getInstallationsEndpoint(appConfig)}/${fid}`;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Deletes the Firebase Installation and all associated data.\n * @param installations - The `Installations` instance.\n *\n * @public\n */\nasync function deleteInstallations(installations) {\n    const { appConfig } = installations;\n    const entry = await update(appConfig, oldEntry => {\n        if (oldEntry && oldEntry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */) {\n            // Delete the unregistered entry without sending a deleteInstallation request.\n            return undefined;\n        }\n        return oldEntry;\n    });\n    if (entry) {\n        if (entry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */) {\n            // Can't delete while trying to register.\n            throw ERROR_FACTORY.create(\"delete-pending-registration\" /* ErrorCode.DELETE_PENDING_REGISTRATION */);\n        }\n        else if (entry.registrationStatus === 2 /* RequestStatus.COMPLETED */) {\n            if (!navigator.onLine) {\n                throw ERROR_FACTORY.create(\"app-offline\" /* ErrorCode.APP_OFFLINE */);\n            }\n            else {\n                await deleteInstallationRequest(appConfig, entry);\n                await remove(appConfig);\n            }\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Sets a new callback that will get called when Installation ID changes.\n * Returns an unsubscribe function that will remove the callback when called.\n * @param installations - The `Installations` instance.\n * @param callback - The callback function that is invoked when FID changes.\n * @returns A function that can be called to unsubscribe.\n *\n * @public\n */\nfunction onIdChange(installations, callback) {\n    const { appConfig } = installations;\n    addCallback(appConfig, callback);\n    return () => {\n        removeCallback(appConfig, callback);\n    };\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns an instance of {@link Installations} associated with the given\n * {@link @firebase/app#FirebaseApp} instance.\n * @param app - The {@link @firebase/app#FirebaseApp} instance.\n *\n * @public\n */\nfunction getInstallations(app = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)()) {\n    const installationsImpl = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'installations').getImmediate();\n    return installationsImpl;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction extractAppConfig(app) {\n    if (!app || !app.options) {\n        throw getMissingValueError('App Configuration');\n    }\n    if (!app.name) {\n        throw getMissingValueError('App Name');\n    }\n    // Required app config keys\n    const configKeys = [\n        'projectId',\n        'apiKey',\n        'appId'\n    ];\n    for (const keyName of configKeys) {\n        if (!app.options[keyName]) {\n            throw getMissingValueError(keyName);\n        }\n    }\n    return {\n        appName: app.name,\n        projectId: app.options.projectId,\n        apiKey: app.options.apiKey,\n        appId: app.options.appId\n    };\n}\nfunction getMissingValueError(valueName) {\n    return ERROR_FACTORY.create(\"missing-app-config-values\" /* ErrorCode.MISSING_APP_CONFIG_VALUES */, {\n        valueName\n    });\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst INSTALLATIONS_NAME = 'installations';\nconst INSTALLATIONS_NAME_INTERNAL = 'installations-internal';\nconst publicFactory = (container) => {\n    const app = container.getProvider('app').getImmediate();\n    // Throws if app isn't configured properly.\n    const appConfig = extractAppConfig(app);\n    const heartbeatServiceProvider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'heartbeat');\n    const installationsImpl = {\n        app,\n        appConfig,\n        heartbeatServiceProvider,\n        _delete: () => Promise.resolve()\n    };\n    return installationsImpl;\n};\nconst internalFactory = (container) => {\n    const app = container.getProvider('app').getImmediate();\n    // Internal FIS instance relies on public FIS instance.\n    const installations = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, INSTALLATIONS_NAME).getImmediate();\n    const installationsInternal = {\n        getId: () => getId(installations),\n        getToken: (forceRefresh) => getToken(installations, forceRefresh)\n    };\n    return installationsInternal;\n};\nfunction registerInstallations() {\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component(INSTALLATIONS_NAME, publicFactory, \"PUBLIC\" /* ComponentType.PUBLIC */));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component(INSTALLATIONS_NAME_INTERNAL, internalFactory, \"PRIVATE\" /* ComponentType.PRIVATE */));\n}\n\n/**\n * The Firebase Installations Web SDK.\n * This SDK does not work in a Node.js environment.\n *\n * @packageDocumentation\n */\nregisterInstallations();\n(0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version);\n// BUILD_TARGET will be replaced by values like esm2017, cjs2017, etc during the compilation\n(0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, 'esm2017');\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2luc3RhbGxhdGlvbnMvZGlzdC9lc20vaW5kZXguZXNtMjAxNy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBMEY7QUFDMUM7QUFDYTtBQUNoQzs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSEFBaUgsV0FBVztBQUM1SDtBQUNBO0FBQ0EseURBQXlELGNBQWMsNEJBQTRCLGNBQWMsY0FBYyxHQUFHLGVBQWU7QUFDako7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdEQUFZO0FBQ3RDO0FBQ0E7QUFDQSw2QkFBNkIseURBQWE7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxXQUFXO0FBQy9DLGNBQWMsc0JBQXNCLFlBQVksVUFBVTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCLEVBQUUsYUFBYTtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxxQ0FBcUMsSUFBSSxLQUFLO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsR0FBRztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0JBQWtCLEdBQUcsZ0JBQWdCO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkNBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlDQUF5QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQ0FBcUM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsS0FBSztBQUN4RCxjQUFjLG9DQUFvQyxHQUFHLElBQUk7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZUFBZSxhQUFhLG9EQUFvRDtBQUNqSTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLHdCQUF3QixXQUFXO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsd0JBQXdCLGFBQWEsb0RBQW9EO0FBQ3BLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxlQUFlLGdDQUFnQztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5Q0FBeUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxLQUFLO0FBQzdDLGNBQWMsb0NBQW9DLEdBQUcsSUFBSTtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQsSUFBSSxpQ0FBaUM7QUFDckMscUJBQXFCLGlDQUFpQztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscURBQU07QUFDdEMsOEJBQThCLDJEQUFZO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywyREFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJEQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpRUFBa0IsS0FBSywwREFBUztBQUNwQyxJQUFJLGlFQUFrQixLQUFLLDBEQUFTO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQWU7QUFDZjtBQUNBLDhEQUFlOztBQUUrRDtBQUM5RSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2luc3RhbGxhdGlvbnMvZGlzdC9lc20vaW5kZXguZXNtMjAxNy5qcz9iZDlmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9nZXRQcm92aWRlciwgZ2V0QXBwLCBfcmVnaXN0ZXJDb21wb25lbnQsIHJlZ2lzdGVyVmVyc2lvbiB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBFcnJvckZhY3RvcnksIEZpcmViYXNlRXJyb3IgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBvcGVuREIgfSBmcm9tICdpZGInO1xuXG5jb25zdCBuYW1lID0gXCJAZmlyZWJhc2UvaW5zdGFsbGF0aW9uc1wiO1xuY29uc3QgdmVyc2lvbiA9IFwiMC42LjExXCI7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBQRU5ESU5HX1RJTUVPVVRfTVMgPSAxMDAwMDtcbmNvbnN0IFBBQ0tBR0VfVkVSU0lPTiA9IGB3OiR7dmVyc2lvbn1gO1xuY29uc3QgSU5URVJOQUxfQVVUSF9WRVJTSU9OID0gJ0ZJU192Mic7XG5jb25zdCBJTlNUQUxMQVRJT05TX0FQSV9VUkwgPSAnaHR0cHM6Ly9maXJlYmFzZWluc3RhbGxhdGlvbnMuZ29vZ2xlYXBpcy5jb20vdjEnO1xuY29uc3QgVE9LRU5fRVhQSVJBVElPTl9CVUZGRVIgPSA2MCAqIDYwICogMTAwMDsgLy8gT25lIGhvdXJcbmNvbnN0IFNFUlZJQ0UgPSAnaW5zdGFsbGF0aW9ucyc7XG5jb25zdCBTRVJWSUNFX05BTUUgPSAnSW5zdGFsbGF0aW9ucyc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBFUlJPUl9ERVNDUklQVElPTl9NQVAgPSB7XG4gICAgW1wibWlzc2luZy1hcHAtY29uZmlnLXZhbHVlc1wiIC8qIEVycm9yQ29kZS5NSVNTSU5HX0FQUF9DT05GSUdfVkFMVUVTICovXTogJ01pc3NpbmcgQXBwIGNvbmZpZ3VyYXRpb24gdmFsdWU6IFwieyR2YWx1ZU5hbWV9XCInLFxuICAgIFtcIm5vdC1yZWdpc3RlcmVkXCIgLyogRXJyb3JDb2RlLk5PVF9SRUdJU1RFUkVEICovXTogJ0ZpcmViYXNlIEluc3RhbGxhdGlvbiBpcyBub3QgcmVnaXN0ZXJlZC4nLFxuICAgIFtcImluc3RhbGxhdGlvbi1ub3QtZm91bmRcIiAvKiBFcnJvckNvZGUuSU5TVEFMTEFUSU9OX05PVF9GT1VORCAqL106ICdGaXJlYmFzZSBJbnN0YWxsYXRpb24gbm90IGZvdW5kLicsXG4gICAgW1wicmVxdWVzdC1mYWlsZWRcIiAvKiBFcnJvckNvZGUuUkVRVUVTVF9GQUlMRUQgKi9dOiAneyRyZXF1ZXN0TmFtZX0gcmVxdWVzdCBmYWlsZWQgd2l0aCBlcnJvciBcInskc2VydmVyQ29kZX0geyRzZXJ2ZXJTdGF0dXN9OiB7JHNlcnZlck1lc3NhZ2V9XCInLFxuICAgIFtcImFwcC1vZmZsaW5lXCIgLyogRXJyb3JDb2RlLkFQUF9PRkZMSU5FICovXTogJ0NvdWxkIG5vdCBwcm9jZXNzIHJlcXVlc3QuIEFwcGxpY2F0aW9uIG9mZmxpbmUuJyxcbiAgICBbXCJkZWxldGUtcGVuZGluZy1yZWdpc3RyYXRpb25cIiAvKiBFcnJvckNvZGUuREVMRVRFX1BFTkRJTkdfUkVHSVNUUkFUSU9OICovXTogXCJDYW4ndCBkZWxldGUgaW5zdGFsbGF0aW9uIHdoaWxlIHRoZXJlIGlzIGEgcGVuZGluZyByZWdpc3RyYXRpb24gcmVxdWVzdC5cIlxufTtcbmNvbnN0IEVSUk9SX0ZBQ1RPUlkgPSBuZXcgRXJyb3JGYWN0b3J5KFNFUlZJQ0UsIFNFUlZJQ0VfTkFNRSwgRVJST1JfREVTQ1JJUFRJT05fTUFQKTtcbi8qKiBSZXR1cm5zIHRydWUgaWYgZXJyb3IgaXMgYSBGaXJlYmFzZUVycm9yIHRoYXQgaXMgYmFzZWQgb24gYW4gZXJyb3IgZnJvbSB0aGUgc2VydmVyLiAqL1xuZnVuY3Rpb24gaXNTZXJ2ZXJFcnJvcihlcnJvcikge1xuICAgIHJldHVybiAoZXJyb3IgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yICYmXG4gICAgICAgIGVycm9yLmNvZGUuaW5jbHVkZXMoXCJyZXF1ZXN0LWZhaWxlZFwiIC8qIEVycm9yQ29kZS5SRVFVRVNUX0ZBSUxFRCAqLykpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gZ2V0SW5zdGFsbGF0aW9uc0VuZHBvaW50KHsgcHJvamVjdElkIH0pIHtcbiAgICByZXR1cm4gYCR7SU5TVEFMTEFUSU9OU19BUElfVVJMfS9wcm9qZWN0cy8ke3Byb2plY3RJZH0vaW5zdGFsbGF0aW9uc2A7XG59XG5mdW5jdGlvbiBleHRyYWN0QXV0aFRva2VuSW5mb0Zyb21SZXNwb25zZShyZXNwb25zZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuOiByZXNwb25zZS50b2tlbixcbiAgICAgICAgcmVxdWVzdFN0YXR1czogMiAvKiBSZXF1ZXN0U3RhdHVzLkNPTVBMRVRFRCAqLyxcbiAgICAgICAgZXhwaXJlc0luOiBnZXRFeHBpcmVzSW5Gcm9tUmVzcG9uc2VFeHBpcmVzSW4ocmVzcG9uc2UuZXhwaXJlc0luKSxcbiAgICAgICAgY3JlYXRpb25UaW1lOiBEYXRlLm5vdygpXG4gICAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEVycm9yRnJvbVJlc3BvbnNlKHJlcXVlc3ROYW1lLCByZXNwb25zZSkge1xuICAgIGNvbnN0IHJlc3BvbnNlSnNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBjb25zdCBlcnJvckRhdGEgPSByZXNwb25zZUpzb24uZXJyb3I7XG4gICAgcmV0dXJuIEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwicmVxdWVzdC1mYWlsZWRcIiAvKiBFcnJvckNvZGUuUkVRVUVTVF9GQUlMRUQgKi8sIHtcbiAgICAgICAgcmVxdWVzdE5hbWUsXG4gICAgICAgIHNlcnZlckNvZGU6IGVycm9yRGF0YS5jb2RlLFxuICAgICAgICBzZXJ2ZXJNZXNzYWdlOiBlcnJvckRhdGEubWVzc2FnZSxcbiAgICAgICAgc2VydmVyU3RhdHVzOiBlcnJvckRhdGEuc3RhdHVzXG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRIZWFkZXJzKHsgYXBpS2V5IH0pIHtcbiAgICByZXR1cm4gbmV3IEhlYWRlcnMoe1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgJ3gtZ29vZy1hcGkta2V5JzogYXBpS2V5XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRIZWFkZXJzV2l0aEF1dGgoYXBwQ29uZmlnLCB7IHJlZnJlc2hUb2tlbiB9KSB7XG4gICAgY29uc3QgaGVhZGVycyA9IGdldEhlYWRlcnMoYXBwQ29uZmlnKTtcbiAgICBoZWFkZXJzLmFwcGVuZCgnQXV0aG9yaXphdGlvbicsIGdldEF1dGhvcml6YXRpb25IZWFkZXIocmVmcmVzaFRva2VuKSk7XG4gICAgcmV0dXJuIGhlYWRlcnM7XG59XG4vKipcbiAqIENhbGxzIHRoZSBwYXNzZWQgaW4gZmV0Y2ggd3JhcHBlciBhbmQgcmV0dXJucyB0aGUgcmVzcG9uc2UuXG4gKiBJZiB0aGUgcmV0dXJuZWQgcmVzcG9uc2UgaGFzIGEgc3RhdHVzIG9mIDV4eCwgcmUtcnVucyB0aGUgZnVuY3Rpb24gb25jZSBhbmRcbiAqIHJldHVybnMgdGhlIHJlc3BvbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiByZXRyeUlmU2VydmVyRXJyb3IoZm4pIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmbigpO1xuICAgIGlmIChyZXN1bHQuc3RhdHVzID49IDUwMCAmJiByZXN1bHQuc3RhdHVzIDwgNjAwKSB7XG4gICAgICAgIC8vIEludGVybmFsIFNlcnZlciBFcnJvci4gUmV0cnkgcmVxdWVzdC5cbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRFeHBpcmVzSW5Gcm9tUmVzcG9uc2VFeHBpcmVzSW4ocmVzcG9uc2VFeHBpcmVzSW4pIHtcbiAgICAvLyBUaGlzIHdvcmtzIGJlY2F1c2UgdGhlIHNlcnZlciB3aWxsIG5ldmVyIHJlc3BvbmQgd2l0aCBmcmFjdGlvbnMgb2YgYSBzZWNvbmQuXG4gICAgcmV0dXJuIE51bWJlcihyZXNwb25zZUV4cGlyZXNJbi5yZXBsYWNlKCdzJywgJzAwMCcpKTtcbn1cbmZ1bmN0aW9uIGdldEF1dGhvcml6YXRpb25IZWFkZXIocmVmcmVzaFRva2VuKSB7XG4gICAgcmV0dXJuIGAke0lOVEVSTkFMX0FVVEhfVkVSU0lPTn0gJHtyZWZyZXNoVG9rZW59YDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbGxhdGlvblJlcXVlc3QoeyBhcHBDb25maWcsIGhlYXJ0YmVhdFNlcnZpY2VQcm92aWRlciB9LCB7IGZpZCB9KSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSBnZXRJbnN0YWxsYXRpb25zRW5kcG9pbnQoYXBwQ29uZmlnKTtcbiAgICBjb25zdCBoZWFkZXJzID0gZ2V0SGVhZGVycyhhcHBDb25maWcpO1xuICAgIC8vIElmIGhlYXJ0YmVhdCBzZXJ2aWNlIGV4aXN0cywgYWRkIHRoZSBoZWFydGJlYXQgc3RyaW5nIHRvIHRoZSBoZWFkZXIuXG4gICAgY29uc3QgaGVhcnRiZWF0U2VydmljZSA9IGhlYXJ0YmVhdFNlcnZpY2VQcm92aWRlci5nZXRJbW1lZGlhdGUoe1xuICAgICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChoZWFydGJlYXRTZXJ2aWNlKSB7XG4gICAgICAgIGNvbnN0IGhlYXJ0YmVhdHNIZWFkZXIgPSBhd2FpdCBoZWFydGJlYXRTZXJ2aWNlLmdldEhlYXJ0YmVhdHNIZWFkZXIoKTtcbiAgICAgICAgaWYgKGhlYXJ0YmVhdHNIZWFkZXIpIHtcbiAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKCd4LWZpcmViYXNlLWNsaWVudCcsIGhlYXJ0YmVhdHNIZWFkZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgIGZpZCxcbiAgICAgICAgYXV0aFZlcnNpb246IElOVEVSTkFMX0FVVEhfVkVSU0lPTixcbiAgICAgICAgYXBwSWQ6IGFwcENvbmZpZy5hcHBJZCxcbiAgICAgICAgc2RrVmVyc2lvbjogUEFDS0FHRV9WRVJTSU9OXG4gICAgfTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgICB9O1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmV0cnlJZlNlcnZlckVycm9yKCgpID0+IGZldGNoKGVuZHBvaW50LCByZXF1ZXN0KSk7XG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlVmFsdWUgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyZWRJbnN0YWxsYXRpb25FbnRyeSA9IHtcbiAgICAgICAgICAgIGZpZDogcmVzcG9uc2VWYWx1ZS5maWQgfHwgZmlkLFxuICAgICAgICAgICAgcmVnaXN0cmF0aW9uU3RhdHVzOiAyIC8qIFJlcXVlc3RTdGF0dXMuQ09NUExFVEVEICovLFxuICAgICAgICAgICAgcmVmcmVzaFRva2VuOiByZXNwb25zZVZhbHVlLnJlZnJlc2hUb2tlbixcbiAgICAgICAgICAgIGF1dGhUb2tlbjogZXh0cmFjdEF1dGhUb2tlbkluZm9Gcm9tUmVzcG9uc2UocmVzcG9uc2VWYWx1ZS5hdXRoVG9rZW4pXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWdpc3RlcmVkSW5zdGFsbGF0aW9uRW50cnk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBhd2FpdCBnZXRFcnJvckZyb21SZXNwb25zZSgnQ3JlYXRlIEluc3RhbGxhdGlvbicsIHJlc3BvbnNlKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciBnaXZlbiB0aW1lIHBhc3Nlcy4gKi9cbmZ1bmN0aW9uIHNsZWVwKG1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRvQmFzZTY0VXJsU2FmZShhcnJheSkge1xuICAgIGNvbnN0IGI2NCA9IGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5hcnJheSkpO1xuICAgIHJldHVybiBiNjQucmVwbGFjZSgvXFwrL2csICctJykucmVwbGFjZSgvXFwvL2csICdfJyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBWQUxJRF9GSURfUEFUVEVSTiA9IC9eW2NkZWZdW1xcdy1dezIxfSQvO1xuY29uc3QgSU5WQUxJRF9GSUQgPSAnJztcbi8qKlxuICogR2VuZXJhdGVzIGEgbmV3IEZJRCB1c2luZyByYW5kb20gdmFsdWVzIGZyb20gV2ViIENyeXB0byBBUEkuXG4gKiBSZXR1cm5zIGFuIGVtcHR5IHN0cmluZyBpZiBGSUQgZ2VuZXJhdGlvbiBmYWlscyBmb3IgYW55IHJlYXNvbi5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVGaWQoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQSB2YWxpZCBGSUQgaGFzIGV4YWN0bHkgMjIgYmFzZTY0IGNoYXJhY3RlcnMsIHdoaWNoIGlzIDEzMiBiaXRzLCBvciAxNi41XG4gICAgICAgIC8vIGJ5dGVzLiBvdXIgaW1wbGVtZW50YXRpb24gZ2VuZXJhdGVzIGEgMTcgYnl0ZSBhcnJheSBpbnN0ZWFkLlxuICAgICAgICBjb25zdCBmaWRCeXRlQXJyYXkgPSBuZXcgVWludDhBcnJheSgxNyk7XG4gICAgICAgIGNvbnN0IGNyeXB0byA9IHNlbGYuY3J5cHRvIHx8IHNlbGYubXNDcnlwdG87XG4gICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoZmlkQnl0ZUFycmF5KTtcbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgZmlyc3QgNCByYW5kb20gYml0cyB3aXRoIHRoZSBjb25zdGFudCBGSUQgaGVhZGVyIG9mIDBiMDExMS5cbiAgICAgICAgZmlkQnl0ZUFycmF5WzBdID0gMGIwMTExMDAwMCArIChmaWRCeXRlQXJyYXlbMF0gJSAwYjAwMDEwMDAwKTtcbiAgICAgICAgY29uc3QgZmlkID0gZW5jb2RlKGZpZEJ5dGVBcnJheSk7XG4gICAgICAgIHJldHVybiBWQUxJRF9GSURfUEFUVEVSTi50ZXN0KGZpZCkgPyBmaWQgOiBJTlZBTElEX0ZJRDtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIC8vIEZJRCBnZW5lcmF0aW9uIGVycm9yZWRcbiAgICAgICAgcmV0dXJuIElOVkFMSURfRklEO1xuICAgIH1cbn1cbi8qKiBDb252ZXJ0cyBhIEZJRCBVaW50OEFycmF5IHRvIGEgYmFzZTY0IHN0cmluZyByZXByZXNlbnRhdGlvbi4gKi9cbmZ1bmN0aW9uIGVuY29kZShmaWRCeXRlQXJyYXkpIHtcbiAgICBjb25zdCBiNjRTdHJpbmcgPSBidWZmZXJUb0Jhc2U2NFVybFNhZmUoZmlkQnl0ZUFycmF5KTtcbiAgICAvLyBSZW1vdmUgdGhlIDIzcmQgY2hhcmFjdGVyIHRoYXQgd2FzIGFkZGVkIGJlY2F1c2Ugb2YgdGhlIGV4dHJhIDQgYml0cyBhdCB0aGVcbiAgICAvLyBlbmQgb2Ygb3VyIDE3IGJ5dGUgYXJyYXksIGFuZCB0aGUgJz0nIHBhZGRpbmcuXG4gICAgcmV0dXJuIGI2NFN0cmluZy5zdWJzdHIoMCwgMjIpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqIFJldHVybnMgYSBzdHJpbmcga2V5IHRoYXQgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgdGhlIGFwcC4gKi9cbmZ1bmN0aW9uIGdldEtleShhcHBDb25maWcpIHtcbiAgICByZXR1cm4gYCR7YXBwQ29uZmlnLmFwcE5hbWV9ISR7YXBwQ29uZmlnLmFwcElkfWA7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBmaWRDaGFuZ2VDYWxsYmFja3MgPSBuZXcgTWFwKCk7XG4vKipcbiAqIENhbGxzIHRoZSBvbklkQ2hhbmdlIGNhbGxiYWNrcyB3aXRoIHRoZSBuZXcgRklEIHZhbHVlLCBhbmQgYnJvYWRjYXN0cyB0aGVcbiAqIGNoYW5nZSB0byBvdGhlciB0YWJzLlxuICovXG5mdW5jdGlvbiBmaWRDaGFuZ2VkKGFwcENvbmZpZywgZmlkKSB7XG4gICAgY29uc3Qga2V5ID0gZ2V0S2V5KGFwcENvbmZpZyk7XG4gICAgY2FsbEZpZENoYW5nZUNhbGxiYWNrcyhrZXksIGZpZCk7XG4gICAgYnJvYWRjYXN0RmlkQ2hhbmdlKGtleSwgZmlkKTtcbn1cbmZ1bmN0aW9uIGFkZENhbGxiYWNrKGFwcENvbmZpZywgY2FsbGJhY2spIHtcbiAgICAvLyBPcGVuIHRoZSBicm9hZGNhc3QgY2hhbm5lbCBpZiBpdCdzIG5vdCBhbHJlYWR5IG9wZW4sXG4gICAgLy8gdG8gYmUgYWJsZSB0byBsaXN0ZW4gdG8gY2hhbmdlIGV2ZW50cyBmcm9tIG90aGVyIHRhYnMuXG4gICAgZ2V0QnJvYWRjYXN0Q2hhbm5lbCgpO1xuICAgIGNvbnN0IGtleSA9IGdldEtleShhcHBDb25maWcpO1xuICAgIGxldCBjYWxsYmFja1NldCA9IGZpZENoYW5nZUNhbGxiYWNrcy5nZXQoa2V5KTtcbiAgICBpZiAoIWNhbGxiYWNrU2V0KSB7XG4gICAgICAgIGNhbGxiYWNrU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICBmaWRDaGFuZ2VDYWxsYmFja3Muc2V0KGtleSwgY2FsbGJhY2tTZXQpO1xuICAgIH1cbiAgICBjYWxsYmFja1NldC5hZGQoY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gcmVtb3ZlQ2FsbGJhY2soYXBwQ29uZmlnLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGtleSA9IGdldEtleShhcHBDb25maWcpO1xuICAgIGNvbnN0IGNhbGxiYWNrU2V0ID0gZmlkQ2hhbmdlQ2FsbGJhY2tzLmdldChrZXkpO1xuICAgIGlmICghY2FsbGJhY2tTZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFja1NldC5kZWxldGUoY2FsbGJhY2spO1xuICAgIGlmIChjYWxsYmFja1NldC5zaXplID09PSAwKSB7XG4gICAgICAgIGZpZENoYW5nZUNhbGxiYWNrcy5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgLy8gQ2xvc2UgYnJvYWRjYXN0IGNoYW5uZWwgaWYgdGhlcmUgYXJlIG5vIG1vcmUgY2FsbGJhY2tzLlxuICAgIGNsb3NlQnJvYWRjYXN0Q2hhbm5lbCgpO1xufVxuZnVuY3Rpb24gY2FsbEZpZENoYW5nZUNhbGxiYWNrcyhrZXksIGZpZCkge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IGZpZENoYW5nZUNhbGxiYWNrcy5nZXQoa2V5KTtcbiAgICBpZiAoIWNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgY2FsbGJhY2tzKSB7XG4gICAgICAgIGNhbGxiYWNrKGZpZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYnJvYWRjYXN0RmlkQ2hhbmdlKGtleSwgZmlkKSB7XG4gICAgY29uc3QgY2hhbm5lbCA9IGdldEJyb2FkY2FzdENoYW5uZWwoKTtcbiAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICBjaGFubmVsLnBvc3RNZXNzYWdlKHsga2V5LCBmaWQgfSk7XG4gICAgfVxuICAgIGNsb3NlQnJvYWRjYXN0Q2hhbm5lbCgpO1xufVxubGV0IGJyb2FkY2FzdENoYW5uZWwgPSBudWxsO1xuLyoqIE9wZW5zIGFuZCByZXR1cm5zIGEgQnJvYWRjYXN0Q2hhbm5lbCBpZiBpdCBpcyBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIuICovXG5mdW5jdGlvbiBnZXRCcm9hZGNhc3RDaGFubmVsKCkge1xuICAgIGlmICghYnJvYWRjYXN0Q2hhbm5lbCAmJiAnQnJvYWRjYXN0Q2hhbm5lbCcgaW4gc2VsZikge1xuICAgICAgICBicm9hZGNhc3RDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoJ1tGaXJlYmFzZV0gRklEIENoYW5nZScpO1xuICAgICAgICBicm9hZGNhc3RDaGFubmVsLm9ubWVzc2FnZSA9IGUgPT4ge1xuICAgICAgICAgICAgY2FsbEZpZENoYW5nZUNhbGxiYWNrcyhlLmRhdGEua2V5LCBlLmRhdGEuZmlkKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGJyb2FkY2FzdENoYW5uZWw7XG59XG5mdW5jdGlvbiBjbG9zZUJyb2FkY2FzdENoYW5uZWwoKSB7XG4gICAgaWYgKGZpZENoYW5nZUNhbGxiYWNrcy5zaXplID09PSAwICYmIGJyb2FkY2FzdENoYW5uZWwpIHtcbiAgICAgICAgYnJvYWRjYXN0Q2hhbm5lbC5jbG9zZSgpO1xuICAgICAgICBicm9hZGNhc3RDaGFubmVsID0gbnVsbDtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBEQVRBQkFTRV9OQU1FID0gJ2ZpcmViYXNlLWluc3RhbGxhdGlvbnMtZGF0YWJhc2UnO1xuY29uc3QgREFUQUJBU0VfVkVSU0lPTiA9IDE7XG5jb25zdCBPQkpFQ1RfU1RPUkVfTkFNRSA9ICdmaXJlYmFzZS1pbnN0YWxsYXRpb25zLXN0b3JlJztcbmxldCBkYlByb21pc2UgPSBudWxsO1xuZnVuY3Rpb24gZ2V0RGJQcm9taXNlKCkge1xuICAgIGlmICghZGJQcm9taXNlKSB7XG4gICAgICAgIGRiUHJvbWlzZSA9IG9wZW5EQihEQVRBQkFTRV9OQU1FLCBEQVRBQkFTRV9WRVJTSU9OLCB7XG4gICAgICAgICAgICB1cGdyYWRlOiAoZGIsIG9sZFZlcnNpb24pID0+IHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB1c2UgJ2JyZWFrJyBpbiB0aGlzIHN3aXRjaCBzdGF0ZW1lbnQsIHRoZSBmYWxsLXRocm91Z2hcbiAgICAgICAgICAgICAgICAvLyBiZWhhdmlvciBpcyB3aGF0IHdlIHdhbnQsIGJlY2F1c2UgaWYgdGhlcmUgYXJlIG11bHRpcGxlIHZlcnNpb25zIGJldHdlZW5cbiAgICAgICAgICAgICAgICAvLyB0aGUgb2xkIHZlcnNpb24gYW5kIHRoZSBjdXJyZW50IHZlcnNpb24sIHdlIHdhbnQgQUxMIHRoZSBtaWdyYXRpb25zXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBjb3JyZXNwb25kIHRvIHRob3NlIHZlcnNpb25zIHRvIHJ1biwgbm90IG9ubHkgdGhlIGxhc3Qgb25lLlxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZWZhdWx0LWNhc2VcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9sZFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX05BTUUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkYlByb21pc2U7XG59XG4vKiogQXNzaWducyBvciBvdmVyd3JpdGVzIHRoZSByZWNvcmQgZm9yIHRoZSBnaXZlbiBrZXkgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuICovXG5hc3luYyBmdW5jdGlvbiBzZXQoYXBwQ29uZmlnLCB2YWx1ZSkge1xuICAgIGNvbnN0IGtleSA9IGdldEtleShhcHBDb25maWcpO1xuICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XG4gICAgY29uc3QgdHggPSBkYi50cmFuc2FjdGlvbihPQkpFQ1RfU1RPUkVfTkFNRSwgJ3JlYWR3cml0ZScpO1xuICAgIGNvbnN0IG9iamVjdFN0b3JlID0gdHgub2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX05BTUUpO1xuICAgIGNvbnN0IG9sZFZhbHVlID0gKGF3YWl0IG9iamVjdFN0b3JlLmdldChrZXkpKTtcbiAgICBhd2FpdCBvYmplY3RTdG9yZS5wdXQodmFsdWUsIGtleSk7XG4gICAgYXdhaXQgdHguZG9uZTtcbiAgICBpZiAoIW9sZFZhbHVlIHx8IG9sZFZhbHVlLmZpZCAhPT0gdmFsdWUuZmlkKSB7XG4gICAgICAgIGZpZENoYW5nZWQoYXBwQ29uZmlnLCB2YWx1ZS5maWQpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKiogUmVtb3ZlcyByZWNvcmQocykgZnJvbSB0aGUgb2JqZWN0U3RvcmUgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4ga2V5LiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVtb3ZlKGFwcENvbmZpZykge1xuICAgIGNvbnN0IGtleSA9IGdldEtleShhcHBDb25maWcpO1xuICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XG4gICAgY29uc3QgdHggPSBkYi50cmFuc2FjdGlvbihPQkpFQ1RfU1RPUkVfTkFNRSwgJ3JlYWR3cml0ZScpO1xuICAgIGF3YWl0IHR4Lm9iamVjdFN0b3JlKE9CSkVDVF9TVE9SRV9OQU1FKS5kZWxldGUoa2V5KTtcbiAgICBhd2FpdCB0eC5kb25lO1xufVxuLyoqXG4gKiBBdG9taWNhbGx5IHVwZGF0ZXMgYSByZWNvcmQgd2l0aCB0aGUgcmVzdWx0IG9mIHVwZGF0ZUZuLCB3aGljaCBnZXRzXG4gKiBjYWxsZWQgd2l0aCB0aGUgY3VycmVudCB2YWx1ZS4gSWYgbmV3VmFsdWUgaXMgdW5kZWZpbmVkLCB0aGUgcmVjb3JkIGlzXG4gKiBkZWxldGVkIGluc3RlYWQuXG4gKiBAcmV0dXJuIFVwZGF0ZWQgdmFsdWVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdXBkYXRlKGFwcENvbmZpZywgdXBkYXRlRm4pIHtcbiAgICBjb25zdCBrZXkgPSBnZXRLZXkoYXBwQ29uZmlnKTtcbiAgICBjb25zdCBkYiA9IGF3YWl0IGdldERiUHJvbWlzZSgpO1xuICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oT0JKRUNUX1NUT1JFX05BTUUsICdyZWFkd3JpdGUnKTtcbiAgICBjb25zdCBzdG9yZSA9IHR4Lm9iamVjdFN0b3JlKE9CSkVDVF9TVE9SRV9OQU1FKTtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IChhd2FpdCBzdG9yZS5nZXQoa2V5KSk7XG4gICAgY29uc3QgbmV3VmFsdWUgPSB1cGRhdGVGbihvbGRWYWx1ZSk7XG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgc3RvcmUuZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhd2FpdCBzdG9yZS5wdXQobmV3VmFsdWUsIGtleSk7XG4gICAgfVxuICAgIGF3YWl0IHR4LmRvbmU7XG4gICAgaWYgKG5ld1ZhbHVlICYmICghb2xkVmFsdWUgfHwgb2xkVmFsdWUuZmlkICE9PSBuZXdWYWx1ZS5maWQpKSB7XG4gICAgICAgIGZpZENoYW5nZWQoYXBwQ29uZmlnLCBuZXdWYWx1ZS5maWQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3VmFsdWU7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFVwZGF0ZXMgYW5kIHJldHVybnMgdGhlIEluc3RhbGxhdGlvbkVudHJ5IGZyb20gdGhlIGRhdGFiYXNlLlxuICogQWxzbyB0cmlnZ2VycyBhIHJlZ2lzdHJhdGlvbiByZXF1ZXN0IGlmIGl0IGlzIG5lY2Vzc2FyeSBhbmQgcG9zc2libGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEluc3RhbGxhdGlvbkVudHJ5KGluc3RhbGxhdGlvbnMpIHtcbiAgICBsZXQgcmVnaXN0cmF0aW9uUHJvbWlzZTtcbiAgICBjb25zdCBpbnN0YWxsYXRpb25FbnRyeSA9IGF3YWl0IHVwZGF0ZShpbnN0YWxsYXRpb25zLmFwcENvbmZpZywgb2xkRW50cnkgPT4ge1xuICAgICAgICBjb25zdCBpbnN0YWxsYXRpb25FbnRyeSA9IHVwZGF0ZU9yQ3JlYXRlSW5zdGFsbGF0aW9uRW50cnkob2xkRW50cnkpO1xuICAgICAgICBjb25zdCBlbnRyeVdpdGhQcm9taXNlID0gdHJpZ2dlclJlZ2lzdHJhdGlvbklmTmVjZXNzYXJ5KGluc3RhbGxhdGlvbnMsIGluc3RhbGxhdGlvbkVudHJ5KTtcbiAgICAgICAgcmVnaXN0cmF0aW9uUHJvbWlzZSA9IGVudHJ5V2l0aFByb21pc2UucmVnaXN0cmF0aW9uUHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIGVudHJ5V2l0aFByb21pc2UuaW5zdGFsbGF0aW9uRW50cnk7XG4gICAgfSk7XG4gICAgaWYgKGluc3RhbGxhdGlvbkVudHJ5LmZpZCA9PT0gSU5WQUxJRF9GSUQpIHtcbiAgICAgICAgLy8gRklEIGdlbmVyYXRpb24gZmFpbGVkLiBXYWl0aW5nIGZvciB0aGUgRklEIGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgcmV0dXJuIHsgaW5zdGFsbGF0aW9uRW50cnk6IGF3YWl0IHJlZ2lzdHJhdGlvblByb21pc2UgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5zdGFsbGF0aW9uRW50cnksXG4gICAgICAgIHJlZ2lzdHJhdGlvblByb21pc2VcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEluc3RhbGxhdGlvbiBFbnRyeSBpZiBvbmUgZG9lcyBub3QgZXhpc3QuXG4gKiBBbHNvIGNsZWFycyB0aW1lZCBvdXQgcGVuZGluZyByZXF1ZXN0cy5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlT3JDcmVhdGVJbnN0YWxsYXRpb25FbnRyeShvbGRFbnRyeSkge1xuICAgIGNvbnN0IGVudHJ5ID0gb2xkRW50cnkgfHwge1xuICAgICAgICBmaWQ6IGdlbmVyYXRlRmlkKCksXG4gICAgICAgIHJlZ2lzdHJhdGlvblN0YXR1czogMCAvKiBSZXF1ZXN0U3RhdHVzLk5PVF9TVEFSVEVEICovXG4gICAgfTtcbiAgICByZXR1cm4gY2xlYXJUaW1lZE91dFJlcXVlc3QoZW50cnkpO1xufVxuLyoqXG4gKiBJZiB0aGUgRmlyZWJhc2UgSW5zdGFsbGF0aW9uIGlzIG5vdCByZWdpc3RlcmVkIHlldCwgdGhpcyB3aWxsIHRyaWdnZXIgdGhlXG4gKiByZWdpc3RyYXRpb24gYW5kIHJldHVybiBhbiBJblByb2dyZXNzSW5zdGFsbGF0aW9uRW50cnkuXG4gKlxuICogSWYgcmVnaXN0cmF0aW9uUHJvbWlzZSBkb2VzIG5vdCBleGlzdCwgdGhlIGluc3RhbGxhdGlvbkVudHJ5IGlzIGd1YXJhbnRlZWRcbiAqIHRvIGJlIHJlZ2lzdGVyZWQuXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXJSZWdpc3RyYXRpb25JZk5lY2Vzc2FyeShpbnN0YWxsYXRpb25zLCBpbnN0YWxsYXRpb25FbnRyeSkge1xuICAgIGlmIChpbnN0YWxsYXRpb25FbnRyeS5yZWdpc3RyYXRpb25TdGF0dXMgPT09IDAgLyogUmVxdWVzdFN0YXR1cy5OT1RfU1RBUlRFRCAqLykge1xuICAgICAgICBpZiAoIW5hdmlnYXRvci5vbkxpbmUpIHtcbiAgICAgICAgICAgIC8vIFJlZ2lzdHJhdGlvbiByZXF1aXJlZCBidXQgYXBwIGlzIG9mZmxpbmUuXG4gICAgICAgICAgICBjb25zdCByZWdpc3RyYXRpb25Qcm9taXNlV2l0aEVycm9yID0gUHJvbWlzZS5yZWplY3QoRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJhcHAtb2ZmbGluZVwiIC8qIEVycm9yQ29kZS5BUFBfT0ZGTElORSAqLykpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbnN0YWxsYXRpb25FbnRyeSxcbiAgICAgICAgICAgICAgICByZWdpc3RyYXRpb25Qcm9taXNlOiByZWdpc3RyYXRpb25Qcm9taXNlV2l0aEVycm9yXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSByZWdpc3RlcmluZy4gQ2hhbmdlIHN0YXR1cyB0byBJTl9QUk9HUkVTUy5cbiAgICAgICAgY29uc3QgaW5Qcm9ncmVzc0VudHJ5ID0ge1xuICAgICAgICAgICAgZmlkOiBpbnN0YWxsYXRpb25FbnRyeS5maWQsXG4gICAgICAgICAgICByZWdpc3RyYXRpb25TdGF0dXM6IDEgLyogUmVxdWVzdFN0YXR1cy5JTl9QUk9HUkVTUyAqLyxcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvblRpbWU6IERhdGUubm93KClcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVnaXN0cmF0aW9uUHJvbWlzZSA9IHJlZ2lzdGVySW5zdGFsbGF0aW9uKGluc3RhbGxhdGlvbnMsIGluUHJvZ3Jlc3NFbnRyeSk7XG4gICAgICAgIHJldHVybiB7IGluc3RhbGxhdGlvbkVudHJ5OiBpblByb2dyZXNzRW50cnksIHJlZ2lzdHJhdGlvblByb21pc2UgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5zdGFsbGF0aW9uRW50cnkucmVnaXN0cmF0aW9uU3RhdHVzID09PSAxIC8qIFJlcXVlc3RTdGF0dXMuSU5fUFJPR1JFU1MgKi8pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluc3RhbGxhdGlvbkVudHJ5LFxuICAgICAgICAgICAgcmVnaXN0cmF0aW9uUHJvbWlzZTogd2FpdFVudGlsRmlkUmVnaXN0cmF0aW9uKGluc3RhbGxhdGlvbnMpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyBpbnN0YWxsYXRpb25FbnRyeSB9O1xuICAgIH1cbn1cbi8qKiBUaGlzIHdpbGwgYmUgZXhlY3V0ZWQgb25seSBvbmNlIGZvciBlYWNoIG5ldyBGaXJlYmFzZSBJbnN0YWxsYXRpb24uICovXG5hc3luYyBmdW5jdGlvbiByZWdpc3Rlckluc3RhbGxhdGlvbihpbnN0YWxsYXRpb25zLCBpbnN0YWxsYXRpb25FbnRyeSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyZWRJbnN0YWxsYXRpb25FbnRyeSA9IGF3YWl0IGNyZWF0ZUluc3RhbGxhdGlvblJlcXVlc3QoaW5zdGFsbGF0aW9ucywgaW5zdGFsbGF0aW9uRW50cnkpO1xuICAgICAgICByZXR1cm4gc2V0KGluc3RhbGxhdGlvbnMuYXBwQ29uZmlnLCByZWdpc3RlcmVkSW5zdGFsbGF0aW9uRW50cnkpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoaXNTZXJ2ZXJFcnJvcihlKSAmJiBlLmN1c3RvbURhdGEuc2VydmVyQ29kZSA9PT0gNDA5KSB7XG4gICAgICAgICAgICAvLyBTZXJ2ZXIgcmV0dXJuZWQgYSBcIkZJRCBjYW5ub3QgYmUgdXNlZFwiIGVycm9yLlxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBuZXcgSUQgbmV4dCB0aW1lLlxuICAgICAgICAgICAgYXdhaXQgcmVtb3ZlKGluc3RhbGxhdGlvbnMuYXBwQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlZ2lzdHJhdGlvbiBmYWlsZWQuIFNldCBGSUQgYXMgbm90IHJlZ2lzdGVyZWQuXG4gICAgICAgICAgICBhd2FpdCBzZXQoaW5zdGFsbGF0aW9ucy5hcHBDb25maWcsIHtcbiAgICAgICAgICAgICAgICBmaWQ6IGluc3RhbGxhdGlvbkVudHJ5LmZpZCxcbiAgICAgICAgICAgICAgICByZWdpc3RyYXRpb25TdGF0dXM6IDAgLyogUmVxdWVzdFN0YXR1cy5OT1RfU1RBUlRFRCAqL1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG59XG4vKiogQ2FsbCBpZiBGSUQgcmVnaXN0cmF0aW9uIGlzIHBlbmRpbmcgaW4gYW5vdGhlciByZXF1ZXN0LiAqL1xuYXN5bmMgZnVuY3Rpb24gd2FpdFVudGlsRmlkUmVnaXN0cmF0aW9uKGluc3RhbGxhdGlvbnMpIHtcbiAgICAvLyBVbmZvcnR1bmF0ZWx5LCB0aGVyZSBpcyBubyB3YXkgb2YgcmVsaWFibHkgb2JzZXJ2aW5nIHdoZW4gYSB2YWx1ZSBpblxuICAgIC8vIEluZGV4ZWREQiBjaGFuZ2VzICh5ZXQsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vV0lDRy9pbmRleGVkLWRiLW9ic2VydmVycyksXG4gICAgLy8gc28gd2UgbmVlZCB0byBwb2xsLlxuICAgIGxldCBlbnRyeSA9IGF3YWl0IHVwZGF0ZUluc3RhbGxhdGlvblJlcXVlc3QoaW5zdGFsbGF0aW9ucy5hcHBDb25maWcpO1xuICAgIHdoaWxlIChlbnRyeS5yZWdpc3RyYXRpb25TdGF0dXMgPT09IDEgLyogUmVxdWVzdFN0YXR1cy5JTl9QUk9HUkVTUyAqLykge1xuICAgICAgICAvLyBjcmVhdGVJbnN0YWxsYXRpb24gcmVxdWVzdCBzdGlsbCBpbiBwcm9ncmVzcy5cbiAgICAgICAgYXdhaXQgc2xlZXAoMTAwKTtcbiAgICAgICAgZW50cnkgPSBhd2FpdCB1cGRhdGVJbnN0YWxsYXRpb25SZXF1ZXN0KGluc3RhbGxhdGlvbnMuYXBwQ29uZmlnKTtcbiAgICB9XG4gICAgaWYgKGVudHJ5LnJlZ2lzdHJhdGlvblN0YXR1cyA9PT0gMCAvKiBSZXF1ZXN0U3RhdHVzLk5PVF9TVEFSVEVEICovKSB7XG4gICAgICAgIC8vIFRoZSByZXF1ZXN0IHRpbWVkIG91dCBvciBmYWlsZWQgaW4gYSBkaWZmZXJlbnQgY2FsbC4gVHJ5IGFnYWluLlxuICAgICAgICBjb25zdCB7IGluc3RhbGxhdGlvbkVudHJ5LCByZWdpc3RyYXRpb25Qcm9taXNlIH0gPSBhd2FpdCBnZXRJbnN0YWxsYXRpb25FbnRyeShpbnN0YWxsYXRpb25zKTtcbiAgICAgICAgaWYgKHJlZ2lzdHJhdGlvblByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdpc3RyYXRpb25Qcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gcmVnaXN0cmF0aW9uUHJvbWlzZSwgZW50cnkgaXMgcmVnaXN0ZXJlZC5cbiAgICAgICAgICAgIHJldHVybiBpbnN0YWxsYXRpb25FbnRyeTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW50cnk7XG59XG4vKipcbiAqIENhbGxlZCBvbmx5IGlmIHRoZXJlIGlzIGEgQ3JlYXRlSW5zdGFsbGF0aW9uIHJlcXVlc3QgaW4gcHJvZ3Jlc3MuXG4gKlxuICogVXBkYXRlcyB0aGUgSW5zdGFsbGF0aW9uRW50cnkgaW4gdGhlIERCIGJhc2VkIG9uIHRoZSBzdGF0dXMgb2YgdGhlXG4gKiBDcmVhdGVJbnN0YWxsYXRpb24gcmVxdWVzdC5cbiAqXG4gKiBSZXR1cm5zIHRoZSB1cGRhdGVkIEluc3RhbGxhdGlvbkVudHJ5LlxuICovXG5mdW5jdGlvbiB1cGRhdGVJbnN0YWxsYXRpb25SZXF1ZXN0KGFwcENvbmZpZykge1xuICAgIHJldHVybiB1cGRhdGUoYXBwQ29uZmlnLCBvbGRFbnRyeSA9PiB7XG4gICAgICAgIGlmICghb2xkRW50cnkpIHtcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaW5zdGFsbGF0aW9uLW5vdC1mb3VuZFwiIC8qIEVycm9yQ29kZS5JTlNUQUxMQVRJT05fTk9UX0ZPVU5EICovKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xlYXJUaW1lZE91dFJlcXVlc3Qob2xkRW50cnkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY2xlYXJUaW1lZE91dFJlcXVlc3QoZW50cnkpIHtcbiAgICBpZiAoaGFzSW5zdGFsbGF0aW9uUmVxdWVzdFRpbWVkT3V0KGVudHJ5KSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmlkOiBlbnRyeS5maWQsXG4gICAgICAgICAgICByZWdpc3RyYXRpb25TdGF0dXM6IDAgLyogUmVxdWVzdFN0YXR1cy5OT1RfU1RBUlRFRCAqL1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZW50cnk7XG59XG5mdW5jdGlvbiBoYXNJbnN0YWxsYXRpb25SZXF1ZXN0VGltZWRPdXQoaW5zdGFsbGF0aW9uRW50cnkpIHtcbiAgICByZXR1cm4gKGluc3RhbGxhdGlvbkVudHJ5LnJlZ2lzdHJhdGlvblN0YXR1cyA9PT0gMSAvKiBSZXF1ZXN0U3RhdHVzLklOX1BST0dSRVNTICovICYmXG4gICAgICAgIGluc3RhbGxhdGlvbkVudHJ5LnJlZ2lzdHJhdGlvblRpbWUgKyBQRU5ESU5HX1RJTUVPVVRfTVMgPCBEYXRlLm5vdygpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlQXV0aFRva2VuUmVxdWVzdCh7IGFwcENvbmZpZywgaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyIH0sIGluc3RhbGxhdGlvbkVudHJ5KSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSBnZXRHZW5lcmF0ZUF1dGhUb2tlbkVuZHBvaW50KGFwcENvbmZpZywgaW5zdGFsbGF0aW9uRW50cnkpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBnZXRIZWFkZXJzV2l0aEF1dGgoYXBwQ29uZmlnLCBpbnN0YWxsYXRpb25FbnRyeSk7XG4gICAgLy8gSWYgaGVhcnRiZWF0IHNlcnZpY2UgZXhpc3RzLCBhZGQgdGhlIGhlYXJ0YmVhdCBzdHJpbmcgdG8gdGhlIGhlYWRlci5cbiAgICBjb25zdCBoZWFydGJlYXRTZXJ2aWNlID0gaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyLmdldEltbWVkaWF0ZSh7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKGhlYXJ0YmVhdFNlcnZpY2UpIHtcbiAgICAgICAgY29uc3QgaGVhcnRiZWF0c0hlYWRlciA9IGF3YWl0IGhlYXJ0YmVhdFNlcnZpY2UuZ2V0SGVhcnRiZWF0c0hlYWRlcigpO1xuICAgICAgICBpZiAoaGVhcnRiZWF0c0hlYWRlcikge1xuICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoJ3gtZmlyZWJhc2UtY2xpZW50JywgaGVhcnRiZWF0c0hlYWRlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgaW5zdGFsbGF0aW9uOiB7XG4gICAgICAgICAgICBzZGtWZXJzaW9uOiBQQUNLQUdFX1ZFUlNJT04sXG4gICAgICAgICAgICBhcHBJZDogYXBwQ29uZmlnLmFwcElkXG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KVxuICAgIH07XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXRyeUlmU2VydmVyRXJyb3IoKCkgPT4gZmV0Y2goZW5kcG9pbnQsIHJlcXVlc3QpKTtcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VWYWx1ZSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc3QgY29tcGxldGVkQXV0aFRva2VuID0gZXh0cmFjdEF1dGhUb2tlbkluZm9Gcm9tUmVzcG9uc2UocmVzcG9uc2VWYWx1ZSk7XG4gICAgICAgIHJldHVybiBjb21wbGV0ZWRBdXRoVG9rZW47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBhd2FpdCBnZXRFcnJvckZyb21SZXNwb25zZSgnR2VuZXJhdGUgQXV0aCBUb2tlbicsIHJlc3BvbnNlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRHZW5lcmF0ZUF1dGhUb2tlbkVuZHBvaW50KGFwcENvbmZpZywgeyBmaWQgfSkge1xuICAgIHJldHVybiBgJHtnZXRJbnN0YWxsYXRpb25zRW5kcG9pbnQoYXBwQ29uZmlnKX0vJHtmaWR9L2F1dGhUb2tlbnM6Z2VuZXJhdGVgO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXR1cm5zIGEgdmFsaWQgYXV0aGVudGljYXRpb24gdG9rZW4gZm9yIHRoZSBpbnN0YWxsYXRpb24uIEdlbmVyYXRlcyBhIG5ld1xuICogdG9rZW4gaWYgb25lIGRvZXNuJ3QgZXhpc3QsIGlzIGV4cGlyZWQgb3IgYWJvdXQgdG8gZXhwaXJlLlxuICpcbiAqIFNob3VsZCBvbmx5IGJlIGNhbGxlZCBpZiB0aGUgRmlyZWJhc2UgSW5zdGFsbGF0aW9uIGlzIHJlZ2lzdGVyZWQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlZnJlc2hBdXRoVG9rZW4oaW5zdGFsbGF0aW9ucywgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgICBsZXQgdG9rZW5Qcm9taXNlO1xuICAgIGNvbnN0IGVudHJ5ID0gYXdhaXQgdXBkYXRlKGluc3RhbGxhdGlvbnMuYXBwQ29uZmlnLCBvbGRFbnRyeSA9PiB7XG4gICAgICAgIGlmICghaXNFbnRyeVJlZ2lzdGVyZWQob2xkRW50cnkpKSB7XG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcIm5vdC1yZWdpc3RlcmVkXCIgLyogRXJyb3JDb2RlLk5PVF9SRUdJU1RFUkVEICovKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRBdXRoVG9rZW4gPSBvbGRFbnRyeS5hdXRoVG9rZW47XG4gICAgICAgIGlmICghZm9yY2VSZWZyZXNoICYmIGlzQXV0aFRva2VuVmFsaWQob2xkQXV0aFRva2VuKSkge1xuICAgICAgICAgICAgLy8gVGhlcmUgaXMgYSB2YWxpZCB0b2tlbiBpbiB0aGUgREIuXG4gICAgICAgICAgICByZXR1cm4gb2xkRW50cnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2xkQXV0aFRva2VuLnJlcXVlc3RTdGF0dXMgPT09IDEgLyogUmVxdWVzdFN0YXR1cy5JTl9QUk9HUkVTUyAqLykge1xuICAgICAgICAgICAgLy8gVGhlcmUgYWxyZWFkeSBpcyBhIHRva2VuIHJlcXVlc3QgaW4gcHJvZ3Jlc3MuXG4gICAgICAgICAgICB0b2tlblByb21pc2UgPSB3YWl0VW50aWxBdXRoVG9rZW5SZXF1ZXN0KGluc3RhbGxhdGlvbnMsIGZvcmNlUmVmcmVzaCk7XG4gICAgICAgICAgICByZXR1cm4gb2xkRW50cnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBObyB0b2tlbiBvciB0b2tlbiBleHBpcmVkLlxuICAgICAgICAgICAgaWYgKCFuYXZpZ2F0b3Iub25MaW5lKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJhcHAtb2ZmbGluZVwiIC8qIEVycm9yQ29kZS5BUFBfT0ZGTElORSAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpblByb2dyZXNzRW50cnkgPSBtYWtlQXV0aFRva2VuUmVxdWVzdEluUHJvZ3Jlc3NFbnRyeShvbGRFbnRyeSk7XG4gICAgICAgICAgICB0b2tlblByb21pc2UgPSBmZXRjaEF1dGhUb2tlbkZyb21TZXJ2ZXIoaW5zdGFsbGF0aW9ucywgaW5Qcm9ncmVzc0VudHJ5KTtcbiAgICAgICAgICAgIHJldHVybiBpblByb2dyZXNzRW50cnk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBhdXRoVG9rZW4gPSB0b2tlblByb21pc2VcbiAgICAgICAgPyBhd2FpdCB0b2tlblByb21pc2VcbiAgICAgICAgOiBlbnRyeS5hdXRoVG9rZW47XG4gICAgcmV0dXJuIGF1dGhUb2tlbjtcbn1cbi8qKlxuICogQ2FsbCBvbmx5IGlmIEZJRCBpcyByZWdpc3RlcmVkIGFuZCBBdXRoIFRva2VuIHJlcXVlc3QgaXMgaW4gcHJvZ3Jlc3MuXG4gKlxuICogV2FpdHMgdW50aWwgdGhlIGN1cnJlbnQgcGVuZGluZyByZXF1ZXN0IGZpbmlzaGVzLiBJZiB0aGUgcmVxdWVzdCB0aW1lcyBvdXQsXG4gKiB0cmllcyBvbmNlIGluIHRoaXMgdGhyZWFkIGFzIHdlbGwuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHdhaXRVbnRpbEF1dGhUb2tlblJlcXVlc3QoaW5zdGFsbGF0aW9ucywgZm9yY2VSZWZyZXNoKSB7XG4gICAgLy8gVW5mb3J0dW5hdGVseSwgdGhlcmUgaXMgbm8gd2F5IG9mIHJlbGlhYmx5IG9ic2VydmluZyB3aGVuIGEgdmFsdWUgaW5cbiAgICAvLyBJbmRleGVkREIgY2hhbmdlcyAoeWV0LCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvaW5kZXhlZC1kYi1vYnNlcnZlcnMpLFxuICAgIC8vIHNvIHdlIG5lZWQgdG8gcG9sbC5cbiAgICBsZXQgZW50cnkgPSBhd2FpdCB1cGRhdGVBdXRoVG9rZW5SZXF1ZXN0KGluc3RhbGxhdGlvbnMuYXBwQ29uZmlnKTtcbiAgICB3aGlsZSAoZW50cnkuYXV0aFRva2VuLnJlcXVlc3RTdGF0dXMgPT09IDEgLyogUmVxdWVzdFN0YXR1cy5JTl9QUk9HUkVTUyAqLykge1xuICAgICAgICAvLyBnZW5lcmF0ZUF1dGhUb2tlbiBzdGlsbCBpbiBwcm9ncmVzcy5cbiAgICAgICAgYXdhaXQgc2xlZXAoMTAwKTtcbiAgICAgICAgZW50cnkgPSBhd2FpdCB1cGRhdGVBdXRoVG9rZW5SZXF1ZXN0KGluc3RhbGxhdGlvbnMuYXBwQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgYXV0aFRva2VuID0gZW50cnkuYXV0aFRva2VuO1xuICAgIGlmIChhdXRoVG9rZW4ucmVxdWVzdFN0YXR1cyA9PT0gMCAvKiBSZXF1ZXN0U3RhdHVzLk5PVF9TVEFSVEVEICovKSB7XG4gICAgICAgIC8vIFRoZSByZXF1ZXN0IHRpbWVkIG91dCBvciBmYWlsZWQgaW4gYSBkaWZmZXJlbnQgY2FsbC4gVHJ5IGFnYWluLlxuICAgICAgICByZXR1cm4gcmVmcmVzaEF1dGhUb2tlbihpbnN0YWxsYXRpb25zLCBmb3JjZVJlZnJlc2gpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGF1dGhUb2tlbjtcbiAgICB9XG59XG4vKipcbiAqIENhbGxlZCBvbmx5IGlmIHRoZXJlIGlzIGEgR2VuZXJhdGVBdXRoVG9rZW4gcmVxdWVzdCBpbiBwcm9ncmVzcy5cbiAqXG4gKiBVcGRhdGVzIHRoZSBJbnN0YWxsYXRpb25FbnRyeSBpbiB0aGUgREIgYmFzZWQgb24gdGhlIHN0YXR1cyBvZiB0aGVcbiAqIEdlbmVyYXRlQXV0aFRva2VuIHJlcXVlc3QuXG4gKlxuICogUmV0dXJucyB0aGUgdXBkYXRlZCBJbnN0YWxsYXRpb25FbnRyeS5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlQXV0aFRva2VuUmVxdWVzdChhcHBDb25maWcpIHtcbiAgICByZXR1cm4gdXBkYXRlKGFwcENvbmZpZywgb2xkRW50cnkgPT4ge1xuICAgICAgICBpZiAoIWlzRW50cnlSZWdpc3RlcmVkKG9sZEVudHJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJub3QtcmVnaXN0ZXJlZFwiIC8qIEVycm9yQ29kZS5OT1RfUkVHSVNURVJFRCAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkQXV0aFRva2VuID0gb2xkRW50cnkuYXV0aFRva2VuO1xuICAgICAgICBpZiAoaGFzQXV0aFRva2VuUmVxdWVzdFRpbWVkT3V0KG9sZEF1dGhUb2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9sZEVudHJ5KSwgeyBhdXRoVG9rZW46IHsgcmVxdWVzdFN0YXR1czogMCAvKiBSZXF1ZXN0U3RhdHVzLk5PVF9TVEFSVEVEICovIH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9sZEVudHJ5O1xuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hBdXRoVG9rZW5Gcm9tU2VydmVyKGluc3RhbGxhdGlvbnMsIGluc3RhbGxhdGlvbkVudHJ5KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYXV0aFRva2VuID0gYXdhaXQgZ2VuZXJhdGVBdXRoVG9rZW5SZXF1ZXN0KGluc3RhbGxhdGlvbnMsIGluc3RhbGxhdGlvbkVudHJ5KTtcbiAgICAgICAgY29uc3QgdXBkYXRlZEluc3RhbGxhdGlvbkVudHJ5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnN0YWxsYXRpb25FbnRyeSksIHsgYXV0aFRva2VuIH0pO1xuICAgICAgICBhd2FpdCBzZXQoaW5zdGFsbGF0aW9ucy5hcHBDb25maWcsIHVwZGF0ZWRJbnN0YWxsYXRpb25FbnRyeSk7XG4gICAgICAgIHJldHVybiBhdXRoVG9rZW47XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChpc1NlcnZlckVycm9yKGUpICYmXG4gICAgICAgICAgICAoZS5jdXN0b21EYXRhLnNlcnZlckNvZGUgPT09IDQwMSB8fCBlLmN1c3RvbURhdGEuc2VydmVyQ29kZSA9PT0gNDA0KSkge1xuICAgICAgICAgICAgLy8gU2VydmVyIHJldHVybmVkIGEgXCJGSUQgbm90IGZvdW5kXCIgb3IgYSBcIkludmFsaWQgYXV0aGVudGljYXRpb25cIiBlcnJvci5cbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIGEgbmV3IElEIG5leHQgdGltZS5cbiAgICAgICAgICAgIGF3YWl0IHJlbW92ZShpbnN0YWxsYXRpb25zLmFwcENvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkSW5zdGFsbGF0aW9uRW50cnkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluc3RhbGxhdGlvbkVudHJ5KSwgeyBhdXRoVG9rZW46IHsgcmVxdWVzdFN0YXR1czogMCAvKiBSZXF1ZXN0U3RhdHVzLk5PVF9TVEFSVEVEICovIH0gfSk7XG4gICAgICAgICAgICBhd2FpdCBzZXQoaW5zdGFsbGF0aW9ucy5hcHBDb25maWcsIHVwZGF0ZWRJbnN0YWxsYXRpb25FbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0VudHJ5UmVnaXN0ZXJlZChpbnN0YWxsYXRpb25FbnRyeSkge1xuICAgIHJldHVybiAoaW5zdGFsbGF0aW9uRW50cnkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBpbnN0YWxsYXRpb25FbnRyeS5yZWdpc3RyYXRpb25TdGF0dXMgPT09IDIgLyogUmVxdWVzdFN0YXR1cy5DT01QTEVURUQgKi8pO1xufVxuZnVuY3Rpb24gaXNBdXRoVG9rZW5WYWxpZChhdXRoVG9rZW4pIHtcbiAgICByZXR1cm4gKGF1dGhUb2tlbi5yZXF1ZXN0U3RhdHVzID09PSAyIC8qIFJlcXVlc3RTdGF0dXMuQ09NUExFVEVEICovICYmXG4gICAgICAgICFpc0F1dGhUb2tlbkV4cGlyZWQoYXV0aFRva2VuKSk7XG59XG5mdW5jdGlvbiBpc0F1dGhUb2tlbkV4cGlyZWQoYXV0aFRva2VuKSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICByZXR1cm4gKG5vdyA8IGF1dGhUb2tlbi5jcmVhdGlvblRpbWUgfHxcbiAgICAgICAgYXV0aFRva2VuLmNyZWF0aW9uVGltZSArIGF1dGhUb2tlbi5leHBpcmVzSW4gPCBub3cgKyBUT0tFTl9FWFBJUkFUSU9OX0JVRkZFUik7XG59XG4vKiogUmV0dXJucyBhbiB1cGRhdGVkIEluc3RhbGxhdGlvbkVudHJ5IHdpdGggYW4gSW5Qcm9ncmVzc0F1dGhUb2tlbi4gKi9cbmZ1bmN0aW9uIG1ha2VBdXRoVG9rZW5SZXF1ZXN0SW5Qcm9ncmVzc0VudHJ5KG9sZEVudHJ5KSB7XG4gICAgY29uc3QgaW5Qcm9ncmVzc0F1dGhUb2tlbiA9IHtcbiAgICAgICAgcmVxdWVzdFN0YXR1czogMSAvKiBSZXF1ZXN0U3RhdHVzLklOX1BST0dSRVNTICovLFxuICAgICAgICByZXF1ZXN0VGltZTogRGF0ZS5ub3coKVxuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb2xkRW50cnkpLCB7IGF1dGhUb2tlbjogaW5Qcm9ncmVzc0F1dGhUb2tlbiB9KTtcbn1cbmZ1bmN0aW9uIGhhc0F1dGhUb2tlblJlcXVlc3RUaW1lZE91dChhdXRoVG9rZW4pIHtcbiAgICByZXR1cm4gKGF1dGhUb2tlbi5yZXF1ZXN0U3RhdHVzID09PSAxIC8qIFJlcXVlc3RTdGF0dXMuSU5fUFJPR1JFU1MgKi8gJiZcbiAgICAgICAgYXV0aFRva2VuLnJlcXVlc3RUaW1lICsgUEVORElOR19USU1FT1VUX01TIDwgRGF0ZS5ub3coKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENyZWF0ZXMgYSBGaXJlYmFzZSBJbnN0YWxsYXRpb24gaWYgdGhlcmUgaXNuJ3Qgb25lIGZvciB0aGUgYXBwIGFuZFxuICogcmV0dXJucyB0aGUgSW5zdGFsbGF0aW9uIElELlxuICogQHBhcmFtIGluc3RhbGxhdGlvbnMgLSBUaGUgYEluc3RhbGxhdGlvbnNgIGluc3RhbmNlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0SWQoaW5zdGFsbGF0aW9ucykge1xuICAgIGNvbnN0IGluc3RhbGxhdGlvbnNJbXBsID0gaW5zdGFsbGF0aW9ucztcbiAgICBjb25zdCB7IGluc3RhbGxhdGlvbkVudHJ5LCByZWdpc3RyYXRpb25Qcm9taXNlIH0gPSBhd2FpdCBnZXRJbnN0YWxsYXRpb25FbnRyeShpbnN0YWxsYXRpb25zSW1wbCk7XG4gICAgaWYgKHJlZ2lzdHJhdGlvblByb21pc2UpIHtcbiAgICAgICAgcmVnaXN0cmF0aW9uUHJvbWlzZS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZSBpbnN0YWxsYXRpb24gaXMgYWxyZWFkeSByZWdpc3RlcmVkLCB1cGRhdGUgdGhlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgIC8vIHRva2VuIGlmIG5lZWRlZC5cbiAgICAgICAgcmVmcmVzaEF1dGhUb2tlbihpbnN0YWxsYXRpb25zSW1wbCkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgfVxuICAgIHJldHVybiBpbnN0YWxsYXRpb25FbnRyeS5maWQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJldHVybnMgYSBGaXJlYmFzZSBJbnN0YWxsYXRpb25zIGF1dGggdG9rZW4sIGlkZW50aWZ5aW5nIHRoZSBjdXJyZW50XG4gKiBGaXJlYmFzZSBJbnN0YWxsYXRpb24uXG4gKiBAcGFyYW0gaW5zdGFsbGF0aW9ucyAtIFRoZSBgSW5zdGFsbGF0aW9uc2AgaW5zdGFuY2UuXG4gKiBAcGFyYW0gZm9yY2VSZWZyZXNoIC0gRm9yY2UgcmVmcmVzaCByZWdhcmRsZXNzIG9mIHRva2VuIGV4cGlyYXRpb24uXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBnZXRUb2tlbihpbnN0YWxsYXRpb25zLCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xuICAgIGNvbnN0IGluc3RhbGxhdGlvbnNJbXBsID0gaW5zdGFsbGF0aW9ucztcbiAgICBhd2FpdCBjb21wbGV0ZUluc3RhbGxhdGlvblJlZ2lzdHJhdGlvbihpbnN0YWxsYXRpb25zSW1wbCk7XG4gICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBlaXRoZXIgaGF2ZSBhIFJlZ2lzdGVyZWQgSW5zdGFsbGF0aW9uIGluIHRoZSBEQiwgb3Igd2UndmVcbiAgICAvLyBhbHJlYWR5IHRocm93biBhbiBlcnJvci5cbiAgICBjb25zdCBhdXRoVG9rZW4gPSBhd2FpdCByZWZyZXNoQXV0aFRva2VuKGluc3RhbGxhdGlvbnNJbXBsLCBmb3JjZVJlZnJlc2gpO1xuICAgIHJldHVybiBhdXRoVG9rZW4udG9rZW47XG59XG5hc3luYyBmdW5jdGlvbiBjb21wbGV0ZUluc3RhbGxhdGlvblJlZ2lzdHJhdGlvbihpbnN0YWxsYXRpb25zKSB7XG4gICAgY29uc3QgeyByZWdpc3RyYXRpb25Qcm9taXNlIH0gPSBhd2FpdCBnZXRJbnN0YWxsYXRpb25FbnRyeShpbnN0YWxsYXRpb25zKTtcbiAgICBpZiAocmVnaXN0cmF0aW9uUHJvbWlzZSkge1xuICAgICAgICAvLyBBIGNyZWF0ZUluc3RhbGxhdGlvbiByZXF1ZXN0IGlzIGluIHByb2dyZXNzLiBXYWl0IHVudGlsIGl0IGZpbmlzaGVzLlxuICAgICAgICBhd2FpdCByZWdpc3RyYXRpb25Qcm9taXNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUluc3RhbGxhdGlvblJlcXVlc3QoYXBwQ29uZmlnLCBpbnN0YWxsYXRpb25FbnRyeSkge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gZ2V0RGVsZXRlRW5kcG9pbnQoYXBwQ29uZmlnLCBpbnN0YWxsYXRpb25FbnRyeSk7XG4gICAgY29uc3QgaGVhZGVycyA9IGdldEhlYWRlcnNXaXRoQXV0aChhcHBDb25maWcsIGluc3RhbGxhdGlvbkVudHJ5KTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICBoZWFkZXJzXG4gICAgfTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJldHJ5SWZTZXJ2ZXJFcnJvcigoKSA9PiBmZXRjaChlbmRwb2ludCwgcmVxdWVzdCkpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgYXdhaXQgZ2V0RXJyb3JGcm9tUmVzcG9uc2UoJ0RlbGV0ZSBJbnN0YWxsYXRpb24nLCByZXNwb25zZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RGVsZXRlRW5kcG9pbnQoYXBwQ29uZmlnLCB7IGZpZCB9KSB7XG4gICAgcmV0dXJuIGAke2dldEluc3RhbGxhdGlvbnNFbmRwb2ludChhcHBDb25maWcpfS8ke2ZpZH1gO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEZWxldGVzIHRoZSBGaXJlYmFzZSBJbnN0YWxsYXRpb24gYW5kIGFsbCBhc3NvY2lhdGVkIGRhdGEuXG4gKiBAcGFyYW0gaW5zdGFsbGF0aW9ucyAtIFRoZSBgSW5zdGFsbGF0aW9uc2AgaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBkZWxldGVJbnN0YWxsYXRpb25zKGluc3RhbGxhdGlvbnMpIHtcbiAgICBjb25zdCB7IGFwcENvbmZpZyB9ID0gaW5zdGFsbGF0aW9ucztcbiAgICBjb25zdCBlbnRyeSA9IGF3YWl0IHVwZGF0ZShhcHBDb25maWcsIG9sZEVudHJ5ID0+IHtcbiAgICAgICAgaWYgKG9sZEVudHJ5ICYmIG9sZEVudHJ5LnJlZ2lzdHJhdGlvblN0YXR1cyA9PT0gMCAvKiBSZXF1ZXN0U3RhdHVzLk5PVF9TVEFSVEVEICovKSB7XG4gICAgICAgICAgICAvLyBEZWxldGUgdGhlIHVucmVnaXN0ZXJlZCBlbnRyeSB3aXRob3V0IHNlbmRpbmcgYSBkZWxldGVJbnN0YWxsYXRpb24gcmVxdWVzdC5cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9sZEVudHJ5O1xuICAgIH0pO1xuICAgIGlmIChlbnRyeSkge1xuICAgICAgICBpZiAoZW50cnkucmVnaXN0cmF0aW9uU3RhdHVzID09PSAxIC8qIFJlcXVlc3RTdGF0dXMuSU5fUFJPR1JFU1MgKi8pIHtcbiAgICAgICAgICAgIC8vIENhbid0IGRlbGV0ZSB3aGlsZSB0cnlpbmcgdG8gcmVnaXN0ZXIuXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImRlbGV0ZS1wZW5kaW5nLXJlZ2lzdHJhdGlvblwiIC8qIEVycm9yQ29kZS5ERUxFVEVfUEVORElOR19SRUdJU1RSQVRJT04gKi8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVudHJ5LnJlZ2lzdHJhdGlvblN0YXR1cyA9PT0gMiAvKiBSZXF1ZXN0U3RhdHVzLkNPTVBMRVRFRCAqLykge1xuICAgICAgICAgICAgaWYgKCFuYXZpZ2F0b3Iub25MaW5lKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJhcHAtb2ZmbGluZVwiIC8qIEVycm9yQ29kZS5BUFBfT0ZGTElORSAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBkZWxldGVJbnN0YWxsYXRpb25SZXF1ZXN0KGFwcENvbmZpZywgZW50cnkpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHJlbW92ZShhcHBDb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBTZXRzIGEgbmV3IGNhbGxiYWNrIHRoYXQgd2lsbCBnZXQgY2FsbGVkIHdoZW4gSW5zdGFsbGF0aW9uIElEIGNoYW5nZXMuXG4gKiBSZXR1cm5zIGFuIHVuc3Vic2NyaWJlIGZ1bmN0aW9uIHRoYXQgd2lsbCByZW1vdmUgdGhlIGNhbGxiYWNrIHdoZW4gY2FsbGVkLlxuICogQHBhcmFtIGluc3RhbGxhdGlvbnMgLSBUaGUgYEluc3RhbGxhdGlvbnNgIGluc3RhbmNlLlxuICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZCB3aGVuIEZJRCBjaGFuZ2VzLlxuICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWQgdG8gdW5zdWJzY3JpYmUuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBvbklkQ2hhbmdlKGluc3RhbGxhdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgeyBhcHBDb25maWcgfSA9IGluc3RhbGxhdGlvbnM7XG4gICAgYWRkQ2FsbGJhY2soYXBwQ29uZmlnLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcmVtb3ZlQ2FsbGJhY2soYXBwQ29uZmlnLCBjYWxsYmFjayk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmV0dXJucyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgSW5zdGFsbGF0aW9uc30gYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlblxuICoge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VBcHB9IGluc3RhbmNlLlxuICogQHBhcmFtIGFwcCAtIFRoZSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBnZXRJbnN0YWxsYXRpb25zKGFwcCA9IGdldEFwcCgpKSB7XG4gICAgY29uc3QgaW5zdGFsbGF0aW9uc0ltcGwgPSBfZ2V0UHJvdmlkZXIoYXBwLCAnaW5zdGFsbGF0aW9ucycpLmdldEltbWVkaWF0ZSgpO1xuICAgIHJldHVybiBpbnN0YWxsYXRpb25zSW1wbDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RBcHBDb25maWcoYXBwKSB7XG4gICAgaWYgKCFhcHAgfHwgIWFwcC5vcHRpb25zKSB7XG4gICAgICAgIHRocm93IGdldE1pc3NpbmdWYWx1ZUVycm9yKCdBcHAgQ29uZmlndXJhdGlvbicpO1xuICAgIH1cbiAgICBpZiAoIWFwcC5uYW1lKSB7XG4gICAgICAgIHRocm93IGdldE1pc3NpbmdWYWx1ZUVycm9yKCdBcHAgTmFtZScpO1xuICAgIH1cbiAgICAvLyBSZXF1aXJlZCBhcHAgY29uZmlnIGtleXNcbiAgICBjb25zdCBjb25maWdLZXlzID0gW1xuICAgICAgICAncHJvamVjdElkJyxcbiAgICAgICAgJ2FwaUtleScsXG4gICAgICAgICdhcHBJZCdcbiAgICBdO1xuICAgIGZvciAoY29uc3Qga2V5TmFtZSBvZiBjb25maWdLZXlzKSB7XG4gICAgICAgIGlmICghYXBwLm9wdGlvbnNba2V5TmFtZV0pIHtcbiAgICAgICAgICAgIHRocm93IGdldE1pc3NpbmdWYWx1ZUVycm9yKGtleU5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGFwcE5hbWU6IGFwcC5uYW1lLFxuICAgICAgICBwcm9qZWN0SWQ6IGFwcC5vcHRpb25zLnByb2plY3RJZCxcbiAgICAgICAgYXBpS2V5OiBhcHAub3B0aW9ucy5hcGlLZXksXG4gICAgICAgIGFwcElkOiBhcHAub3B0aW9ucy5hcHBJZFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRNaXNzaW5nVmFsdWVFcnJvcih2YWx1ZU5hbWUpIHtcbiAgICByZXR1cm4gRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJtaXNzaW5nLWFwcC1jb25maWctdmFsdWVzXCIgLyogRXJyb3JDb2RlLk1JU1NJTkdfQVBQX0NPTkZJR19WQUxVRVMgKi8sIHtcbiAgICAgICAgdmFsdWVOYW1lXG4gICAgfSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBJTlNUQUxMQVRJT05TX05BTUUgPSAnaW5zdGFsbGF0aW9ucyc7XG5jb25zdCBJTlNUQUxMQVRJT05TX05BTUVfSU5URVJOQUwgPSAnaW5zdGFsbGF0aW9ucy1pbnRlcm5hbCc7XG5jb25zdCBwdWJsaWNGYWN0b3J5ID0gKGNvbnRhaW5lcikgPT4ge1xuICAgIGNvbnN0IGFwcCA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XG4gICAgLy8gVGhyb3dzIGlmIGFwcCBpc24ndCBjb25maWd1cmVkIHByb3Blcmx5LlxuICAgIGNvbnN0IGFwcENvbmZpZyA9IGV4dHJhY3RBcHBDb25maWcoYXBwKTtcbiAgICBjb25zdCBoZWFydGJlYXRTZXJ2aWNlUHJvdmlkZXIgPSBfZ2V0UHJvdmlkZXIoYXBwLCAnaGVhcnRiZWF0Jyk7XG4gICAgY29uc3QgaW5zdGFsbGF0aW9uc0ltcGwgPSB7XG4gICAgICAgIGFwcCxcbiAgICAgICAgYXBwQ29uZmlnLFxuICAgICAgICBoZWFydGJlYXRTZXJ2aWNlUHJvdmlkZXIsXG4gICAgICAgIF9kZWxldGU6ICgpID0+IFByb21pc2UucmVzb2x2ZSgpXG4gICAgfTtcbiAgICByZXR1cm4gaW5zdGFsbGF0aW9uc0ltcGw7XG59O1xuY29uc3QgaW50ZXJuYWxGYWN0b3J5ID0gKGNvbnRhaW5lcikgPT4ge1xuICAgIGNvbnN0IGFwcCA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XG4gICAgLy8gSW50ZXJuYWwgRklTIGluc3RhbmNlIHJlbGllcyBvbiBwdWJsaWMgRklTIGluc3RhbmNlLlxuICAgIGNvbnN0IGluc3RhbGxhdGlvbnMgPSBfZ2V0UHJvdmlkZXIoYXBwLCBJTlNUQUxMQVRJT05TX05BTUUpLmdldEltbWVkaWF0ZSgpO1xuICAgIGNvbnN0IGluc3RhbGxhdGlvbnNJbnRlcm5hbCA9IHtcbiAgICAgICAgZ2V0SWQ6ICgpID0+IGdldElkKGluc3RhbGxhdGlvbnMpLFxuICAgICAgICBnZXRUb2tlbjogKGZvcmNlUmVmcmVzaCkgPT4gZ2V0VG9rZW4oaW5zdGFsbGF0aW9ucywgZm9yY2VSZWZyZXNoKVxuICAgIH07XG4gICAgcmV0dXJuIGluc3RhbGxhdGlvbnNJbnRlcm5hbDtcbn07XG5mdW5jdGlvbiByZWdpc3Rlckluc3RhbGxhdGlvbnMoKSB7XG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoSU5TVEFMTEFUSU9OU19OQU1FLCBwdWJsaWNGYWN0b3J5LCBcIlBVQkxJQ1wiIC8qIENvbXBvbmVudFR5cGUuUFVCTElDICovKSk7XG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoSU5TVEFMTEFUSU9OU19OQU1FX0lOVEVSTkFMLCBpbnRlcm5hbEZhY3RvcnksIFwiUFJJVkFURVwiIC8qIENvbXBvbmVudFR5cGUuUFJJVkFURSAqLykpO1xufVxuXG4vKipcbiAqIFRoZSBGaXJlYmFzZSBJbnN0YWxsYXRpb25zIFdlYiBTREsuXG4gKiBUaGlzIFNESyBkb2VzIG5vdCB3b3JrIGluIGEgTm9kZS5qcyBlbnZpcm9ubWVudC5cbiAqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xucmVnaXN0ZXJJbnN0YWxsYXRpb25zKCk7XG5yZWdpc3RlclZlcnNpb24obmFtZSwgdmVyc2lvbik7XG4vLyBCVUlMRF9UQVJHRVQgd2lsbCBiZSByZXBsYWNlZCBieSB2YWx1ZXMgbGlrZSBlc20yMDE3LCBjanMyMDE3LCBldGMgZHVyaW5nIHRoZSBjb21waWxhdGlvblxucmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sICdlc20yMDE3Jyk7XG5cbmV4cG9ydCB7IGRlbGV0ZUluc3RhbGxhdGlvbnMsIGdldElkLCBnZXRJbnN0YWxsYXRpb25zLCBnZXRUb2tlbiwgb25JZENoYW5nZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/installations/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@firebase/logger/dist/esm/index.esm2017.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   Logger: () => (/* binding */ Logger),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   setUserLogHandler: () => (/* binding */ setUserLogHandler)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A container for all of the Logger instances\n */\nconst instances = [];\n/**\n * The JS SDK supports 5 log levels and also allows a user the ability to\n * silence the logs altogether.\n *\n * The order is a follows:\n * DEBUG < VERBOSE < INFO < WARN < ERROR\n *\n * All of the log types above the current log level will be captured (i.e. if\n * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and\n * `VERBOSE` logs will not)\n */\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogLevel[LogLevel[\"VERBOSE\"] = 1] = \"VERBOSE\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"WARN\"] = 3] = \"WARN\";\n    LogLevel[LogLevel[\"ERROR\"] = 4] = \"ERROR\";\n    LogLevel[LogLevel[\"SILENT\"] = 5] = \"SILENT\";\n})(LogLevel || (LogLevel = {}));\nconst levelStringToEnum = {\n    'debug': LogLevel.DEBUG,\n    'verbose': LogLevel.VERBOSE,\n    'info': LogLevel.INFO,\n    'warn': LogLevel.WARN,\n    'error': LogLevel.ERROR,\n    'silent': LogLevel.SILENT\n};\n/**\n * The default log level\n */\nconst defaultLogLevel = LogLevel.INFO;\n/**\n * By default, `console.debug` is not displayed in the developer console (in\n * chrome). To avoid forcing users to have to opt-in to these logs twice\n * (i.e. once for firebase, and once in the console), we are sending `DEBUG`\n * logs to the `console.log` function.\n */\nconst ConsoleMethod = {\n    [LogLevel.DEBUG]: 'log',\n    [LogLevel.VERBOSE]: 'log',\n    [LogLevel.INFO]: 'info',\n    [LogLevel.WARN]: 'warn',\n    [LogLevel.ERROR]: 'error'\n};\n/**\n * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR\n * messages on to their corresponding console counterparts (if the log method\n * is supported by the current log level)\n */\nconst defaultLogHandler = (instance, logType, ...args) => {\n    if (logType < instance.logLevel) {\n        return;\n    }\n    const now = new Date().toISOString();\n    const method = ConsoleMethod[logType];\n    if (method) {\n        console[method](`[${now}]  ${instance.name}:`, ...args);\n    }\n    else {\n        throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);\n    }\n};\nclass Logger {\n    /**\n     * Gives you an instance of a Logger to capture messages according to\n     * Firebase's logging scheme.\n     *\n     * @param name The name that the logs will be associated with\n     */\n    constructor(name) {\n        this.name = name;\n        /**\n         * The log level of the given Logger instance.\n         */\n        this._logLevel = defaultLogLevel;\n        /**\n         * The main (internal) log handler for the Logger instance.\n         * Can be set to a new function in internal package code but not by user.\n         */\n        this._logHandler = defaultLogHandler;\n        /**\n         * The optional, additional, user-defined log handler for the Logger instance.\n         */\n        this._userLogHandler = null;\n        /**\n         * Capture the current instance for later use\n         */\n        instances.push(this);\n    }\n    get logLevel() {\n        return this._logLevel;\n    }\n    set logLevel(val) {\n        if (!(val in LogLevel)) {\n            throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\n        }\n        this._logLevel = val;\n    }\n    // Workaround for setter/getter having to be the same type.\n    setLogLevel(val) {\n        this._logLevel = typeof val === 'string' ? levelStringToEnum[val] : val;\n    }\n    get logHandler() {\n        return this._logHandler;\n    }\n    set logHandler(val) {\n        if (typeof val !== 'function') {\n            throw new TypeError('Value assigned to `logHandler` must be a function');\n        }\n        this._logHandler = val;\n    }\n    get userLogHandler() {\n        return this._userLogHandler;\n    }\n    set userLogHandler(val) {\n        this._userLogHandler = val;\n    }\n    /**\n     * The functions below are all based on the `console` interface\n     */\n    debug(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);\n        this._logHandler(this, LogLevel.DEBUG, ...args);\n    }\n    log(...args) {\n        this._userLogHandler &&\n            this._userLogHandler(this, LogLevel.VERBOSE, ...args);\n        this._logHandler(this, LogLevel.VERBOSE, ...args);\n    }\n    info(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);\n        this._logHandler(this, LogLevel.INFO, ...args);\n    }\n    warn(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);\n        this._logHandler(this, LogLevel.WARN, ...args);\n    }\n    error(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);\n        this._logHandler(this, LogLevel.ERROR, ...args);\n    }\n}\nfunction setLogLevel(level) {\n    instances.forEach(inst => {\n        inst.setLogLevel(level);\n    });\n}\nfunction setUserLogHandler(logCallback, options) {\n    for (const instance of instances) {\n        let customLogLevel = null;\n        if (options && options.level) {\n            customLogLevel = levelStringToEnum[options.level];\n        }\n        if (logCallback === null) {\n            instance.userLogHandler = null;\n        }\n        else {\n            instance.userLogHandler = (instance, level, ...args) => {\n                const message = args\n                    .map(arg => {\n                    if (arg == null) {\n                        return null;\n                    }\n                    else if (typeof arg === 'string') {\n                        return arg;\n                    }\n                    else if (typeof arg === 'number' || typeof arg === 'boolean') {\n                        return arg.toString();\n                    }\n                    else if (arg instanceof Error) {\n                        return arg.message;\n                    }\n                    else {\n                        try {\n                            return JSON.stringify(arg);\n                        }\n                        catch (ignored) {\n                            return null;\n                        }\n                    }\n                })\n                    .filter(arg => arg)\n                    .join(' ');\n                if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) {\n                    logCallback({\n                        level: LogLevel[level].toLowerCase(),\n                        message,\n                        args,\n                        type: instance.name\n                    });\n                }\n            };\n        }\n    }\n}\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2xvZ2dlci9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixJQUFJLEtBQUssY0FBYztBQUNuRDtBQUNBO0FBQ0Esc0ZBQXNGLFFBQVE7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsSUFBSTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEQ7QUFDNUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9sb2dnZXIvZGlzdC9lc20vaW5kZXguZXNtMjAxNy5qcz9hOWVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEEgY29udGFpbmVyIGZvciBhbGwgb2YgdGhlIExvZ2dlciBpbnN0YW5jZXNcbiAqL1xuY29uc3QgaW5zdGFuY2VzID0gW107XG4vKipcbiAqIFRoZSBKUyBTREsgc3VwcG9ydHMgNSBsb2cgbGV2ZWxzIGFuZCBhbHNvIGFsbG93cyBhIHVzZXIgdGhlIGFiaWxpdHkgdG9cbiAqIHNpbGVuY2UgdGhlIGxvZ3MgYWx0b2dldGhlci5cbiAqXG4gKiBUaGUgb3JkZXIgaXMgYSBmb2xsb3dzOlxuICogREVCVUcgPCBWRVJCT1NFIDwgSU5GTyA8IFdBUk4gPCBFUlJPUlxuICpcbiAqIEFsbCBvZiB0aGUgbG9nIHR5cGVzIGFib3ZlIHRoZSBjdXJyZW50IGxvZyBsZXZlbCB3aWxsIGJlIGNhcHR1cmVkIChpLmUuIGlmXG4gKiB5b3Ugc2V0IHRoZSBsb2cgbGV2ZWwgdG8gYElORk9gLCBlcnJvcnMgd2lsbCBzdGlsbCBiZSBsb2dnZWQsIGJ1dCBgREVCVUdgIGFuZFxuICogYFZFUkJPU0VgIGxvZ3Mgd2lsbCBub3QpXG4gKi9cbnZhciBMb2dMZXZlbDtcbihmdW5jdGlvbiAoTG9nTGV2ZWwpIHtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkRFQlVHXCJdID0gMF0gPSBcIkRFQlVHXCI7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJWRVJCT1NFXCJdID0gMV0gPSBcIlZFUkJPU0VcIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIklORk9cIl0gPSAyXSA9IFwiSU5GT1wiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiV0FSTlwiXSA9IDNdID0gXCJXQVJOXCI7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJFUlJPUlwiXSA9IDRdID0gXCJFUlJPUlwiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiU0lMRU5UXCJdID0gNV0gPSBcIlNJTEVOVFwiO1xufSkoTG9nTGV2ZWwgfHwgKExvZ0xldmVsID0ge30pKTtcbmNvbnN0IGxldmVsU3RyaW5nVG9FbnVtID0ge1xuICAgICdkZWJ1Zyc6IExvZ0xldmVsLkRFQlVHLFxuICAgICd2ZXJib3NlJzogTG9nTGV2ZWwuVkVSQk9TRSxcbiAgICAnaW5mbyc6IExvZ0xldmVsLklORk8sXG4gICAgJ3dhcm4nOiBMb2dMZXZlbC5XQVJOLFxuICAgICdlcnJvcic6IExvZ0xldmVsLkVSUk9SLFxuICAgICdzaWxlbnQnOiBMb2dMZXZlbC5TSUxFTlRcbn07XG4vKipcbiAqIFRoZSBkZWZhdWx0IGxvZyBsZXZlbFxuICovXG5jb25zdCBkZWZhdWx0TG9nTGV2ZWwgPSBMb2dMZXZlbC5JTkZPO1xuLyoqXG4gKiBCeSBkZWZhdWx0LCBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGRpc3BsYXllZCBpbiB0aGUgZGV2ZWxvcGVyIGNvbnNvbGUgKGluXG4gKiBjaHJvbWUpLiBUbyBhdm9pZCBmb3JjaW5nIHVzZXJzIHRvIGhhdmUgdG8gb3B0LWluIHRvIHRoZXNlIGxvZ3MgdHdpY2VcbiAqIChpLmUuIG9uY2UgZm9yIGZpcmViYXNlLCBhbmQgb25jZSBpbiB0aGUgY29uc29sZSksIHdlIGFyZSBzZW5kaW5nIGBERUJVR2BcbiAqIGxvZ3MgdG8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24uXG4gKi9cbmNvbnN0IENvbnNvbGVNZXRob2QgPSB7XG4gICAgW0xvZ0xldmVsLkRFQlVHXTogJ2xvZycsXG4gICAgW0xvZ0xldmVsLlZFUkJPU0VdOiAnbG9nJyxcbiAgICBbTG9nTGV2ZWwuSU5GT106ICdpbmZvJyxcbiAgICBbTG9nTGV2ZWwuV0FSTl06ICd3YXJuJyxcbiAgICBbTG9nTGV2ZWwuRVJST1JdOiAnZXJyb3InXG59O1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBsb2cgaGFuZGxlciB3aWxsIGZvcndhcmQgREVCVUcsIFZFUkJPU0UsIElORk8sIFdBUk4sIGFuZCBFUlJPUlxuICogbWVzc2FnZXMgb24gdG8gdGhlaXIgY29ycmVzcG9uZGluZyBjb25zb2xlIGNvdW50ZXJwYXJ0cyAoaWYgdGhlIGxvZyBtZXRob2RcbiAqIGlzIHN1cHBvcnRlZCBieSB0aGUgY3VycmVudCBsb2cgbGV2ZWwpXG4gKi9cbmNvbnN0IGRlZmF1bHRMb2dIYW5kbGVyID0gKGluc3RhbmNlLCBsb2dUeXBlLCAuLi5hcmdzKSA9PiB7XG4gICAgaWYgKGxvZ1R5cGUgPCBpbnN0YW5jZS5sb2dMZXZlbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICBjb25zdCBtZXRob2QgPSBDb25zb2xlTWV0aG9kW2xvZ1R5cGVdO1xuICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgY29uc29sZVttZXRob2RdKGBbJHtub3d9XSAgJHtpbnN0YW5jZS5uYW1lfTpgLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0ZW1wdGVkIHRvIGxvZyBhIG1lc3NhZ2Ugd2l0aCBhbiBpbnZhbGlkIGxvZ1R5cGUgKHZhbHVlOiAke2xvZ1R5cGV9KWApO1xuICAgIH1cbn07XG5jbGFzcyBMb2dnZXIge1xuICAgIC8qKlxuICAgICAqIEdpdmVzIHlvdSBhbiBpbnN0YW5jZSBvZiBhIExvZ2dlciB0byBjYXB0dXJlIG1lc3NhZ2VzIGFjY29yZGluZyB0b1xuICAgICAqIEZpcmViYXNlJ3MgbG9nZ2luZyBzY2hlbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSB0aGF0IHRoZSBsb2dzIHdpbGwgYmUgYXNzb2NpYXRlZCB3aXRoXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxvZyBsZXZlbCBvZiB0aGUgZ2l2ZW4gTG9nZ2VyIGluc3RhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbG9nTGV2ZWwgPSBkZWZhdWx0TG9nTGV2ZWw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWFpbiAoaW50ZXJuYWwpIGxvZyBoYW5kbGVyIGZvciB0aGUgTG9nZ2VyIGluc3RhbmNlLlxuICAgICAgICAgKiBDYW4gYmUgc2V0IHRvIGEgbmV3IGZ1bmN0aW9uIGluIGludGVybmFsIHBhY2thZ2UgY29kZSBidXQgbm90IGJ5IHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyID0gZGVmYXVsdExvZ0hhbmRsZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb3B0aW9uYWwsIGFkZGl0aW9uYWwsIHVzZXItZGVmaW5lZCBsb2cgaGFuZGxlciBmb3IgdGhlIExvZ2dlciBpbnN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhcHR1cmUgdGhlIGN1cnJlbnQgaW5zdGFuY2UgZm9yIGxhdGVyIHVzZVxuICAgICAgICAgKi9cbiAgICAgICAgaW5zdGFuY2VzLnB1c2godGhpcyk7XG4gICAgfVxuICAgIGdldCBsb2dMZXZlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0xldmVsO1xuICAgIH1cbiAgICBzZXQgbG9nTGV2ZWwodmFsKSB7XG4gICAgICAgIGlmICghKHZhbCBpbiBMb2dMZXZlbCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgdmFsdWUgXCIke3ZhbH1cIiBhc3NpZ25lZCB0byBcXGBsb2dMZXZlbFxcYGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gdmFsO1xuICAgIH1cbiAgICAvLyBXb3JrYXJvdW5kIGZvciBzZXR0ZXIvZ2V0dGVyIGhhdmluZyB0byBiZSB0aGUgc2FtZSB0eXBlLlxuICAgIHNldExvZ0xldmVsKHZhbCkge1xuICAgICAgICB0aGlzLl9sb2dMZXZlbCA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gbGV2ZWxTdHJpbmdUb0VudW1bdmFsXSA6IHZhbDtcbiAgICB9XG4gICAgZ2V0IGxvZ0hhbmRsZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dIYW5kbGVyO1xuICAgIH1cbiAgICBzZXQgbG9nSGFuZGxlcih2YWwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1ZhbHVlIGFzc2lnbmVkIHRvIGBsb2dIYW5kbGVyYCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyID0gdmFsO1xuICAgIH1cbiAgICBnZXQgdXNlckxvZ0hhbmRsZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91c2VyTG9nSGFuZGxlcjtcbiAgICB9XG4gICAgc2V0IHVzZXJMb2dIYW5kbGVyKHZhbCkge1xuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciA9IHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9ucyBiZWxvdyBhcmUgYWxsIGJhc2VkIG9uIHRoZSBgY29uc29sZWAgaW50ZXJmYWNlXG4gICAgICovXG4gICAgZGVidWcoLi4uYXJncykge1xuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5ERUJVRywgLi4uYXJncyk7XG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuREVCVUcsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBsb2coLi4uYXJncykge1xuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJlxuICAgICAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuVkVSQk9TRSwgLi4uYXJncyk7XG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuVkVSQk9TRSwgLi4uYXJncyk7XG4gICAgfVxuICAgIGluZm8oLi4uYXJncykge1xuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5JTkZPLCAuLi5hcmdzKTtcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5JTkZPLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgd2FybiguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLldBUk4sIC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLldBUk4sIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBlcnJvciguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkVSUk9SLCAuLi5hcmdzKTtcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5FUlJPUiwgLi4uYXJncyk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWwpIHtcbiAgICBpbnN0YW5jZXMuZm9yRWFjaChpbnN0ID0+IHtcbiAgICAgICAgaW5zdC5zZXRMb2dMZXZlbChsZXZlbCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzZXRVc2VyTG9nSGFuZGxlcihsb2dDYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGZvciAoY29uc3QgaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKSB7XG4gICAgICAgIGxldCBjdXN0b21Mb2dMZXZlbCA9IG51bGw7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubGV2ZWwpIHtcbiAgICAgICAgICAgIGN1c3RvbUxvZ0xldmVsID0gbGV2ZWxTdHJpbmdUb0VudW1bb3B0aW9ucy5sZXZlbF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvZ0NhbGxiYWNrID09PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS51c2VyTG9nSGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnN0YW5jZS51c2VyTG9nSGFuZGxlciA9IChpbnN0YW5jZSwgbGV2ZWwsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYXJnc1xuICAgICAgICAgICAgICAgICAgICAubWFwKGFyZyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmcgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmcubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihhcmcgPT4gYXJnKVxuICAgICAgICAgICAgICAgICAgICAuam9pbignICcpO1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA+PSAoY3VzdG9tTG9nTGV2ZWwgIT09IG51bGwgJiYgY3VzdG9tTG9nTGV2ZWwgIT09IHZvaWQgMCA/IGN1c3RvbUxvZ0xldmVsIDogaW5zdGFuY2UubG9nTGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0NhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsOiBMb2dMZXZlbFtsZXZlbF0udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogaW5zdGFuY2UubmFtZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBMb2dMZXZlbCwgTG9nZ2VyLCBzZXRMb2dMZXZlbCwgc2V0VXNlckxvZ0hhbmRsZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbTIwMTcuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@firebase/util/dist/node-esm/index.node.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONSTANTS: () => (/* binding */ CONSTANTS),\n/* harmony export */   DecodeBase64StringError: () => (/* binding */ DecodeBase64StringError),\n/* harmony export */   Deferred: () => (/* binding */ Deferred),\n/* harmony export */   ErrorFactory: () => (/* binding */ ErrorFactory),\n/* harmony export */   FirebaseError: () => (/* binding */ FirebaseError),\n/* harmony export */   MAX_VALUE_MILLIS: () => (/* binding */ MAX_VALUE_MILLIS),\n/* harmony export */   RANDOM_FACTOR: () => (/* binding */ RANDOM_FACTOR),\n/* harmony export */   Sha1: () => (/* binding */ Sha1),\n/* harmony export */   areCookiesEnabled: () => (/* binding */ areCookiesEnabled),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertionError: () => (/* binding */ assertionError),\n/* harmony export */   async: () => (/* binding */ async),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64Decode: () => (/* binding */ base64Decode),\n/* harmony export */   base64Encode: () => (/* binding */ base64Encode),\n/* harmony export */   base64urlEncodeWithoutPadding: () => (/* binding */ base64urlEncodeWithoutPadding),\n/* harmony export */   calculateBackoffMillis: () => (/* binding */ calculateBackoffMillis),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   createMockUserToken: () => (/* binding */ createMockUserToken),\n/* harmony export */   createSubscribe: () => (/* binding */ createSubscribe),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   deepCopy: () => (/* binding */ deepCopy),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   deepExtend: () => (/* binding */ deepExtend),\n/* harmony export */   errorPrefix: () => (/* binding */ errorPrefix),\n/* harmony export */   extractQuerystring: () => (/* binding */ extractQuerystring),\n/* harmony export */   getDefaultAppConfig: () => (/* binding */ getDefaultAppConfig),\n/* harmony export */   getDefaultEmulatorHost: () => (/* binding */ getDefaultEmulatorHost),\n/* harmony export */   getDefaultEmulatorHostnameAndPort: () => (/* binding */ getDefaultEmulatorHostnameAndPort),\n/* harmony export */   getDefaults: () => (/* binding */ getDefaults),\n/* harmony export */   getExperimentalSetting: () => (/* binding */ getExperimentalSetting),\n/* harmony export */   getGlobal: () => (/* binding */ getGlobal),\n/* harmony export */   getModularInstance: () => (/* binding */ getModularInstance),\n/* harmony export */   getUA: () => (/* binding */ getUA),\n/* harmony export */   isAdmin: () => (/* binding */ isAdmin),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isBrowserExtension: () => (/* binding */ isBrowserExtension),\n/* harmony export */   isCloudflareWorker: () => (/* binding */ isCloudflareWorker),\n/* harmony export */   isElectron: () => (/* binding */ isElectron),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isIE: () => (/* binding */ isIE),\n/* harmony export */   isIndexedDBAvailable: () => (/* binding */ isIndexedDBAvailable),\n/* harmony export */   isMobileCordova: () => (/* binding */ isMobileCordova),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isNodeSdk: () => (/* binding */ isNodeSdk),\n/* harmony export */   isReactNative: () => (/* binding */ isReactNative),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isUWP: () => (/* binding */ isUWP),\n/* harmony export */   isValidFormat: () => (/* binding */ isValidFormat),\n/* harmony export */   isValidTimestamp: () => (/* binding */ isValidTimestamp),\n/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker),\n/* harmony export */   issuedAtTime: () => (/* binding */ issuedAtTime),\n/* harmony export */   jsonEval: () => (/* binding */ jsonEval),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   ordinal: () => (/* binding */ ordinal),\n/* harmony export */   promiseWithTimeout: () => (/* binding */ promiseWithTimeout),\n/* harmony export */   querystring: () => (/* binding */ querystring),\n/* harmony export */   querystringDecode: () => (/* binding */ querystringDecode),\n/* harmony export */   safeGet: () => (/* binding */ safeGet),\n/* harmony export */   stringLength: () => (/* binding */ stringLength),\n/* harmony export */   stringToByteArray: () => (/* binding */ stringToByteArray),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   uuidv4: () => (/* binding */ uuidv4),\n/* harmony export */   validateArgCount: () => (/* binding */ validateArgCount),\n/* harmony export */   validateCallback: () => (/* binding */ validateCallback),\n/* harmony export */   validateContextObject: () => (/* binding */ validateContextObject),\n/* harmony export */   validateIndexedDBOpenable: () => (/* binding */ validateIndexedDBOpenable),\n/* harmony export */   validateNamespace: () => (/* binding */ validateNamespace)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.\n */\nconst CONSTANTS = {\n    /**\n     * @define {boolean} Whether this is the client Node.js SDK.\n     */\n    NODE_CLIENT: false,\n    /**\n     * @define {boolean} Whether this is the Admin Node.js SDK.\n     */\n    NODE_ADMIN: false,\n    /**\n     * Firebase SDK Version\n     */\n    SDK_VERSION: '${JSCORE_VERSION}'\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Throws an error if the provided assertion is falsy\n */\nconst assert = function (assertion, message) {\n    if (!assertion) {\n        throw assertionError(message);\n    }\n};\n/**\n * Returns an Error object suitable for throwing.\n */\nconst assertionError = function (message) {\n    return new Error('Firebase Database (' +\n        CONSTANTS.SDK_VERSION +\n        ') INTERNAL ASSERT FAILED: ' +\n        message);\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst stringToByteArray$1 = function (str) {\n    // TODO(user): Use native implementations if/when available\n    const out = [];\n    let p = 0;\n    for (let i = 0; i < str.length; i++) {\n        let c = str.charCodeAt(i);\n        if (c < 128) {\n            out[p++] = c;\n        }\n        else if (c < 2048) {\n            out[p++] = (c >> 6) | 192;\n            out[p++] = (c & 63) | 128;\n        }\n        else if ((c & 0xfc00) === 0xd800 &&\n            i + 1 < str.length &&\n            (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {\n            // Surrogate Pair\n            c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);\n            out[p++] = (c >> 18) | 240;\n            out[p++] = ((c >> 12) & 63) | 128;\n            out[p++] = ((c >> 6) & 63) | 128;\n            out[p++] = (c & 63) | 128;\n        }\n        else {\n            out[p++] = (c >> 12) | 224;\n            out[p++] = ((c >> 6) & 63) | 128;\n            out[p++] = (c & 63) | 128;\n        }\n    }\n    return out;\n};\n/**\n * Turns an array of numbers into the string given by the concatenation of the\n * characters to which the numbers correspond.\n * @param bytes Array of numbers representing characters.\n * @return Stringification of the array.\n */\nconst byteArrayToString = function (bytes) {\n    // TODO(user): Use native implementations if/when available\n    const out = [];\n    let pos = 0, c = 0;\n    while (pos < bytes.length) {\n        const c1 = bytes[pos++];\n        if (c1 < 128) {\n            out[c++] = String.fromCharCode(c1);\n        }\n        else if (c1 > 191 && c1 < 224) {\n            const c2 = bytes[pos++];\n            out[c++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));\n        }\n        else if (c1 > 239 && c1 < 365) {\n            // Surrogate Pair\n            const c2 = bytes[pos++];\n            const c3 = bytes[pos++];\n            const c4 = bytes[pos++];\n            const u = (((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63)) -\n                0x10000;\n            out[c++] = String.fromCharCode(0xd800 + (u >> 10));\n            out[c++] = String.fromCharCode(0xdc00 + (u & 1023));\n        }\n        else {\n            const c2 = bytes[pos++];\n            const c3 = bytes[pos++];\n            out[c++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n        }\n    }\n    return out.join('');\n};\n// We define it as an object literal instead of a class because a class compiled down to es5 can't\n// be treeshaked. https://github.com/rollup/rollup/issues/1691\n// Static lookup maps, lazily populated by init_()\n// TODO(dlarocque): Define this as a class, since we no longer target ES5.\nconst base64 = {\n    /**\n     * Maps bytes to characters.\n     */\n    byteToCharMap_: null,\n    /**\n     * Maps characters to bytes.\n     */\n    charToByteMap_: null,\n    /**\n     * Maps bytes to websafe characters.\n     * @private\n     */\n    byteToCharMapWebSafe_: null,\n    /**\n     * Maps websafe characters to bytes.\n     * @private\n     */\n    charToByteMapWebSafe_: null,\n    /**\n     * Our default alphabet, shared between\n     * ENCODED_VALS and ENCODED_VALS_WEBSAFE\n     */\n    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',\n    /**\n     * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\n     */\n    get ENCODED_VALS() {\n        return this.ENCODED_VALS_BASE + '+/=';\n    },\n    /**\n     * Our websafe alphabet.\n     */\n    get ENCODED_VALS_WEBSAFE() {\n        return this.ENCODED_VALS_BASE + '-_.';\n    },\n    /**\n     * Whether this browser supports the atob and btoa functions. This extension\n     * started at Mozilla but is now implemented by many browsers. We use the\n     * ASSUME_* variables to avoid pulling in the full useragent detection library\n     * but still allowing the standard per-browser compilations.\n     *\n     */\n    HAS_NATIVE_SUPPORT: typeof atob === 'function',\n    /**\n     * Base64-encode an array of bytes.\n     *\n     * @param input An array of bytes (numbers with\n     *     value in [0, 255]) to encode.\n     * @param webSafe Boolean indicating we should use the\n     *     alternative alphabet.\n     * @return The base64 encoded string.\n     */\n    encodeByteArray(input, webSafe) {\n        if (!Array.isArray(input)) {\n            throw Error('encodeByteArray takes an array as a parameter');\n        }\n        this.init_();\n        const byteToCharMap = webSafe\n            ? this.byteToCharMapWebSafe_\n            : this.byteToCharMap_;\n        const output = [];\n        for (let i = 0; i < input.length; i += 3) {\n            const byte1 = input[i];\n            const haveByte2 = i + 1 < input.length;\n            const byte2 = haveByte2 ? input[i + 1] : 0;\n            const haveByte3 = i + 2 < input.length;\n            const byte3 = haveByte3 ? input[i + 2] : 0;\n            const outByte1 = byte1 >> 2;\n            const outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);\n            let outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);\n            let outByte4 = byte3 & 0x3f;\n            if (!haveByte3) {\n                outByte4 = 64;\n                if (!haveByte2) {\n                    outByte3 = 64;\n                }\n            }\n            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);\n        }\n        return output.join('');\n    },\n    /**\n     * Base64-encode a string.\n     *\n     * @param input A string to encode.\n     * @param webSafe If true, we should use the\n     *     alternative alphabet.\n     * @return The base64 encoded string.\n     */\n    encodeString(input, webSafe) {\n        // Shortcut for Mozilla browsers that implement\n        // a native base64 encoder in the form of \"btoa/atob\"\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n            return btoa(input);\n        }\n        return this.encodeByteArray(stringToByteArray$1(input), webSafe);\n    },\n    /**\n     * Base64-decode a string.\n     *\n     * @param input to decode.\n     * @param webSafe True if we should use the\n     *     alternative alphabet.\n     * @return string representing the decoded value.\n     */\n    decodeString(input, webSafe) {\n        // Shortcut for Mozilla browsers that implement\n        // a native base64 encoder in the form of \"btoa/atob\"\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n            return atob(input);\n        }\n        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));\n    },\n    /**\n     * Base64-decode a string.\n     *\n     * In base-64 decoding, groups of four characters are converted into three\n     * bytes.  If the encoder did not apply padding, the input length may not\n     * be a multiple of 4.\n     *\n     * In this case, the last group will have fewer than 4 characters, and\n     * padding will be inferred.  If the group has one or two characters, it decodes\n     * to one byte.  If the group has three characters, it decodes to two bytes.\n     *\n     * @param input Input to decode.\n     * @param webSafe True if we should use the web-safe alphabet.\n     * @return bytes representing the decoded value.\n     */\n    decodeStringToByteArray(input, webSafe) {\n        this.init_();\n        const charToByteMap = webSafe\n            ? this.charToByteMapWebSafe_\n            : this.charToByteMap_;\n        const output = [];\n        for (let i = 0; i < input.length;) {\n            const byte1 = charToByteMap[input.charAt(i++)];\n            const haveByte2 = i < input.length;\n            const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\n            ++i;\n            const haveByte3 = i < input.length;\n            const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\n            ++i;\n            const haveByte4 = i < input.length;\n            const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\n            ++i;\n            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\n                throw new DecodeBase64StringError();\n            }\n            const outByte1 = (byte1 << 2) | (byte2 >> 4);\n            output.push(outByte1);\n            if (byte3 !== 64) {\n                const outByte2 = ((byte2 << 4) & 0xf0) | (byte3 >> 2);\n                output.push(outByte2);\n                if (byte4 !== 64) {\n                    const outByte3 = ((byte3 << 6) & 0xc0) | byte4;\n                    output.push(outByte3);\n                }\n            }\n        }\n        return output;\n    },\n    /**\n     * Lazy static initialization function. Called before\n     * accessing any of the static map variables.\n     * @private\n     */\n    init_() {\n        if (!this.byteToCharMap_) {\n            this.byteToCharMap_ = {};\n            this.charToByteMap_ = {};\n            this.byteToCharMapWebSafe_ = {};\n            this.charToByteMapWebSafe_ = {};\n            // We want quick mappings back and forth, so we precompute two maps.\n            for (let i = 0; i < this.ENCODED_VALS.length; i++) {\n                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\n                this.charToByteMap_[this.byteToCharMap_[i]] = i;\n                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\n                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;\n                // Be forgiving when decoding and correctly decode both encodings.\n                if (i >= this.ENCODED_VALS_BASE.length) {\n                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\n                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\n                }\n            }\n        }\n    }\n};\n/**\n * An error encountered while decoding base64 string.\n */\nclass DecodeBase64StringError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'DecodeBase64StringError';\n    }\n}\n/**\n * URL-safe base64 encoding\n */\nconst base64Encode = function (str) {\n    const utf8Bytes = stringToByteArray$1(str);\n    return base64.encodeByteArray(utf8Bytes, true);\n};\n/**\n * URL-safe base64 encoding (without \".\" padding in the end).\n * e.g. Used in JSON Web Token (JWT) parts.\n */\nconst base64urlEncodeWithoutPadding = function (str) {\n    // Use base64url encoding and remove padding in the end (dot characters).\n    return base64Encode(str).replace(/\\./g, '');\n};\n/**\n * URL-safe base64 decoding\n *\n * NOTE: DO NOT use the global atob() function - it does NOT support the\n * base64Url variant encoding.\n *\n * @param str To be decoded\n * @return Decoded result, if possible\n */\nconst base64Decode = function (str) {\n    try {\n        return base64.decodeString(str, true);\n    }\n    catch (e) {\n        console.error('base64Decode failed: ', e);\n    }\n    return null;\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Do a deep-copy of basic JavaScript Objects or Arrays.\n */\nfunction deepCopy(value) {\n    return deepExtend(undefined, value);\n}\n/**\n * Copy properties from source to target (recursively allows extension\n * of Objects and Arrays).  Scalar values in the target are over-written.\n * If target is undefined, an object of the appropriate type will be created\n * (and returned).\n *\n * We recursively copy all child properties of plain Objects in the source- so\n * that namespace- like dictionaries are merged.\n *\n * Note that the target can be a function, in which case the properties in\n * the source Object are copied onto it as static properties of the Function.\n *\n * Note: we don't merge __proto__ to prevent prototype pollution\n */\nfunction deepExtend(target, source) {\n    if (!(source instanceof Object)) {\n        return source;\n    }\n    switch (source.constructor) {\n        case Date:\n            // Treat Dates like scalars; if the target date object had any child\n            // properties - they will be lost!\n            const dateValue = source;\n            return new Date(dateValue.getTime());\n        case Object:\n            if (target === undefined) {\n                target = {};\n            }\n            break;\n        case Array:\n            // Always copy the array source and overwrite the target.\n            target = [];\n            break;\n        default:\n            // Not a plain Object - treat it as a scalar.\n            return source;\n    }\n    for (const prop in source) {\n        // use isValidKey to guard against prototype pollution. See https://snyk.io/vuln/SNYK-JS-LODASH-450202\n        if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {\n            continue;\n        }\n        target[prop] = deepExtend(target[prop], source[prop]);\n    }\n    return target;\n}\nfunction isValidKey(key) {\n    return key !== '__proto__';\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Polyfill for `globalThis` object.\n * @returns the `globalThis` object for the given environment.\n * @public\n */\nfunction getGlobal() {\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('Unable to locate global object.');\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst getDefaultsFromGlobal = () => getGlobal().__FIREBASE_DEFAULTS__;\n/**\n * Attempt to read defaults from a JSON string provided to\n * process(.)env(.)__FIREBASE_DEFAULTS__ or a JSON file whose path is in\n * process(.)env(.)__FIREBASE_DEFAULTS_PATH__\n * The dots are in parens because certain compilers (Vite?) cannot\n * handle seeing that variable in comments.\n * See https://github.com/firebase/firebase-js-sdk/issues/6838\n */\nconst getDefaultsFromEnvVariable = () => {\n    if (typeof process === 'undefined' || typeof process.env === 'undefined') {\n        return;\n    }\n    const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;\n    if (defaultsJsonString) {\n        return JSON.parse(defaultsJsonString);\n    }\n};\nconst getDefaultsFromCookie = () => {\n    if (typeof document === 'undefined') {\n        return;\n    }\n    let match;\n    try {\n        match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);\n    }\n    catch (e) {\n        // Some environments such as Angular Universal SSR have a\n        // `document` object but error on accessing `document.cookie`.\n        return;\n    }\n    const decoded = match && base64Decode(match[1]);\n    return decoded && JSON.parse(decoded);\n};\n/**\n * Get the __FIREBASE_DEFAULTS__ object. It checks in order:\n * (1) if such an object exists as a property of `globalThis`\n * (2) if such an object was provided on a shell environment variable\n * (3) if such an object exists in a cookie\n * @public\n */\nconst getDefaults = () => {\n    try {\n        return (getDefaultsFromGlobal() ||\n            getDefaultsFromEnvVariable() ||\n            getDefaultsFromCookie());\n    }\n    catch (e) {\n        /**\n         * Catch-all for being unable to get __FIREBASE_DEFAULTS__ due\n         * to any environment case we have not accounted for. Log to\n         * info instead of swallowing so we can find these unknown cases\n         * and add paths for them if needed.\n         */\n        console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);\n        return;\n    }\n};\n/**\n * Returns emulator host stored in the __FIREBASE_DEFAULTS__ object\n * for the given product.\n * @returns a URL host formatted like `127.0.0.1:9999` or `[::1]:4000` if available\n * @public\n */\nconst getDefaultEmulatorHost = (productName) => { var _a, _b; return (_b = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.emulatorHosts) === null || _b === void 0 ? void 0 : _b[productName]; };\n/**\n * Returns emulator hostname and port stored in the __FIREBASE_DEFAULTS__ object\n * for the given product.\n * @returns a pair of hostname and port like `[\"::1\", 4000]` if available\n * @public\n */\nconst getDefaultEmulatorHostnameAndPort = (productName) => {\n    const host = getDefaultEmulatorHost(productName);\n    if (!host) {\n        return undefined;\n    }\n    const separatorIndex = host.lastIndexOf(':'); // Finding the last since IPv6 addr also has colons.\n    if (separatorIndex <= 0 || separatorIndex + 1 === host.length) {\n        throw new Error(`Invalid host ${host} with no separate hostname and port!`);\n    }\n    // eslint-disable-next-line no-restricted-globals\n    const port = parseInt(host.substring(separatorIndex + 1), 10);\n    if (host[0] === '[') {\n        // Bracket-quoted `[ipv6addr]:port` => return \"ipv6addr\" (without brackets).\n        return [host.substring(1, separatorIndex - 1), port];\n    }\n    else {\n        return [host.substring(0, separatorIndex), port];\n    }\n};\n/**\n * Returns Firebase app config stored in the __FIREBASE_DEFAULTS__ object.\n * @public\n */\nconst getDefaultAppConfig = () => { var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config; };\n/**\n * Returns an experimental setting on the __FIREBASE_DEFAULTS__ object (properties\n * prefixed by \"_\")\n * @public\n */\nconst getExperimentalSetting = (name) => { var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a[`_${name}`]; };\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass Deferred {\n    constructor() {\n        this.reject = () => { };\n        this.resolve = () => { };\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n    /**\n     * Our API internals are not promisified and cannot because our callback APIs have subtle expectations around\n     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\n     * and returns a node-style callback which will resolve or reject the Deferred's promise.\n     */\n    wrapCallback(callback) {\n        return (error, value) => {\n            if (error) {\n                this.reject(error);\n            }\n            else {\n                this.resolve(value);\n            }\n            if (typeof callback === 'function') {\n                // Attaching noop handler just in case developer wasn't expecting\n                // promises\n                this.promise.catch(() => { });\n                // Some of our callbacks don't expect a value and our own tests\n                // assert that the parameter length is 1\n                if (callback.length === 1) {\n                    callback(error);\n                }\n                else {\n                    callback(error, value);\n                }\n            }\n        };\n    }\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction createMockUserToken(token, projectId) {\n    if (token.uid) {\n        throw new Error('The \"uid\" field is no longer supported by mockUserToken. Please use \"sub\" instead for Firebase Auth User ID.');\n    }\n    // Unsecured JWTs use \"none\" as the algorithm.\n    const header = {\n        alg: 'none',\n        type: 'JWT'\n    };\n    const project = projectId || 'demo-project';\n    const iat = token.iat || 0;\n    const sub = token.sub || token.user_id;\n    if (!sub) {\n        throw new Error(\"mockUserToken must contain 'sub' or 'user_id' field!\");\n    }\n    const payload = Object.assign({ \n        // Set all required fields to decent defaults\n        iss: `https://securetoken.google.com/${project}`, aud: project, iat, exp: iat + 3600, auth_time: iat, sub, user_id: sub, firebase: {\n            sign_in_provider: 'custom',\n            identities: {}\n        } }, token);\n    // Unsecured JWTs use the empty string as a signature.\n    const signature = '';\n    return [\n        base64urlEncodeWithoutPadding(JSON.stringify(header)),\n        base64urlEncodeWithoutPadding(JSON.stringify(payload)),\n        signature\n    ].join('.');\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns navigator.userAgent string or '' if it's not defined.\n * @return user agent string\n */\nfunction getUA() {\n    if (typeof navigator !== 'undefined' &&\n        typeof navigator['userAgent'] === 'string') {\n        return navigator['userAgent'];\n    }\n    else {\n        return '';\n    }\n}\n/**\n * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.\n *\n * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap\n * in the Ripple emulator) nor Cordova `onDeviceReady`, which would normally\n * wait for a callback.\n */\nfunction isMobileCordova() {\n    return (typeof window !== 'undefined' &&\n        // @ts-ignore Setting up an broadly applicable index signature for Window\n        // just to deal with this case would probably be a bad idea.\n        !!(window['cordova'] || window['phonegap'] || window['PhoneGap']) &&\n        /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA()));\n}\n/**\n * Detect Node.js.\n *\n * @return true if Node.js environment is detected or specified.\n */\n// Node detection logic from: https://github.com/iliakan/detect-node/\nfunction isNode() {\n    var _a;\n    const forceEnvironment = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.forceEnvironment;\n    if (forceEnvironment === 'node') {\n        return true;\n    }\n    else if (forceEnvironment === 'browser') {\n        return false;\n    }\n    try {\n        return (Object.prototype.toString.call(global.process) === '[object process]');\n    }\n    catch (e) {\n        return false;\n    }\n}\n/**\n * Detect Browser Environment.\n * Note: This will return true for certain test frameworks that are incompletely\n * mimicking a browser, and should not lead to assuming all browser APIs are\n * available.\n */\nfunction isBrowser() {\n    return typeof window !== 'undefined' || isWebWorker();\n}\n/**\n * Detect Web Worker context.\n */\nfunction isWebWorker() {\n    return (typeof WorkerGlobalScope !== 'undefined' &&\n        typeof self !== 'undefined' &&\n        self instanceof WorkerGlobalScope);\n}\n/**\n * Detect Cloudflare Worker context.\n */\nfunction isCloudflareWorker() {\n    return (typeof navigator !== 'undefined' &&\n        navigator.userAgent === 'Cloudflare-Workers');\n}\nfunction isBrowserExtension() {\n    const runtime = typeof chrome === 'object'\n        ? chrome.runtime\n        : typeof browser === 'object'\n            ? browser.runtime\n            : undefined;\n    return typeof runtime === 'object' && runtime.id !== undefined;\n}\n/**\n * Detect React Native.\n *\n * @return true if ReactNative environment is detected.\n */\nfunction isReactNative() {\n    return (typeof navigator === 'object' && navigator['product'] === 'ReactNative');\n}\n/** Detects Electron apps. */\nfunction isElectron() {\n    return getUA().indexOf('Electron/') >= 0;\n}\n/** Detects Internet Explorer. */\nfunction isIE() {\n    const ua = getUA();\n    return ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;\n}\n/** Detects Universal Windows Platform apps. */\nfunction isUWP() {\n    return getUA().indexOf('MSAppHost/') >= 0;\n}\n/**\n * Detect whether the current SDK build is the Node version.\n *\n * @return true if it's the Node SDK build.\n */\nfunction isNodeSdk() {\n    return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;\n}\n/** Returns true if we are running in Safari. */\nfunction isSafari() {\n    return (!isNode() &&\n        !!navigator.userAgent &&\n        navigator.userAgent.includes('Safari') &&\n        !navigator.userAgent.includes('Chrome'));\n}\n/**\n * This method checks if indexedDB is supported by current browser/service worker context\n * @return true if indexedDB is supported by current browser/service worker context\n */\nfunction isIndexedDBAvailable() {\n    try {\n        return typeof indexedDB === 'object';\n    }\n    catch (e) {\n        return false;\n    }\n}\n/**\n * This method validates browser/sw context for indexedDB by opening a dummy indexedDB database and reject\n * if errors occur during the database open operation.\n *\n * @throws exception if current browser/sw context can't run idb.open (ex: Safari iframe, Firefox\n * private browsing)\n */\nfunction validateIndexedDBOpenable() {\n    return new Promise((resolve, reject) => {\n        try {\n            let preExist = true;\n            const DB_CHECK_NAME = 'validate-browser-context-for-indexeddb-analytics-module';\n            const request = self.indexedDB.open(DB_CHECK_NAME);\n            request.onsuccess = () => {\n                request.result.close();\n                // delete database only when it doesn't pre-exist\n                if (!preExist) {\n                    self.indexedDB.deleteDatabase(DB_CHECK_NAME);\n                }\n                resolve(true);\n            };\n            request.onupgradeneeded = () => {\n                preExist = false;\n            };\n            request.onerror = () => {\n                var _a;\n                reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || '');\n            };\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\n/**\n *\n * This method checks whether cookie is enabled within current browser\n * @return true if cookie is enabled within current browser\n */\nfunction areCookiesEnabled() {\n    if (typeof navigator === 'undefined' || !navigator.cookieEnabled) {\n        return false;\n    }\n    return true;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Standardized Firebase Error.\n *\n * Usage:\n *\n *   // TypeScript string literals for type-safe codes\n *   type Err =\n *     'unknown' |\n *     'object-not-found'\n *     ;\n *\n *   // Closure enum for type-safe error codes\n *   // at-enum {string}\n *   var Err = {\n *     UNKNOWN: 'unknown',\n *     OBJECT_NOT_FOUND: 'object-not-found',\n *   }\n *\n *   let errors: Map<Err, string> = {\n *     'generic-error': \"Unknown error\",\n *     'file-not-found': \"Could not find file: {$file}\",\n *   };\n *\n *   // Type-safe function - must pass a valid error code as param.\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\n *\n *   ...\n *   throw error.create(Err.GENERIC);\n *   ...\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\n *   ...\n *   // Service: Could not file file: foo.txt (service/file-not-found).\n *\n *   catch (e) {\n *     assert(e.message === \"Could not find file: foo.txt.\");\n *     if ((e as FirebaseError)?.code === 'service/file-not-found') {\n *       console.log(\"Could not read file: \" + e['file']);\n *     }\n *   }\n */\nconst ERROR_NAME = 'FirebaseError';\n// Based on code from:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types\nclass FirebaseError extends Error {\n    constructor(\n    /** The error code for this error. */\n    code, message, \n    /** Custom data for this error. */\n    customData) {\n        super(message);\n        this.code = code;\n        this.customData = customData;\n        /** The custom name for all FirebaseErrors. */\n        this.name = ERROR_NAME;\n        // Fix For ES5\n        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        // TODO(dlarocque): Replace this with `new.target`: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#support-for-newtarget\n        //                   which we can now use since we no longer target ES5.\n        Object.setPrototypeOf(this, FirebaseError.prototype);\n        // Maintains proper stack trace for where our error was thrown.\n        // Only available on V8.\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, ErrorFactory.prototype.create);\n        }\n    }\n}\nclass ErrorFactory {\n    constructor(service, serviceName, errors) {\n        this.service = service;\n        this.serviceName = serviceName;\n        this.errors = errors;\n    }\n    create(code, ...data) {\n        const customData = data[0] || {};\n        const fullCode = `${this.service}/${code}`;\n        const template = this.errors[code];\n        const message = template ? replaceTemplate(template, customData) : 'Error';\n        // Service Name: Error message (service/code).\n        const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;\n        const error = new FirebaseError(fullCode, fullMessage, customData);\n        return error;\n    }\n}\nfunction replaceTemplate(template, data) {\n    return template.replace(PATTERN, (_, key) => {\n        const value = data[key];\n        return value != null ? String(value) : `<${key}?>`;\n    });\n}\nconst PATTERN = /\\{\\$([^}]+)}/g;\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Evaluates a JSON string into a javascript object.\n *\n * @param {string} str A string containing JSON.\n * @return {*} The javascript object representing the specified JSON.\n */\nfunction jsonEval(str) {\n    return JSON.parse(str);\n}\n/**\n * Returns JSON representing a javascript object.\n * @param {*} data JavaScript object to be stringified.\n * @return {string} The JSON contents of the object.\n */\nfunction stringify(data) {\n    return JSON.stringify(data);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Decodes a Firebase auth. token into constituent parts.\n *\n * Notes:\n * - May return with invalid / incomplete claims if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst decode = function (token) {\n    let header = {}, claims = {}, data = {}, signature = '';\n    try {\n        const parts = token.split('.');\n        header = jsonEval(base64Decode(parts[0]) || '');\n        claims = jsonEval(base64Decode(parts[1]) || '');\n        signature = parts[2];\n        data = claims['d'] || {};\n        delete claims['d'];\n    }\n    catch (e) { }\n    return {\n        header,\n        claims,\n        data,\n        signature\n    };\n};\n/**\n * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the\n * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst isValidTimestamp = function (token) {\n    const claims = decode(token).claims;\n    const now = Math.floor(new Date().getTime() / 1000);\n    let validSince = 0, validUntil = 0;\n    if (typeof claims === 'object') {\n        if (claims.hasOwnProperty('nbf')) {\n            validSince = claims['nbf'];\n        }\n        else if (claims.hasOwnProperty('iat')) {\n            validSince = claims['iat'];\n        }\n        if (claims.hasOwnProperty('exp')) {\n            validUntil = claims['exp'];\n        }\n        else {\n            // token will expire after 24h by default\n            validUntil = validSince + 86400;\n        }\n    }\n    return (!!now &&\n        !!validSince &&\n        !!validUntil &&\n        now >= validSince &&\n        now <= validUntil);\n};\n/**\n * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.\n *\n * Notes:\n * - May return null if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst issuedAtTime = function (token) {\n    const claims = decode(token).claims;\n    if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {\n        return claims['iat'];\n    }\n    return null;\n};\n/**\n * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst isValidFormat = function (token) {\n    const decoded = decode(token), claims = decoded.claims;\n    return !!claims && typeof claims === 'object' && claims.hasOwnProperty('iat');\n};\n/**\n * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst isAdmin = function (token) {\n    const claims = decode(token).claims;\n    return typeof claims === 'object' && claims['admin'] === true;\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction contains(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nfunction safeGet(obj, key) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        return obj[key];\n    }\n    else {\n        return undefined;\n    }\n}\nfunction isEmpty(obj) {\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction map(obj, fn, contextObj) {\n    const res = {};\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            res[key] = fn.call(contextObj, obj[key], key, obj);\n        }\n    }\n    return res;\n}\n/**\n * Deep equal two objects. Support Arrays and Objects.\n */\nfunction deepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    for (const k of aKeys) {\n        if (!bKeys.includes(k)) {\n            return false;\n        }\n        const aProp = a[k];\n        const bProp = b[k];\n        if (isObject(aProp) && isObject(bProp)) {\n            if (!deepEqual(aProp, bProp)) {\n                return false;\n            }\n        }\n        else if (aProp !== bProp) {\n            return false;\n        }\n    }\n    for (const k of bKeys) {\n        if (!aKeys.includes(k)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isObject(thing) {\n    return thing !== null && typeof thing === 'object';\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Rejects if the given promise doesn't resolve in timeInMS milliseconds.\n * @internal\n */\nfunction promiseWithTimeout(promise, timeInMS = 2000) {\n    const deferredPromise = new Deferred();\n    setTimeout(() => deferredPromise.reject('timeout!'), timeInMS);\n    promise.then(deferredPromise.resolve, deferredPromise.reject);\n    return deferredPromise.promise;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a\n * params object (e.g. {arg: 'val', arg2: 'val2'})\n * Note: You must prepend it with ? when adding it to a URL.\n */\nfunction querystring(querystringParams) {\n    const params = [];\n    for (const [key, value] of Object.entries(querystringParams)) {\n        if (Array.isArray(value)) {\n            value.forEach(arrayVal => {\n                params.push(encodeURIComponent(key) + '=' + encodeURIComponent(arrayVal));\n            });\n        }\n        else {\n            params.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\n        }\n    }\n    return params.length ? '&' + params.join('&') : '';\n}\n/**\n * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object\n * (e.g. {arg: 'val', arg2: 'val2'})\n */\nfunction querystringDecode(querystring) {\n    const obj = {};\n    const tokens = querystring.replace(/^\\?/, '').split('&');\n    tokens.forEach(token => {\n        if (token) {\n            const [key, value] = token.split('=');\n            obj[decodeURIComponent(key)] = decodeURIComponent(value);\n        }\n    });\n    return obj;\n}\n/**\n * Extract the query string part of a URL, including the leading question mark (if present).\n */\nfunction extractQuerystring(url) {\n    const queryStart = url.indexOf('?');\n    if (!queryStart) {\n        return '';\n    }\n    const fragmentStart = url.indexOf('#', queryStart);\n    return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : undefined);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview SHA-1 cryptographic hash.\n * Variable names follow the notation in FIPS PUB 180-3:\n * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.\n *\n * Usage:\n *   var sha1 = new sha1();\n *   sha1.update(bytes);\n *   var hash = sha1.digest();\n *\n * Performance:\n *   Chrome 23:   ~400 Mbit/s\n *   Firefox 16:  ~250 Mbit/s\n *\n */\n/**\n * SHA-1 cryptographic hash constructor.\n *\n * The properties declared here are discussed in the above algorithm document.\n * @constructor\n * @final\n * @struct\n */\nclass Sha1 {\n    constructor() {\n        /**\n         * Holds the previous values of accumulated variables a-e in the compress_\n         * function.\n         * @private\n         */\n        this.chain_ = [];\n        /**\n         * A buffer holding the partially computed hash result.\n         * @private\n         */\n        this.buf_ = [];\n        /**\n         * An array of 80 bytes, each a part of the message to be hashed.  Referred to\n         * as the message schedule in the docs.\n         * @private\n         */\n        this.W_ = [];\n        /**\n         * Contains data needed to pad messages less than 64 bytes.\n         * @private\n         */\n        this.pad_ = [];\n        /**\n         * @private {number}\n         */\n        this.inbuf_ = 0;\n        /**\n         * @private {number}\n         */\n        this.total_ = 0;\n        this.blockSize = 512 / 8;\n        this.pad_[0] = 128;\n        for (let i = 1; i < this.blockSize; ++i) {\n            this.pad_[i] = 0;\n        }\n        this.reset();\n    }\n    reset() {\n        this.chain_[0] = 0x67452301;\n        this.chain_[1] = 0xefcdab89;\n        this.chain_[2] = 0x98badcfe;\n        this.chain_[3] = 0x10325476;\n        this.chain_[4] = 0xc3d2e1f0;\n        this.inbuf_ = 0;\n        this.total_ = 0;\n    }\n    /**\n     * Internal compress helper function.\n     * @param buf Block to compress.\n     * @param offset Offset of the block in the buffer.\n     * @private\n     */\n    compress_(buf, offset) {\n        if (!offset) {\n            offset = 0;\n        }\n        const W = this.W_;\n        // get 16 big endian words\n        if (typeof buf === 'string') {\n            for (let i = 0; i < 16; i++) {\n                // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS\n                // have a bug that turns the post-increment ++ operator into pre-increment\n                // during JIT compilation.  We have code that depends heavily on SHA-1 for\n                // correctness and which is affected by this bug, so I've removed all uses\n                // of post-increment ++ in which the result value is used.  We can revert\n                // this change once the Safari bug\n                // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and\n                // most clients have been updated.\n                W[i] =\n                    (buf.charCodeAt(offset) << 24) |\n                        (buf.charCodeAt(offset + 1) << 16) |\n                        (buf.charCodeAt(offset + 2) << 8) |\n                        buf.charCodeAt(offset + 3);\n                offset += 4;\n            }\n        }\n        else {\n            for (let i = 0; i < 16; i++) {\n                W[i] =\n                    (buf[offset] << 24) |\n                        (buf[offset + 1] << 16) |\n                        (buf[offset + 2] << 8) |\n                        buf[offset + 3];\n                offset += 4;\n            }\n        }\n        // expand to 80 words\n        for (let i = 16; i < 80; i++) {\n            const t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n            W[i] = ((t << 1) | (t >>> 31)) & 0xffffffff;\n        }\n        let a = this.chain_[0];\n        let b = this.chain_[1];\n        let c = this.chain_[2];\n        let d = this.chain_[3];\n        let e = this.chain_[4];\n        let f, k;\n        // TODO(user): Try to unroll this loop to speed up the computation.\n        for (let i = 0; i < 80; i++) {\n            if (i < 40) {\n                if (i < 20) {\n                    f = d ^ (b & (c ^ d));\n                    k = 0x5a827999;\n                }\n                else {\n                    f = b ^ c ^ d;\n                    k = 0x6ed9eba1;\n                }\n            }\n            else {\n                if (i < 60) {\n                    f = (b & c) | (d & (b | c));\n                    k = 0x8f1bbcdc;\n                }\n                else {\n                    f = b ^ c ^ d;\n                    k = 0xca62c1d6;\n                }\n            }\n            const t = (((a << 5) | (a >>> 27)) + f + e + k + W[i]) & 0xffffffff;\n            e = d;\n            d = c;\n            c = ((b << 30) | (b >>> 2)) & 0xffffffff;\n            b = a;\n            a = t;\n        }\n        this.chain_[0] = (this.chain_[0] + a) & 0xffffffff;\n        this.chain_[1] = (this.chain_[1] + b) & 0xffffffff;\n        this.chain_[2] = (this.chain_[2] + c) & 0xffffffff;\n        this.chain_[3] = (this.chain_[3] + d) & 0xffffffff;\n        this.chain_[4] = (this.chain_[4] + e) & 0xffffffff;\n    }\n    update(bytes, length) {\n        // TODO(johnlenz): tighten the function signature and remove this check\n        if (bytes == null) {\n            return;\n        }\n        if (length === undefined) {\n            length = bytes.length;\n        }\n        const lengthMinusBlock = length - this.blockSize;\n        let n = 0;\n        // Using local instead of member variables gives ~5% speedup on Firefox 16.\n        const buf = this.buf_;\n        let inbuf = this.inbuf_;\n        // The outer while loop should execute at most twice.\n        while (n < length) {\n            // When we have no data in the block to top up, we can directly process the\n            // input buffer (assuming it contains sufficient data). This gives ~25%\n            // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that\n            // the data is provided in large chunks (or in multiples of 64 bytes).\n            if (inbuf === 0) {\n                while (n <= lengthMinusBlock) {\n                    this.compress_(bytes, n);\n                    n += this.blockSize;\n                }\n            }\n            if (typeof bytes === 'string') {\n                while (n < length) {\n                    buf[inbuf] = bytes.charCodeAt(n);\n                    ++inbuf;\n                    ++n;\n                    if (inbuf === this.blockSize) {\n                        this.compress_(buf);\n                        inbuf = 0;\n                        // Jump to the outer loop so we use the full-block optimization.\n                        break;\n                    }\n                }\n            }\n            else {\n                while (n < length) {\n                    buf[inbuf] = bytes[n];\n                    ++inbuf;\n                    ++n;\n                    if (inbuf === this.blockSize) {\n                        this.compress_(buf);\n                        inbuf = 0;\n                        // Jump to the outer loop so we use the full-block optimization.\n                        break;\n                    }\n                }\n            }\n        }\n        this.inbuf_ = inbuf;\n        this.total_ += length;\n    }\n    /** @override */\n    digest() {\n        const digest = [];\n        let totalBits = this.total_ * 8;\n        // Add pad 0x80 0x00*.\n        if (this.inbuf_ < 56) {\n            this.update(this.pad_, 56 - this.inbuf_);\n        }\n        else {\n            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));\n        }\n        // Add # bits.\n        for (let i = this.blockSize - 1; i >= 56; i--) {\n            this.buf_[i] = totalBits & 255;\n            totalBits /= 256; // Don't use bit-shifting here!\n        }\n        this.compress_(this.buf_);\n        let n = 0;\n        for (let i = 0; i < 5; i++) {\n            for (let j = 24; j >= 0; j -= 8) {\n                digest[n] = (this.chain_[i] >> j) & 255;\n                ++n;\n            }\n        }\n        return digest;\n    }\n}\n\n/**\n * Helper to make a Subscribe function (just like Promise helps make a\n * Thenable).\n *\n * @param executor Function which can make calls to a single Observer\n *     as a proxy.\n * @param onNoObservers Callback when count of Observers goes to zero.\n */\nfunction createSubscribe(executor, onNoObservers) {\n    const proxy = new ObserverProxy(executor, onNoObservers);\n    return proxy.subscribe.bind(proxy);\n}\n/**\n * Implement fan-out for any number of Observers attached via a subscribe\n * function.\n */\nclass ObserverProxy {\n    /**\n     * @param executor Function which can make calls to a single Observer\n     *     as a proxy.\n     * @param onNoObservers Callback when count of Observers goes to zero.\n     */\n    constructor(executor, onNoObservers) {\n        this.observers = [];\n        this.unsubscribes = [];\n        this.observerCount = 0;\n        // Micro-task scheduling by calling task.then().\n        this.task = Promise.resolve();\n        this.finalized = false;\n        this.onNoObservers = onNoObservers;\n        // Call the executor asynchronously so subscribers that are called\n        // synchronously after the creation of the subscribe function\n        // can still receive the very first value generated in the executor.\n        this.task\n            .then(() => {\n            executor(this);\n        })\n            .catch(e => {\n            this.error(e);\n        });\n    }\n    next(value) {\n        this.forEachObserver((observer) => {\n            observer.next(value);\n        });\n    }\n    error(error) {\n        this.forEachObserver((observer) => {\n            observer.error(error);\n        });\n        this.close(error);\n    }\n    complete() {\n        this.forEachObserver((observer) => {\n            observer.complete();\n        });\n        this.close();\n    }\n    /**\n     * Subscribe function that can be used to add an Observer to the fan-out list.\n     *\n     * - We require that no event is sent to a subscriber synchronously to their\n     *   call to subscribe().\n     */\n    subscribe(nextOrObserver, error, complete) {\n        let observer;\n        if (nextOrObserver === undefined &&\n            error === undefined &&\n            complete === undefined) {\n            throw new Error('Missing Observer.');\n        }\n        // Assemble an Observer object when passed as callback functions.\n        if (implementsAnyMethods(nextOrObserver, [\n            'next',\n            'error',\n            'complete'\n        ])) {\n            observer = nextOrObserver;\n        }\n        else {\n            observer = {\n                next: nextOrObserver,\n                error,\n                complete\n            };\n        }\n        if (observer.next === undefined) {\n            observer.next = noop;\n        }\n        if (observer.error === undefined) {\n            observer.error = noop;\n        }\n        if (observer.complete === undefined) {\n            observer.complete = noop;\n        }\n        const unsub = this.unsubscribeOne.bind(this, this.observers.length);\n        // Attempt to subscribe to a terminated Observable - we\n        // just respond to the Observer with the final error or complete\n        // event.\n        if (this.finalized) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.task.then(() => {\n                try {\n                    if (this.finalError) {\n                        observer.error(this.finalError);\n                    }\n                    else {\n                        observer.complete();\n                    }\n                }\n                catch (e) {\n                    // nothing\n                }\n                return;\n            });\n        }\n        this.observers.push(observer);\n        return unsub;\n    }\n    // Unsubscribe is synchronous - we guarantee that no events are sent to\n    // any unsubscribed Observer.\n    unsubscribeOne(i) {\n        if (this.observers === undefined || this.observers[i] === undefined) {\n            return;\n        }\n        delete this.observers[i];\n        this.observerCount -= 1;\n        if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n            this.onNoObservers(this);\n        }\n    }\n    forEachObserver(fn) {\n        if (this.finalized) {\n            // Already closed by previous event....just eat the additional values.\n            return;\n        }\n        // Since sendOne calls asynchronously - there is no chance that\n        // this.observers will become undefined.\n        for (let i = 0; i < this.observers.length; i++) {\n            this.sendOne(i, fn);\n        }\n    }\n    // Call the Observer via one of it's callback function. We are careful to\n    // confirm that the observe has not been unsubscribed since this asynchronous\n    // function had been queued.\n    sendOne(i, fn) {\n        // Execute the callback asynchronously\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.task.then(() => {\n            if (this.observers !== undefined && this.observers[i] !== undefined) {\n                try {\n                    fn(this.observers[i]);\n                }\n                catch (e) {\n                    // Ignore exceptions raised in Observers or missing methods of an\n                    // Observer.\n                    // Log error to console. b/31404806\n                    if (typeof console !== 'undefined' && console.error) {\n                        console.error(e);\n                    }\n                }\n            }\n        });\n    }\n    close(err) {\n        if (this.finalized) {\n            return;\n        }\n        this.finalized = true;\n        if (err !== undefined) {\n            this.finalError = err;\n        }\n        // Proxy is no longer needed - garbage collect references\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.task.then(() => {\n            this.observers = undefined;\n            this.onNoObservers = undefined;\n        });\n    }\n}\n/** Turn synchronous function into one called asynchronously. */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction async(fn, onError) {\n    return (...args) => {\n        Promise.resolve(true)\n            .then(() => {\n            fn(...args);\n        })\n            .catch((error) => {\n            if (onError) {\n                onError(error);\n            }\n        });\n    };\n}\n/**\n * Return true if the object passed in implements any of the named methods.\n */\nfunction implementsAnyMethods(obj, methods) {\n    if (typeof obj !== 'object' || obj === null) {\n        return false;\n    }\n    for (const method of methods) {\n        if (method in obj && typeof obj[method] === 'function') {\n            return true;\n        }\n    }\n    return false;\n}\nfunction noop() {\n    // do nothing\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Check to make sure the appropriate number of arguments are provided for a public function.\n * Throws an error if it fails.\n *\n * @param fnName The function name\n * @param minCount The minimum number of arguments to allow for the function call\n * @param maxCount The maximum number of argument to allow for the function call\n * @param argCount The actual number of arguments provided.\n */\nconst validateArgCount = function (fnName, minCount, maxCount, argCount) {\n    let argError;\n    if (argCount < minCount) {\n        argError = 'at least ' + minCount;\n    }\n    else if (argCount > maxCount) {\n        argError = maxCount === 0 ? 'none' : 'no more than ' + maxCount;\n    }\n    if (argError) {\n        const error = fnName +\n            ' failed: Was called with ' +\n            argCount +\n            (argCount === 1 ? ' argument.' : ' arguments.') +\n            ' Expects ' +\n            argError +\n            '.';\n        throw new Error(error);\n    }\n};\n/**\n * Generates a string to prefix an error message about failed argument validation\n *\n * @param fnName The function name\n * @param argName The name of the argument\n * @return The prefix to add to the error thrown for validation.\n */\nfunction errorPrefix(fnName, argName) {\n    return `${fnName} failed: ${argName} argument `;\n}\n/**\n * @param fnName\n * @param argumentNumber\n * @param namespace\n * @param optional\n */\nfunction validateNamespace(fnName, namespace, optional) {\n    if (optional && !namespace) {\n        return;\n    }\n    if (typeof namespace !== 'string') {\n        //TODO: I should do more validation here. We only allow certain chars in namespaces.\n        throw new Error(errorPrefix(fnName, 'namespace') + 'must be a valid firebase namespace.');\n    }\n}\nfunction validateCallback(fnName, argumentName, \n// eslint-disable-next-line @typescript-eslint/ban-types\ncallback, optional) {\n    if (optional && !callback) {\n        return;\n    }\n    if (typeof callback !== 'function') {\n        throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid function.');\n    }\n}\nfunction validateContextObject(fnName, argumentName, context, optional) {\n    if (optional && !context) {\n        return;\n    }\n    if (typeof context !== 'object' || context === null) {\n        throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid context object.');\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they\n// automatically replaced '\\r\\n' with '\\n', and they didn't handle surrogate pairs,\n// so it's been modified.\n// Note that not all Unicode characters appear as single characters in JavaScript strings.\n// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters\n// use 2 characters in JavaScript.  All 4-byte UTF-8 characters begin with a first\n// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate\n// pair).\n// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3\n/**\n * @param {string} str\n * @return {Array}\n */\nconst stringToByteArray = function (str) {\n    const out = [];\n    let p = 0;\n    for (let i = 0; i < str.length; i++) {\n        let c = str.charCodeAt(i);\n        // Is this the lead surrogate in a surrogate pair?\n        if (c >= 0xd800 && c <= 0xdbff) {\n            const high = c - 0xd800; // the high 10 bits.\n            i++;\n            assert(i < str.length, 'Surrogate pair missing trail surrogate.');\n            const low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.\n            c = 0x10000 + (high << 10) + low;\n        }\n        if (c < 128) {\n            out[p++] = c;\n        }\n        else if (c < 2048) {\n            out[p++] = (c >> 6) | 192;\n            out[p++] = (c & 63) | 128;\n        }\n        else if (c < 65536) {\n            out[p++] = (c >> 12) | 224;\n            out[p++] = ((c >> 6) & 63) | 128;\n            out[p++] = (c & 63) | 128;\n        }\n        else {\n            out[p++] = (c >> 18) | 240;\n            out[p++] = ((c >> 12) & 63) | 128;\n            out[p++] = ((c >> 6) & 63) | 128;\n            out[p++] = (c & 63) | 128;\n        }\n    }\n    return out;\n};\n/**\n * Calculate length without actually converting; useful for doing cheaper validation.\n * @param {string} str\n * @return {number}\n */\nconst stringLength = function (str) {\n    let p = 0;\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n        if (c < 128) {\n            p++;\n        }\n        else if (c < 2048) {\n            p += 2;\n        }\n        else if (c >= 0xd800 && c <= 0xdbff) {\n            // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.\n            p += 4;\n            i++; // skip trail surrogate.\n        }\n        else {\n            p += 3;\n        }\n    }\n    return p;\n};\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Copied from https://stackoverflow.com/a/2117523\n * Generates a new uuid.\n * @public\n */\nconst uuidv4 = function () {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n        const r = (Math.random() * 16) | 0, v = c === 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n};\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The amount of milliseconds to exponentially increase.\n */\nconst DEFAULT_INTERVAL_MILLIS = 1000;\n/**\n * The factor to backoff by.\n * Should be a number greater than 1.\n */\nconst DEFAULT_BACKOFF_FACTOR = 2;\n/**\n * The maximum milliseconds to increase to.\n *\n * <p>Visible for testing\n */\nconst MAX_VALUE_MILLIS = 4 * 60 * 60 * 1000; // Four hours, like iOS and Android.\n/**\n * The percentage of backoff time to randomize by.\n * See\n * http://go/safe-client-behavior#step-1-determine-the-appropriate-retry-interval-to-handle-spike-traffic\n * for context.\n *\n * <p>Visible for testing\n */\nconst RANDOM_FACTOR = 0.5;\n/**\n * Based on the backoff method from\n * https://github.com/google/closure-library/blob/master/closure/goog/math/exponentialbackoff.js.\n * Extracted here so we don't need to pass metadata and a stateful ExponentialBackoff object around.\n */\nfunction calculateBackoffMillis(backoffCount, intervalMillis = DEFAULT_INTERVAL_MILLIS, backoffFactor = DEFAULT_BACKOFF_FACTOR) {\n    // Calculates an exponentially increasing value.\n    // Deviation: calculates value from count and a constant interval, so we only need to save value\n    // and count to restore state.\n    const currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);\n    // A random \"fuzz\" to avoid waves of retries.\n    // Deviation: randomFactor is required.\n    const randomWait = Math.round(\n    // A fraction of the backoff value to add/subtract.\n    // Deviation: changes multiplication order to improve readability.\n    RANDOM_FACTOR *\n        currBaseValue *\n        // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines\n        // if we add or subtract.\n        (Math.random() - 0.5) *\n        2);\n    // Limits backoff to max to avoid effectively permanent backoff.\n    return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provide English ordinal letters after a number\n */\nfunction ordinal(i) {\n    if (!Number.isFinite(i)) {\n        return `${i}`;\n    }\n    return i + indicator(i);\n}\nfunction indicator(i) {\n    i = Math.abs(i);\n    const cent = i % 100;\n    if (cent >= 10 && cent <= 20) {\n        return 'th';\n    }\n    const dec = i % 10;\n    if (dec === 1) {\n        return 'st';\n    }\n    if (dec === 2) {\n        return 'nd';\n    }\n    if (dec === 3) {\n        return 'rd';\n    }\n    return 'th';\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction getModularInstance(service) {\n    if (service && service._delegate) {\n        return service._delegate;\n    }\n    else {\n        return service;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Overriding the constant (we should be the only ones doing this)\nCONSTANTS.NODE_CLIENT = true;\n\n\n//# sourceMappingURL=index.node.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9ub2RlLWVzbS9pbmRleC5ub2RlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLEVBQUU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLHdDQUF3QyxNQUFNO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUSx3RUFBd0UsS0FBSzs7QUFFaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxNQUFNO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUJBQWlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYSxHQUFHLEtBQUs7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQixJQUFJLFNBQVMsR0FBRyxTQUFTO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELElBQUk7QUFDdkQsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLE1BQU0sSUFBSTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxHQUFHO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhLFdBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUSxVQUFVLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsRUFBRTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNi9CO0FBQzcvQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9ub2RlLWVzbS9pbmRleC5ub2RlLmVzbS5qcz9kOThlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRmlyZWJhc2UgY29uc3RhbnRzLiAgU29tZSBvZiB0aGVzZSAoQGRlZmluZXMpIGNhbiBiZSBvdmVycmlkZGVuIGF0IGNvbXBpbGUtdGltZS5cbiAqL1xuY29uc3QgQ09OU1RBTlRTID0ge1xuICAgIC8qKlxuICAgICAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBpcyB0aGUgY2xpZW50IE5vZGUuanMgU0RLLlxuICAgICAqL1xuICAgIE5PREVfQ0xJRU5UOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRoaXMgaXMgdGhlIEFkbWluIE5vZGUuanMgU0RLLlxuICAgICAqL1xuICAgIE5PREVfQURNSU46IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEZpcmViYXNlIFNESyBWZXJzaW9uXG4gICAgICovXG4gICAgU0RLX1ZFUlNJT046ICcke0pTQ09SRV9WRVJTSU9OfSdcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgcHJvdmlkZWQgYXNzZXJ0aW9uIGlzIGZhbHN5XG4gKi9cbmNvbnN0IGFzc2VydCA9IGZ1bmN0aW9uIChhc3NlcnRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWFzc2VydGlvbikge1xuICAgICAgICB0aHJvdyBhc3NlcnRpb25FcnJvcihtZXNzYWdlKTtcbiAgICB9XG59O1xuLyoqXG4gKiBSZXR1cm5zIGFuIEVycm9yIG9iamVjdCBzdWl0YWJsZSBmb3IgdGhyb3dpbmcuXG4gKi9cbmNvbnN0IGFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdGaXJlYmFzZSBEYXRhYmFzZSAoJyArXG4gICAgICAgIENPTlNUQU5UUy5TREtfVkVSU0lPTiArXG4gICAgICAgICcpIElOVEVSTkFMIEFTU0VSVCBGQUlMRUQ6ICcgK1xuICAgICAgICBtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBzdHJpbmdUb0J5dGVBcnJheSQxID0gZnVuY3Rpb24gKHN0cikge1xuICAgIC8vIFRPRE8odXNlcik6IFVzZSBuYXRpdmUgaW1wbGVtZW50YXRpb25zIGlmL3doZW4gYXZhaWxhYmxlXG4gICAgY29uc3Qgb3V0ID0gW107XG4gICAgbGV0IHAgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpIHtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gNikgfCAxOTI7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmXG4gICAgICAgICAgICBpICsgMSA8IHN0ci5sZW5ndGggJiZcbiAgICAgICAgICAgIChzdHIuY2hhckNvZGVBdChpICsgMSkgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgICAgIC8vIFN1cnJvZ2F0ZSBQYWlyXG4gICAgICAgICAgICBjID0gMHgxMDAwMCArICgoYyAmIDB4MDNmZikgPDwgMTApICsgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweDAzZmYpO1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxOCkgfCAyNDA7XG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiAxMikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDEyKSB8IDIyNDtcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcbi8qKlxuICogVHVybnMgYW4gYXJyYXkgb2YgbnVtYmVycyBpbnRvIHRoZSBzdHJpbmcgZ2l2ZW4gYnkgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlXG4gKiBjaGFyYWN0ZXJzIHRvIHdoaWNoIHRoZSBudW1iZXJzIGNvcnJlc3BvbmQuXG4gKiBAcGFyYW0gYnl0ZXMgQXJyYXkgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgY2hhcmFjdGVycy5cbiAqIEByZXR1cm4gU3RyaW5naWZpY2F0aW9uIG9mIHRoZSBhcnJheS5cbiAqL1xuY29uc3QgYnl0ZUFycmF5VG9TdHJpbmcgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAvLyBUT0RPKHVzZXIpOiBVc2UgbmF0aXZlIGltcGxlbWVudGF0aW9ucyBpZi93aGVuIGF2YWlsYWJsZVxuICAgIGNvbnN0IG91dCA9IFtdO1xuICAgIGxldCBwb3MgPSAwLCBjID0gMDtcbiAgICB3aGlsZSAocG9zIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGMxID0gYnl0ZXNbcG9zKytdO1xuICAgICAgICBpZiAoYzEgPCAxMjgpIHtcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYzEgPiAxOTEgJiYgYzEgPCAyMjQpIHtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xuICAgICAgICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYzEgJiAzMSkgPDwgNikgfCAoYzIgJiA2MykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMxID4gMjM5ICYmIGMxIDwgMzY1KSB7XG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxuICAgICAgICAgICAgY29uc3QgYzIgPSBieXRlc1twb3MrK107XG4gICAgICAgICAgICBjb25zdCBjMyA9IGJ5dGVzW3BvcysrXTtcbiAgICAgICAgICAgIGNvbnN0IGM0ID0gYnl0ZXNbcG9zKytdO1xuICAgICAgICAgICAgY29uc3QgdSA9ICgoKGMxICYgNykgPDwgMTgpIHwgKChjMiAmIDYzKSA8PCAxMikgfCAoKGMzICYgNjMpIDw8IDYpIHwgKGM0ICYgNjMpKSAtXG4gICAgICAgICAgICAgICAgMHgxMDAwMDtcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MDAgKyAodSA+PiAxMCkpO1xuICAgICAgICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZGMwMCArICh1ICYgMTAyMykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYzIgPSBieXRlc1twb3MrK107XG4gICAgICAgICAgICBjb25zdCBjMyA9IGJ5dGVzW3BvcysrXTtcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMxICYgMTUpIDw8IDEyKSB8ICgoYzIgJiA2MykgPDwgNikgfCAoYzMgJiA2MykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQuam9pbignJyk7XG59O1xuLy8gV2UgZGVmaW5lIGl0IGFzIGFuIG9iamVjdCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjbGFzcyBiZWNhdXNlIGEgY2xhc3MgY29tcGlsZWQgZG93biB0byBlczUgY2FuJ3Rcbi8vIGJlIHRyZWVzaGFrZWQuIGh0dHBzOi8vZ2l0aHViLmNvbS9yb2xsdXAvcm9sbHVwL2lzc3Vlcy8xNjkxXG4vLyBTdGF0aWMgbG9va3VwIG1hcHMsIGxhemlseSBwb3B1bGF0ZWQgYnkgaW5pdF8oKVxuLy8gVE9ETyhkbGFyb2NxdWUpOiBEZWZpbmUgdGhpcyBhcyBhIGNsYXNzLCBzaW5jZSB3ZSBubyBsb25nZXIgdGFyZ2V0IEVTNS5cbmNvbnN0IGJhc2U2NCA9IHtcbiAgICAvKipcbiAgICAgKiBNYXBzIGJ5dGVzIHRvIGNoYXJhY3RlcnMuXG4gICAgICovXG4gICAgYnl0ZVRvQ2hhck1hcF86IG51bGwsXG4gICAgLyoqXG4gICAgICogTWFwcyBjaGFyYWN0ZXJzIHRvIGJ5dGVzLlxuICAgICAqL1xuICAgIGNoYXJUb0J5dGVNYXBfOiBudWxsLFxuICAgIC8qKlxuICAgICAqIE1hcHMgYnl0ZXMgdG8gd2Vic2FmZSBjaGFyYWN0ZXJzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYnl0ZVRvQ2hhck1hcFdlYlNhZmVfOiBudWxsLFxuICAgIC8qKlxuICAgICAqIE1hcHMgd2Vic2FmZSBjaGFyYWN0ZXJzIHRvIGJ5dGVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2hhclRvQnl0ZU1hcFdlYlNhZmVfOiBudWxsLFxuICAgIC8qKlxuICAgICAqIE91ciBkZWZhdWx0IGFscGhhYmV0LCBzaGFyZWQgYmV0d2VlblxuICAgICAqIEVOQ09ERURfVkFMUyBhbmQgRU5DT0RFRF9WQUxTX1dFQlNBRkVcbiAgICAgKi9cbiAgICBFTkNPREVEX1ZBTFNfQkFTRTogJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJyArICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicgKyAnMDEyMzQ1Njc4OScsXG4gICAgLyoqXG4gICAgICogT3VyIGRlZmF1bHQgYWxwaGFiZXQuIFZhbHVlIDY0ICg9KSBpcyBzcGVjaWFsOyBpdCBtZWFucyBcIm5vdGhpbmcuXCJcbiAgICAgKi9cbiAgICBnZXQgRU5DT0RFRF9WQUxTKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRSArICcrLz0nO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogT3VyIHdlYnNhZmUgYWxwaGFiZXQuXG4gICAgICovXG4gICAgZ2V0IEVOQ09ERURfVkFMU19XRUJTQUZFKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRSArICctXy4nO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgdGhlIGF0b2IgYW5kIGJ0b2EgZnVuY3Rpb25zLiBUaGlzIGV4dGVuc2lvblxuICAgICAqIHN0YXJ0ZWQgYXQgTW96aWxsYSBidXQgaXMgbm93IGltcGxlbWVudGVkIGJ5IG1hbnkgYnJvd3NlcnMuIFdlIHVzZSB0aGVcbiAgICAgKiBBU1NVTUVfKiB2YXJpYWJsZXMgdG8gYXZvaWQgcHVsbGluZyBpbiB0aGUgZnVsbCB1c2VyYWdlbnQgZGV0ZWN0aW9uIGxpYnJhcnlcbiAgICAgKiBidXQgc3RpbGwgYWxsb3dpbmcgdGhlIHN0YW5kYXJkIHBlci1icm93c2VyIGNvbXBpbGF0aW9ucy5cbiAgICAgKlxuICAgICAqL1xuICAgIEhBU19OQVRJVkVfU1VQUE9SVDogdHlwZW9mIGF0b2IgPT09ICdmdW5jdGlvbicsXG4gICAgLyoqXG4gICAgICogQmFzZTY0LWVuY29kZSBhbiBhcnJheSBvZiBieXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBBbiBhcnJheSBvZiBieXRlcyAobnVtYmVycyB3aXRoXG4gICAgICogICAgIHZhbHVlIGluIFswLCAyNTVdKSB0byBlbmNvZGUuXG4gICAgICogQHBhcmFtIHdlYlNhZmUgQm9vbGVhbiBpbmRpY2F0aW5nIHdlIHNob3VsZCB1c2UgdGhlXG4gICAgICogICAgIGFsdGVybmF0aXZlIGFscGhhYmV0LlxuICAgICAqIEByZXR1cm4gVGhlIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBlbmNvZGVCeXRlQXJyYXkoaW5wdXQsIHdlYlNhZmUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ2VuY29kZUJ5dGVBcnJheSB0YWtlcyBhbiBhcnJheSBhcyBhIHBhcmFtZXRlcicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdF8oKTtcbiAgICAgICAgY29uc3QgYnl0ZVRvQ2hhck1hcCA9IHdlYlNhZmVcbiAgICAgICAgICAgID8gdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV9cbiAgICAgICAgICAgIDogdGhpcy5ieXRlVG9DaGFyTWFwXztcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUxID0gaW5wdXRbaV07XG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTIgPSBpICsgMSA8IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUyID0gaGF2ZUJ5dGUyID8gaW5wdXRbaSArIDFdIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGhhdmVCeXRlMyA9IGkgKyAyIDwgaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgYnl0ZTMgPSBoYXZlQnl0ZTMgPyBpbnB1dFtpICsgMl0gOiAwO1xuICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTEgPSBieXRlMSA+PiAyO1xuICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTIgPSAoKGJ5dGUxICYgMHgwMykgPDwgNCkgfCAoYnl0ZTIgPj4gNCk7XG4gICAgICAgICAgICBsZXQgb3V0Qnl0ZTMgPSAoKGJ5dGUyICYgMHgwZikgPDwgMikgfCAoYnl0ZTMgPj4gNik7XG4gICAgICAgICAgICBsZXQgb3V0Qnl0ZTQgPSBieXRlMyAmIDB4M2Y7XG4gICAgICAgICAgICBpZiAoIWhhdmVCeXRlMykge1xuICAgICAgICAgICAgICAgIG91dEJ5dGU0ID0gNjQ7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXZlQnl0ZTIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0Qnl0ZTMgPSA2NDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQucHVzaChieXRlVG9DaGFyTWFwW291dEJ5dGUxXSwgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlMl0sIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTNdLCBieXRlVG9DaGFyTWFwW291dEJ5dGU0XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEJhc2U2NC1lbmNvZGUgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgQSBzdHJpbmcgdG8gZW5jb2RlLlxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIElmIHRydWUsIHdlIHNob3VsZCB1c2UgdGhlXG4gICAgICogICAgIGFsdGVybmF0aXZlIGFscGhhYmV0LlxuICAgICAqIEByZXR1cm4gVGhlIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBlbmNvZGVTdHJpbmcoaW5wdXQsIHdlYlNhZmUpIHtcbiAgICAgICAgLy8gU2hvcnRjdXQgZm9yIE1vemlsbGEgYnJvd3NlcnMgdGhhdCBpbXBsZW1lbnRcbiAgICAgICAgLy8gYSBuYXRpdmUgYmFzZTY0IGVuY29kZXIgaW4gdGhlIGZvcm0gb2YgXCJidG9hL2F0b2JcIlxuICAgICAgICBpZiAodGhpcy5IQVNfTkFUSVZFX1NVUFBPUlQgJiYgIXdlYlNhZmUpIHtcbiAgICAgICAgICAgIHJldHVybiBidG9hKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVCeXRlQXJyYXkoc3RyaW5nVG9CeXRlQXJyYXkkMShpbnB1dCksIHdlYlNhZmUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQmFzZTY0LWRlY29kZSBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCB0byBkZWNvZGUuXG4gICAgICogQHBhcmFtIHdlYlNhZmUgVHJ1ZSBpZiB3ZSBzaG91bGQgdXNlIHRoZVxuICAgICAqICAgICBhbHRlcm5hdGl2ZSBhbHBoYWJldC5cbiAgICAgKiBAcmV0dXJuIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGRlY29kZWQgdmFsdWUuXG4gICAgICovXG4gICAgZGVjb2RlU3RyaW5nKGlucHV0LCB3ZWJTYWZlKSB7XG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBNb3ppbGxhIGJyb3dzZXJzIHRoYXQgaW1wbGVtZW50XG4gICAgICAgIC8vIGEgbmF0aXZlIGJhc2U2NCBlbmNvZGVyIGluIHRoZSBmb3JtIG9mIFwiYnRvYS9hdG9iXCJcbiAgICAgICAgaWYgKHRoaXMuSEFTX05BVElWRV9TVVBQT1JUICYmICF3ZWJTYWZlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXRvYihpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ5dGVBcnJheVRvU3RyaW5nKHRoaXMuZGVjb2RlU3RyaW5nVG9CeXRlQXJyYXkoaW5wdXQsIHdlYlNhZmUpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEJhc2U2NC1kZWNvZGUgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBJbiBiYXNlLTY0IGRlY29kaW5nLCBncm91cHMgb2YgZm91ciBjaGFyYWN0ZXJzIGFyZSBjb252ZXJ0ZWQgaW50byB0aHJlZVxuICAgICAqIGJ5dGVzLiAgSWYgdGhlIGVuY29kZXIgZGlkIG5vdCBhcHBseSBwYWRkaW5nLCB0aGUgaW5wdXQgbGVuZ3RoIG1heSBub3RcbiAgICAgKiBiZSBhIG11bHRpcGxlIG9mIDQuXG4gICAgICpcbiAgICAgKiBJbiB0aGlzIGNhc2UsIHRoZSBsYXN0IGdyb3VwIHdpbGwgaGF2ZSBmZXdlciB0aGFuIDQgY2hhcmFjdGVycywgYW5kXG4gICAgICogcGFkZGluZyB3aWxsIGJlIGluZmVycmVkLiAgSWYgdGhlIGdyb3VwIGhhcyBvbmUgb3IgdHdvIGNoYXJhY3RlcnMsIGl0IGRlY29kZXNcbiAgICAgKiB0byBvbmUgYnl0ZS4gIElmIHRoZSBncm91cCBoYXMgdGhyZWUgY2hhcmFjdGVycywgaXQgZGVjb2RlcyB0byB0d28gYnl0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgSW5wdXQgdG8gZGVjb2RlLlxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIFRydWUgaWYgd2Ugc2hvdWxkIHVzZSB0aGUgd2ViLXNhZmUgYWxwaGFiZXQuXG4gICAgICogQHJldHVybiBieXRlcyByZXByZXNlbnRpbmcgdGhlIGRlY29kZWQgdmFsdWUuXG4gICAgICovXG4gICAgZGVjb2RlU3RyaW5nVG9CeXRlQXJyYXkoaW5wdXQsIHdlYlNhZmUpIHtcbiAgICAgICAgdGhpcy5pbml0XygpO1xuICAgICAgICBjb25zdCBjaGFyVG9CeXRlTWFwID0gd2ViU2FmZVxuICAgICAgICAgICAgPyB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlX1xuICAgICAgICAgICAgOiB0aGlzLmNoYXJUb0J5dGVNYXBfO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7KSB7XG4gICAgICAgICAgICBjb25zdCBieXRlMSA9IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUyID0gaSA8IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUyID0gaGF2ZUJ5dGUyID8gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSldIDogMDtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIGNvbnN0IGhhdmVCeXRlMyA9IGkgPCBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBieXRlMyA9IGhhdmVCeXRlMyA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDY0O1xuICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGU0ID0gaSA8IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGU0ID0gaGF2ZUJ5dGU0ID8gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSldIDogNjQ7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgICBpZiAoYnl0ZTEgPT0gbnVsbCB8fCBieXRlMiA9PSBudWxsIHx8IGJ5dGUzID09IG51bGwgfHwgYnl0ZTQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBEZWNvZGVCYXNlNjRTdHJpbmdFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTEgPSAoYnl0ZTEgPDwgMikgfCAoYnl0ZTIgPj4gNCk7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChvdXRCeXRlMSk7XG4gICAgICAgICAgICBpZiAoYnl0ZTMgIT09IDY0KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTIgPSAoKGJ5dGUyIDw8IDQpICYgMHhmMCkgfCAoYnl0ZTMgPj4gMik7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gob3V0Qnl0ZTIpO1xuICAgICAgICAgICAgICAgIGlmIChieXRlNCAhPT0gNjQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTMgPSAoKGJ5dGUzIDw8IDYpICYgMHhjMCkgfCBieXRlNDtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gob3V0Qnl0ZTMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogTGF6eSBzdGF0aWMgaW5pdGlhbGl6YXRpb24gZnVuY3Rpb24uIENhbGxlZCBiZWZvcmVcbiAgICAgKiBhY2Nlc3NpbmcgYW55IG9mIHRoZSBzdGF0aWMgbWFwIHZhcmlhYmxlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGluaXRfKCkge1xuICAgICAgICBpZiAoIXRoaXMuYnl0ZVRvQ2hhck1hcF8pIHtcbiAgICAgICAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcF8gPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcF8gPSB7fTtcbiAgICAgICAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfID0ge307XG4gICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlXyA9IHt9O1xuICAgICAgICAgICAgLy8gV2Ugd2FudCBxdWljayBtYXBwaW5ncyBiYWNrIGFuZCBmb3J0aCwgc28gd2UgcHJlY29tcHV0ZSB0d28gbWFwcy5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTkNPREVEX1ZBTFMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBfW2ldID0gdGhpcy5FTkNPREVEX1ZBTFMuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcF9bdGhpcy5ieXRlVG9DaGFyTWFwX1tpXV0gPSBpO1xuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfW2ldID0gdGhpcy5FTkNPREVEX1ZBTFNfV0VCU0FGRS5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV9bdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV9baV1dID0gaTtcbiAgICAgICAgICAgICAgICAvLyBCZSBmb3JnaXZpbmcgd2hlbiBkZWNvZGluZyBhbmQgY29ycmVjdGx5IGRlY29kZSBib3RoIGVuY29kaW5ncy5cbiAgICAgICAgICAgICAgICBpZiAoaSA+PSB0aGlzLkVOQ09ERURfVkFMU19CQVNFLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfW3RoaXMuRU5DT0RFRF9WQUxTX1dFQlNBRkUuY2hhckF0KGkpXSA9IGk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfW3RoaXMuRU5DT0RFRF9WQUxTLmNoYXJBdChpKV0gPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqIEFuIGVycm9yIGVuY291bnRlcmVkIHdoaWxlIGRlY29kaW5nIGJhc2U2NCBzdHJpbmcuXG4gKi9cbmNsYXNzIERlY29kZUJhc2U2NFN0cmluZ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3InO1xuICAgIH1cbn1cbi8qKlxuICogVVJMLXNhZmUgYmFzZTY0IGVuY29kaW5nXG4gKi9cbmNvbnN0IGJhc2U2NEVuY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBjb25zdCB1dGY4Qnl0ZXMgPSBzdHJpbmdUb0J5dGVBcnJheSQxKHN0cik7XG4gICAgcmV0dXJuIGJhc2U2NC5lbmNvZGVCeXRlQXJyYXkodXRmOEJ5dGVzLCB0cnVlKTtcbn07XG4vKipcbiAqIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZyAod2l0aG91dCBcIi5cIiBwYWRkaW5nIGluIHRoZSBlbmQpLlxuICogZS5nLiBVc2VkIGluIEpTT04gV2ViIFRva2VuIChKV1QpIHBhcnRzLlxuICovXG5jb25zdCBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAvLyBVc2UgYmFzZTY0dXJsIGVuY29kaW5nIGFuZCByZW1vdmUgcGFkZGluZyBpbiB0aGUgZW5kIChkb3QgY2hhcmFjdGVycykuXG4gICAgcmV0dXJuIGJhc2U2NEVuY29kZShzdHIpLnJlcGxhY2UoL1xcLi9nLCAnJyk7XG59O1xuLyoqXG4gKiBVUkwtc2FmZSBiYXNlNjQgZGVjb2RpbmdcbiAqXG4gKiBOT1RFOiBETyBOT1QgdXNlIHRoZSBnbG9iYWwgYXRvYigpIGZ1bmN0aW9uIC0gaXQgZG9lcyBOT1Qgc3VwcG9ydCB0aGVcbiAqIGJhc2U2NFVybCB2YXJpYW50IGVuY29kaW5nLlxuICpcbiAqIEBwYXJhbSBzdHIgVG8gYmUgZGVjb2RlZFxuICogQHJldHVybiBEZWNvZGVkIHJlc3VsdCwgaWYgcG9zc2libGVcbiAqL1xuY29uc3QgYmFzZTY0RGVjb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBiYXNlNjQuZGVjb2RlU3RyaW5nKHN0ciwgdHJ1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2Jhc2U2NERlY29kZSBmYWlsZWQ6ICcsIGUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIERvIGEgZGVlcC1jb3B5IG9mIGJhc2ljIEphdmFTY3JpcHQgT2JqZWN0cyBvciBBcnJheXMuXG4gKi9cbmZ1bmN0aW9uIGRlZXBDb3B5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGRlZXBFeHRlbmQodW5kZWZpbmVkLCB2YWx1ZSk7XG59XG4vKipcbiAqIENvcHkgcHJvcGVydGllcyBmcm9tIHNvdXJjZSB0byB0YXJnZXQgKHJlY3Vyc2l2ZWx5IGFsbG93cyBleHRlbnNpb25cbiAqIG9mIE9iamVjdHMgYW5kIEFycmF5cykuICBTY2FsYXIgdmFsdWVzIGluIHRoZSB0YXJnZXQgYXJlIG92ZXItd3JpdHRlbi5cbiAqIElmIHRhcmdldCBpcyB1bmRlZmluZWQsIGFuIG9iamVjdCBvZiB0aGUgYXBwcm9wcmlhdGUgdHlwZSB3aWxsIGJlIGNyZWF0ZWRcbiAqIChhbmQgcmV0dXJuZWQpLlxuICpcbiAqIFdlIHJlY3Vyc2l2ZWx5IGNvcHkgYWxsIGNoaWxkIHByb3BlcnRpZXMgb2YgcGxhaW4gT2JqZWN0cyBpbiB0aGUgc291cmNlLSBzb1xuICogdGhhdCBuYW1lc3BhY2UtIGxpa2UgZGljdGlvbmFyaWVzIGFyZSBtZXJnZWQuXG4gKlxuICogTm90ZSB0aGF0IHRoZSB0YXJnZXQgY2FuIGJlIGEgZnVuY3Rpb24sIGluIHdoaWNoIGNhc2UgdGhlIHByb3BlcnRpZXMgaW5cbiAqIHRoZSBzb3VyY2UgT2JqZWN0IGFyZSBjb3BpZWQgb250byBpdCBhcyBzdGF0aWMgcHJvcGVydGllcyBvZiB0aGUgRnVuY3Rpb24uXG4gKlxuICogTm90ZTogd2UgZG9uJ3QgbWVyZ2UgX19wcm90b19fIHRvIHByZXZlbnQgcHJvdG90eXBlIHBvbGx1dGlvblxuICovXG5mdW5jdGlvbiBkZWVwRXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cbiAgICBzd2l0Y2ggKHNvdXJjZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBjYXNlIERhdGU6XG4gICAgICAgICAgICAvLyBUcmVhdCBEYXRlcyBsaWtlIHNjYWxhcnM7IGlmIHRoZSB0YXJnZXQgZGF0ZSBvYmplY3QgaGFkIGFueSBjaGlsZFxuICAgICAgICAgICAgLy8gcHJvcGVydGllcyAtIHRoZXkgd2lsbCBiZSBsb3N0IVxuICAgICAgICAgICAgY29uc3QgZGF0ZVZhbHVlID0gc291cmNlO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGVWYWx1ZS5nZXRUaW1lKCkpO1xuICAgICAgICBjYXNlIE9iamVjdDpcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQXJyYXk6XG4gICAgICAgICAgICAvLyBBbHdheXMgY29weSB0aGUgYXJyYXkgc291cmNlIGFuZCBvdmVyd3JpdGUgdGhlIHRhcmdldC5cbiAgICAgICAgICAgIHRhcmdldCA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBOb3QgYSBwbGFpbiBPYmplY3QgLSB0cmVhdCBpdCBhcyBhIHNjYWxhci5cbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgLy8gdXNlIGlzVmFsaWRLZXkgdG8gZ3VhcmQgYWdhaW5zdCBwcm90b3R5cGUgcG9sbHV0aW9uLiBTZWUgaHR0cHM6Ly9zbnlrLmlvL3Z1bG4vU05ZSy1KUy1MT0RBU0gtNDUwMjAyXG4gICAgICAgIGlmICghc291cmNlLmhhc093blByb3BlcnR5KHByb3ApIHx8ICFpc1ZhbGlkS2V5KHByb3ApKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXRbcHJvcF0gPSBkZWVwRXh0ZW5kKHRhcmdldFtwcm9wXSwgc291cmNlW3Byb3BdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XG4gICAgcmV0dXJuIGtleSAhPT0gJ19fcHJvdG9fXyc7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFBvbHlmaWxsIGZvciBgZ2xvYmFsVGhpc2Agb2JqZWN0LlxuICogQHJldHVybnMgdGhlIGBnbG9iYWxUaGlzYCBvYmplY3QgZm9yIHRoZSBnaXZlbiBlbnZpcm9ubWVudC5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3QuJyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBnZXREZWZhdWx0c0Zyb21HbG9iYWwgPSAoKSA9PiBnZXRHbG9iYWwoKS5fX0ZJUkVCQVNFX0RFRkFVTFRTX187XG4vKipcbiAqIEF0dGVtcHQgdG8gcmVhZCBkZWZhdWx0cyBmcm9tIGEgSlNPTiBzdHJpbmcgcHJvdmlkZWQgdG9cbiAqIHByb2Nlc3MoLillbnYoLilfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb3IgYSBKU09OIGZpbGUgd2hvc2UgcGF0aCBpcyBpblxuICogcHJvY2VzcyguKWVudiguKV9fRklSRUJBU0VfREVGQVVMVFNfUEFUSF9fXG4gKiBUaGUgZG90cyBhcmUgaW4gcGFyZW5zIGJlY2F1c2UgY2VydGFpbiBjb21waWxlcnMgKFZpdGU/KSBjYW5ub3RcbiAqIGhhbmRsZSBzZWVpbmcgdGhhdCB2YXJpYWJsZSBpbiBjb21tZW50cy5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmlyZWJhc2UvZmlyZWJhc2UtanMtc2RrL2lzc3Vlcy82ODM4XG4gKi9cbmNvbnN0IGdldERlZmF1bHRzRnJvbUVudlZhcmlhYmxlID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHByb2Nlc3MuZW52ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRzSnNvblN0cmluZyA9IHByb2Nlc3MuZW52Ll9fRklSRUJBU0VfREVGQVVMVFNfXztcbiAgICBpZiAoZGVmYXVsdHNKc29uU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRlZmF1bHRzSnNvblN0cmluZyk7XG4gICAgfVxufTtcbmNvbnN0IGdldERlZmF1bHRzRnJvbUNvb2tpZSA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBtYXRjaDtcbiAgICB0cnkge1xuICAgICAgICBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaCgvX19GSVJFQkFTRV9ERUZBVUxUU19fPShbXjtdKykvKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gU29tZSBlbnZpcm9ubWVudHMgc3VjaCBhcyBBbmd1bGFyIFVuaXZlcnNhbCBTU1IgaGF2ZSBhXG4gICAgICAgIC8vIGBkb2N1bWVudGAgb2JqZWN0IGJ1dCBlcnJvciBvbiBhY2Nlc3NpbmcgYGRvY3VtZW50LmNvb2tpZWAuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVjb2RlZCA9IG1hdGNoICYmIGJhc2U2NERlY29kZShtYXRjaFsxXSk7XG4gICAgcmV0dXJuIGRlY29kZWQgJiYgSlNPTi5wYXJzZShkZWNvZGVkKTtcbn07XG4vKipcbiAqIEdldCB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdC4gSXQgY2hlY2tzIGluIG9yZGVyOlxuICogKDEpIGlmIHN1Y2ggYW4gb2JqZWN0IGV4aXN0cyBhcyBhIHByb3BlcnR5IG9mIGBnbG9iYWxUaGlzYFxuICogKDIpIGlmIHN1Y2ggYW4gb2JqZWN0IHdhcyBwcm92aWRlZCBvbiBhIHNoZWxsIGVudmlyb25tZW50IHZhcmlhYmxlXG4gKiAoMykgaWYgc3VjaCBhbiBvYmplY3QgZXhpc3RzIGluIGEgY29va2llXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IGdldERlZmF1bHRzID0gKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoZ2V0RGVmYXVsdHNGcm9tR2xvYmFsKCkgfHxcbiAgICAgICAgICAgIGdldERlZmF1bHRzRnJvbUVudlZhcmlhYmxlKCkgfHxcbiAgICAgICAgICAgIGdldERlZmF1bHRzRnJvbUNvb2tpZSgpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhdGNoLWFsbCBmb3IgYmVpbmcgdW5hYmxlIHRvIGdldCBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gZHVlXG4gICAgICAgICAqIHRvIGFueSBlbnZpcm9ubWVudCBjYXNlIHdlIGhhdmUgbm90IGFjY291bnRlZCBmb3IuIExvZyB0b1xuICAgICAgICAgKiBpbmZvIGluc3RlYWQgb2Ygc3dhbGxvd2luZyBzbyB3ZSBjYW4gZmluZCB0aGVzZSB1bmtub3duIGNhc2VzXG4gICAgICAgICAqIGFuZCBhZGQgcGF0aHMgZm9yIHRoZW0gaWYgbmVlZGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc29sZS5pbmZvKGBVbmFibGUgdG8gZ2V0IF9fRklSRUJBU0VfREVGQVVMVFNfXyBkdWUgdG86ICR7ZX1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbn07XG4vKipcbiAqIFJldHVybnMgZW11bGF0b3IgaG9zdCBzdG9yZWQgaW4gdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3RcbiAqIGZvciB0aGUgZ2l2ZW4gcHJvZHVjdC5cbiAqIEByZXR1cm5zIGEgVVJMIGhvc3QgZm9ybWF0dGVkIGxpa2UgYDEyNy4wLjAuMTo5OTk5YCBvciBgWzo6MV06NDAwMGAgaWYgYXZhaWxhYmxlXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IGdldERlZmF1bHRFbXVsYXRvckhvc3QgPSAocHJvZHVjdE5hbWUpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IGdldERlZmF1bHRzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbXVsYXRvckhvc3RzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbcHJvZHVjdE5hbWVdOyB9O1xuLyoqXG4gKiBSZXR1cm5zIGVtdWxhdG9yIGhvc3RuYW1lIGFuZCBwb3J0IHN0b3JlZCBpbiB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdFxuICogZm9yIHRoZSBnaXZlbiBwcm9kdWN0LlxuICogQHJldHVybnMgYSBwYWlyIG9mIGhvc3RuYW1lIGFuZCBwb3J0IGxpa2UgYFtcIjo6MVwiLCA0MDAwXWAgaWYgYXZhaWxhYmxlXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCA9IChwcm9kdWN0TmFtZSkgPT4ge1xuICAgIGNvbnN0IGhvc3QgPSBnZXREZWZhdWx0RW11bGF0b3JIb3N0KHByb2R1Y3ROYW1lKTtcbiAgICBpZiAoIWhvc3QpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qgc2VwYXJhdG9ySW5kZXggPSBob3N0Lmxhc3RJbmRleE9mKCc6Jyk7IC8vIEZpbmRpbmcgdGhlIGxhc3Qgc2luY2UgSVB2NiBhZGRyIGFsc28gaGFzIGNvbG9ucy5cbiAgICBpZiAoc2VwYXJhdG9ySW5kZXggPD0gMCB8fCBzZXBhcmF0b3JJbmRleCArIDEgPT09IGhvc3QubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBob3N0ICR7aG9zdH0gd2l0aCBubyBzZXBhcmF0ZSBob3N0bmFtZSBhbmQgcG9ydCFgKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgIGNvbnN0IHBvcnQgPSBwYXJzZUludChob3N0LnN1YnN0cmluZyhzZXBhcmF0b3JJbmRleCArIDEpLCAxMCk7XG4gICAgaWYgKGhvc3RbMF0gPT09ICdbJykge1xuICAgICAgICAvLyBCcmFja2V0LXF1b3RlZCBgW2lwdjZhZGRyXTpwb3J0YCA9PiByZXR1cm4gXCJpcHY2YWRkclwiICh3aXRob3V0IGJyYWNrZXRzKS5cbiAgICAgICAgcmV0dXJuIFtob3N0LnN1YnN0cmluZygxLCBzZXBhcmF0b3JJbmRleCAtIDEpLCBwb3J0XTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbaG9zdC5zdWJzdHJpbmcoMCwgc2VwYXJhdG9ySW5kZXgpLCBwb3J0XTtcbiAgICB9XG59O1xuLyoqXG4gKiBSZXR1cm5zIEZpcmViYXNlIGFwcCBjb25maWcgc3RvcmVkIGluIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0LlxuICogQHB1YmxpY1xuICovXG5jb25zdCBnZXREZWZhdWx0QXBwQ29uZmlnID0gKCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBnZXREZWZhdWx0cygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29uZmlnOyB9O1xuLyoqXG4gKiBSZXR1cm5zIGFuIGV4cGVyaW1lbnRhbCBzZXR0aW5nIG9uIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0IChwcm9wZXJ0aWVzXG4gKiBwcmVmaXhlZCBieSBcIl9cIilcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgZ2V0RXhwZXJpbWVudGFsU2V0dGluZyA9IChuYW1lKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IGdldERlZmF1bHRzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtgXyR7bmFtZX1gXTsgfTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIERlZmVycmVkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yZWplY3QgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMucmVzb2x2ZSA9ICgpID0+IHsgfTtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3VyIEFQSSBpbnRlcm5hbHMgYXJlIG5vdCBwcm9taXNpZmllZCBhbmQgY2Fubm90IGJlY2F1c2Ugb3VyIGNhbGxiYWNrIEFQSXMgaGF2ZSBzdWJ0bGUgZXhwZWN0YXRpb25zIGFyb3VuZFxuICAgICAqIGludm9raW5nIHByb21pc2VzIGlubGluZSwgd2hpY2ggUHJvbWlzZXMgYXJlIGZvcmJpZGRlbiB0byBkby4gVGhpcyBtZXRob2QgYWNjZXB0cyBhbiBvcHRpb25hbCBub2RlLXN0eWxlIGNhbGxiYWNrXG4gICAgICogYW5kIHJldHVybnMgYSBub2RlLXN0eWxlIGNhbGxiYWNrIHdoaWNoIHdpbGwgcmVzb2x2ZSBvciByZWplY3QgdGhlIERlZmVycmVkJ3MgcHJvbWlzZS5cbiAgICAgKi9cbiAgICB3cmFwQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIChlcnJvciwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gQXR0YWNoaW5nIG5vb3AgaGFuZGxlciBqdXN0IGluIGNhc2UgZGV2ZWxvcGVyIHdhc24ndCBleHBlY3RpbmdcbiAgICAgICAgICAgICAgICAvLyBwcm9taXNlc1xuICAgICAgICAgICAgICAgIHRoaXMucHJvbWlzZS5jYXRjaCgoKSA9PiB7IH0pO1xuICAgICAgICAgICAgICAgIC8vIFNvbWUgb2Ygb3VyIGNhbGxiYWNrcyBkb24ndCBleHBlY3QgYSB2YWx1ZSBhbmQgb3VyIG93biB0ZXN0c1xuICAgICAgICAgICAgICAgIC8vIGFzc2VydCB0aGF0IHRoZSBwYXJhbWV0ZXIgbGVuZ3RoIGlzIDFcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2subGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1vY2tVc2VyVG9rZW4odG9rZW4sIHByb2plY3RJZCkge1xuICAgIGlmICh0b2tlbi51aWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgXCJ1aWRcIiBmaWVsZCBpcyBubyBsb25nZXIgc3VwcG9ydGVkIGJ5IG1vY2tVc2VyVG9rZW4uIFBsZWFzZSB1c2UgXCJzdWJcIiBpbnN0ZWFkIGZvciBGaXJlYmFzZSBBdXRoIFVzZXIgSUQuJyk7XG4gICAgfVxuICAgIC8vIFVuc2VjdXJlZCBKV1RzIHVzZSBcIm5vbmVcIiBhcyB0aGUgYWxnb3JpdGhtLlxuICAgIGNvbnN0IGhlYWRlciA9IHtcbiAgICAgICAgYWxnOiAnbm9uZScsXG4gICAgICAgIHR5cGU6ICdKV1QnXG4gICAgfTtcbiAgICBjb25zdCBwcm9qZWN0ID0gcHJvamVjdElkIHx8ICdkZW1vLXByb2plY3QnO1xuICAgIGNvbnN0IGlhdCA9IHRva2VuLmlhdCB8fCAwO1xuICAgIGNvbnN0IHN1YiA9IHRva2VuLnN1YiB8fCB0b2tlbi51c2VyX2lkO1xuICAgIGlmICghc3ViKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1vY2tVc2VyVG9rZW4gbXVzdCBjb250YWluICdzdWInIG9yICd1c2VyX2lkJyBmaWVsZCFcIik7XG4gICAgfVxuICAgIGNvbnN0IHBheWxvYWQgPSBPYmplY3QuYXNzaWduKHsgXG4gICAgICAgIC8vIFNldCBhbGwgcmVxdWlyZWQgZmllbGRzIHRvIGRlY2VudCBkZWZhdWx0c1xuICAgICAgICBpc3M6IGBodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vJHtwcm9qZWN0fWAsIGF1ZDogcHJvamVjdCwgaWF0LCBleHA6IGlhdCArIDM2MDAsIGF1dGhfdGltZTogaWF0LCBzdWIsIHVzZXJfaWQ6IHN1YiwgZmlyZWJhc2U6IHtcbiAgICAgICAgICAgIHNpZ25faW5fcHJvdmlkZXI6ICdjdXN0b20nLFxuICAgICAgICAgICAgaWRlbnRpdGllczoge31cbiAgICAgICAgfSB9LCB0b2tlbik7XG4gICAgLy8gVW5zZWN1cmVkIEpXVHMgdXNlIHRoZSBlbXB0eSBzdHJpbmcgYXMgYSBzaWduYXR1cmUuXG4gICAgY29uc3Qgc2lnbmF0dXJlID0gJyc7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoSlNPTi5zdHJpbmdpZnkoaGVhZGVyKSksXG4gICAgICAgIGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKSxcbiAgICAgICAgc2lnbmF0dXJlXG4gICAgXS5qb2luKCcuJyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJldHVybnMgbmF2aWdhdG9yLnVzZXJBZ2VudCBzdHJpbmcgb3IgJycgaWYgaXQncyBub3QgZGVmaW5lZC5cbiAqIEByZXR1cm4gdXNlciBhZ2VudCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZ2V0VUEoKSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHR5cGVvZiBuYXZpZ2F0b3JbJ3VzZXJBZ2VudCddID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yWyd1c2VyQWdlbnQnXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG4vKipcbiAqIERldGVjdCBDb3Jkb3ZhIC8gUGhvbmVHYXAgLyBJb25pYyBmcmFtZXdvcmtzIG9uIGEgbW9iaWxlIGRldmljZS5cbiAqXG4gKiBEZWxpYmVyYXRlbHkgZG9lcyBub3QgcmVseSBvbiBjaGVja2luZyBgZmlsZTovL2AgVVJMcyAoYXMgdGhpcyBmYWlscyBQaG9uZUdhcFxuICogaW4gdGhlIFJpcHBsZSBlbXVsYXRvcikgbm9yIENvcmRvdmEgYG9uRGV2aWNlUmVhZHlgLCB3aGljaCB3b3VsZCBub3JtYWxseVxuICogd2FpdCBmb3IgYSBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gaXNNb2JpbGVDb3Jkb3ZhKCkge1xuICAgIHJldHVybiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBTZXR0aW5nIHVwIGFuIGJyb2FkbHkgYXBwbGljYWJsZSBpbmRleCBzaWduYXR1cmUgZm9yIFdpbmRvd1xuICAgICAgICAvLyBqdXN0IHRvIGRlYWwgd2l0aCB0aGlzIGNhc2Ugd291bGQgcHJvYmFibHkgYmUgYSBiYWQgaWRlYS5cbiAgICAgICAgISEod2luZG93Wydjb3Jkb3ZhJ10gfHwgd2luZG93WydwaG9uZWdhcCddIHx8IHdpbmRvd1snUGhvbmVHYXAnXSkgJiZcbiAgICAgICAgL2lvc3xpcGhvbmV8aXBvZHxpcGFkfGFuZHJvaWR8YmxhY2tiZXJyeXxpZW1vYmlsZS9pLnRlc3QoZ2V0VUEoKSkpO1xufVxuLyoqXG4gKiBEZXRlY3QgTm9kZS5qcy5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgTm9kZS5qcyBlbnZpcm9ubWVudCBpcyBkZXRlY3RlZCBvciBzcGVjaWZpZWQuXG4gKi9cbi8vIE5vZGUgZGV0ZWN0aW9uIGxvZ2ljIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9pbGlha2FuL2RldGVjdC1ub2RlL1xuZnVuY3Rpb24gaXNOb2RlKCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBmb3JjZUVudmlyb25tZW50ID0gKF9hID0gZ2V0RGVmYXVsdHMoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvcmNlRW52aXJvbm1lbnQ7XG4gICAgaWYgKGZvcmNlRW52aXJvbm1lbnQgPT09ICdub2RlJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZm9yY2VFbnZpcm9ubWVudCA9PT0gJ2Jyb3dzZXInKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBEZXRlY3QgQnJvd3NlciBFbnZpcm9ubWVudC5cbiAqIE5vdGU6IFRoaXMgd2lsbCByZXR1cm4gdHJ1ZSBmb3IgY2VydGFpbiB0ZXN0IGZyYW1ld29ya3MgdGhhdCBhcmUgaW5jb21wbGV0ZWx5XG4gKiBtaW1pY2tpbmcgYSBicm93c2VyLCBhbmQgc2hvdWxkIG5vdCBsZWFkIHRvIGFzc3VtaW5nIGFsbCBicm93c2VyIEFQSXMgYXJlXG4gKiBhdmFpbGFibGUuXG4gKi9cbmZ1bmN0aW9uIGlzQnJvd3NlcigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgfHwgaXNXZWJXb3JrZXIoKTtcbn1cbi8qKlxuICogRGV0ZWN0IFdlYiBXb3JrZXIgY29udGV4dC5cbiAqL1xuZnVuY3Rpb24gaXNXZWJXb3JrZXIoKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpO1xufVxuLyoqXG4gKiBEZXRlY3QgQ2xvdWRmbGFyZSBXb3JrZXIgY29udGV4dC5cbiAqL1xuZnVuY3Rpb24gaXNDbG91ZGZsYXJlV29ya2VyKCkge1xuICAgIHJldHVybiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudCA9PT0gJ0Nsb3VkZmxhcmUtV29ya2VycycpO1xufVxuZnVuY3Rpb24gaXNCcm93c2VyRXh0ZW5zaW9uKCkge1xuICAgIGNvbnN0IHJ1bnRpbWUgPSB0eXBlb2YgY2hyb21lID09PSAnb2JqZWN0J1xuICAgICAgICA/IGNocm9tZS5ydW50aW1lXG4gICAgICAgIDogdHlwZW9mIGJyb3dzZXIgPT09ICdvYmplY3QnXG4gICAgICAgICAgICA/IGJyb3dzZXIucnVudGltZVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHR5cGVvZiBydW50aW1lID09PSAnb2JqZWN0JyAmJiBydW50aW1lLmlkICE9PSB1bmRlZmluZWQ7XG59XG4vKipcbiAqIERldGVjdCBSZWFjdCBOYXRpdmUuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIFJlYWN0TmF0aXZlIGVudmlyb25tZW50IGlzIGRldGVjdGVkLlxuICovXG5mdW5jdGlvbiBpc1JlYWN0TmF0aXZlKCkge1xuICAgIHJldHVybiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ29iamVjdCcgJiYgbmF2aWdhdG9yWydwcm9kdWN0J10gPT09ICdSZWFjdE5hdGl2ZScpO1xufVxuLyoqIERldGVjdHMgRWxlY3Ryb24gYXBwcy4gKi9cbmZ1bmN0aW9uIGlzRWxlY3Ryb24oKSB7XG4gICAgcmV0dXJuIGdldFVBKCkuaW5kZXhPZignRWxlY3Ryb24vJykgPj0gMDtcbn1cbi8qKiBEZXRlY3RzIEludGVybmV0IEV4cGxvcmVyLiAqL1xuZnVuY3Rpb24gaXNJRSgpIHtcbiAgICBjb25zdCB1YSA9IGdldFVBKCk7XG4gICAgcmV0dXJuIHVhLmluZGV4T2YoJ01TSUUgJykgPj0gMCB8fCB1YS5pbmRleE9mKCdUcmlkZW50LycpID49IDA7XG59XG4vKiogRGV0ZWN0cyBVbml2ZXJzYWwgV2luZG93cyBQbGF0Zm9ybSBhcHBzLiAqL1xuZnVuY3Rpb24gaXNVV1AoKSB7XG4gICAgcmV0dXJuIGdldFVBKCkuaW5kZXhPZignTVNBcHBIb3N0LycpID49IDA7XG59XG4vKipcbiAqIERldGVjdCB3aGV0aGVyIHRoZSBjdXJyZW50IFNESyBidWlsZCBpcyB0aGUgTm9kZSB2ZXJzaW9uLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiBpdCdzIHRoZSBOb2RlIFNESyBidWlsZC5cbiAqL1xuZnVuY3Rpb24gaXNOb2RlU2RrKCkge1xuICAgIHJldHVybiBDT05TVEFOVFMuTk9ERV9DTElFTlQgPT09IHRydWUgfHwgQ09OU1RBTlRTLk5PREVfQURNSU4gPT09IHRydWU7XG59XG4vKiogUmV0dXJucyB0cnVlIGlmIHdlIGFyZSBydW5uaW5nIGluIFNhZmFyaS4gKi9cbmZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICAgIHJldHVybiAoIWlzTm9kZSgpICYmXG4gICAgICAgICEhbmF2aWdhdG9yLnVzZXJBZ2VudCAmJlxuICAgICAgICBuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKCdTYWZhcmknKSAmJlxuICAgICAgICAhbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcygnQ2hyb21lJykpO1xufVxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjaGVja3MgaWYgaW5kZXhlZERCIGlzIHN1cHBvcnRlZCBieSBjdXJyZW50IGJyb3dzZXIvc2VydmljZSB3b3JrZXIgY29udGV4dFxuICogQHJldHVybiB0cnVlIGlmIGluZGV4ZWREQiBpcyBzdXBwb3J0ZWQgYnkgY3VycmVudCBicm93c2VyL3NlcnZpY2Ugd29ya2VyIGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gaXNJbmRleGVkREJBdmFpbGFibGUoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpbmRleGVkREIgPT09ICdvYmplY3QnO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIG1ldGhvZCB2YWxpZGF0ZXMgYnJvd3Nlci9zdyBjb250ZXh0IGZvciBpbmRleGVkREIgYnkgb3BlbmluZyBhIGR1bW15IGluZGV4ZWREQiBkYXRhYmFzZSBhbmQgcmVqZWN0XG4gKiBpZiBlcnJvcnMgb2NjdXIgZHVyaW5nIHRoZSBkYXRhYmFzZSBvcGVuIG9wZXJhdGlvbi5cbiAqXG4gKiBAdGhyb3dzIGV4Y2VwdGlvbiBpZiBjdXJyZW50IGJyb3dzZXIvc3cgY29udGV4dCBjYW4ndCBydW4gaWRiLm9wZW4gKGV4OiBTYWZhcmkgaWZyYW1lLCBGaXJlZm94XG4gKiBwcml2YXRlIGJyb3dzaW5nKVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcHJlRXhpc3QgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgREJfQ0hFQ0tfTkFNRSA9ICd2YWxpZGF0ZS1icm93c2VyLWNvbnRleHQtZm9yLWluZGV4ZWRkYi1hbmFseXRpY3MtbW9kdWxlJztcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzZWxmLmluZGV4ZWREQi5vcGVuKERCX0NIRUNLX05BTUUpO1xuICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZXN1bHQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgZGF0YWJhc2Ugb25seSB3aGVuIGl0IGRvZXNuJ3QgcHJlLWV4aXN0XG4gICAgICAgICAgICAgICAgaWYgKCFwcmVFeGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShEQl9DSEVDS19OQU1FKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBwcmVFeGlzdCA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmVqZWN0KCgoX2EgPSByZXF1ZXN0LmVycm9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVzc2FnZSkgfHwgJycpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICpcbiAqIFRoaXMgbWV0aG9kIGNoZWNrcyB3aGV0aGVyIGNvb2tpZSBpcyBlbmFibGVkIHdpdGhpbiBjdXJyZW50IGJyb3dzZXJcbiAqIEByZXR1cm4gdHJ1ZSBpZiBjb29raWUgaXMgZW5hYmxlZCB3aXRoaW4gY3VycmVudCBicm93c2VyXG4gKi9cbmZ1bmN0aW9uIGFyZUNvb2tpZXNFbmFibGVkKCkge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhbmF2aWdhdG9yLmNvb2tpZUVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQGZpbGVvdmVydmlldyBTdGFuZGFyZGl6ZWQgRmlyZWJhc2UgRXJyb3IuXG4gKlxuICogVXNhZ2U6XG4gKlxuICogICAvLyBUeXBlU2NyaXB0IHN0cmluZyBsaXRlcmFscyBmb3IgdHlwZS1zYWZlIGNvZGVzXG4gKiAgIHR5cGUgRXJyID1cbiAqICAgICAndW5rbm93bicgfFxuICogICAgICdvYmplY3Qtbm90LWZvdW5kJ1xuICogICAgIDtcbiAqXG4gKiAgIC8vIENsb3N1cmUgZW51bSBmb3IgdHlwZS1zYWZlIGVycm9yIGNvZGVzXG4gKiAgIC8vIGF0LWVudW0ge3N0cmluZ31cbiAqICAgdmFyIEVyciA9IHtcbiAqICAgICBVTktOT1dOOiAndW5rbm93bicsXG4gKiAgICAgT0JKRUNUX05PVF9GT1VORDogJ29iamVjdC1ub3QtZm91bmQnLFxuICogICB9XG4gKlxuICogICBsZXQgZXJyb3JzOiBNYXA8RXJyLCBzdHJpbmc+ID0ge1xuICogICAgICdnZW5lcmljLWVycm9yJzogXCJVbmtub3duIGVycm9yXCIsXG4gKiAgICAgJ2ZpbGUtbm90LWZvdW5kJzogXCJDb3VsZCBub3QgZmluZCBmaWxlOiB7JGZpbGV9XCIsXG4gKiAgIH07XG4gKlxuICogICAvLyBUeXBlLXNhZmUgZnVuY3Rpb24gLSBtdXN0IHBhc3MgYSB2YWxpZCBlcnJvciBjb2RlIGFzIHBhcmFtLlxuICogICBsZXQgZXJyb3IgPSBuZXcgRXJyb3JGYWN0b3J5PEVycj4oJ3NlcnZpY2UnLCAnU2VydmljZScsIGVycm9ycyk7XG4gKlxuICogICAuLi5cbiAqICAgdGhyb3cgZXJyb3IuY3JlYXRlKEVyci5HRU5FUklDKTtcbiAqICAgLi4uXG4gKiAgIHRocm93IGVycm9yLmNyZWF0ZShFcnIuRklMRV9OT1RfRk9VTkQsIHsnZmlsZSc6IGZpbGVOYW1lfSk7XG4gKiAgIC4uLlxuICogICAvLyBTZXJ2aWNlOiBDb3VsZCBub3QgZmlsZSBmaWxlOiBmb28udHh0IChzZXJ2aWNlL2ZpbGUtbm90LWZvdW5kKS5cbiAqXG4gKiAgIGNhdGNoIChlKSB7XG4gKiAgICAgYXNzZXJ0KGUubWVzc2FnZSA9PT0gXCJDb3VsZCBub3QgZmluZCBmaWxlOiBmb28udHh0LlwiKTtcbiAqICAgICBpZiAoKGUgYXMgRmlyZWJhc2VFcnJvcik/LmNvZGUgPT09ICdzZXJ2aWNlL2ZpbGUtbm90LWZvdW5kJykge1xuICogICAgICAgY29uc29sZS5sb2coXCJDb3VsZCBub3QgcmVhZCBmaWxlOiBcIiArIGVbJ2ZpbGUnXSk7XG4gKiAgICAgfVxuICogICB9XG4gKi9cbmNvbnN0IEVSUk9SX05BTUUgPSAnRmlyZWJhc2VFcnJvcic7XG4vLyBCYXNlZCBvbiBjb2RlIGZyb206XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNDdXN0b21fRXJyb3JfVHlwZXNcbmNsYXNzIEZpcmViYXNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqIFRoZSBlcnJvciBjb2RlIGZvciB0aGlzIGVycm9yLiAqL1xuICAgIGNvZGUsIG1lc3NhZ2UsIFxuICAgIC8qKiBDdXN0b20gZGF0YSBmb3IgdGhpcyBlcnJvci4gKi9cbiAgICBjdXN0b21EYXRhKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLmN1c3RvbURhdGEgPSBjdXN0b21EYXRhO1xuICAgICAgICAvKiogVGhlIGN1c3RvbSBuYW1lIGZvciBhbGwgRmlyZWJhc2VFcnJvcnMuICovXG4gICAgICAgIHRoaXMubmFtZSA9IEVSUk9SX05BTUU7XG4gICAgICAgIC8vIEZpeCBGb3IgRVM1XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC13aWtpL2Jsb2IvbWFzdGVyL0JyZWFraW5nLUNoYW5nZXMubWQjZXh0ZW5kaW5nLWJ1aWx0LWlucy1saWtlLWVycm9yLWFycmF5LWFuZC1tYXAtbWF5LW5vLWxvbmdlci13b3JrXG4gICAgICAgIC8vIFRPRE8oZGxhcm9jcXVlKTogUmVwbGFjZSB0aGlzIHdpdGggYG5ldy50YXJnZXRgOiBodHRwczovL3d3dy50eXBlc2NyaXB0bGFuZy5vcmcvZG9jcy9oYW5kYm9vay9yZWxlYXNlLW5vdGVzL3R5cGVzY3JpcHQtMi0yLmh0bWwjc3VwcG9ydC1mb3ItbmV3dGFyZ2V0XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgIHdoaWNoIHdlIGNhbiBub3cgdXNlIHNpbmNlIHdlIG5vIGxvbmdlciB0YXJnZXQgRVM1LlxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgRmlyZWJhc2VFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICAvLyBNYWludGFpbnMgcHJvcGVyIHN0YWNrIHRyYWNlIGZvciB3aGVyZSBvdXIgZXJyb3Igd2FzIHRocm93bi5cbiAgICAgICAgLy8gT25seSBhdmFpbGFibGUgb24gVjguXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgRXJyb3JGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgRXJyb3JGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlLCBzZXJ2aWNlTmFtZSwgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgICAgIHRoaXMuc2VydmljZU5hbWUgPSBzZXJ2aWNlTmFtZTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgfVxuICAgIGNyZWF0ZShjb2RlLCAuLi5kYXRhKSB7XG4gICAgICAgIGNvbnN0IGN1c3RvbURhdGEgPSBkYXRhWzBdIHx8IHt9O1xuICAgICAgICBjb25zdCBmdWxsQ29kZSA9IGAke3RoaXMuc2VydmljZX0vJHtjb2RlfWA7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGhpcy5lcnJvcnNbY29kZV07XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0ZW1wbGF0ZSA/IHJlcGxhY2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgY3VzdG9tRGF0YSkgOiAnRXJyb3InO1xuICAgICAgICAvLyBTZXJ2aWNlIE5hbWU6IEVycm9yIG1lc3NhZ2UgKHNlcnZpY2UvY29kZSkuXG4gICAgICAgIGNvbnN0IGZ1bGxNZXNzYWdlID0gYCR7dGhpcy5zZXJ2aWNlTmFtZX06ICR7bWVzc2FnZX0gKCR7ZnVsbENvZGV9KS5gO1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBGaXJlYmFzZUVycm9yKGZ1bGxDb2RlLCBmdWxsTWVzc2FnZSwgY3VzdG9tRGF0YSk7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG59XG5mdW5jdGlvbiByZXBsYWNlVGVtcGxhdGUodGVtcGxhdGUsIGRhdGEpIHtcbiAgICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZShQQVRURVJOLCAoXywga2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZGF0YVtrZXldO1xuICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IFN0cmluZyh2YWx1ZSkgOiBgPCR7a2V5fT8+YDtcbiAgICB9KTtcbn1cbmNvbnN0IFBBVFRFUk4gPSAvXFx7XFwkKFtefV0rKX0vZztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogRXZhbHVhdGVzIGEgSlNPTiBzdHJpbmcgaW50byBhIGphdmFzY3JpcHQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgQSBzdHJpbmcgY29udGFpbmluZyBKU09OLlxuICogQHJldHVybiB7Kn0gVGhlIGphdmFzY3JpcHQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIEpTT04uXG4gKi9cbmZ1bmN0aW9uIGpzb25FdmFsKHN0cikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHN0cik7XG59XG4vKipcbiAqIFJldHVybnMgSlNPTiByZXByZXNlbnRpbmcgYSBqYXZhc2NyaXB0IG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gZGF0YSBKYXZhU2NyaXB0IG9iamVjdCB0byBiZSBzdHJpbmdpZmllZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEpTT04gY29udGVudHMgb2YgdGhlIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5KGRhdGEpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBpbnRvIGNvbnN0aXR1ZW50IHBhcnRzLlxuICpcbiAqIE5vdGVzOlxuICogLSBNYXkgcmV0dXJuIHdpdGggaW52YWxpZCAvIGluY29tcGxldGUgY2xhaW1zIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cbiAqL1xuY29uc3QgZGVjb2RlID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgbGV0IGhlYWRlciA9IHt9LCBjbGFpbXMgPSB7fSwgZGF0YSA9IHt9LCBzaWduYXR1cmUgPSAnJztcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IHRva2VuLnNwbGl0KCcuJyk7XG4gICAgICAgIGhlYWRlciA9IGpzb25FdmFsKGJhc2U2NERlY29kZShwYXJ0c1swXSkgfHwgJycpO1xuICAgICAgICBjbGFpbXMgPSBqc29uRXZhbChiYXNlNjREZWNvZGUocGFydHNbMV0pIHx8ICcnKTtcbiAgICAgICAgc2lnbmF0dXJlID0gcGFydHNbMl07XG4gICAgICAgIGRhdGEgPSBjbGFpbXNbJ2QnXSB8fCB7fTtcbiAgICAgICAgZGVsZXRlIGNsYWltc1snZCddO1xuICAgIH1cbiAgICBjYXRjaCAoZSkgeyB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGVhZGVyLFxuICAgICAgICBjbGFpbXMsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHNpZ25hdHVyZVxuICAgIH07XG59O1xuLyoqXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gYW5kIGNoZWNrcyB0aGUgdmFsaWRpdHkgb2YgaXRzIHRpbWUtYmFzZWQgY2xhaW1zLiBXaWxsIHJldHVybiB0cnVlIGlmIHRoZVxuICogdG9rZW4gaXMgd2l0aGluIHRoZSB0aW1lIHdpbmRvdyBhdXRob3JpemVkIGJ5IHRoZSAnbmJmJyAobm90LWJlZm9yZSkgYW5kICdpYXQnIChpc3N1ZWQtYXQpIGNsYWltcy5cbiAqXG4gKiBOb3RlczpcbiAqIC0gTWF5IHJldHVybiBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cbiAqL1xuY29uc3QgaXNWYWxpZFRpbWVzdGFtcCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIGNvbnN0IGNsYWltcyA9IGRlY29kZSh0b2tlbikuY2xhaW1zO1xuICAgIGNvbnN0IG5vdyA9IE1hdGguZmxvb3IobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKTtcbiAgICBsZXQgdmFsaWRTaW5jZSA9IDAsIHZhbGlkVW50aWwgPSAwO1xuICAgIGlmICh0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoY2xhaW1zLmhhc093blByb3BlcnR5KCduYmYnKSkge1xuICAgICAgICAgICAgdmFsaWRTaW5jZSA9IGNsYWltc1snbmJmJ107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xhaW1zLmhhc093blByb3BlcnR5KCdpYXQnKSkge1xuICAgICAgICAgICAgdmFsaWRTaW5jZSA9IGNsYWltc1snaWF0J107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnZXhwJykpIHtcbiAgICAgICAgICAgIHZhbGlkVW50aWwgPSBjbGFpbXNbJ2V4cCddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdG9rZW4gd2lsbCBleHBpcmUgYWZ0ZXIgMjRoIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIHZhbGlkVW50aWwgPSB2YWxpZFNpbmNlICsgODY0MDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICghIW5vdyAmJlxuICAgICAgICAhIXZhbGlkU2luY2UgJiZcbiAgICAgICAgISF2YWxpZFVudGlsICYmXG4gICAgICAgIG5vdyA+PSB2YWxpZFNpbmNlICYmXG4gICAgICAgIG5vdyA8PSB2YWxpZFVudGlsKTtcbn07XG4vKipcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBhbmQgcmV0dXJucyBpdHMgaXNzdWVkIGF0IHRpbWUgaWYgdmFsaWQsIG51bGwgb3RoZXJ3aXNlLlxuICpcbiAqIE5vdGVzOlxuICogLSBNYXkgcmV0dXJuIG51bGwgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxuICovXG5jb25zdCBpc3N1ZWRBdFRpbWUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICBjb25zdCBjbGFpbXMgPSBkZWNvZGUodG9rZW4pLmNsYWltcztcbiAgICBpZiAodHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcgJiYgY2xhaW1zLmhhc093blByb3BlcnR5KCdpYXQnKSkge1xuICAgICAgICByZXR1cm4gY2xhaW1zWydpYXQnXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuLyoqXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gYW5kIGNoZWNrcyB0aGUgdmFsaWRpdHkgb2YgaXRzIGZvcm1hdC4gRXhwZWN0cyBhIHZhbGlkIGlzc3VlZC1hdCB0aW1lLlxuICpcbiAqIE5vdGVzOlxuICogLSBNYXkgcmV0dXJuIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxuICovXG5jb25zdCBpc1ZhbGlkRm9ybWF0ID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZSh0b2tlbiksIGNsYWltcyA9IGRlY29kZWQuY2xhaW1zO1xuICAgIHJldHVybiAhIWNsYWltcyAmJiB0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0JyAmJiBjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2lhdCcpO1xufTtcbi8qKlxuICogQXR0ZW1wdHMgdG8gcGVlciBpbnRvIGFuIGF1dGggdG9rZW4gYW5kIGRldGVybWluZSBpZiBpdCdzIGFuIGFkbWluIGF1dGggdG9rZW4gYnkgbG9va2luZyBhdCB0aGUgY2xhaW1zIHBvcnRpb24uXG4gKlxuICogTm90ZXM6XG4gKiAtIE1heSByZXR1cm4gYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXG4gKi9cbmNvbnN0IGlzQWRtaW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICBjb25zdCBjbGFpbXMgPSBkZWNvZGUodG9rZW4pLmNsYWltcztcbiAgICByZXR1cm4gdHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcgJiYgY2xhaW1zWydhZG1pbiddID09PSB0cnVlO1xufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5mdW5jdGlvbiBzYWZlR2V0KG9iaiwga2V5KSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbWFwKG9iaiwgZm4sIGNvbnRleHRPYmopIHtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIHJlc1trZXldID0gZm4uY2FsbChjb250ZXh0T2JqLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIERlZXAgZXF1YWwgdHdvIG9iamVjdHMuIFN1cHBvcnQgQXJyYXlzIGFuZCBPYmplY3RzLlxuICovXG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBhS2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGNvbnN0IGJLZXlzID0gT2JqZWN0LmtleXMoYik7XG4gICAgZm9yIChjb25zdCBrIG9mIGFLZXlzKSB7XG4gICAgICAgIGlmICghYktleXMuaW5jbHVkZXMoaykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhUHJvcCA9IGFba107XG4gICAgICAgIGNvbnN0IGJQcm9wID0gYltrXTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KGFQcm9wKSAmJiBpc09iamVjdChiUHJvcCkpIHtcbiAgICAgICAgICAgIGlmICghZGVlcEVxdWFsKGFQcm9wLCBiUHJvcCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYVByb3AgIT09IGJQcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrIG9mIGJLZXlzKSB7XG4gICAgICAgIGlmICghYUtleXMuaW5jbHVkZXMoaykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHRoaW5nKSB7XG4gICAgcmV0dXJuIHRoaW5nICE9PSBudWxsICYmIHR5cGVvZiB0aGluZyA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJlamVjdHMgaWYgdGhlIGdpdmVuIHByb21pc2UgZG9lc24ndCByZXNvbHZlIGluIHRpbWVJbk1TIG1pbGxpc2Vjb25kcy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBwcm9taXNlV2l0aFRpbWVvdXQocHJvbWlzZSwgdGltZUluTVMgPSAyMDAwKSB7XG4gICAgY29uc3QgZGVmZXJyZWRQcm9taXNlID0gbmV3IERlZmVycmVkKCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiBkZWZlcnJlZFByb21pc2UucmVqZWN0KCd0aW1lb3V0IScpLCB0aW1lSW5NUyk7XG4gICAgcHJvbWlzZS50aGVuKGRlZmVycmVkUHJvbWlzZS5yZXNvbHZlLCBkZWZlcnJlZFByb21pc2UucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWRQcm9taXNlLnByb21pc2U7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJldHVybnMgYSBxdWVyeXN0cmluZy1mb3JtYXR0ZWQgc3RyaW5nIChlLmcuICZhcmc9dmFsJmFyZzI9dmFsMikgZnJvbSBhXG4gKiBwYXJhbXMgb2JqZWN0IChlLmcuIHthcmc6ICd2YWwnLCBhcmcyOiAndmFsMid9KVxuICogTm90ZTogWW91IG11c3QgcHJlcGVuZCBpdCB3aXRoID8gd2hlbiBhZGRpbmcgaXQgdG8gYSBVUkwuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nKHF1ZXJ5c3RyaW5nUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocXVlcnlzdHJpbmdQYXJhbXMpKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChhcnJheVZhbCA9PiB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoYXJyYXlWYWwpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zLmxlbmd0aCA/ICcmJyArIHBhcmFtcy5qb2luKCcmJykgOiAnJztcbn1cbi8qKlxuICogRGVjb2RlcyBhIHF1ZXJ5c3RyaW5nIChlLmcuID9hcmc9dmFsJmFyZzI9dmFsMikgaW50byBhIHBhcmFtcyBvYmplY3RcbiAqIChlLmcuIHthcmc6ICd2YWwnLCBhcmcyOiAndmFsMid9KVxuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZ0RlY29kZShxdWVyeXN0cmluZykge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIGNvbnN0IHRva2VucyA9IHF1ZXJ5c3RyaW5nLnJlcGxhY2UoL15cXD8vLCAnJykuc3BsaXQoJyYnKTtcbiAgICB0b2tlbnMuZm9yRWFjaCh0b2tlbiA9PiB7XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gdG9rZW4uc3BsaXQoJz0nKTtcbiAgICAgICAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQoa2V5KV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbn1cbi8qKlxuICogRXh0cmFjdCB0aGUgcXVlcnkgc3RyaW5nIHBhcnQgb2YgYSBVUkwsIGluY2x1ZGluZyB0aGUgbGVhZGluZyBxdWVzdGlvbiBtYXJrIChpZiBwcmVzZW50KS5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFF1ZXJ5c3RyaW5nKHVybCkge1xuICAgIGNvbnN0IHF1ZXJ5U3RhcnQgPSB1cmwuaW5kZXhPZignPycpO1xuICAgIGlmICghcXVlcnlTdGFydCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGNvbnN0IGZyYWdtZW50U3RhcnQgPSB1cmwuaW5kZXhPZignIycsIHF1ZXJ5U3RhcnQpO1xuICAgIHJldHVybiB1cmwuc3Vic3RyaW5nKHF1ZXJ5U3RhcnQsIGZyYWdtZW50U3RhcnQgPiAwID8gZnJhZ21lbnRTdGFydCA6IHVuZGVmaW5lZCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU0hBLTEgY3J5cHRvZ3JhcGhpYyBoYXNoLlxuICogVmFyaWFibGUgbmFtZXMgZm9sbG93IHRoZSBub3RhdGlvbiBpbiBGSVBTIFBVQiAxODAtMzpcbiAqIGh0dHA6Ly9jc3JjLm5pc3QuZ292L3B1YmxpY2F0aW9ucy9maXBzL2ZpcHMxODAtMy9maXBzMTgwLTNfZmluYWwucGRmLlxuICpcbiAqIFVzYWdlOlxuICogICB2YXIgc2hhMSA9IG5ldyBzaGExKCk7XG4gKiAgIHNoYTEudXBkYXRlKGJ5dGVzKTtcbiAqICAgdmFyIGhhc2ggPSBzaGExLmRpZ2VzdCgpO1xuICpcbiAqIFBlcmZvcm1hbmNlOlxuICogICBDaHJvbWUgMjM6ICAgfjQwMCBNYml0L3NcbiAqICAgRmlyZWZveCAxNjogIH4yNTAgTWJpdC9zXG4gKlxuICovXG4vKipcbiAqIFNIQS0xIGNyeXB0b2dyYXBoaWMgaGFzaCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBUaGUgcHJvcGVydGllcyBkZWNsYXJlZCBoZXJlIGFyZSBkaXNjdXNzZWQgaW4gdGhlIGFib3ZlIGFsZ29yaXRobSBkb2N1bWVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGZpbmFsXG4gKiBAc3RydWN0XG4gKi9cbmNsYXNzIFNoYTEge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogSG9sZHMgdGhlIHByZXZpb3VzIHZhbHVlcyBvZiBhY2N1bXVsYXRlZCB2YXJpYWJsZXMgYS1lIGluIHRoZSBjb21wcmVzc19cbiAgICAgICAgICogZnVuY3Rpb24uXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYWluXyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBidWZmZXIgaG9sZGluZyB0aGUgcGFydGlhbGx5IGNvbXB1dGVkIGhhc2ggcmVzdWx0LlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5idWZfID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiA4MCBieXRlcywgZWFjaCBhIHBhcnQgb2YgdGhlIG1lc3NhZ2UgdG8gYmUgaGFzaGVkLiAgUmVmZXJyZWQgdG9cbiAgICAgICAgICogYXMgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgaW4gdGhlIGRvY3MuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLldfID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250YWlucyBkYXRhIG5lZWRlZCB0byBwYWQgbWVzc2FnZXMgbGVzcyB0aGFuIDY0IGJ5dGVzLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYWRfID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmJ1Zl8gPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudG90YWxfID0gMDtcbiAgICAgICAgdGhpcy5ibG9ja1NpemUgPSA1MTIgLyA4O1xuICAgICAgICB0aGlzLnBhZF9bMF0gPSAxMjg7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5ibG9ja1NpemU7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5wYWRfW2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLmNoYWluX1swXSA9IDB4Njc0NTIzMDE7XG4gICAgICAgIHRoaXMuY2hhaW5fWzFdID0gMHhlZmNkYWI4OTtcbiAgICAgICAgdGhpcy5jaGFpbl9bMl0gPSAweDk4YmFkY2ZlO1xuICAgICAgICB0aGlzLmNoYWluX1szXSA9IDB4MTAzMjU0NzY7XG4gICAgICAgIHRoaXMuY2hhaW5fWzRdID0gMHhjM2QyZTFmMDtcbiAgICAgICAgdGhpcy5pbmJ1Zl8gPSAwO1xuICAgICAgICB0aGlzLnRvdGFsXyA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGNvbXByZXNzIGhlbHBlciBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gYnVmIEJsb2NrIHRvIGNvbXByZXNzLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgT2Zmc2V0IG9mIHRoZSBibG9jayBpbiB0aGUgYnVmZmVyLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29tcHJlc3NfKGJ1Ziwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFcgPSB0aGlzLldfO1xuICAgICAgICAvLyBnZXQgMTYgYmlnIGVuZGlhbiB3b3Jkc1xuICAgICAgICBpZiAodHlwZW9mIGJ1ZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8odXNlcik6IFtidWcgODE0MDEyMl0gUmVjZW50IHZlcnNpb25zIG9mIFNhZmFyaSBmb3IgTWFjIE9TIGFuZCBpT1NcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGEgYnVnIHRoYXQgdHVybnMgdGhlIHBvc3QtaW5jcmVtZW50ICsrIG9wZXJhdG9yIGludG8gcHJlLWluY3JlbWVudFxuICAgICAgICAgICAgICAgIC8vIGR1cmluZyBKSVQgY29tcGlsYXRpb24uICBXZSBoYXZlIGNvZGUgdGhhdCBkZXBlbmRzIGhlYXZpbHkgb24gU0hBLTEgZm9yXG4gICAgICAgICAgICAgICAgLy8gY29ycmVjdG5lc3MgYW5kIHdoaWNoIGlzIGFmZmVjdGVkIGJ5IHRoaXMgYnVnLCBzbyBJJ3ZlIHJlbW92ZWQgYWxsIHVzZXNcbiAgICAgICAgICAgICAgICAvLyBvZiBwb3N0LWluY3JlbWVudCArKyBpbiB3aGljaCB0aGUgcmVzdWx0IHZhbHVlIGlzIHVzZWQuICBXZSBjYW4gcmV2ZXJ0XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjaGFuZ2Ugb25jZSB0aGUgU2FmYXJpIGJ1Z1xuICAgICAgICAgICAgICAgIC8vIChodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTA5MDM2KSBoYXMgYmVlbiBmaXhlZCBhbmRcbiAgICAgICAgICAgICAgICAvLyBtb3N0IGNsaWVudHMgaGF2ZSBiZWVuIHVwZGF0ZWQuXG4gICAgICAgICAgICAgICAgV1tpXSA9XG4gICAgICAgICAgICAgICAgICAgIChidWYuY2hhckNvZGVBdChvZmZzZXQpIDw8IDI0KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMSkgPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWYuY2hhckNvZGVBdChvZmZzZXQgKyAyKSA8PCA4KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICBidWYuY2hhckNvZGVBdChvZmZzZXQgKyAzKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIFdbaV0gPVxuICAgICAgICAgICAgICAgICAgICAoYnVmW29mZnNldF0gPDwgMjQpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWZbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWZbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmW29mZnNldCArIDNdO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGV4cGFuZCB0byA4MCB3b3Jkc1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0gV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XTtcbiAgICAgICAgICAgIFdbaV0gPSAoKHQgPDwgMSkgfCAodCA+Pj4gMzEpKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGEgPSB0aGlzLmNoYWluX1swXTtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmNoYWluX1sxXTtcbiAgICAgICAgbGV0IGMgPSB0aGlzLmNoYWluX1syXTtcbiAgICAgICAgbGV0IGQgPSB0aGlzLmNoYWluX1szXTtcbiAgICAgICAgbGV0IGUgPSB0aGlzLmNoYWluX1s0XTtcbiAgICAgICAgbGV0IGYsIGs7XG4gICAgICAgIC8vIFRPRE8odXNlcik6IFRyeSB0byB1bnJvbGwgdGhpcyBsb29wIHRvIHNwZWVkIHVwIHRoZSBjb21wdXRhdGlvbi5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA8IDQwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCAyMCkge1xuICAgICAgICAgICAgICAgICAgICBmID0gZCBeIChiICYgKGMgXiBkKSk7XG4gICAgICAgICAgICAgICAgICAgIGsgPSAweDVhODI3OTk5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgICAgICAgICAgICAgICAgayA9IDB4NmVkOWViYTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCA2MCkge1xuICAgICAgICAgICAgICAgICAgICBmID0gKGIgJiBjKSB8IChkICYgKGIgfCBjKSk7XG4gICAgICAgICAgICAgICAgICAgIGsgPSAweDhmMWJiY2RjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgICAgICAgICAgICAgICAgayA9IDB4Y2E2MmMxZDY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdCA9ICgoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGYgKyBlICsgayArIFdbaV0pICYgMHhmZmZmZmZmZjtcbiAgICAgICAgICAgIGUgPSBkO1xuICAgICAgICAgICAgZCA9IGM7XG4gICAgICAgICAgICBjID0gKChiIDw8IDMwKSB8IChiID4+PiAyKSkgJiAweGZmZmZmZmZmO1xuICAgICAgICAgICAgYiA9IGE7XG4gICAgICAgICAgICBhID0gdDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYWluX1swXSA9ICh0aGlzLmNoYWluX1swXSArIGEpICYgMHhmZmZmZmZmZjtcbiAgICAgICAgdGhpcy5jaGFpbl9bMV0gPSAodGhpcy5jaGFpbl9bMV0gKyBiKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgIHRoaXMuY2hhaW5fWzJdID0gKHRoaXMuY2hhaW5fWzJdICsgYykgJiAweGZmZmZmZmZmO1xuICAgICAgICB0aGlzLmNoYWluX1szXSA9ICh0aGlzLmNoYWluX1szXSArIGQpICYgMHhmZmZmZmZmZjtcbiAgICAgICAgdGhpcy5jaGFpbl9bNF0gPSAodGhpcy5jaGFpbl9bNF0gKyBlKSAmIDB4ZmZmZmZmZmY7XG4gICAgfVxuICAgIHVwZGF0ZShieXRlcywgbGVuZ3RoKSB7XG4gICAgICAgIC8vIFRPRE8oam9obmxlbnopOiB0aWdodGVuIHRoZSBmdW5jdGlvbiBzaWduYXR1cmUgYW5kIHJlbW92ZSB0aGlzIGNoZWNrXG4gICAgICAgIGlmIChieXRlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZW5ndGggPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoTWludXNCbG9jayA9IGxlbmd0aCAtIHRoaXMuYmxvY2tTaXplO1xuICAgICAgICBsZXQgbiA9IDA7XG4gICAgICAgIC8vIFVzaW5nIGxvY2FsIGluc3RlYWQgb2YgbWVtYmVyIHZhcmlhYmxlcyBnaXZlcyB+NSUgc3BlZWR1cCBvbiBGaXJlZm94IDE2LlxuICAgICAgICBjb25zdCBidWYgPSB0aGlzLmJ1Zl87XG4gICAgICAgIGxldCBpbmJ1ZiA9IHRoaXMuaW5idWZfO1xuICAgICAgICAvLyBUaGUgb3V0ZXIgd2hpbGUgbG9vcCBzaG91bGQgZXhlY3V0ZSBhdCBtb3N0IHR3aWNlLlxuICAgICAgICB3aGlsZSAobiA8IGxlbmd0aCkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBoYXZlIG5vIGRhdGEgaW4gdGhlIGJsb2NrIHRvIHRvcCB1cCwgd2UgY2FuIGRpcmVjdGx5IHByb2Nlc3MgdGhlXG4gICAgICAgICAgICAvLyBpbnB1dCBidWZmZXIgKGFzc3VtaW5nIGl0IGNvbnRhaW5zIHN1ZmZpY2llbnQgZGF0YSkuIFRoaXMgZ2l2ZXMgfjI1JVxuICAgICAgICAgICAgLy8gc3BlZWR1cCBvbiBDaHJvbWUgMjMgYW5kIH4xNSUgc3BlZWR1cCBvbiBGaXJlZm94IDE2LCBidXQgcmVxdWlyZXMgdGhhdFxuICAgICAgICAgICAgLy8gdGhlIGRhdGEgaXMgcHJvdmlkZWQgaW4gbGFyZ2UgY2h1bmtzIChvciBpbiBtdWx0aXBsZXMgb2YgNjQgYnl0ZXMpLlxuICAgICAgICAgICAgaWYgKGluYnVmID09PSAwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPD0gbGVuZ3RoTWludXNCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzXyhieXRlcywgbik7XG4gICAgICAgICAgICAgICAgICAgIG4gKz0gdGhpcy5ibG9ja1NpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBidWZbaW5idWZdID0gYnl0ZXMuY2hhckNvZGVBdChuKTtcbiAgICAgICAgICAgICAgICAgICAgKytpbmJ1ZjtcbiAgICAgICAgICAgICAgICAgICAgKytuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5idWYgPT09IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzXyhidWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5idWYgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVtcCB0byB0aGUgb3V0ZXIgbG9vcCBzbyB3ZSB1c2UgdGhlIGZ1bGwtYmxvY2sgb3B0aW1pemF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBidWZbaW5idWZdID0gYnl0ZXNbbl07XG4gICAgICAgICAgICAgICAgICAgICsraW5idWY7XG4gICAgICAgICAgICAgICAgICAgICsrbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluYnVmID09PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzc18oYnVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluYnVmID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1bXAgdG8gdGhlIG91dGVyIGxvb3Agc28gd2UgdXNlIHRoZSBmdWxsLWJsb2NrIG9wdGltaXphdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5idWZfID0gaW5idWY7XG4gICAgICAgIHRoaXMudG90YWxfICs9IGxlbmd0aDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgZGlnZXN0ID0gW107XG4gICAgICAgIGxldCB0b3RhbEJpdHMgPSB0aGlzLnRvdGFsXyAqIDg7XG4gICAgICAgIC8vIEFkZCBwYWQgMHg4MCAweDAwKi5cbiAgICAgICAgaWYgKHRoaXMuaW5idWZfIDwgNTYpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHRoaXMucGFkXywgNTYgLSB0aGlzLmluYnVmXyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLnBhZF8sIHRoaXMuYmxvY2tTaXplIC0gKHRoaXMuaW5idWZfIC0gNTYpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgIyBiaXRzLlxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5ibG9ja1NpemUgLSAxOyBpID49IDU2OyBpLS0pIHtcbiAgICAgICAgICAgIHRoaXMuYnVmX1tpXSA9IHRvdGFsQml0cyAmIDI1NTtcbiAgICAgICAgICAgIHRvdGFsQml0cyAvPSAyNTY7IC8vIERvbid0IHVzZSBiaXQtc2hpZnRpbmcgaGVyZSFcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXByZXNzXyh0aGlzLmJ1Zl8pO1xuICAgICAgICBsZXQgbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMjQ7IGogPj0gMDsgaiAtPSA4KSB7XG4gICAgICAgICAgICAgICAgZGlnZXN0W25dID0gKHRoaXMuY2hhaW5fW2ldID4+IGopICYgMjU1O1xuICAgICAgICAgICAgICAgICsrbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlnZXN0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gbWFrZSBhIFN1YnNjcmliZSBmdW5jdGlvbiAoanVzdCBsaWtlIFByb21pc2UgaGVscHMgbWFrZSBhXG4gKiBUaGVuYWJsZSkuXG4gKlxuICogQHBhcmFtIGV4ZWN1dG9yIEZ1bmN0aW9uIHdoaWNoIGNhbiBtYWtlIGNhbGxzIHRvIGEgc2luZ2xlIE9ic2VydmVyXG4gKiAgICAgYXMgYSBwcm94eS5cbiAqIEBwYXJhbSBvbk5vT2JzZXJ2ZXJzIENhbGxiYWNrIHdoZW4gY291bnQgb2YgT2JzZXJ2ZXJzIGdvZXMgdG8gemVyby5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3Vic2NyaWJlKGV4ZWN1dG9yLCBvbk5vT2JzZXJ2ZXJzKSB7XG4gICAgY29uc3QgcHJveHkgPSBuZXcgT2JzZXJ2ZXJQcm94eShleGVjdXRvciwgb25Ob09ic2VydmVycyk7XG4gICAgcmV0dXJuIHByb3h5LnN1YnNjcmliZS5iaW5kKHByb3h5KTtcbn1cbi8qKlxuICogSW1wbGVtZW50IGZhbi1vdXQgZm9yIGFueSBudW1iZXIgb2YgT2JzZXJ2ZXJzIGF0dGFjaGVkIHZpYSBhIHN1YnNjcmliZVxuICogZnVuY3Rpb24uXG4gKi9cbmNsYXNzIE9ic2VydmVyUHJveHkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBleGVjdXRvciBGdW5jdGlvbiB3aGljaCBjYW4gbWFrZSBjYWxscyB0byBhIHNpbmdsZSBPYnNlcnZlclxuICAgICAqICAgICBhcyBhIHByb3h5LlxuICAgICAqIEBwYXJhbSBvbk5vT2JzZXJ2ZXJzIENhbGxiYWNrIHdoZW4gY291bnQgb2YgT2JzZXJ2ZXJzIGdvZXMgdG8gemVyby5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihleGVjdXRvciwgb25Ob09ic2VydmVycykge1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlcyA9IFtdO1xuICAgICAgICB0aGlzLm9ic2VydmVyQ291bnQgPSAwO1xuICAgICAgICAvLyBNaWNyby10YXNrIHNjaGVkdWxpbmcgYnkgY2FsbGluZyB0YXNrLnRoZW4oKS5cbiAgICAgICAgdGhpcy50YXNrID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHRoaXMuZmluYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25Ob09ic2VydmVycyA9IG9uTm9PYnNlcnZlcnM7XG4gICAgICAgIC8vIENhbGwgdGhlIGV4ZWN1dG9yIGFzeW5jaHJvbm91c2x5IHNvIHN1YnNjcmliZXJzIHRoYXQgYXJlIGNhbGxlZFxuICAgICAgICAvLyBzeW5jaHJvbm91c2x5IGFmdGVyIHRoZSBjcmVhdGlvbiBvZiB0aGUgc3Vic2NyaWJlIGZ1bmN0aW9uXG4gICAgICAgIC8vIGNhbiBzdGlsbCByZWNlaXZlIHRoZSB2ZXJ5IGZpcnN0IHZhbHVlIGdlbmVyYXRlZCBpbiB0aGUgZXhlY3V0b3IuXG4gICAgICAgIHRoaXMudGFza1xuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgZXhlY3V0b3IodGhpcyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmV4dCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5mb3JFYWNoT2JzZXJ2ZXIoKG9ic2VydmVyKSA9PiB7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNsb3NlKGVycm9yKTtcbiAgICB9XG4gICAgY29tcGxldGUoKSB7XG4gICAgICAgIHRoaXMuZm9yRWFjaE9ic2VydmVyKChvYnNlcnZlcikgPT4ge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gYWRkIGFuIE9ic2VydmVyIHRvIHRoZSBmYW4tb3V0IGxpc3QuXG4gICAgICpcbiAgICAgKiAtIFdlIHJlcXVpcmUgdGhhdCBubyBldmVudCBpcyBzZW50IHRvIGEgc3Vic2NyaWJlciBzeW5jaHJvbm91c2x5IHRvIHRoZWlyXG4gICAgICogICBjYWxsIHRvIHN1YnNjcmliZSgpLlxuICAgICAqL1xuICAgIHN1YnNjcmliZShuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIGxldCBvYnNlcnZlcjtcbiAgICAgICAgaWYgKG5leHRPck9ic2VydmVyID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGVycm9yID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGNvbXBsZXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBPYnNlcnZlci4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBc3NlbWJsZSBhbiBPYnNlcnZlciBvYmplY3Qgd2hlbiBwYXNzZWQgYXMgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICAgICAgICBpZiAoaW1wbGVtZW50c0FueU1ldGhvZHMobmV4dE9yT2JzZXJ2ZXIsIFtcbiAgICAgICAgICAgICduZXh0JyxcbiAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAnY29tcGxldGUnXG4gICAgICAgIF0pKSB7XG4gICAgICAgICAgICBvYnNlcnZlciA9IG5leHRPck9ic2VydmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JzZXJ2ZXIgPSB7XG4gICAgICAgICAgICAgICAgbmV4dDogbmV4dE9yT2JzZXJ2ZXIsXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgY29tcGxldGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9ic2VydmVyLm5leHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9ic2VydmVyLmVycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JzZXJ2ZXIuY29tcGxldGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVuc3ViID0gdGhpcy51bnN1YnNjcmliZU9uZS5iaW5kKHRoaXMsIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCk7XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gc3Vic2NyaWJlIHRvIGEgdGVybWluYXRlZCBPYnNlcnZhYmxlIC0gd2VcbiAgICAgICAgLy8ganVzdCByZXNwb25kIHRvIHRoZSBPYnNlcnZlciB3aXRoIHRoZSBmaW5hbCBlcnJvciBvciBjb21wbGV0ZVxuICAgICAgICAvLyBldmVudC5cbiAgICAgICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgICAgICB0aGlzLnRhc2sudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluYWxFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IodGhpcy5maW5hbEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90aGluZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgICAgICAgcmV0dXJuIHVuc3ViO1xuICAgIH1cbiAgICAvLyBVbnN1YnNjcmliZSBpcyBzeW5jaHJvbm91cyAtIHdlIGd1YXJhbnRlZSB0aGF0IG5vIGV2ZW50cyBhcmUgc2VudCB0b1xuICAgIC8vIGFueSB1bnN1YnNjcmliZWQgT2JzZXJ2ZXIuXG4gICAgdW5zdWJzY3JpYmVPbmUoaSkge1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlcnMgPT09IHVuZGVmaW5lZCB8fCB0aGlzLm9ic2VydmVyc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMub2JzZXJ2ZXJzW2ldO1xuICAgICAgICB0aGlzLm9ic2VydmVyQ291bnQgLT0gMTtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXJDb3VudCA9PT0gMCAmJiB0aGlzLm9uTm9PYnNlcnZlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vbk5vT2JzZXJ2ZXJzKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvckVhY2hPYnNlcnZlcihmbikge1xuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgICAgICAgIC8vIEFscmVhZHkgY2xvc2VkIGJ5IHByZXZpb3VzIGV2ZW50Li4uLmp1c3QgZWF0IHRoZSBhZGRpdGlvbmFsIHZhbHVlcy5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaW5jZSBzZW5kT25lIGNhbGxzIGFzeW5jaHJvbm91c2x5IC0gdGhlcmUgaXMgbm8gY2hhbmNlIHRoYXRcbiAgICAgICAgLy8gdGhpcy5vYnNlcnZlcnMgd2lsbCBiZWNvbWUgdW5kZWZpbmVkLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub2JzZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRPbmUoaSwgZm4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENhbGwgdGhlIE9ic2VydmVyIHZpYSBvbmUgb2YgaXQncyBjYWxsYmFjayBmdW5jdGlvbi4gV2UgYXJlIGNhcmVmdWwgdG9cbiAgICAvLyBjb25maXJtIHRoYXQgdGhlIG9ic2VydmUgaGFzIG5vdCBiZWVuIHVuc3Vic2NyaWJlZCBzaW5jZSB0aGlzIGFzeW5jaHJvbm91c1xuICAgIC8vIGZ1bmN0aW9uIGhhZCBiZWVuIHF1ZXVlZC5cbiAgICBzZW5kT25lKGksIGZuKSB7XG4gICAgICAgIC8vIEV4ZWN1dGUgdGhlIGNhbGxiYWNrIGFzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICAgICAgdGhpcy50YXNrLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXJzICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vYnNlcnZlcnNbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZuKHRoaXMub2JzZXJ2ZXJzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGV4Y2VwdGlvbnMgcmFpc2VkIGluIE9ic2VydmVycyBvciBtaXNzaW5nIG1ldGhvZHMgb2YgYW5cbiAgICAgICAgICAgICAgICAgICAgLy8gT2JzZXJ2ZXIuXG4gICAgICAgICAgICAgICAgICAgIC8vIExvZyBlcnJvciB0byBjb25zb2xlLiBiLzMxNDA0ODA2XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsb3NlKGVycikge1xuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmFsaXplZCA9IHRydWU7XG4gICAgICAgIGlmIChlcnIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5maW5hbEVycm9yID0gZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByb3h5IGlzIG5vIGxvbmdlciBuZWVkZWQgLSBnYXJiYWdlIGNvbGxlY3QgcmVmZXJlbmNlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgIHRoaXMudGFzay50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5vbk5vT2JzZXJ2ZXJzID0gdW5kZWZpbmVkO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVHVybiBzeW5jaHJvbm91cyBmdW5jdGlvbiBpbnRvIG9uZSBjYWxsZWQgYXN5bmNocm9ub3VzbHkuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuZnVuY3Rpb24gYXN5bmMoZm4sIG9uRXJyb3IpIHtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHRydWUpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBmbiguLi5hcmdzKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHRoZSBvYmplY3QgcGFzc2VkIGluIGltcGxlbWVudHMgYW55IG9mIHRoZSBuYW1lZCBtZXRob2RzLlxuICovXG5mdW5jdGlvbiBpbXBsZW1lbnRzQW55TWV0aG9kcyhvYmosIG1ldGhvZHMpIHtcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBtZXRob2Qgb2YgbWV0aG9kcykge1xuICAgICAgICBpZiAobWV0aG9kIGluIG9iaiAmJiB0eXBlb2Ygb2JqW21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgLy8gZG8gbm90aGluZ1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBDaGVjayB0byBtYWtlIHN1cmUgdGhlIGFwcHJvcHJpYXRlIG51bWJlciBvZiBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIGZvciBhIHB1YmxpYyBmdW5jdGlvbi5cbiAqIFRocm93cyBhbiBlcnJvciBpZiBpdCBmYWlscy5cbiAqXG4gKiBAcGFyYW0gZm5OYW1lIFRoZSBmdW5jdGlvbiBuYW1lXG4gKiBAcGFyYW0gbWluQ291bnQgVGhlIG1pbmltdW0gbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBhbGxvdyBmb3IgdGhlIGZ1bmN0aW9uIGNhbGxcbiAqIEBwYXJhbSBtYXhDb3VudCBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXJndW1lbnQgdG8gYWxsb3cgZm9yIHRoZSBmdW5jdGlvbiBjYWxsXG4gKiBAcGFyYW0gYXJnQ291bnQgVGhlIGFjdHVhbCBudW1iZXIgb2YgYXJndW1lbnRzIHByb3ZpZGVkLlxuICovXG5jb25zdCB2YWxpZGF0ZUFyZ0NvdW50ID0gZnVuY3Rpb24gKGZuTmFtZSwgbWluQ291bnQsIG1heENvdW50LCBhcmdDb3VudCkge1xuICAgIGxldCBhcmdFcnJvcjtcbiAgICBpZiAoYXJnQ291bnQgPCBtaW5Db3VudCkge1xuICAgICAgICBhcmdFcnJvciA9ICdhdCBsZWFzdCAnICsgbWluQ291bnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFyZ0NvdW50ID4gbWF4Q291bnQpIHtcbiAgICAgICAgYXJnRXJyb3IgPSBtYXhDb3VudCA9PT0gMCA/ICdub25lJyA6ICdubyBtb3JlIHRoYW4gJyArIG1heENvdW50O1xuICAgIH1cbiAgICBpZiAoYXJnRXJyb3IpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBmbk5hbWUgK1xuICAgICAgICAgICAgJyBmYWlsZWQ6IFdhcyBjYWxsZWQgd2l0aCAnICtcbiAgICAgICAgICAgIGFyZ0NvdW50ICtcbiAgICAgICAgICAgIChhcmdDb3VudCA9PT0gMSA/ICcgYXJndW1lbnQuJyA6ICcgYXJndW1lbnRzLicpICtcbiAgICAgICAgICAgICcgRXhwZWN0cyAnICtcbiAgICAgICAgICAgIGFyZ0Vycm9yICtcbiAgICAgICAgICAgICcuJztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICB9XG59O1xuLyoqXG4gKiBHZW5lcmF0ZXMgYSBzdHJpbmcgdG8gcHJlZml4IGFuIGVycm9yIG1lc3NhZ2UgYWJvdXQgZmFpbGVkIGFyZ3VtZW50IHZhbGlkYXRpb25cbiAqXG4gKiBAcGFyYW0gZm5OYW1lIFRoZSBmdW5jdGlvbiBuYW1lXG4gKiBAcGFyYW0gYXJnTmFtZSBUaGUgbmFtZSBvZiB0aGUgYXJndW1lbnRcbiAqIEByZXR1cm4gVGhlIHByZWZpeCB0byBhZGQgdG8gdGhlIGVycm9yIHRocm93biBmb3IgdmFsaWRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmdOYW1lKSB7XG4gICAgcmV0dXJuIGAke2ZuTmFtZX0gZmFpbGVkOiAke2FyZ05hbWV9IGFyZ3VtZW50IGA7XG59XG4vKipcbiAqIEBwYXJhbSBmbk5hbWVcbiAqIEBwYXJhbSBhcmd1bWVudE51bWJlclxuICogQHBhcmFtIG5hbWVzcGFjZVxuICogQHBhcmFtIG9wdGlvbmFsXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlTmFtZXNwYWNlKGZuTmFtZSwgbmFtZXNwYWNlLCBvcHRpb25hbCkge1xuICAgIGlmIChvcHRpb25hbCAmJiAhbmFtZXNwYWNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vVE9ETzogSSBzaG91bGQgZG8gbW9yZSB2YWxpZGF0aW9uIGhlcmUuIFdlIG9ubHkgYWxsb3cgY2VydGFpbiBjaGFycyBpbiBuYW1lc3BhY2VzLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCAnbmFtZXNwYWNlJykgKyAnbXVzdCBiZSBhIHZhbGlkIGZpcmViYXNlIG5hbWVzcGFjZS4nKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUNhbGxiYWNrKGZuTmFtZSwgYXJndW1lbnROYW1lLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5jYWxsYmFjaywgb3B0aW9uYWwpIHtcbiAgICBpZiAob3B0aW9uYWwgJiYgIWNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE5hbWUpICsgJ211c3QgYmUgYSB2YWxpZCBmdW5jdGlvbi4nKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUNvbnRleHRPYmplY3QoZm5OYW1lLCBhcmd1bWVudE5hbWUsIGNvbnRleHQsIG9wdGlvbmFsKSB7XG4gICAgaWYgKG9wdGlvbmFsICYmICFjb250ZXh0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSAnb2JqZWN0JyB8fCBjb250ZXh0ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TmFtZSkgKyAnbXVzdCBiZSBhIHZhbGlkIGNvbnRleHQgb2JqZWN0LicpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8vIENvZGUgb3JpZ2luYWxseSBjYW1lIGZyb20gZ29vZy5jcnlwdC5zdHJpbmdUb1V0ZjhCeXRlQXJyYXksIGJ1dCBmb3Igc29tZSByZWFzb24gdGhleVxuLy8gYXV0b21hdGljYWxseSByZXBsYWNlZCAnXFxyXFxuJyB3aXRoICdcXG4nLCBhbmQgdGhleSBkaWRuJ3QgaGFuZGxlIHN1cnJvZ2F0ZSBwYWlycyxcbi8vIHNvIGl0J3MgYmVlbiBtb2RpZmllZC5cbi8vIE5vdGUgdGhhdCBub3QgYWxsIFVuaWNvZGUgY2hhcmFjdGVycyBhcHBlYXIgYXMgc2luZ2xlIGNoYXJhY3RlcnMgaW4gSmF2YVNjcmlwdCBzdHJpbmdzLlxuLy8gZnJvbUNoYXJDb2RlIHJldHVybnMgdGhlIFVURi0xNiBlbmNvZGluZyBvZiBhIGNoYXJhY3RlciAtIHNvIHNvbWUgVW5pY29kZSBjaGFyYWN0ZXJzXG4vLyB1c2UgMiBjaGFyYWN0ZXJzIGluIEphdmFTY3JpcHQuICBBbGwgNC1ieXRlIFVURi04IGNoYXJhY3RlcnMgYmVnaW4gd2l0aCBhIGZpcnN0XG4vLyBjaGFyYWN0ZXIgaW4gdGhlIHJhbmdlIDB4RDgwMCAtIDB4REJGRiAodGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIHNvLWNhbGxlZCBzdXJyb2dhdGVcbi8vIHBhaXIpLlxuLy8gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy0xNS4xLjNcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmNvbnN0IHN0cmluZ1RvQnl0ZUFycmF5ID0gZnVuY3Rpb24gKHN0cikge1xuICAgIGNvbnN0IG91dCA9IFtdO1xuICAgIGxldCBwID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAvLyBJcyB0aGlzIHRoZSBsZWFkIHN1cnJvZ2F0ZSBpbiBhIHN1cnJvZ2F0ZSBwYWlyP1xuICAgICAgICBpZiAoYyA+PSAweGQ4MDAgJiYgYyA8PSAweGRiZmYpIHtcbiAgICAgICAgICAgIGNvbnN0IGhpZ2ggPSBjIC0gMHhkODAwOyAvLyB0aGUgaGlnaCAxMCBiaXRzLlxuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgYXNzZXJ0KGkgPCBzdHIubGVuZ3RoLCAnU3Vycm9nYXRlIHBhaXIgbWlzc2luZyB0cmFpbCBzdXJyb2dhdGUuJyk7XG4gICAgICAgICAgICBjb25zdCBsb3cgPSBzdHIuY2hhckNvZGVBdChpKSAtIDB4ZGMwMDsgLy8gdGhlIGxvdyAxMCBiaXRzLlxuICAgICAgICAgICAgYyA9IDB4MTAwMDAgKyAoaGlnaCA8PCAxMCkgKyBsb3c7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgICAgICAgIG91dFtwKytdID0gYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OCkge1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiA2KSB8IDE5MjtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDY1NTM2KSB7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDEyKSB8IDIyNDtcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gMTgpIHwgMjQwO1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gMTIpICYgNjMpIHwgMTI4O1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuLyoqXG4gKiBDYWxjdWxhdGUgbGVuZ3RoIHdpdGhvdXQgYWN0dWFsbHkgY29udmVydGluZzsgdXNlZnVsIGZvciBkb2luZyBjaGVhcGVyIHZhbGlkYXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmNvbnN0IHN0cmluZ0xlbmd0aCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBsZXQgcCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgICAgcCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KSB7XG4gICAgICAgICAgICBwICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA+PSAweGQ4MDAgJiYgYyA8PSAweGRiZmYpIHtcbiAgICAgICAgICAgIC8vIExlYWQgc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXIuICBUaGUgcGFpciB0b2dldGhlciB3aWxsIHRha2UgNCBieXRlcyB0byByZXByZXNlbnQuXG4gICAgICAgICAgICBwICs9IDQ7XG4gICAgICAgICAgICBpKys7IC8vIHNraXAgdHJhaWwgc3Vycm9nYXRlLlxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcCArPSAzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwO1xufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ29waWVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIxMTc1MjNcbiAqIEdlbmVyYXRlcyBhIG5ldyB1dWlkLlxuICogQHB1YmxpY1xuICovXG5jb25zdCB1dWlkdjQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgYyA9PiB7XG4gICAgICAgIGNvbnN0IHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDAsIHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4O1xuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaGUgYW1vdW50IG9mIG1pbGxpc2Vjb25kcyB0byBleHBvbmVudGlhbGx5IGluY3JlYXNlLlxuICovXG5jb25zdCBERUZBVUxUX0lOVEVSVkFMX01JTExJUyA9IDEwMDA7XG4vKipcbiAqIFRoZSBmYWN0b3IgdG8gYmFja29mZiBieS5cbiAqIFNob3VsZCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMS5cbiAqL1xuY29uc3QgREVGQVVMVF9CQUNLT0ZGX0ZBQ1RPUiA9IDI7XG4vKipcbiAqIFRoZSBtYXhpbXVtIG1pbGxpc2Vjb25kcyB0byBpbmNyZWFzZSB0by5cbiAqXG4gKiA8cD5WaXNpYmxlIGZvciB0ZXN0aW5nXG4gKi9cbmNvbnN0IE1BWF9WQUxVRV9NSUxMSVMgPSA0ICogNjAgKiA2MCAqIDEwMDA7IC8vIEZvdXIgaG91cnMsIGxpa2UgaU9TIGFuZCBBbmRyb2lkLlxuLyoqXG4gKiBUaGUgcGVyY2VudGFnZSBvZiBiYWNrb2ZmIHRpbWUgdG8gcmFuZG9taXplIGJ5LlxuICogU2VlXG4gKiBodHRwOi8vZ28vc2FmZS1jbGllbnQtYmVoYXZpb3Ijc3RlcC0xLWRldGVybWluZS10aGUtYXBwcm9wcmlhdGUtcmV0cnktaW50ZXJ2YWwtdG8taGFuZGxlLXNwaWtlLXRyYWZmaWNcbiAqIGZvciBjb250ZXh0LlxuICpcbiAqIDxwPlZpc2libGUgZm9yIHRlc3RpbmdcbiAqL1xuY29uc3QgUkFORE9NX0ZBQ1RPUiA9IDAuNTtcbi8qKlxuICogQmFzZWQgb24gdGhlIGJhY2tvZmYgbWV0aG9kIGZyb21cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1saWJyYXJ5L2Jsb2IvbWFzdGVyL2Nsb3N1cmUvZ29vZy9tYXRoL2V4cG9uZW50aWFsYmFja29mZi5qcy5cbiAqIEV4dHJhY3RlZCBoZXJlIHNvIHdlIGRvbid0IG5lZWQgdG8gcGFzcyBtZXRhZGF0YSBhbmQgYSBzdGF0ZWZ1bCBFeHBvbmVudGlhbEJhY2tvZmYgb2JqZWN0IGFyb3VuZC5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlQmFja29mZk1pbGxpcyhiYWNrb2ZmQ291bnQsIGludGVydmFsTWlsbGlzID0gREVGQVVMVF9JTlRFUlZBTF9NSUxMSVMsIGJhY2tvZmZGYWN0b3IgPSBERUZBVUxUX0JBQ0tPRkZfRkFDVE9SKSB7XG4gICAgLy8gQ2FsY3VsYXRlcyBhbiBleHBvbmVudGlhbGx5IGluY3JlYXNpbmcgdmFsdWUuXG4gICAgLy8gRGV2aWF0aW9uOiBjYWxjdWxhdGVzIHZhbHVlIGZyb20gY291bnQgYW5kIGEgY29uc3RhbnQgaW50ZXJ2YWwsIHNvIHdlIG9ubHkgbmVlZCB0byBzYXZlIHZhbHVlXG4gICAgLy8gYW5kIGNvdW50IHRvIHJlc3RvcmUgc3RhdGUuXG4gICAgY29uc3QgY3VyckJhc2VWYWx1ZSA9IGludGVydmFsTWlsbGlzICogTWF0aC5wb3coYmFja29mZkZhY3RvciwgYmFja29mZkNvdW50KTtcbiAgICAvLyBBIHJhbmRvbSBcImZ1enpcIiB0byBhdm9pZCB3YXZlcyBvZiByZXRyaWVzLlxuICAgIC8vIERldmlhdGlvbjogcmFuZG9tRmFjdG9yIGlzIHJlcXVpcmVkLlxuICAgIGNvbnN0IHJhbmRvbVdhaXQgPSBNYXRoLnJvdW5kKFxuICAgIC8vIEEgZnJhY3Rpb24gb2YgdGhlIGJhY2tvZmYgdmFsdWUgdG8gYWRkL3N1YnRyYWN0LlxuICAgIC8vIERldmlhdGlvbjogY2hhbmdlcyBtdWx0aXBsaWNhdGlvbiBvcmRlciB0byBpbXByb3ZlIHJlYWRhYmlsaXR5LlxuICAgIFJBTkRPTV9GQUNUT1IgKlxuICAgICAgICBjdXJyQmFzZVZhbHVlICpcbiAgICAgICAgLy8gQSByYW5kb20gZmxvYXQgKHJvdW5kZWQgdG8gaW50IGJ5IE1hdGgucm91bmQgYWJvdmUpIGluIHRoZSByYW5nZSBbLTEsIDFdLiBEZXRlcm1pbmVzXG4gICAgICAgIC8vIGlmIHdlIGFkZCBvciBzdWJ0cmFjdC5cbiAgICAgICAgKE1hdGgucmFuZG9tKCkgLSAwLjUpICpcbiAgICAgICAgMik7XG4gICAgLy8gTGltaXRzIGJhY2tvZmYgdG8gbWF4IHRvIGF2b2lkIGVmZmVjdGl2ZWx5IHBlcm1hbmVudCBiYWNrb2ZmLlxuICAgIHJldHVybiBNYXRoLm1pbihNQVhfVkFMVUVfTUlMTElTLCBjdXJyQmFzZVZhbHVlICsgcmFuZG9tV2FpdCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFByb3ZpZGUgRW5nbGlzaCBvcmRpbmFsIGxldHRlcnMgYWZ0ZXIgYSBudW1iZXJcbiAqL1xuZnVuY3Rpb24gb3JkaW5hbChpKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaSkpIHtcbiAgICAgICAgcmV0dXJuIGAke2l9YDtcbiAgICB9XG4gICAgcmV0dXJuIGkgKyBpbmRpY2F0b3IoaSk7XG59XG5mdW5jdGlvbiBpbmRpY2F0b3IoaSkge1xuICAgIGkgPSBNYXRoLmFicyhpKTtcbiAgICBjb25zdCBjZW50ID0gaSAlIDEwMDtcbiAgICBpZiAoY2VudCA+PSAxMCAmJiBjZW50IDw9IDIwKSB7XG4gICAgICAgIHJldHVybiAndGgnO1xuICAgIH1cbiAgICBjb25zdCBkZWMgPSBpICUgMTA7XG4gICAgaWYgKGRlYyA9PT0gMSkge1xuICAgICAgICByZXR1cm4gJ3N0JztcbiAgICB9XG4gICAgaWYgKGRlYyA9PT0gMikge1xuICAgICAgICByZXR1cm4gJ25kJztcbiAgICB9XG4gICAgaWYgKGRlYyA9PT0gMykge1xuICAgICAgICByZXR1cm4gJ3JkJztcbiAgICB9XG4gICAgcmV0dXJuICd0aCc7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBnZXRNb2R1bGFySW5zdGFuY2Uoc2VydmljZSkge1xuICAgIGlmIChzZXJ2aWNlICYmIHNlcnZpY2UuX2RlbGVnYXRlKSB7XG4gICAgICAgIHJldHVybiBzZXJ2aWNlLl9kZWxlZ2F0ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzZXJ2aWNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8vIE92ZXJyaWRpbmcgdGhlIGNvbnN0YW50ICh3ZSBzaG91bGQgYmUgdGhlIG9ubHkgb25lcyBkb2luZyB0aGlzKVxuQ09OU1RBTlRTLk5PREVfQ0xJRU5UID0gdHJ1ZTtcblxuZXhwb3J0IHsgQ09OU1RBTlRTLCBEZWNvZGVCYXNlNjRTdHJpbmdFcnJvciwgRGVmZXJyZWQsIEVycm9yRmFjdG9yeSwgRmlyZWJhc2VFcnJvciwgTUFYX1ZBTFVFX01JTExJUywgUkFORE9NX0ZBQ1RPUiwgU2hhMSwgYXJlQ29va2llc0VuYWJsZWQsIGFzc2VydCwgYXNzZXJ0aW9uRXJyb3IsIGFzeW5jLCBiYXNlNjQsIGJhc2U2NERlY29kZSwgYmFzZTY0RW5jb2RlLCBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZywgY2FsY3VsYXRlQmFja29mZk1pbGxpcywgY29udGFpbnMsIGNyZWF0ZU1vY2tVc2VyVG9rZW4sIGNyZWF0ZVN1YnNjcmliZSwgZGVjb2RlLCBkZWVwQ29weSwgZGVlcEVxdWFsLCBkZWVwRXh0ZW5kLCBlcnJvclByZWZpeCwgZXh0cmFjdFF1ZXJ5c3RyaW5nLCBnZXREZWZhdWx0QXBwQ29uZmlnLCBnZXREZWZhdWx0RW11bGF0b3JIb3N0LCBnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQsIGdldERlZmF1bHRzLCBnZXRFeHBlcmltZW50YWxTZXR0aW5nLCBnZXRHbG9iYWwsIGdldE1vZHVsYXJJbnN0YW5jZSwgZ2V0VUEsIGlzQWRtaW4sIGlzQnJvd3NlciwgaXNCcm93c2VyRXh0ZW5zaW9uLCBpc0Nsb3VkZmxhcmVXb3JrZXIsIGlzRWxlY3Ryb24sIGlzRW1wdHksIGlzSUUsIGlzSW5kZXhlZERCQXZhaWxhYmxlLCBpc01vYmlsZUNvcmRvdmEsIGlzTm9kZSwgaXNOb2RlU2RrLCBpc1JlYWN0TmF0aXZlLCBpc1NhZmFyaSwgaXNVV1AsIGlzVmFsaWRGb3JtYXQsIGlzVmFsaWRUaW1lc3RhbXAsIGlzV2ViV29ya2VyLCBpc3N1ZWRBdFRpbWUsIGpzb25FdmFsLCBtYXAsIG9yZGluYWwsIHByb21pc2VXaXRoVGltZW91dCwgcXVlcnlzdHJpbmcsIHF1ZXJ5c3RyaW5nRGVjb2RlLCBzYWZlR2V0LCBzdHJpbmdMZW5ndGgsIHN0cmluZ1RvQnl0ZUFycmF5LCBzdHJpbmdpZnksIHV1aWR2NCwgdmFsaWRhdGVBcmdDb3VudCwgdmFsaWRhdGVDYWxsYmFjaywgdmFsaWRhdGVDb250ZXh0T2JqZWN0LCB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlLCB2YWxpZGF0ZU5hbWVzcGFjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\n");

/***/ })

};
;